'From Pharo6.0 of 13 May 2016 [Latest update: #60493] on 17 May 2017 at 1:01:41.053846 pm'!----QUIT----2017-05-17T13:02:17.571196+02:00 Pharo-60493.image priorSource: 0!----QUIT----2017-05-17T13:02:52.052925+02:00 Pharo-60493.image priorSource: 92!----QUIT/NOSAVE----2017-05-17T13:03:08.259387+02:00 Pharo-60493.image priorSource: 172!----QUIT----2017-05-17T13:03:42.089076+02:00 Pharo-60493.image priorSource: 172!----QUIT----2017-05-17T13:09:56.388095+02:00 Pharo-60493.image priorSource: 342!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/17/2017 15:15' prior: 59349094!commentForCurrentUpdate ^ '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/20064'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/17/2017 15:15'!script60494	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.4.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.71.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/17/2017 15:15'!update60494	"self new update60494"	self withUpdateLog: '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/20064'.	self loadTogether: self script60494 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60493!ScriptLoader removeSelector: #script60493!"ScriptLoader60"!!ClassTest methodsFor: 'testing - navigation' stamp: 'PavelKrivanek 5/16/2017 14:47' prior: 19489936!testMethodsReferencingClass	self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest111)) equals: {(ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.	self		assert: ((ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest1)) sort: [ :a :b | a name <= b name]) asArray		equals:			{ClassTest>>#referencingMethod1. 			ClassTest>>#referencingMethod2. 			ClassTest>>#testOrdersACollectionOfClassesBySuperclass}.	self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #BehaviorTest)) isEmpty! !"Kernel-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.568.mcz') load.ScriptLoader new update60494.!----End fileIn----!----QUIT----2017-05-18T09:47:15.580373+02:00 Pharo.image priorSource: 424!----QUIT----2017-05-18T09:47:26.423036+02:00 Pharo.image priorSource: 20220!----QUIT----2017-05-19T09:35:29.483671+02:00 Pharo.image priorSource: 20296!----QUIT----2017-05-19T09:35:36.656906+02:00 Pharo.image priorSource: 20374!----QUIT----2017-05-19T14:15:05.912563+02:00 Pharo.image priorSource: 20452!----QUIT----2017-05-19T14:15:13.143532+02:00 Pharo.image priorSource: 20530!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/22/2017 09:50' prior: 33555030!commentForCurrentUpdate ^ '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/2006420074 Red-pane-of-death when sources file missing	https://pharo.fogbugz.com/f/cases/20074'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/22/2017 09:50'!script60495	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.4.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/22/2017 09:50'!update60495	"self new update60495"	self withUpdateLog: '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/2006420074 Red-pane-of-death when sources file missing	https://pharo.fogbugz.com/f/cases/20074'.	self loadTogether: self script60495 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60494!ScriptLoader removeSelector: #script60494!"ScriptLoader60"!!SourceFileArray methodsFor: 'private' stamp: 'BenComan 5/21/2017 23:27' prior: 61198173!createReadOnlyFiles	| readOnly failed |		failed := false.	readOnly := files collect: [ :file | 		file 			ifNil: [  failed := true. nil ]			ifNotNil: [ [ file readOnlyCopy ]         		on: FileDoesNotExistException        		do: [ failed := true. nil ] ]	].	^ failed ifFalse: [ readOnly ] ifTrue: [ self closeFileArray: readOnly. nil ]! !"System-Sources"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.571.mcz') load.ScriptLoader new update60495.!----End fileIn----!----QUIT----2017-05-22T09:53:26.771406+02:00 Pharo.image priorSource: 20608!----QUIT----2017-05-22T09:53:36.987945+02:00 Pharo.image priorSource: 40350!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/23/2017 11:30' prior: 33575210!commentForCurrentUpdate ^ '20068 Change sources file name for bootstrapped image	https://pharo.fogbugz.com/f/cases/20068'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/23/2017 11:30'!script60496	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/23/2017 11:30'!update60496	"self new update60496"	self withUpdateLog: '20068 Change sources file name for bootstrapped image	https://pharo.fogbugz.com/f/cases/20068'.	self loadTogether: self script60496 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60495!ScriptLoader removeSelector: #script60495!"ScriptLoader60"!!PharoBootstrapInitialization class methodsFor: 'public api' stamp: 'PavelKrivanek 5/18/2017 15:54' prior: 54387033!initializeCommandLineHandlerAndErrorHandling	"This method is run before the new bootstrapped image is saved!!"	ProcessorScheduler initialize.		Delay initialize.	SmallInteger initialize.		ProcessorScheduler startUp.		OSPlatform startUp: true.		"2 following lines are used to initialize Unicode tag constants.	Must be replaced by an uptodate version of Unicode class>>#initializeTagConstants and a call to it"	#(#Cc #Cf #Co #Cs #Ll #Lm #Lo #Lt #Lu #Mc #Me #Mn #Nd #Nl #No #Pc #Pd #Pe #Pf #Pi #Po #Ps #Sc #Sk #Sm #So #Zl #Zp #Zs)			doWithIndex: [ :each :index | Unicode classPool at: each put: index ].Unicode classPool at: #Cn put: 0.	UnicodeDefinitions initializeUnicodeClass.	EncodedCharSet initialize.	String initialize.	ByteString initialize. "needed by TextConverter to install LineEnd convention (called by Smalltalk openLog)"	ZnUTF8Encoder initialize.			"Weak array class initialization 2 lines"	Smalltalk specialObjectsArray at: 42 put: Semaphore new."to put in EPObjectSpace>>#createSpecialObjectsArray?"	WeakArray restartFinalizationProcess.		DiskStore useFilePlugin "initialize".	FileStream initialize.	FileStream classVarNamed: 'TheStdioHandles' put: FileStream stdioHandles. "FileStream startup"	ByteTextConverter initialize.	MultiByteFileStream initialize.	ASTCache default: ASTCache new. "ASTCache initialize, neeeded to print stack on error"	FileLocator startUp: true. "FileLocator initialize"	Smalltalk globals 		at: #Transcript		put: (NonInteractiveTranscript stdout install).	CompilationContext initialize.	Float initialize.	ZipConstants initialize.	ZipWriteStream initialize.	"Initialize classes related to compiler"	InflateStream initialize.	ByteTextConverter initialize.	ZipWriteStream initialize.	SetElement initialize.	ExternalSemaphoreTable initialize.	MacRomanTextConverter initialize.	Collection initialize.	ISOLanguageDefinition initialize.	CompiledMethod initialize.	MD5NonPrimitive initialize.	DangerousClassNotifier initialize.	Categorizer initialize.	Slot initialize.	CP1252TextConverter initialize.	SHA1 initialize.	TraitBehavior initialize.	RPackage initialize.	CompilationContext initialize.	OCASTTranslator initialize.	UIManager classVarNamed: 'Default' put: NonInteractiveUIManager new.	UIManager default activate.	Smalltalk sourceFileVersionString: 'PharoV60'.	(Smalltalk class classVariableNamed: 'LastImagePath') value: Smalltalk imagePath. "set the default value"	SourceFiles := SourceFileArray new ensureOpen. "needed to get source from a compiled method, used to log an error."	Smalltalk openSourceFiles.		BasicCommandLineHandler new activate. "BasicCommandLineHandler startUp:"	Processor terminateActive.! !"PharoBootstrap-Initialization"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.572.mcz') load.ScriptLoader new update60496.!----End fileIn----!----QUIT----2017-05-23T11:33:20.381382+02:00 Pharo.image priorSource: 40428!----QUIT----2017-05-23T11:33:30.825145+02:00 Pharo.image priorSource: 62354!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/23/2017 15:34' prior: 33595030!commentForCurrentUpdate ^ '20084 Highlight Message Send is not enabled by default in bootstrapped/reloaded image	https://pharo.fogbugz.com/f/cases/2008420072 Importing Resource Help needs improvement	https://pharo.fogbugz.com/f/cases/2007219809 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/19809'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/23/2017 15:34'!script60497	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/23/2017 15:34'!update60497	"self new update60497"	self withUpdateLog: '20084 Highlight Message Send is not enabled by default in bootstrapped/reloaded image	https://pharo.fogbugz.com/f/cases/2008420072 Importing Resource Help needs improvement	https://pharo.fogbugz.com/f/cases/2007219809 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/19809'.	self loadTogether: self script60497 merge: false.	(SystemAnnouncer uniqueInstance subscriptions glmSubscriptions select: [:sub | sub subscriber isNil]) do: #finalize. 3 timesRepeat: [Smalltalk garbageCollect ].	self flushCaches.! !ScriptLoader removeSelector: #update60496!ScriptLoader removeSelector: #script60496!"ScriptLoader60"!!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:40' prior: 29378986!encodingAndDecoding	^ HelpTopic 		title: 'Encoding and Decoding'		contents: (self heading: 'Encoding and Decoding'),'The basic mechanism to encode and decode data is provided by the class Base64MimeConverter. Consider the following example:mimeEncoded := ''Hello World'' asByteArray base64Encoded.(Base64MimeConverter mimeDecodeToBytes: mimeEncoded readStream) contents asStringThe variable mimeEncoded contains an encoding of the Hello World string using the mime64 encoding. The method #mimeDecodeToBytes: reads mime64 strings from a stream. The example uses a string, but it could refers to any objects. You essentially need a ReadStream. '! !!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:48'!encodingAndDecodingImage	^ HelpTopic 		title: 'Encoding and Decoding Image'		contents: (self heading: 'Encoding and Decoding Image'),'Embedding pictures in plan source code is often the reason why one need to encode resources. The following script loads an image located in the filesystem, create a string-friendly representation, and store it in a method. You probably want to keep the image in a class variable or a hash table.',(self bold: 'form := PNGReadWriter formFromStream: ''/Users/alexandrebergel/Dropbox/Screenshots/Screenshot 2017-05-19 15.25.44.png'' asFileReference readStream."Write the stream on a stream"w := WriteStream on: ByteArray new.PNGReadWriter putForm: form onStream: w.w contents."Convert the byteArray into mime 64. It takes less space in the image"encodedContent := w contents base64Encoded."The following code converts the stream content "PNGReadWriter formFromStream: (Base64MimeConverter mimeDecodeToBytes: encodedContent readStream)."We encode the image as a method"Object compile: ''imageSource  ^ '''',  encodedContent, ''''.Object compile: ''image ^ PNGReadWriter formFromStream: (Base64MimeConverter mimeDecodeToBytes: self imageSource readStream). ''."A better implementation is to cache the image in an instance or class variable""The following expression return the image initially encoded"Object new image '),''! !!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:39' prior: 29378243!overview	^ HelpTopic 		title: 'Overview'		contents: (self heading: 'Overview'),'Non trivial applications often rely on resources that may be externally provided such as icons, pictures, sounds. Such resources are typically defined as external files. Naturally, you can make your application depends on external files, however, importing resource files within the Pharo image and make it integrally part of you code has a number of advantages:- you can simply deploy your application by downloading it from smalltalkhub. - having less dependencies on external files is always good to avoid technical subtilities such as file path containing weird characters. '! !!ImportingResourceHelp class methodsFor: 'accessing' stamp: 'AlexandreBergel 5/19/2017 15:40' prior: 29380828!pages	^#(overview encodingAndDecoding encodingAndDecodingImage)! !!BaselineOfIDE methodsFor: 'actions' stamp: 'PavelKrivanek 5/23/2017 12:47' prior: 18109028!additionalInitialization	self class environment at: #GTGenericStackDebugger ifPresent: [	  Smalltalk tools register: GTGenericStackDebugger as: #debugger.	  Smalltalk tools registeredDebuggersWithRanks.	  Smalltalk tools debuggers add: ((self class environment at: #GTGenericStackDebugger)->3).	  Smalltalk tools debuggers add: ((self class environment at: #GTSUnitDebugger)->70).	  Smalltalk tools debuggers add: ((self class environment at: #GTBytecodeDebugger)->5).].	  	self class environment at: #GTPlayground ifPresent: [:playground | 	  Smalltalk tools register: playground as: #workspace.].	self class environment at: #GTInspector ifPresent: [:inspector | 	  Smalltalk tools register: inspector as: #inspector.].	  Smalltalk tools register: ExternalChangesBrowser as: #changeList.	Smalltalk tools register: FileList as: #fileList.	Smalltalk tools register: Finder as: #finder.	Smalltalk tools register: ProcessBrowser as: #processBrowser.	Smalltalk tools register: RecentMessageList as: #recentMessageList.	Smalltalk tools register: SyntaxErrorDebugger as: #syntaxErrorDebugger.	Smalltalk tools register: TimeProfiler as: #timeProfiler.	(MorphicCoreUIManager classPool at: #UIProcess) ifNotNil: [ :proc | proc terminate ].	MorphicCoreUIManager classPool at: #UIProcess put: nil.	PolymorphSystemSettings desktopColor:  Color veryVeryLightGray lighter.	SourceCodeFonts setSourceCodeFonts: 10.	FreeTypeSystemSettings loadFt2Library: true.	FreeTypeSettings current monitorType: #LCD.	FreeTypeSettings current glyphContrast: 55.		CatalogSettings displayCatalogProjectsInSpotter: false.	RealEstateAgent usedStrategy: #cascadeFor:initialExtent:world:.	GrowlMorph position: #bottomLeft.	ShortcutReminder enabled: true.	self class environment at: #QASettings ifPresent: [:qaSettings |	  qaSettings nautilusPlugin: true].	KMRepository reset.	Morph shortcutsHandler: KMShortcutHandler new.	"because of Komitter"	MCSaveVersionDialog previousMessages add: String new.	RBProgramNode formatterClass: BIConfigurableFormatter.	Color flushCache.	ASTTransformExamplePluginActive recompile.	PharoCommandLineHandler recompile.	SmalltalkImage recompile.		RubCharacterScanner initialize.		RubAbstractTextArea highlightMessageSend: true.		Pharo3DarkTheme beCurrent.		Smalltalk ui theme settings secondarySelectionColor: (Color r: 0.31 g: 0.31 b: 0.36 alpha: 1.0).		3 timesRepeat: [		Smalltalk garbageCollect.		Undeclared removeUnreferencedKeys.].		self loadIceberg.! !"BaselineOfIDE"!"ImportingResource-Help"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.573.mcz') load.ScriptLoader new update60497.!----End fileIn----!----QUIT----2017-05-23T15:38:14.333294+02:00 Pharo.image priorSource: 62432!----QUIT----2017-05-23T15:38:24.907147+02:00 Pharo.image priorSource: 87995!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/1/2017 15:55' prior: 33617034!commentForCurrentUpdate ^ '20095 SystemProgressMorph should call doOneCycleNow on refresh only when active process is UIProcess	https://pharo.fogbugz.com/f/cases/2009520099 Cairo fonts crashing on 64bits	https://pharo.fogbugz.com/f/cases/20099'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/1/2017 15:55'!script60498	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/1/2017 15:55'!update60498	"self new update60498"	self withUpdateLog: '20095 SystemProgressMorph should call doOneCycleNow on refresh only when active process is UIProcess	https://pharo.fogbugz.com/f/cases/2009520099 Cairo fonts crashing on 64bits	https://pharo.fogbugz.com/f/cases/20099'.	self loadTogether: self script60498 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60497!ScriptLoader removeSelector: #script60497!"ScriptLoader60"!!SystemProgressMorph methodsFor: 'updating' stamp: 'DenisKudryashov 5/30/2017 18:12' prior: 63149702!refresh	"We may be blocking the UI thread, and thus have to draw the world ourselves when necessary"	lastRefresh := Time millisecondClockValue.	UIManager default uiProcess == Processor activeProcess		ifTrue: [ self currentWorld doOneCycleNow]! !!CairoFontFace class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:10' prior: 18768599!fromFreetypeFace: aFace	| handle cairoFace |		handle := aFace handle pointerAt: 1. 	cairoFace := self primFtFace: handle loadFlags: ( LoadNoHinting | LoadTargetLCD | LoadNoAutohint | LoadNoBitmap). 		^ cairoFace initializeWithFreetypeFace: aFace! !!CairoFontFace class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:10' prior: 18768082!primFtFace: aFace loadFlags: flags"cairo_font_face_t * cairo_ft_font_face_create_for_ft_face                                                        (FT_Face face,                                                         int load_flags);"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCall: #( CairoFontFace cairo_ft_font_face_create_for_ft_face(void * aFace , int flags )) ! !!CairoScaledFont class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:09' prior: 18799108!fromFreetypeFont: aFont	| ftFace face |	^ CairoBackendCache soleInstance at: aFont ifAbsentPut: [ | emphasis |			emphasis := aFont simulatedEmphasis.			ftFace := aFont face.			face := CairoBackendCache soleInstance 				at: {ftFace.	emphasis} 				ifAbsentPut: [ | cff |					cff := CairoFontFace fromFreetypeFace: ftFace.					emphasis ifNotNil: [ cff synthesizeEmphasis: emphasis ].					cff ].			self fromFreetypeFont: aFont cairoFace: face ]! !!AthensCairoMatrix class methodsFor: 'field definition' stamp: 'EstebanLorenzano 6/1/2017 15:34' prior: 17537657!fieldsDesc	"self rebuildFieldAccessors"	^ #(   double sx; double shx;   double shy; double sy;   double x; double y;	)! !!SystemProgressItemMorph methodsFor: 'private' stamp: 'DenisKudryashov 5/30/2017 18:12' prior: 63145033!refresh	lastRefresh := Time millisecondClockValue.	UIManager default uiProcess == Processor activeProcess		ifTrue: [ self currentWorld doOneCycleNow ]! !"Athens-Cairo"!"Morphic-Base"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.574.mcz') load.ScriptLoader new update60498.!----End fileIn----!----QUIT----2017-06-01T15:57:07.284048+02:00 Pharo.image priorSource: 88073!----QUIT----2017-06-01T15:57:17.746509+02:00 Pharo.image priorSource: 109737!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/6/2017 15:11' prior: 33642674!commentForCurrentUpdate ^ '20102 SmallInteger>>#digitAt: not ready for 64-bit - Some Kernel-Tests-Numbers fail to take 64-bit into account	https://pharo.fogbugz.com/f/cases/2010220070 terminal color not reset after a error message	https://pharo.fogbugz.com/f/cases/2007019949 ensureEndsWith: does not handle start of stream case	https://pharo.fogbugz.com/f/cases/1994920101 Typos and general writing of release welcome text	https://pharo.fogbugz.com/f/cases/20101'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/6/2017 15:11'!script60499	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2513.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/6/2017 15:11'!update60499	"self new update60499"	self withUpdateLog: '20102 SmallInteger>>#digitAt: not ready for 64-bit - Some Kernel-Tests-Numbers fail to take 64-bit into account	https://pharo.fogbugz.com/f/cases/2010220070 terminal color not reset after a error message	https://pharo.fogbugz.com/f/cases/2007019949 ensureEndsWith: does not handle start of stream case	https://pharo.fogbugz.com/f/cases/1994920101 Typos and general writing of release welcome text	https://pharo.fogbugz.com/f/cases/20101'.	self loadTogether: self script60499 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60498!ScriptLoader removeSelector: #script60498!"ScriptLoader60"!!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:10' prior: 84508630!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: (self heading: 'Highlights (aka New Stuff) in Pharo 6.0'),'- The PharoVM and image are also provided in a 64-bit version in Linux and macOS/OSX and bring even better performance and stability- A new code changes management system named Epicea for reviewing and recovering of your code easily- Integrated support for Git through an easy-to-use tool for repositories and commits management named Iceberg (as a preview in Pharo 6, it will be the default in Pharo 7)- The unified foreign function interface (UnifiedFFI) for interfacing with the outside world is significantly improved- The PharoVM is now part of OpenSmalltalk initiative- Introduction of object immutability, alternative bytecode sets and block closures independent of outer context- Pharo can now be bootstrapped from source code managed by Git- Pharo modularity is improved- Pharo is faster- The Dark Theme was improved and set as default color theme of Pharo', (self heading: 'All Issues'), 'Over 1400 fixes and enhancements were integrated in this release.As the complete list of fixed issues is too large to be placed here, you can review it on the FogBugz issue tracker (', (self url: 'https://pharo.fogbugz.com'), ') (requires account).', (self subheading: 'Tools'),'- Epicea provides a code changes manager- Iceberg provides a Git repositories manager- GTInspector, GTDebugger and other tools are now based on FastTable (long lists of items are rendered much faster)- GToolkit and GTools have been updated- Quality Assistant has been improved- Interrupt key (Cmd+ /, Ctrl+.) has been made more reliable- Playground variables are now visible from debugger- Debugger temp names mapping is fixed- There is a "Close all debuggers"  in the taskbar context menu- GTDebugger has a "Run to here" feature- Results and critiques can be filtered in the MessageBrowser- Dependency Analyzer has been improved- Nautilus enhancements        - Splitting of large variable entries in the Variables menu        - Deprecated methods are shown with strikethrough emphasis        - Abstract classes are shown in italics with a slight color adjustment', (self subheading: 'VM related'), '- 64-bits support- Improvement of host platforms management (32-bit/64-bit)- Improved UnifiedFFI- The PharoVM is now part of OpenSmalltalk initiative- Introduction of object immutability- Introduction of FullBlockClosure which will help in future evolutions of Pharo- Ephemerons support, introduction of the EphemeronRegistry- Support of alternative bytecode sets and introduction of Sista Encoder, the encoder for the SistaV1 bytecode set. This will be the bedrock on which Pharo will improve',(self subheading: 'Reflectivity'), '- General improvements- haltOnce is active by default per method. It does not require global turning on (enable haltOnce) and it is managed from the source code area in Nautilus- Execution counter for message nodes in the source code area in Nautilus- API for Metalinks on AST nodes- Mirror primitives (Those are reflection primitives which access object state without messaging them, see MirrorPrimitives class)- Inlined method const can be implemented by Metalinks', (self subheading: 'Other'), '- Dark Theme improvements- Improvement of theme change while windows are open- Support of two double quotes inside comments- Standalone Morphic worlds in separate windows- Fix of several memory leaks- Improvement of working directory structure (introduction of a ''pharo-local'' directory to include Pharo directories such as ''package-cache'')- Better autocategorization of methods- Introduction of a FuzzyMatcher for approximate string matching- Glamour integration in Spec- Renaming (Cmd+R / Ctrl+R) in Nautilus supports more AST nodes- anObject asMethodConst to cache expressions dynamically- GlobalIdentifier for computer identification- NeoUUIDGenerator replaces the old UUIDGenerator- STON was improved and is now used by Monticello FileTree- Storage of suspended announcements- Improved newAnonymousSubclass- Inheritable process specific variables- Fuel improvements- Enablement of <example> methods so that they can be executed easily- Support for <sampleInstance>- New class and method API for tags as replacement for categories and protocols- TabMorph improvements- Unification of Dictionary APIs (including an OrderedDictionary)- Package manifests improvements- Improvement of RadioButton groups', (self subheading: 'Cleanups'), '- Object>>#name is now deprecated and will be removed in Pharo 7- Better system modularization- Ability for the system to be fully bootstrapped from source code- Turn off of catalog search in Spotter by default (This improves the stability of Pharo when used with poor Internet connections)- Removal of Chroma-CubeHelix and TxWorkspace- Rename of Pragma>>#selector to Pragma>>#methodSelector- Improvement of icons management (#iconNamed: introduced in order to replace DNU-based icons)- Limit use of #asClass in order to rely on an environment- It is now possible to give a rewrite rule when deprecating a method to automatically rewrite code with deprecation (#deprecated:transformWith:)- Deprecation of the following:        Object>>name        ShortRunArray class        Object>>confirm:orCancel:        Object>>ifNil:ifNotNilDo:        Object>>ifNotNilDo:        Object>>ifNotNilDo:ifNil:        Collection>>ifEmpty:ifNotEmptyDo:        Collection>>ifNotEmptyDo:        Collection>>ifNotEmptyDo:ifEmpty:        SequenceableCollection>>copyLast:        Integer>>asBytesDescription        Pragma>>method:', (self subheading: 'Unit testing/Documentation'), '- RecursionStopper provides an easy way to check if we are in a recursion and execute code just once in a recursion- New process specific variable ''CurrentExecutionEnvironment'' with value DefaultExecutionEnvironment by default and TestExecutionEnvironment during a test run- SUnit is improved by introducing a time limit for tests, preventing "forked debuggers"- New assert extension to compare floats with #closeTo:- More class comments and documentation', (self subheading: 'Network'), '- Support Server Name Indication (SNI) in Zodiac/SSLPlugin- Zinc/Zodiac updateYou can see the Pharo 6.0 changelog at: ', (self url: 'https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo60ChangeLogs.md')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:54' prior: 84516114!documentation	^ HelpTopic 		title: 'More Documentation'		contents: (self heading: 'More Documentation'), 			'The most important documentation is the one you can get by exploring the system, reading class comments and looking for examples. You can find "in image" help by clicking on the following expression:', (self doItFrom: 'HelpBrowser open.'), 'This browser is also accessible from the World>Help>Help Browser menu (just click the desktop, select Help, and then Help Browser).A compendium of Pharo documentation can be found at: ', (self url: 'http://pharo.org/documentation'), 'There you can find:- Pharo books: ', (self url: 'http://books.pharo.org'), '- Screencasts: ', (self url: 'https://www.youtube.com/channel/UCp3mNigANqkesFzdm058bvw'), '- Presentations: ', (self url: 'http://www.slideshare.net/pharoproject/')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:54' prior: 84519806!exploreEnvironment	^ HelpTopic 		title: 'Explore the Pharo Environment'		contents: (self heading: 'Explore the Pharo Environment'), 				'The best way to learn Pharo is to explore it by yourself. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to get started with the tools and capabilities the environment provides.The most complete and updated guide for the Pharo environment can be found in the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: ', (self url: 'https://github.com/SquareBracketAssociates/UpdatedPharoByExample'), 'One chapter of particular interest is the one that provides a quick tour of the environment: ', (self url: 'https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:55' prior: 84515442!gettingHelp	^ HelpTopic 		title: 'Getting Help'		contents: (self heading: 'Getting Help'),		'Pharo has a vibrant community that shares knowledge in different ways: - The "Pharo Users" mailing list: 	', (self url: 'http://lists.pharo.org/mailman/listinfo/pharo-users_lists.pharo.org'), '- The "Pharo Discord channel": 	', 	(self url: 'http://discord.gg/Sj2rhxn'), '- The "Pharo IRC Channel": 	', (self url: 'irc.freenode.net, #pharo channel '), 'You can find more information, lists to browse/suscribe and places to share code at: ', (self url: 'http://pharo.org/community')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:11' prior: 84518270!learn	^ HelpTopic 		title: 'Learn Pharo'		contents: (self heading: 'Learn Pharo'), 		'You can learn Pharo by clicking on the following expression: 	', (self doItFrom: 'ProfStef go.'), (self subheading: 'MOOC'), 'Pharo has an excellent MOOC (Massive Open Online Course). You can find more information here: ', (self url: 'http://mooc.pharo.org'), (self subheading: 'Books'), 'There are several free Pharo books that can be download here: ', (self url: 'http://books.pharo.org'), 'A very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: ', (self url: 'https://github.com/SquareBracketAssociates/UpdatedPharoByExample'), ''! !!WelcomeHelp class methodsFor: 'showing' stamp: 'PhilippeBack 6/1/2017 17:23' prior: 84517046!open	<script>	^ (HelpBrowser openOn: self) next! !!WelcomeHelp class methodsFor: 'showing' stamp: 'PhilippeBack 6/1/2017 17:24' prior: 84515001!openForRelease	<script>	| browser window findBlock |		findBlock := [ :each | (each isKindOf: SystemWindow) and: [ each label = self bookName ] ]. 	World submorphs 		detect: findBlock 		ifFound: [ :oldWindow | oldWindow delete ].	browser := self open.	window := browser dependents detect: findBlock.	window extent: 700@400.	window center: Display extent / 2! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:13' prior: 84517171!useExternalPackages	^ HelpTopic 		title: 'Using Eternal Packages'		contents: (self heading: 'Using External Packages'), 'Pharo already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the "Catalog Browser". To open it click on the following expression:		', (self doItFrom: 'CatalogBrowser open.'), 'This browser is also accessible from the World>Tools>Catalog Browser menu (just click the desktop, select Tools, and then Catalog Browser).Catalog projects can be browsed online: ', (self url: 'http://catalog.pharo.org'), 'You can also a rough list (not very friendly) of many packages available stored in smalltalkhub repository:', (self url: 'http://smalltalkhub.com/list'), '(this list is not a compendium of packages for Pharo but is a good place to start looking for something in particular and which happens to not be present in the catalog).The catalog can be enabled in Spotter by enabling the "Display catalog projects in Spotter" system preference.'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:58' prior: 84519159!welcome	^ HelpTopic 		title: 'Welcome to Pharo 6.0'		contents: (self heading: 'Pharo 6.0'), 		'Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visit here: ', (self url: 'http://pharo.org'),(self subheading: 'Color themes'),'White theme: ', (self doItFrom: 'Pharo3Theme beCurrent. '), ' Dark theme: ', (self doItFrom: 'Pharo3DarkTheme beCurrent. ').! !!WriteStreamTest methodsFor: 'tests' stamp: 'KKSubbu 6/2/2017 21:03' prior: 84725775!testEnsureEndsWith	"self debug: #testEnsureEndsWith"	| stream |	stream := self newStream.	stream nextPutAll: 'this is a test'.	stream ensureEndsWith: Character cr.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').		"Manually put a new line and verify there are no 2 new lines"	stream := self newStream.	stream nextPutAll: ('this is a test' copyWith: Character cr).	stream ensureEndsWith: Character cr.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').		"Test with a empty stream"	stream := self newStream.	stream ensureEndsWith: Character cr.	self assert: stream contents equals: ''.! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'SvenVanCaekenberghe 6/1/2017 20:45' prior: 29635981!testBitString	"self debug: #testBitString"		Smalltalk vm wordSize = 4		ifTrue: [			self assert: 2 bitString equals: '0000000000000000000000000000010'.			self assert: -1 bitString equals: '1111111111111111111111111111111'.			self assert: -2 bitString equals: '1111111111111111111111111111110'.			self assert: 2 bitStringLength equals: 31 ]. 	Smalltalk vm wordSize = 8		ifTrue: [			self assert: 2 bitString equals: '0000000000000000000000000000000000000000000000000000000000010'.			self assert: -1 bitString equals: '1111111111111111111111111111111111111111111111111111111111111'.			self assert: -2 bitString equals: '1111111111111111111111111111111111111111111111111111111111110'.			self assert: 2 bitStringLength equals: 61 ]. 	"32 minus 1 for immediate encoding = 31 = 30 for number + 1 for sign"	"64 minus 3 for immediate encoding = 61 = 60 for number + 1 for sign"	self assert: 2 bitStringLength equals: (SmallInteger maxVal highBit + 1).! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29639619!testCreationFromBytes1	"self run: #testCreationFromBytes1"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs SmallInteger maxVal as an instance of SmallInteger. "  	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := maxSmallInt printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = maxSmallInt.	self assert: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29640579!testCreationFromBytes2 	"self run: #testCreationFromBytes2"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal + 1) as an instance of LargePositiveInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt + 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt + 1).	self deny: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29625524!testCreationFromBytes3	"self run: #testCreationFromBytes3"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal - 1) as an instance of SmallInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt - 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt - 1).	self assert: builtInteger class = SmallInteger! !!VTermOutputDriver methodsFor: 'coloring' stamp: 'kks 5/19/2017 19:58' prior: 84236066!errorColor 	self red! !!STCommandLineHandler class methodsFor: 'printing' stamp: 'kks 5/19/2017 20:01' prior: 59101401!printCompilerWarning: aSyntaxErrorNotification	| stderr position contents errorLine errorMessage maxLineNumberSize lineNumber |		"format the error"	position := aSyntaxErrorNotification location.	contents := aSyntaxErrorNotification errorCode.	errorLine := contents lineNumberCorrespondingToIndex: position.	stderr := VTermOutputDriver stderr.			"first gather the error title to be able to underline it properly"	errorMessage := String streamContents: [ :s|		s nextPutAll: 'Syntax Error on line '; 			print: errorLine; nextPutAll: ': '; 			print: aSyntaxErrorNotification errorMessage].		 stderr red;		nextPutAll: errorMessage; lf;		nextPutAll: ('' padLeftTo: errorMessage size with: $=); lf;		clear.		"print each source line and mark the found syntax error"	maxLineNumberSize := contents lines size asString size.	lineNumber := 0.	contents lineIndicesDo: [:start :endWithoutDelimiters :end |		lineNumber := lineNumber + 1.		lineNumber == errorLine ifTrue: [ stderr errorColor ].		"0 pad the line numbers to the same size"		stderr 			nextPutAll: (lineNumber asString padLeftTo: maxLineNumberSize with: $0);			nextPutAll: ': ';			nextPutAll: (contents copyFrom: start to: endWithoutDelimiters);			lf.			"print the marker under the error line"		(lineNumber == errorLine)			ifTrue: [					stderr nextPutAll:( '_^_' padLeftTo: position - start + maxLineNumberSize + 4);							 lf;							 clear]	]! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'PhilippeBack 6/1/2017 17:22' prior: 54501828!open	<script>	| group welcome help zen about window |	welcome := WelcomeHelp open.	help := HelpBrowser open.	zen := TextModel new			text: ProfStef pharoZenValuesContents;			title: 'Pharo Zen';			aboutText: ProfStef aboutPharoZen;			beForText;			openWithSpec.				about := TextModel new			text: Smalltalk systemInformationString withCRs;			title: 'About Pharo';			beForText;			openWithSpec.	group := GroupWindowMorph new.	group addWindow: welcome window.	group addWindow: help window.	group addWindow: SettingBrowser open.	group addWindow: KeymapBrowser new openWithSpec window.	group addWindow: zen window.	group addWindow: about window.	window := (group openInWindowLabeled: self title translated)		extent: welcome window extent;		yourself.			group tabGroup selectedPageIndex: 1.	^ window! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'PhilippeBack 6/1/2017 17:22' prior: 54502733!openForRelease	<script>	| window |		World submorphs 		detect: [ :each | (each isKindOf: SystemWindow) and: [ each label = self title ] ] 		ifFound: [ :oldWindow | oldWindow delete ].	window := self open.	window extent: 750@400.	window center: Display extent / 2! !!SmallIntegerTest methodsFor: 'tests - Class Methods' stamp: 'SvenVanCaekenberghe 6/1/2017 20:03' prior: 60216021!testMaxVal	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger maxVal = 16r3FFFFFFF ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger maxVal = 16rFFFFFFFFFFFFFFF ]! !!SmallIntegerTest methodsFor: 'tests - Class Methods' stamp: 'SvenVanCaekenberghe 6/1/2017 20:04' prior: 60215871!testMinVal	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger minVal = -16r40000000 ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger minVal = -16r1000000000000000 ]! !!SmallIntegerTest methodsFor: 'tests - printing' stamp: 'SvenVanCaekenberghe 6/1/2017 20:08' prior: 60217483!testPrintString	self assert: 1 printString equals: '1'.	self assert: -1 printString equals: '-1'.	Smalltalk vm wordSize = 4		ifTrue: [ 			self assert: SmallInteger minVal printString equals: '-1073741824'.			self assert: SmallInteger maxVal printString equals: '1073741823' ].	Smalltalk vm wordSize = 8		ifTrue: [ 			self assert: SmallInteger minVal printString equals: '-1152921504606846976'.			self assert: SmallInteger maxVal printString equals: '1152921504606846975' ].	self assert: 12345 printString equals: '12345'.	self assert: -54321 printString equals: '-54321'.		self assert: 0 decimalDigitLength equals: 1.	self assert: 4 decimalDigitLength equals: 1.	self assert: 12 decimalDigitLength equals: 2.	self assert: 123 decimalDigitLength equals: 3.	self assert: 1234 decimalDigitLength equals: 4.	self assert: 56789 decimalDigitLength equals: 5.	self assert: 657483 decimalDigitLength equals: 6.	self assert: 6571483 decimalDigitLength equals: 7.	self assert: 65174383 decimalDigitLength equals: 8.	self assert: 625744831 decimalDigitLength equals: 9.	self assert: 1000001111 decimalDigitLength equals: 10.	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 10 ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 19 ].! !!SmallInteger methodsFor: 'system primitives' stamp: 'SvenVanCaekenberghe 6/2/2017 09:42' prior: 60213036!digitAt: n	"Answer the value of an apparent byte-indexable field in the receiver,	 analogous to the large integers, which are organized as bytes."	n = 1		ifTrue: [ 			"Negate carefully in case the receiver is SmallInteger minVal"			^ self < 0				ifTrue: [ -256 - self bitAnd: 255 ]				ifFalse: [ self bitAnd: 255 ] ].	^ self < 0		ifTrue: [ (-256 - self bitShift: -8) + 1 digitAt: n - 1 ]		ifFalse: [ (self bitShift: 8 - (n bitShift: 3)) bitAnd: 255 ]! !!WriteStream methodsFor: 'accessing' stamp: 'kks 4/18/2017 22:42' prior: 84716398!ensureEndsWith: anObject	"Append anObject to the receiver IFF it is non-empty and there is not one on the end."	(position == 0 or: [(collection at: position) = anObject]) ifTrue: [^self].	self nextPut: anObject! !"CodeImportCommandLineHandlers"!"Collections-Streams"!"Collections-Tests"!"Kernel"!"Kernel-Tests"!"Pharo-Help"!"System-CommandLine"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.575.mcz') load.ScriptLoader new update60499.!----End fileIn----!----QUIT----2017-06-06T15:14:03.768117+02:00 Pharo.image priorSource: 109815!----QUIT----2017-06-06T15:14:14.551317+02:00 Pharo.image priorSource: 153371!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/13/2017 17:20' prior: 33664417!commentForCurrentUpdate ^ '20146 ZnHTTPSTests>>#testGetPharoVersion started to fail	https://pharo.fogbugz.com/f/cases/20146'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/13/2017 17:20'!script60500	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2513.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/13/2017 17:20'!update60500	"self new update60500"	self withUpdateLog: '20146 ZnHTTPSTests>>#testGetPharoVersion started to fail	https://pharo.fogbugz.com/f/cases/20146'.	self loadTogether: self script60500 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60499!ScriptLoader removeSelector: #script60499!"ScriptLoader60"!!ZnHTTPSTests methodsFor: 'testing' stamp: 'PavelKrivanek 6/13/2017 16:53' prior: 85303548!testGetPharoVersion	| client lastBuildVersion version |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].	self runningOnWindowsInriaCI ifTrue: [ ^ self ].	lastBuildVersion := (client := ZnClient new)		beOneShot;		get: 'https://ci.inria.fr/pharo/job/Pharo-6.0/lastSuccessfulBuild/api/xml?xpath=/*/fullDisplayName'.	self assert: client isSuccess.	self assert: (client response contentType matches: ZnMimeType applicationXml).	self assert: client response contentLength > 0.	self assert: lastBuildVersion notNil.	self assert: lastBuildVersion isString.	self assert: lastBuildVersion size > 0.	version := (lastBuildVersion copyAfter: $>) copyUpTo: $<.	self deny: version isEmpty! !"Zinc-Zodiac"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.576.mcz') load.ScriptLoader new update60500.!----End fileIn----!----QUIT----2017-06-14T09:44:11.413887+02:00 Pharo.image priorSource: 153450!----QUIT----2017-06-14T09:44:21.849899+02:00 Pharo.image priorSource: 173343!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/14/2017 14:17' prior: 33708053!commentForCurrentUpdate ^ '20093 Missing source stamp makes changes hard to view	https://pharo.fogbugz.com/f/cases/2009320148 transforming deprecations should take #showWarning into account	https://pharo.fogbugz.com/f/cases/20148'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/14/2017 14:18'!script60501	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2515.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/14/2017 14:18'!update60501	"self new update60501"	self withUpdateLog: '20093 Missing source stamp makes changes hard to view	https://pharo.fogbugz.com/f/cases/2009320148 transforming deprecations should take #showWarning into account	https://pharo.fogbugz.com/f/cases/20148'.	self loadTogether: self script60501 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60500!ScriptLoader removeSelector: #script60500!"ScriptLoader60"!!VersionBrowser methodsFor: 'accessing' stamp: 'akevalion 6/2/2017 12:19' prior: 84263674!displayStringsFor: aMethodVersion	| author version cleanStampParts |		"a stamp is a string in the form  'GuillermoPolito 3/4/2015 14:33'"	"It may be incomplete, empty or even start with spaces."	cleanStampParts := aMethodVersion stamp trim substrings.		author := cleanStampParts ifEmpty: [ '<missing>' ] ifNotEmpty: [ :parts | parts first ].	version := cleanStampParts ifEmpty: [ '<missing>' ] ifNotEmpty: [ :parts | parts allButFirst joinUsing: ' ' ].		^ {author.	version.	(aMethodVersion realClass name).	(aMethodVersion selector).	('{' , aMethodVersion category , '}')}! !!Deprecation class methodsFor: 'logging' stamp: 'MarcusDenker 6/14/2017 10:12' prior: 22471619!deprecationsWhile: aBlock	"returns a log of all deprecated methods seen while executing aBlock"	| oldLog result |	oldLog := Log.	Log := Set new.	aBlock value.	result := Log.	oldLog ifNotNil: [oldLog addAll: result].	Log := oldLog.	^result! !!Deprecation class methodsFor: 'class initialization' stamp: 'MarcusDenker 6/14/2017 10:11' prior: 22471111!initialize	Log := nil "#deprecationsWhile: logs all deprecations here"! !!Deprecation class methodsFor: 'settings' stamp: 'MarcusDenker 6/14/2017 10:12' prior: 22471882!raiseWarning	"If true, then a dialog is popup for each deprecated method invocation"	^ RaiseWarning ifNil: [RaiseWarning := true]! !!Deprecation class methodsFor: 'settings' stamp: 'MarcusDenker 6/14/2017 10:12' prior: 22471221!showWarning	"If true, then a message is send to the Transcript for each deprecated method invocation"	^ ShowWarning ifNil: [ShowWarning := true]! !!Deprecation methodsFor: 'handling' stamp: 'MarcusDenker 6/14/2017 09:49' prior: 22467842!transform	| node rewriteRule aMethod |	self raiseWarning ifFalse: [ ^ self ]. "when desprecations are disables, we do not want to transform, either"	self rewriterClass ifNil:[ ^ self signal ].	aMethod := self contextOfSender method.	aMethod isDoIt ifTrue:[^ self]. "no need to transform doits"	node := self contextOfSender sourceNodeExecuted.	rewriteRule := self rewriterClass new 		replace: rule key with: rule value.	(rewriteRule executeTree: node)		ifFalse: [ ^ self ].	node replaceWith: rewriteRule tree. 	Author 		useAuthor: 'AutoDeprecationRefactoring'		during: [aMethod origin compile: aMethod ast formattedCode classified: aMethod protocol].		Log 		ifNotNil: [:log | log add: self].	self logTranscript! !"Kernel"!"Spec-Tools"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.577.mcz') load.ScriptLoader new update60501.!----End fileIn----!----QUIT----2017-06-14T14:20:25.717131+02:00 Pharo.image priorSource: 173422!----QUIT----2017-06-14T14:20:36.169244+02:00 Pharo.image priorSource: 195237!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/23/2017 14:15' prior: 33728025!commentForCurrentUpdate ^ '20110 AllocationTest>>#testOutOfMemorySignal not well suited to 64-bit	https://pharo.fogbugz.com/f/cases/2011020096 Add script pragma to SpaceTally>>printSpaceAnalysis	https://pharo.fogbugz.com/f/cases/2009620174  In the debug halo of a morph: clicking on "inspect morph" and "explore morph" bring up the same window.	https://pharo.fogbugz.com/f/cases/20174'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/23/2017 14:15'!script60502	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2515.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/23/2017 14:15'!update60502	"self new update60502"	self withUpdateLog: '20110 AllocationTest>>#testOutOfMemorySignal not well suited to 64-bit	https://pharo.fogbugz.com/f/cases/2011020096 Add script pragma to SpaceTally>>printSpaceAnalysis	https://pharo.fogbugz.com/f/cases/2009620174  In the debug halo of a morph: clicking on "inspect morph" and "explore morph" bring up the same window.	https://pharo.fogbugz.com/f/cases/20174'.	self loadTogether: self script60502 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60501!ScriptLoader removeSelector: #script60501!"ScriptLoader60"!!SpaceTally class methodsFor: 'fileout' stamp: 'MarcusDenker 6/22/2017 15:39' prior: 62052990!printSpaceAnalysis		<script>	self new printSpaceAnalysis! !!Morph methodsFor: 'debug and other' stamp: 'MarcusDenker 6/22/2017 15:34' prior: 51484071!buildDebugMenu: aHand	"Answer a debugging menu for the receiver. 	 The hand argument is seemingly historical and plays no role presently"	| aMenu |	aMenu := UIManager default newMenuIn: self for: self.	(self hasProperty: #errorOnDraw)		ifTrue: [ aMenu add: 'start drawing again' selector: #resumeAfterDrawError ].	(self hasProperty: #drawError)		ifTrue: [ aMenu add: 'debug drawing error' selector: #debugDrawError.			aMenu addLine ].	(self hasProperty: #errorOnStep)		ifTrue: [ aMenu add: 'start stepping again' selector: #resumeAfterStepError.			aMenu addLine ].	aMenu add: 'inspect morph' selector: #inspectInMorphic:.	aMenu lastItem		icon: (self iconNamed: #smallInspectItIcon).	aMenu add: 'inspect owner chain' selector: #inspectOwnerChain.	aMenu lastItem		icon: (self iconNamed: #smallInspectItIcon).	self isMorphicModel		ifTrue: [ aMenu add: 'inspect model' target: self model selector: #inspect.			aMenu lastItem				icon: (self iconNamed: #smallInspectItIcon) ].	aMenu addLine.	aMenu		add: 'browse morph class'		target: self		selector: #browseHierarchy.	self isMorphicModel		ifTrue: [ aMenu				add: 'browse model class'				target: self model				selector: #browseHierarchy ].	^ aMenu! !AllocationTest removeSelector: #testOutOfMemorySignal!"Kernel-Tests"!"Morphic-Core"!"Tool-Profilers"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.578.mcz') load.ScriptLoader new update60502.!----End fileIn----!----QUIT----2017-06-26T14:11:01.865402+02:00 Pharo.image priorSource: 195316!----QUIT----2017-06-26T14:11:13.050177+02:00 Pharo.image priorSource: 216495!----QUIT----2017-06-28T07:15:11.489762+02:00 Pharo.image priorSource: 216574!----QUIT----2017-06-28T07:15:18.88258+02:00 Pharo.image priorSource: 216653!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/28/2017 17:06' prior: 33749919!commentForCurrentUpdate ^ '20167 Regression with PNGReaderWriter in P6	https://pharo.fogbugz.com/f/cases/2016720198 inner structure access does not work on multiple architecture	https://pharo.fogbugz.com/f/cases/20198'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/28/2017 17:06'!script60503	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2515.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/28/2017 17:06'!update60503	"self new update60503"	self withUpdateLog: '20167 Regression with PNGReaderWriter in P6	https://pharo.fogbugz.com/f/cases/2016720198 inner structure access does not work on multiple architecture	https://pharo.fogbugz.com/f/cases/20198'.	self loadTogether: self script60503 merge: false.	self loadConfiguration: 'UnifiedFFI' version: '0.26.8'.self flushCaches.! !ScriptLoader removeSelector: #update60502!ScriptLoader removeSelector: #script60502!"ScriptLoader60"!!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'dtl 6/18/2017 17:07'!testNewFromSampleBytes	"Based on a problem report by Hilaire Fernandes, this fails on 64 bit Spur if a	synthesized LargeInteger parameter to Bitmap #at:put: is not normalized prior	to calling the primitive. See problem report at	http://lists.pharo.org/pipermail/pharo-users_lists.pharo.org/2017-June/032660.html"	| sampleBytes png form |	sampleBytes := #[137 80 78 71 13 10 26 10 0 0 0 13 73 72		68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255		255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72		0 70 201 107 62 0 0 1 153 73 68 65 84 120 218 237 155 73 110 195 48 12		69 227 162 183 211 9 180 11 130 220 77 39 208 249 210 77 181 8 81 69 19		39 169 255 109 12 35 137 197 255 105 81 244 144 219 13 0 0 0 0 0 116 16		66 8 33 188 94 214 113 120 99 214 151 111 238 1 115 206 57 231 235 178		54 68 10 238 19 112 58 1 189 1 238 158 16 233 25 255 37 117 224 221 141		215 210 193 158 128 83 140 215 210 181 156 0 26 216 169 139 180 155 210		218 50 184 124 126 74 34 122 245 204 234 101 207 224 41 221 145 150 14		49 67 118 77 132 118 220 98 93 208 168 64 107 172 226 18 63 19 91 194		172 103 132 117 124 106 194 117 132 210 227 215 143 103 109 124 65 173 4		181 4 173 149 128 254 223 121 49 190 160 190 6 212 4 126 22 94 12 163 91		173 241 229 112 219 141 188 51 106 184 223 46 139 162 62 3 164 137 49		198 24 253 117 89 219 241 183 145 181 82 180 94 154 192 47 212 248 247		253 209 45 152 102 205 120 36 130 137 182 193 159 19 5 22 233 53 158 126		31 48 209 54 190 181 15 8 189 247 215 71 141 174 25 127 218 243 137 105		168 17 53 99 164 140 247 154 8 183 119 67 139 177 41 165 148 210 117 209		125 233 241 181 16 187 18 158 21 254 124 62 30 247 251 186 241 173 113		122 227 148 70 237 145 100 175 33 210 120 139 207 205 237 232 255 22 71		129 45 16 60 3 158 163 123 6 140 214 74 239 198 207 198 201 189 102 12		151 32 26 128 155 23 150 22 105 189 96 38 181 88 31 211 206 113 163 165		151 109 17 182 110 231 118 213 193 222 5 237 154 8 171 184 217 254 31		176 123 9 114 255 146 177 187 128 224 3 0 0 0 0 192 198 252 0 102 116 72		96 211 171 62 8 0 0 0 0 73 69 78 68 174 66 96 130].	png := PNGReadWriter on: sampleBytes readStream.	form := png nextImage.	self assert: Form equals: form class.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:04' prior: 53948907!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits |	(transparentPixelValue isNil and: [ bitsPerChannel = 8 ]) ifTrue: [ "Do the same trick as in #copyPixelsRGBA:"		| targetIndex |		tempBits := ByteArray new: thisScanline size * 4 // 3 withAll: 16rFF.		tempForm := Form extent: width@1 depth: 32 bits: tempBits.		targetIndex := 1.		1 to: thisScanline size by: 3 do: [ :index |			tempBits				at: targetIndex put: (thisScanline at: index);				at: targetIndex + 1 put: (thisScanline at: index + 1);				at: targetIndex + 2 put: (thisScanline at: index + 2).			targetIndex := targetIndex + 4 ].		cachedDecoderMap 			ifNil:[cachedDecoderMap := self rgbaDecoderMapForDepth: depth].		(BitBlt toForm: form)			sourceForm: tempForm;			destOrigin: 0@y;			combinationRule: Form over;			colorMap: cachedDecoderMap;			copyBits.		^self ].	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	bitsPerChannel = 8		ifTrue:			[i := 1.			1 to: width do:				[ :x |				pixel					at: 3 put: (thisScanline at: i);					at: 2 put: (thisScanline at: i+1);					at: 1 put: (thisScanline at: i+2).				tempBits at: x put: pixel normalize.				i := i + 3].			transparentPixelValue				ifNotNil:					[1 to: width do: [ :x |						(tempBits at: x) = transparentPixelValue							ifTrue: [tempBits at: x put: 0]]]]		ifFalse:			[i := 1.			1 to: width do:				[ :x |				(transparentPixelValue == nil or: [(1 to: 6) anySatisfy: [:k | (transparentPixelValue digitAt: k) ~= (thisScanline at: i + 6 - k)]])					ifTrue:						[pixel							at: 3 put: (thisScanline at: i);							at: 2 put: (thisScanline at: i+2);							at: 1 put: (thisScanline at: i+4).						tempBits at: x put: pixel normalize]					ifFalse:						[tempBits at: x put: 0].				i := i + 6]].		tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:04' prior: 53957421!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo := width - startX + incX - 1 // incX.	bitsPerChannel = 8		ifTrue:			[i := (startX // incX * 3) + 1.			xx := startX+1.			1 to: loopsToDo do:				[ :j |				pixel					at: 3 put: (thisScanline at: i);					at: 2 put: (thisScanline at: i+1);					at: 1 put: (thisScanline at: i+2).				tempBits at: xx put: pixel normalize.				i := i + 3.				xx := xx + incX].			transparentPixelValue				ifNotNil: [startX to: width-1 by: incX do: [ :x |					(tempBits at: x+1) = transparentPixelValue						ifTrue: [	tempBits at: x+1 put: 0]]]]		ifFalse:			[i := (startX // incX * 6) + 1.			xx := startX+1.			1 to: loopsToDo do:				[ :j |				(transparentPixelValue == nil or: [(1 to: 6) anySatisfy: [:k | (transparentPixelValue digitAt: k) ~= (thisScanline at: i + 6 - k)]])					ifTrue:						[pixel							at: 3 put: (thisScanline at: i);							at: 2 put: (thisScanline at: i+2);							at: 1 put: (thisScanline at: i+4).						tempBits at: xx put: pixel normalize.]					ifFalse:						[tempBits at: xx put: 0].				i := i + 6.				xx := xx + incX]].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:03' prior: 53944375!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits ff |	bitsPerChannel = 8 ifTrue: [		ff := Form extent: width@1 depth: 32 bits: thisScanline.		cachedDecoderMap 			ifNil:[cachedDecoderMap := self rgbaDecoderMapForDepth: depth].		(BitBlt toForm: form)			sourceForm: ff;			destOrigin: 0@y;			combinationRule: Form over;			colorMap: cachedDecoderMap;			copyBits.		^self.	].	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	i := -7.	0 to: width-1 do: [ :x |			i := i + 8.			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel normalize.	].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:02' prior: 53963469!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i := (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel normalize.			i := i + 4.		]	] ifFalse: [		i := (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel normalize.			i := i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form paintAlpha.! !"Graphics-Files"!"Graphics-Tests"!!ConfigurationOfUnifiedFFI methodsFor: 'symbolic versions' stamp: 'EstebanLorenzano 6/28/2017 12:42' prior: 21193873!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '0.26.8'! !!ConfigurationOfUnifiedFFI methodsFor: 'versions' stamp: 'EstebanLorenzano 6/28/2017 12:42'!v0_26_8: spec	<version: '0.26.8' imports: #('0.13-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: '- fixed size_t for i386/x86_64- fixed accessing to inner structures for i386/x86_64'.		spec author: 'EstebanLorenzano'.		spec timestamp: '2017-06-28 12:30'.		spec 			package: 'FFI-Pools' with: 'FFI-Pools-eem.3';			package: 'FFI-Kernel' with: 'FFI-Kernel-EstebanLorenzano.45';			package: 'Alien' with: 'Alien-RonieSalgado.40';			package: 'UnifiedFFI' with: 'UnifiedFFI-EstebanLorenzano.111';			package: 'UnifiedFFI-Tests' with: 'UnifiedFFI-Tests-EstebanLorenzano.41';			package: 'UnifiedFFI-Legacy' with: 'UnifiedFFI-Legacy-EstebanLorenzano.3' ]! !"ConfigurationOfUnifiedFFI"!!FFIConstants commentStamp: '' prior: 24017986!!!FFIConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:54' prior: 24021054!initialize	"FFIConstants initialize"	self initializeTypeConstants.	self initializeErrorConstants.	self initializeCallingConventions.! !!FFIConstants class methodsFor: 'pool initialization' stamp: 'eem 8/4/2009 19:49' prior: 24020615!initializeCallingConventions	"These constants map onto the flags inst var of an ExternalFunction.	 The first eight bits define the calling convention.  Attribute flags	 occupy bits 8 on up."	"FFIConstants initializeCallingConventions"	FFICallTypesMask := 255.	FFICallTypeCDecl := 0.	FFICallTypeApi := 1.	FFICallFlagThreaded := 256! !!FFIConstants class methodsFor: 'pool initialization' stamp: 'eem 11/5/2009 10:21' prior: 24019118!initializeErrorConstants	"FFIConstants initializeErrorConstants"	"No callout mechanism available"	FFINoCalloutAvailable := -1.	"generic error"	FFIErrorGenericError := 0.	"primitive invoked without ExternalFunction"	FFIErrorNotFunction := 1.	"bad arguments to primitive call"	FFIErrorBadArgs := 2.	"generic bad argument"	FFIErrorBadArg := 3.	"int passed as pointer"	FFIErrorIntAsPointer := 4.	"bad atomic type (e.g., unknown)"	FFIErrorBadAtomicType := 5.	"argument coercion failed"	FFIErrorCoercionFailed := 6.	"Type check for non-atomic types failed"	FFIErrorWrongType := 7.	"struct size wrong or too large"	FFIErrorStructSize := 8.	"unsupported calling convention"	FFIErrorCallType := 9.	"cannot return the given type"	FFIErrorBadReturn := 10.	"bad function address"	FFIErrorBadAddress := 11.	"no module given but required for finding address"	FFIErrorNoModule := 12.	"function address not found"	FFIErrorAddressNotFound := 13.	"attempt to pass 'void' parameter"	FFIErrorAttemptToPassVoid := 14.	"module not found"	FFIErrorModuleNotFound := 15.	"external library invalid"	FFIErrorBadExternalLibrary := 16.	"external function invalid"	FFIErrorBadExternalFunction := 17.	"ExternalAddress points to ST memory (don't you dare to do this!!)"	FFIErrorInvalidPointer := 18.	"Stack frame required more than 16k bytes to pass arguments."	FFIErrorCallFrameTooBig := 19! !!FFIConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:34' prior: 24018105!initializeTypeConstants	"type void"	FFITypeVoid := 0.	"type bool"	FFITypeBool := 1.	"basic integer types.	note: (integerType anyMask: 1) = integerType isSigned"	FFITypeUnsignedByte := 2.	FFITypeSignedByte := 3.	FFITypeUnsignedShort := 4.	FFITypeSignedShort := 5.	FFITypeUnsignedInt := 6.	FFITypeSignedInt := 7.	"64bit types"	FFITypeUnsignedLongLong := 8.	FFITypeSignedLongLong := 9.	"special integer types"	FFITypeUnsignedChar := 10.	FFITypeSignedChar := 11.	"float types"	FFITypeSingleFloat := 12.	FFITypeDoubleFloat := 13.	"type flags"	FFIFlagAtomic := 16r40000. "type is atomic"	FFIFlagPointer := 16r20000. "type is pointer to base type"	FFIFlagStructure := 16r10000. "baseType is structure of 64k length"	FFIStructSizeMask := 16rFFFF. "mask for max size of structure"	FFIAtomicTypeMask := 16r0F000000. "mask for atomic type spec"	FFIAtomicTypeShift := 24. "shift for atomic type"! !"FFI-Pools"!!FFIExternalStructureReferenceHandle methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/27/2017 14:29'!getHandle	^ handle! !!FFIExternalStructure class methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/16/2017 08:49' prior: 24067773!structureAlignment	externalStructureAlignment ifNil: [ self compileFields ].	^ externalStructureAlignment! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:27' prior: 23753519!offsetReadFieldAt: offsetVariableName	"Answer a string defining the accessor to an entity of the receiver type starting at the 	 given byte offset. 	 Private. Used for field definition only.	 NOTE: This is used on UFFI to define field accessors that depends on a class variable 	 (this works like this to allow mapping 32bits and 64bits structures)"	self isPointerType ifTrue:		[| accessor |		accessor := self pointerSize caseOf: {						[nil]	->	[#pointerAt:].						[4]	->	[#shortPointerAt:].						[8]	->	[#longPointerAt:] }.		 ^String streamContents:			[:s|			 referentClass				ifNil:					[s nextPutAll: '^ExternalData fromHandle: (handle ', accessor, ' ';						nextPutAll: offsetVariableName;						nextPutAll: ') type: ExternalType ';						nextPutAll: (AtomicTypeNames at: self atomicType);						nextPutAll: ' asPointerType']				ifNotNil:					[s nextPutAll: '^';						print: referentClass;						nextPutAll: ' fromHandle: (handle ', accessor, ' ';						nextPutAll: offsetVariableName;						nextPut: $)]]].	self isAtomic ifFalse: "structure type"		[^ self offsetReadStructFieldAt: offsetVariableName ].	"Atomic non-pointer types"	^String streamContents:		[:s|		s nextPutAll:'^handle ';			nextPutAll: (AtomicSelectors at: self atomicType);			space; nextPutAll: offsetVariableName].! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:29'!offsetReadStructFieldAt: offsetVariableName	^ '^ {1} fromHandle: (handle structAt: {2} length: {1} byteSize)' 		format: { 			referentClass name.			offsetVariableName }! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:21' prior: 23749828!offsetWriteFieldAt: offsetVariableName with: valueName	"Answer a string defining the accessor to an entity of the receiver type starting at the given byte offset. 	 Private. Used for field definition only."	self isPointerType ifTrue:		[| accessor |		accessor := self pointerSize caseOf: {						[nil]	->	[#pointerAt:].						[4]	->	[#shortPointerAt:].						[8]	->	[#longPointerAt:] }.		^String streamContents:			[:s|			s nextPutAll:'handle ', accessor, ' ';				nextPutAll: offsetVariableName;				nextPutAll:' put: ';				nextPutAll: valueName;				nextPutAll:' getHandle.']].	self isAtomic ifFalse:[		^ self offsetWriteStructFieldAt: offsetVariableName with: valueName ].	^String streamContents:[:s|		s nextPutAll:'handle ';			nextPutAll: (AtomicSelectors at: self atomicType); space; 			nextPutAll: offsetVariableName;			nextPutAll:' put: ';			nextPutAll: valueName].! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:35'!offsetWriteStructFieldAt: offsetVariableName with: valueName	^ 'handle structAt: {1} put: {2} getHandle length: {3} byteSize' 		format: {			offsetVariableName. 			valueName. 			referentClass name }! !!FFISizeT class methodsFor: 'converting' stamp: 'EstebanLorenzano 6/19/2017 11:17' prior: 24168971!asExternalTypeOn: generator	^ generator resolveType: #ulong! !!FFISizeT methodsFor: 'private' stamp: 'EstebanLorenzano 6/19/2017 10:57' prior: 24168483!basicHandle: aHandle at: index	^ aHandle platformUnsignedLongAt: index! !!FFISizeT methodsFor: 'private' stamp: 'EstebanLorenzano 6/19/2017 10:57' prior: 24168650!basicHandle: aHandle at: index put: value	^ aHandle platformUnsignedLongAt: index put: value! !!FFISizeT methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/19/2017 11:13'!readFieldAt: byteOffset	self isPointer ifTrue: [ 		^ self pointerReadFieldAt: byteOffset ].	^ String streamContents: [ :stream |		stream << '^handle platformUnsignedLongAt: ' << byteOffset asString ].! !!FFISizeT methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/19/2017 11:09'!writeFieldAt: byteOffset with: valueName	self isPointer ifTrue: [ 		^ self externalTypeWithArity 			writeFieldAt: byteOffset			with: valueName ].	^ String streamContents: [ :stream |		stream 			<< '^handle platformUnsignedLongAt: ' << byteOffset asString			<< ' put: ' << valueName ]! !!FFIExternalStructureType methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/27/2017 15:40' prior: 24102484!offsetReadReferenceAt: offsetVariableName	^ '^ {1} fromHandle: (handle referenceStructAt: {2} length: {1} byteSize)'		format: { self objectClass name. offsetVariableName }! !!FFIExternalStructureType methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/27/2017 15:42' prior: 24102101!readReferenceAt: byteOffset	^ '^ {1} fromHandle: (handle referenceStructAt: {2} length: {1} byteSize)'		format: { 			self objectClass name.			byteOffset }! !!FFICallbackType methodsFor: 'emitting code' stamp: 'EstebanLorenzano 4/13/2017 17:11' prior: 23963994!offsetWriteFieldAt: offsetVariableName with: valueName	| cr tab |	cr := String cr.	tab := String tab.	^ String streamContents: [ :stream | 		stream 			<< 'handle ' << cr 			<< tab << tab << 'pointerAt: ' << offsetVariableName << cr 			<< tab << tab << 'put: (anObject ' << cr 			<< tab << tab << tab << 'ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]' << cr			<< tab << tab << tab << 'ifNil: [ ExternalAddress null ])' ]! !"UnifiedFFI"!"UnifiedFFI-Tests"!"UnifiedFFI-Legacy"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.579.mcz') load.ScriptLoader new update60503.!----End fileIn----!----QUIT----2017-06-28T17:09:15.864278+02:00 Pharo.image priorSource: 216732!----QUIT----2017-06-28T17:09:26.342968+02:00 Pharo.image priorSource: 253892!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/29/2017 12:31' prior: 33771334!commentForCurrentUpdate ^ '20185 Request pipe after block argments	https://pharo.fogbugz.com/f/cases/2018520183 TraitDescription>>fileOutLocalMethodsInCategory:on: method temp var name overlap	https://pharo.fogbugz.com/f/cases/2018320184 Request space between argument and selector in StdioStream>>next:	https://pharo.fogbugz.com/f/cases/20184'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/29/2017 12:31'!script60504	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.430.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2517.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1180.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-EstebanLorenzano.111.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/29/2017 12:31'!update60504	"self new update60504"	self withUpdateLog: '20185 Request pipe after block argments	https://pharo.fogbugz.com/f/cases/2018520183 TraitDescription>>fileOutLocalMethodsInCategory:on: method temp var name overlap	https://pharo.fogbugz.com/f/cases/2018320184 Request space between argument and selector in StdioStream>>next:	https://pharo.fogbugz.com/f/cases/20184'.	self loadTogether: self script60504 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60503!ScriptLoader removeSelector: #script60503!"ScriptLoader60"!!Context class methodsFor: 'simulation' stamp: 'MarcusDenker 6/29/2017 11:20' prior: 21724094!runSimulated: aBlock	"Simulate the execution of the argument, current. Answer the result it 	returns."	^ thisContext sender		runSimulated: aBlock		contextAtEachStep: [:ignored | ]	"Context runSimulated: [Pen new defaultNib: 5; go: 100]"! !!MCMczReader methodsFor: 'loading' stamp: 'MarcusDenker 6/29/2017 11:20' prior: 31818543!loadDefinitions	definitions := OrderedCollection new.	(self zip memberNamed: 'snapshot.bin') ifNotNil:		[:m | [^ definitions := (MCDataStream on: m contentStream) next definitions]			on: Error do: [:fallThrough | ]].	"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].! !!MCVersion methodsFor: 'enumerating' stamp: 'MarcusDenker 6/29/2017 11:18' prior: 32089434!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored | ].	aBlock value: self! !!MCMcdReader methodsFor: 'loading' stamp: 'MarcusDenker 6/29/2017 11:20' prior: 31808620!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNil:		[:m | [^ patch := (MCDataStream on: m contentStream) next ]			on: Error do: [:fallThrough | ]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!MCPatch methodsFor: 'intializing' stamp: 'MarcusDenker 6/29/2017 11:18' prior: 31920696!initializeWithBase: baseSnapshot target: targetSnapshot	| base target |		operations := OrderedCollection new.	base := MCDefinitionIndex definitions: baseSnapshot definitions.	target := MCDefinitionIndex definitions: targetSnapshot definitions.		target definitions 		do: [ :t |			base				definitionLike: t				ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]				ifAbsent:  [operations add: (MCAddition of: t)] ]		displayingProgress: 'Diffing...'.			base definitions do: [:b |		target			definitionLike: b			ifPresent: [:t | ]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!TClassDescription methodsFor: '*CodeExport' stamp: 'MarcusDenker 6/29/2017 11:12' prior: 86056743!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	"File out only the local (non-trait) methods for this category."	| selectors selectorsLocal |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.   selectorsLocal := selectors select:[:s | self isLocalSelector: s ].	"Overridden to preserve author stamps in sources file regardless"	selectorsLocal do: [:sel |		self printMethodChunk: sel on: aFileStream ].	^ self! !!StdioStream methodsFor: 'accessing' stamp: 'OleksandrZaytsev 6/28/2017 16:54' prior: 62348092!next: n	"Return a string with the next n characters of the filestream in it."	| readBuffer read startingAt |	readBuffer := ByteArray new: n.	startingAt := 1.	peekBuffer ifNotNil: [ 		readBuffer at: 1 put: peekBuffer.		startingAt := startingAt + 1.		peekBuffer := nil ].	read := self primRead: handle into: readBuffer startingAt: startingAt count: n - startingAt + 1.	^read = (n - startingAt + 1)		ifTrue: [ readBuffer ]		ifFalse: [ readBuffer copyFrom: 1 to: read ]! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	"File out only the local (non-trait) methods for this category."	| selectors selectorsLocal |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.   selectorsLocal := selectors select:[:s | self isLocalSelector: s ].	"Overridden to preserve author stamps in sources file regardless"	selectorsLocal do: [:sel |		self printMethodChunk: sel on: aFileStream ].	^ self! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	"File out only the local (non-trait) methods for this category."	| selectors selectorsLocal |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.   selectorsLocal := selectors select:[:s | self isLocalSelector: s ].	"Overridden to preserve author stamps in sources file regardless"	selectorsLocal do: [:sel |		self printMethodChunk: sel on: aFileStream ].	^ self! !"CodeExport"!"Files"!"Kernel"!"Monticello"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.580.mcz') load.ScriptLoader new update60504.!----End fileIn----!----QUIT----2017-06-29T12:37:38.234233+02:00 Pharo.image priorSource: 253971!----QUIT----2017-06-29T12:37:58.541211+02:00 Pharo.image priorSource: 277897!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/30/2017 14:14' prior: 33808574!commentForCurrentUpdate ^ '20187 Request use of block in certain methods	https://pharo.fogbugz.com/f/cases/2018720188 Request representation of integer literal without float exponent	https://pharo.fogbugz.com/f/cases/2018820182 Extra dot in literal array	https://pharo.fogbugz.com/f/cases/2018218760 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/1876020186 Request removal of extra statement separators (dot)	https://pharo.fogbugz.com/f/cases/20186'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/30/2017 14:15'!script60505	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.32.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2518.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1180.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.69.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.990.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-EstebanLorenzano.111.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/30/2017 14:15'!update60505	"self new update60505"	self withUpdateLog: '20187 Request use of block in certain methods	https://pharo.fogbugz.com/f/cases/2018720188 Request representation of integer literal without float exponent	https://pharo.fogbugz.com/f/cases/2018820182 Extra dot in literal array	https://pharo.fogbugz.com/f/cases/2018218760 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/1876020186 Request removal of extra statement separators (dot)	https://pharo.fogbugz.com/f/cases/20186'.	self loadTogether: self script60505 merge: false.	(SystemAnnouncer uniqueInstance subscriptions glmSubscriptions select: [:sub | sub subscriber isNil]) do: #finalize. 3 timesRepeat: [Smalltalk garbageCollect ].	self flushCaches.! !ScriptLoader removeSelector: #update60504!ScriptLoader removeSelector: #script60504!"ScriptLoader60"!!RBProgramNode methodsFor: 'accessing' stamp: 'MarcusDenker 6/30/2017 10:03' prior: 56263770!comments: aCollection	(aCollection ifNil: [#()])		ifEmpty: [ self removeProperty: #comments ifAbsent: [] ] 		ifNotEmpty: [ self propertyAt: #comments put: aCollection ].! !!UTF16TextConverter methodsFor: 'conversion' stamp: 'MarcusDenker 6/29/2017 12:20' prior: 65417347!nextFromStream: aStream	| character1 character2 readBOM charValue |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^nil].	character2 := aStream basicNext ifNil: [^nil].	readBOM := false.	(character1 asciiValue = 16rFF and: [character2 asciiValue = 16rFE]) ifTrue: 		[self useLittleEndian: true.		readBOM := true].	(character1 asciiValue = 16rFE and: [character2 asciiValue = 16rFF]) ifTrue: 		[self useLittleEndian: false.		readBOM := true].	readBOM ifTrue: 		[self useByteOrderMark: true.		character1 := aStream basicNext ifNil: [^nil].		character2 := aStream basicNext ifNil: [^nil]].	charValue := self useLittleEndian 		ifTrue: [(character2 charCode bitShift: 8) + character1 charCode] 		ifFalse: [(character1 charCode bitShift: 8) + character2 charCode].	^ self charFromStream: aStream withFirst: charValue.! !!TemporaryVariable methodsFor: 'comparing' stamp: 'MarcusDenker 6/30/2017 10:05' prior: 63541185!hash	^ (name hash		bitXor: method hash)		bitXor: (startpc ifNil: [0])! !!TextFontChange class methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 6/30/2017 10:05' prior: 63909793!defaultFontChange  "Answer a TextFontChange that represents the default font"  | defaultFontStyle fontIndex |  defaultFontStyle := TextStyle default.  fontIndex := defaultFontStyle ifNil: [1] ifNotNil: [defaultFontStyle defaultFontIndex].  ^ self new fontNumber: fontIndex.! !!UIManager methodsFor: 'ui process' stamp: 'MarcusDenker 6/29/2017 12:17' prior: 65091276!spawnNewProcess	"do nothing by default"! !!ChunkReadStream methodsFor: 'decorated' stamp: 'MarcusDenker 6/29/2017 12:22' prior: 19183935!parseLangTagFor: aString	| string peek runsRaw foundTag |	string := aString.	"Test for ]lang[ tag"	peek := self skipSeparators; peek.	peek = $] ifFalse: [ ^ string ].  "no tag"	foundTag := (decoratedStream upTo: $[).	foundTag = ']lang' ifTrue: [		runsRaw := self basicNextChunk.		string := self decodeString: aString andRuns: runsRaw	] ifFalse: [		"If we find a ] but not a lang tag, there is something really wrong and we are not ready to parse that"		^ string , self basicNextChunk	].	^ string! !!TBehaviorCategorization methodsFor: 'organization' stamp: 'MarcusDenker 6/30/2017 10:08' prior: 85966532!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !!Job class methodsFor: 'examples' stamp: 'MarcusDenker 6/29/2017 12:18' prior: 29986359!exampleCurrentValue	[ :job| 		job title: 'Simulating some progress for 1 Second'.		1 second wait. "simulate some work"		job currentValue: 50.		1 second wait. "simulate some more work"		job currentValue: 100.		1 second wait. "simulate some more work"	] asJob run! !!ConfigurationCommandLineHandler methodsFor: 'printing' stamp: 'MarcusDenker 6/30/2017 10:07' prior: 20156717!printConfigurations: configurations	self inform: (String streamContents:  [ :s|		s			nextPutAll: 'Found ';			print: configurations size;			nextPutAll: ' Configuration';			nextPutAll: (configurations size = 1 ifTrue: [':'] ifFalse: ['s:']) ]).		configurations do: [ :name | 			self << name. 			self stdout lf ].	! !!SourceFileArray methodsFor: 'private - copying' stamp: 'MarcusDenker 6/30/2017 10:05' prior: 61195344!readOnlyCopy	"Answer a read only copy of self. The caller is responsible of closing it."	^ self species new		sourcesFileStream: (self sourcesFileStream ifNotNil: [:aStream | aStream readOnlyCopy]);		changesFileStream: (self changesFileStream ifNotNil: [:aStream | aStream readOnlyCopy]);		yourself! !!ZnImageExampleDelegate methodsFor: 'accessing' stamp: 'MarcusDenker 6/30/2017 11:00' prior: 85343737!html	^ ZnHtmlOutputStream streamContents: [ :html |		 html page: 'Image' do: [			html 				tag: #src attributes: #(src 'image?raw=true');				tag: #br;				tag: #form attributes: #(enctype 'multipart/form-data' action image method POST) do: [					html						tag: #h3 with: 'Change the image:';						tag: #input attributes: #(type file name file);						tag: #input attributes: #(type submit value Upload) ] ] ]! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'MarcusDenker 6/29/2017 12:21' prior: 28857190!visitPopIntoRemoteTemp: remoteTemp	stream nextPutAll: 'popIntoRemoteTemp: '.	remoteTemp name printOn: stream.	stream nextPutAll: ' inVector: '.	remoteTemp tempVectorName printOn: stream! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'MarcusDenker 6/29/2017 12:22' prior: 28858059!visitPushRemoteTemp: remoteTemp	stream nextPutAll: 'pushRemoteTemp: '.	remoteTemp name printOn: stream.	stream nextPutAll: ' inVector: '.	remoteTemp tempVectorName printOn: stream! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'MarcusDenker 6/29/2017 12:22' prior: 28855547!visitStoreRemoteTemp: remoteTemp	stream nextPutAll: 'storeRemoteTemp: '.	remoteTemp name printOn: stream.	stream nextPutAll: ' inVector: '.	remoteTemp tempVectorName printOn: stream.! !!IRBytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'MarcusDenker 6/29/2017 12:19' prior: 28775840!jump: dist	| index seq instr newSeq seqs |	index := instructionStream pc + dist.	dist >= 0 ifTrue: [		"jump forward"		^ irBuilder jumpAheadTo: index ].	"jump to the jump instuction itself"	dist >= -2 ifTrue: 		[	irBuilder jumpBackTarget: index.			irBuilder jumpBackTo: index.		^self].	"jump backward"	seqs := irBuilder ir allSequences.	seq := seqs findLast: [:s | s notEmpty and: [s first bytecodeIndex <= index]].	seq := seqs at: seq.	seq first bytecodeIndex = index		ifTrue: [ newSeq := seq ]		ifFalse: [			instr := seq detect: [:i | (seq after: i) bytecodeIndex = index].			newSeq := seq splitAfter: instr ].	irBuilder addJumpBackTarget: index to: newSeq.	"if we have split the currentSequence of the irBuilder, make sure to set it	to the newSeq"	irBuilder currentSequence = seq ifTrue: [irBuilder currentSequence: newSeq].	irBuilder jumpBackTo: index.! !!Form methodsFor: 'other' stamp: 'MarcusDenker 6/29/2017 12:23' prior: 25521945!fillAlpha: alphaValue	"Fill a 32bit form with a constant alpha value"	| bb |	self depth = 32 ifFalse:[^self error: 'Only valid for 32 bit forms'].	bb := BitBlt toForm: self.	bb combinationRule: 7. "bitOr:with:"	bb fillColor: (Bitmap with: alphaValue << 24).	bb copyBits.! !!PharoChangesCondenser methodsFor: 'initialization' stamp: 'MarcusDenker 6/29/2017 12:18' prior: 54402043!reset	remoteStringMap := IdentityDictionary new.	newChangesFile := self temporaryFile.		"Keep a copy of the source streams for performance"	sourceStreams := Array			with: PharoFilesOpener default sourcesFileOrNil			with: PharoFilesOpener default changesFileOrNil! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'MarcusDenker 6/29/2017 12:24' prior: 52064442!nextChunk	"Answer the contents of the receiver, up to the next terminator	character. Doubled terminators indicate an embedded terminator	character."	self skipSeparators.	^ self		parseLangTagFor: (self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]])! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'MarcusDenker 6/29/2017 12:24' prior: 52069235!nextPreamble	"Assuming that preamble part does not contain ]lang[ tag"	self skipSeparators.	^ self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]]! !!Protocol methodsFor: 'initialization' stamp: 'MarcusDenker 6/29/2017 12:17' prior: 55287718!initialize	super initialize.	methods := IdentitySet new.	name := self class defaultName.! !!IRReconstructor methodsFor: 'initialize' stamp: 'MarcusDenker 6/29/2017 12:21' prior: 28870270!createTempVectorNamed: name withVars: anArray	" Don't add the temp yet, we only know it's index at the end of the block or method "	"self addVectorTemps: anArray"	" Update the byte index to point before the pushing of the new vector "	sourceMapByteIndex := sourceMapByteIndex - 2.	self add: (IRInstruction createTempVectorNamed: name withVars: anArray)! !!ZdcPluginSSLSession methodsFor: 'accessing' stamp: 'MarcusDenker 6/30/2017 10:07' prior: 84802687!serverName: serverName	"Set the Server Name Indication (SNI) to serverName, 	the fully qualified domain name of the host to connect to.	This should be set by a client before #connect is attempted."		^ self primitiveSSL: handle setStringProperty: 2 toValue: (serverName ifNil: [''])! !!Text class methodsFor: 'instance creation' stamp: 'MarcusDenker 6/30/2017 10:09' prior: 63718200!fromString: aString   "Answer an instance of me whose characters are those of the argument, aString."  | defaultFontStyle fontNumber |  defaultFontStyle := TextStyle default.  fontNumber := defaultFontStyle ifNil: [1] ifNotNil: [defaultFontStyle defaultFontIndex].  ^ self    string: aString    attributes:{ "No default attributes" }! !!Text class methodsFor: 'initialization' stamp: 'MarcusDenker 6/30/2017 11:09' prior: 63716753!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextSharedInformation at: #CaretForm put:				(Form extent: 16@5					fromArray: #(	 						2r00110000000000000000000000000000 						2r00110000000000000000000000000000 					 	2r01111000000000000000000000000000 					 	2r11111100000000000000000000000000 					 	2r11001100000000000000000000000000)					offset: -3@0).! !!String methodsFor: 'converting' stamp: 'MarcusDenker 6/29/2017 12:24' prior: 62489088!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	(aNumber isNumber not or: [ aNumber < 1 ]) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end |				| pastEnd lineStart |				pastEnd := endWithoutDelimiters + 1.				"eliminate spaces at beginning of line"				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.				[| lineStop lineEnd spacePosition |				lineEnd := lineStop  := lineStart + aNumber min: pastEnd.				spacePosition := lineStart.				[spacePosition < lineStop] whileTrue: [					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].					spacePosition <= lineStop ifTrue: [lineEnd := spacePosition].				].				"split before space or before lineStop if no space"				stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).				"eliminate spaces at beginning of next line"				lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: pastEnd to: end) ] ]! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !"AST-Core"!"CodeImport"!"Collections-Strings"!"ConfigurationCommandLineHandler-Core"!"Files"!"Graphics-Display Objects"!"Jobs"!"Kernel"!"Multilingual-TextConversion"!"OpalCompiler-Core"!"Slot"!"System-Sources"!"Text-Core"!"Traits"!"UIManager"!"Zinc-HTTP"!"Zodiac-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.581.mcz') load.ScriptLoader new update60505.!----End fileIn----!----QUIT----2017-06-30T14:18:17.675696+02:00 Pharo.image priorSource: 277976!----QUIT----2017-06-30T14:18:34.498843+02:00 Pharo.image priorSource: 312306!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/4/2017 16:11' prior: 33832579!commentForCurrentUpdate ^ '20092 Improve speed of WriteStream>>tab:	https://pharo.fogbugz.com/f/cases/2009220088 Improve speed of Character>>isSeparator in when the separator is not a space	https://pharo.fogbugz.com/f/cases/2008820204 Text class>>#fromString	https://pharo.fogbugz.com/f/cases/20204'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/4/2017 16:11'!script60506	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.32.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2520.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1180.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.71.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.990.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-EstebanLorenzano.111.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/4/2017 16:11'!update60506	"self new update60506"	self withUpdateLog: '20092 Improve speed of WriteStream>>tab:	https://pharo.fogbugz.com/f/cases/2009220088 Improve speed of Character>>isSeparator in when the separator is not a space	https://pharo.fogbugz.com/f/cases/2008820204 Text class>>#fromString	https://pharo.fogbugz.com/f/cases/20204'.	self loadTogether: self script60506 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60505!ScriptLoader removeSelector: #script60505!"ScriptLoader60"!!WriteStreamTest methodsFor: 'tests' stamp: 'HenrikNergaard 5/29/2017 12:15'!testEnsureNoSpace	"self debug: #testEnsureASpace2"	| stream |	stream := self newStream.	stream ensureNoSpace.		self assert: stream contents equals: ''.		stream nextPutAll: ' a '.	stream ensureNoSpace.	self assert: stream contents equals: ' a'.		stream nextPutAll: 'b  '.	stream ensureNoSpace.	self assert: stream contents equals: ' ab'.			! !!Character methodsFor: 'testing' stamp: 'MarcusDenker 7/1/2017 14:52' prior: 19056099!isSeparator    | in |    ^ (in := self asInteger) == 32 or: [ in == 13 or: [ in == 9 or: [ in == 10 or: [ in == 12 ] ] ] ]! !!Text class methodsFor: 'instance creation' stamp: 'MarcusDenker 7/1/2017 14:47' prior: 33861804!fromString: aString   "Answer an instance of me whose characters are those of the argument, aString."  ^ self    string: aString    attributes:{ "No default attributes" }! !!Stream methodsFor: 'accessing' stamp: 'HenrikNergaard 5/29/2017 12:09' prior: 62373559!next: anInteger put: anObject 	<compilerOptions: #(+ optionInlineTimesRepeat)>		"Make anObject be the next anInteger number of objects accessible by the 	receiver. Answer anObject."		anInteger timesRepeat: [ self nextPut: anObject ].	^ anObject! !!CharacterTest methodsFor: 'tests' stamp: 'MarcusDenker 7/1/2017 14:55'!testIsSeparator    {Character space.    Character cr.    Character lf.    Character newPage.    Character tab} do: [ :each | self assert: each isSeparator ].    Character alphabet do: [ :each | self deny: each isSeparator ]! !!WriteStream methodsFor: 'accessing' stamp: 'HenrikNergaard 5/29/2017 12:10' prior: 84714960!crlf	"Append a line feed character to the receiver."	self cr; lf! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:10' prior: 84721483!crtab	"Append a return character, followed by a single tab character, to the 	receiver."	self cr; tab! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:10' prior: 84716139!crtab: anInteger 	"Append a return character, followed by anInteger tab characters, to the 	receiver."	self cr; tab: anInteger! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:15' prior: 84721850!ensureNoSpace	"If there is not one on the end, remove it."	| space |		space := Character space.		[ position > 0 and: [(collection at: position) = space ]]		whileTrue: [ self skip: -1 ]! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:11' prior: 84719188!space: anInteger 	"Append anInteger space characters to the receiver."		self next: anInteger put: Character space	! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:12' prior: 84717846!tab: anInteger 	"Append anInteger tab characters to the receiver."		self next: anInteger put: Character tab! !"Collections-Streams"!"Collections-Tests"!"Kernel"!"Text-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.582.mcz') load.ScriptLoader new update60506.!----End fileIn----!----QUIT----2017-07-04T16:14:02.32477+02:00 Pharo.image priorSource: 312385!----QUIT----2017-07-04T16:14:12.807834+02:00 Pharo.image priorSource: 334804!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/6/2017 14:44' prior: 33866987!commentForCurrentUpdate ^ '20218 Master branch (Pharo 6) needs to be safely merged into development branch (Pharo 7).	https://pharo.fogbugz.com/f/cases/20218'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/6/2017 14:45'!script60507	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/6/2017 14:45'!update60507	"self new update60507"	self withUpdateLog: '20218 Master branch (Pharo 6) needs to be safely merged into development branch (Pharo 7).	https://pharo.fogbugz.com/f/cases/20218'.	self loadTogether: self script60507 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60506!ScriptLoader removeSelector: #script60506!"ScriptLoader60"!!Context class methodsFor: 'simulation' stamp: 'PavelKrivanek 7/6/2017 11:21' prior: 33827420!runSimulated: aBlock	"Simulate the execution of the argument, current. Answer the result it 	returns."	^ thisContext sender		runSimulated: aBlock		contextAtEachStep: [:ignored |]	"Context runSimulated: [Pen new defaultNib: 5; go: 100]"! !!MCMczReader methodsFor: 'loading' stamp: 'PavelKrivanek 7/6/2017 11:20' prior: 33827758!loadDefinitions	definitions := OrderedCollection new.	(self zip memberNamed: 'snapshot.bin') ifNotNil:		[:m | [^ definitions := (MCDataStream on: m contentStream) next definitions]			on: Error do: [:fallThrough |]].	"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].! !!TBehaviorCategorization methodsFor: 'organization' stamp: 'PavelKrivanek 7/6/2017 11:16' prior: 33854492!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !!MCVersion methodsFor: 'enumerating' stamp: 'PavelKrivanek 7/6/2017 11:19' prior: 33828175!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored |].	aBlock value: self! !!Text class methodsFor: 'initialization' stamp: 'PavelKrivanek 7/6/2017 11:18' prior: 33862248!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextSharedInformation at: #CaretForm put:				(Form extent: 16@5					fromArray: #(							2r00110000000000000000000000000000						2r00110000000000000000000000000000					 	2r01111000000000000000000000000000					 	2r11111100000000000000000000000000					 	2r11001100000000000000000000000000)					offset: -3@0).! !!MCMcdReader methodsFor: 'loading' stamp: 'PavelKrivanek 7/6/2017 11:21' prior: 33828379!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNil:		[:m | [^ patch := (MCDataStream on: m contentStream) next ]			on: Error do: [:fallThrough |]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!FFISizeT class methodsFor: 'converting' stamp: 'PavelKrivanek 7/6/2017 11:17' prior: 33805469!asExternalTypeOn: generator	"We resolve size_t to a uint/ulong which may be not the case always"	^ generator resolveType: #ulong! !!MCPatch methodsFor: 'intializing' stamp: 'PavelKrivanek 7/6/2017 11:20' prior: 33828989!initializeWithBase: baseSnapshot target: targetSnapshot	| base target |		operations := OrderedCollection new.	base := MCDefinitionIndex definitions: baseSnapshot definitions.	target := MCDefinitionIndex definitions: targetSnapshot definitions.		target definitions 		do: [ :t |			base				definitionLike: t				ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]				ifAbsent:  [operations add: (MCAddition of: t)] ]		displayingProgress: 'Diffing...'.			base definitions do: [:b |		target			definitionLike: b			ifPresent: [:t |]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!Job class methodsFor: 'examples' stamp: 'PavelKrivanek 7/6/2017 11:21' prior: 33855129!exampleCurrentValue	[ :job| 		job title: 'Simulating some progress for 1 Second'. 		1 second wait. "simulate some work"		job currentValue: 50.		1 second wait. "simulate some more work"		job currentValue: 100.		1 second wait. "simulate some more work"	] asJob run! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !"Jobs"!"Kernel"!"Monticello"!"Text-Core"!"Traits"!"UnifiedFFI"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.583.mcz') load.ScriptLoader new update60507.!----End fileIn----!----QUIT----2017-07-06T14:47:02.648193+02:00 Pharo.image priorSource: 334882!----QUIT----2017-07-06T14:47:13.080132+02:00 Pharo.image priorSource: 359862!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/11/2017 17:51' prior: 33889484!commentForCurrentUpdate ^ '20226 TabMorph should use stepping mechanism for animating background building	https://pharo.fogbugz.com/f/cases/2022620238 Run out of memory the image hangs without out of memory warning	https://pharo.fogbugz.com/f/cases/20238'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/11/2017 17:51'!script60508	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.56.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1437.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/11/2017 17:51'!update60508	"self new update60508"	self withUpdateLog: '20226 TabMorph should use stepping mechanism for animating background building	https://pharo.fogbugz.com/f/cases/2022620238 Run out of memory the image hangs without out of memory warning	https://pharo.fogbugz.com/f/cases/20238'.	self loadTogether: self script60508 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60507!ScriptLoader removeSelector: #script60507!"ScriptLoader60"!!TabBuildingIconMorph commentStamp: 'DenisKudryashov 7/6/2017 15:19' prior: 0!I implement rotated icon to animate background tab building. I use stepping mechanizm for animation.Just create my instance with #new message to use in other morphs.Internal Representation and Key Implementation Points.    Instance Variables	progress:		<Integer>	progressIconMorph:		<ImageMorph>    Implementation Points!!MorphicUIManager methodsFor: 'debug' stamp: 'DenisKudryashov 7/11/2017 15:10' prior: 51990251!lowSpaceWatcherDefaultAction: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	| preemptedProcess projectProcess debugSession |	ActiveHand ifNotNil:[ActiveHand interrupted].	ActiveWorld := World. "reinstall active globals"	ActiveHand := World primaryHand.	ActiveHand interrupted. "make sure this one's interrupted too"	ActiveEvent := nil.	projectProcess := self uiProcess.	"we still need the accessor for a while"	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	"Only debug preempted process if its priority is >= projectProcess' priority"	preemptedProcess priority < projectProcess priority 		ifTrue:[preemptedProcess := projectProcess].	preemptedProcess suspend.		debugSession := preemptedProcess 		newDebugSessionNamed: 'Space is low' 		startedAt: preemptedProcess suspendedContext.			debugSession logStackToFileIfNeeded.	debugSession isAboutUIProcess ifTrue: [ 		DefaultExecutionEnvironment beActiveDuring: [self spawnNewProcess]].		Smalltalk tools debugger 		openOn: debugSession 		withFullView: false 		andNotification: self lowSpaceWarningMessage! !!TabBuildingIconMorph methodsFor: 'stepping and presenter' stamp: 'DenisKudryashov 7/6/2017 15:17'!currentIcon	^TabMorph perform: (#refreshIcon, progress asString) asSymbol! !!TabBuildingIconMorph methodsFor: 'initialization' stamp: 'DenisKudryashov 7/6/2017 15:17'!initialize	super initialize.	self 		clipLayoutCells: true;		color: Color transparent.	progress := 1.	progressIconMorph := self currentIcon asMorph.	self addMorphBack: progressIconMorph.	self extent: progressIconMorph extent.! !!TabBuildingIconMorph methodsFor: 'stepping and presenter' stamp: 'DenisKudryashov 7/6/2017 15:17'!step	progress := progress + 1.	progress > 10 ifTrue: [ progress := 1 ].		progressIconMorph form: self currentIcon! !!TabBuildingIconMorph methodsFor: 'stepping and presenter' stamp: 'DenisKudryashov 7/6/2017 15:17'!stepTime		^ 100 "milliseconds"! !!TabMorph methodsFor: 'protocol' stamp: 'DenisKudryashov 7/6/2017 15:12' prior: 63411623!retrieveMorph: aBlock	"This is a hard request. The result is blocking contrary to softRetrieveMorph.	Late binding so the morph may be built only on demand"	morph ifNotNil: [ 		aBlock value: morph.		^ nil ].	retrievingSemaphore isSignaled		ifFalse: [ self softRetrieveMorph ].	^ [ retrievingSemaphore wait.		morph ifNotNil: [ 			UIManager default defer: [aBlock value: morph ]]] 				fork! !!TabMorph methodsFor: 'protocol' stamp: 'DenisKudryashov 7/6/2017 15:20' prior: 63406869!softRetrieveMorph	| oldIcon |	"Like retrieveMorph but done in a separated process"		morph ifNotNil: [ ^ self ].		retrievingProcess 		ifNotNil: [ 			"The retrieving process is already running, let's wait for its result"			retrievingProcess isTerminated 				ifFalse: [ ^ self ] ].		oldIcon := self icon ifNotNil: [ :i | i form ].	label icon: TabBuildingIconMorph new.	retrievingProcess := [ [		morph := retrievingBlock value]	ensure: [				UIManager default defer: [			self icon: oldIcon.			self triggerEvent: #tabRefreshed with: self].		"I should signal all waiters here"		[retrievingSemaphore isEmpty] whileFalse: [ retrievingSemaphore signal].	] ] forkAt: Processor activePriority - 2! !TabMorph removeSelector: #createAnimationProcess!"Morphic-Widgets-Tabs"!"Polymorph-Widgets"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.584.mcz') load.ScriptLoader new update60508.!----End fileIn----!----QUIT----2017-07-12T13:02:48.26072+02:00 Pharo.image priorSource: 359941!----QUIT----2017-07-12T13:02:59.007705+02:00 Pharo.image priorSource: 383187!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/21/2017 17:43' prior: 33914544!commentForCurrentUpdate ^ '20262 Update Iceberg to 0.5.4	https://pharo.fogbugz.com/f/cases/20262'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/21/2017 17:43'!script60509	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.56.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1437.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/21/2017 17:43'!update60509	"self new update60509"	self withUpdateLog: '20262 Update Iceberg to 0.5.4	https://pharo.fogbugz.com/f/cases/20262'.	self loadTogether: self script60509 merge: false.	#('Iceberg-UI' 'Iceberg-Plugin' 'Iceberg-Metacello-Integration' 'Iceberg-Libgit' 'Iceberg' 'BaselineOfIceberg' 'LibGit-Core' 'BaselineOfLibGit') do: [ :each | each asPackage removeFromSystem ].Metacello new  baseline: 'Iceberg';  repository: 'github://pharo-vcs/iceberg:v0.5.4';  load.(Smalltalk classNamed: #Iceberg) enableMetacelloIntegration: false.	self flushCaches.! !ScriptLoader removeSelector: #update60508!ScriptLoader removeSelector: #script60508!"ScriptLoader60"!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourPublishBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfoModel!Smalltalk globals removeClassNamed: #AnObsoleteGLMSwappedColorDiffPresentation!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForPlaintextCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceLocationModel!Smalltalk globals removeClassNamed: #AnObsoleteIceDiffChangeTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteSwappedColorDiffMorph!Smalltalk globals removeClassNamed: #AnObsoleteIceNewRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchBrowser!IceTool removeSelector: #pushRepository:andThen:!IceTool removeSelector: #uiManager!IceTool removeSelector: #mergeIntoAnotherBranch:andThen:!IceTool class removeSelector: #uiManager!IceMergeTool removeSelector: #pushRepository:andThen:!IceMergeTool removeSelector: #uiManager!IceMergeTool removeSelector: #mergeIntoAnotherBranch:andThen:!IceMergeTool class removeSelector: #uiManager!IceCommitModel removeSelector: #pushRepository:andThen:!IceCommitModel removeSelector: #uiManager!IceCommitModel removeSelector: #mergeIntoAnotherBranch:andThen:!IceCommitModel class removeSelector: #uiManager!Smalltalk globals removeClassNamed: #AnObsoleteTIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCreateRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourCommitBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForUsernameAndEmailModel!Smalltalk globals removeClassNamed: #AnObsoleteIceInteractiveCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourSynchronizer!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteAdded!Smalltalk globals removeClassNamed: #AnObsoleteIceFileModel!Smalltalk globals removeClassNamed: #AnObsoleteIceChangesTreeResetSelectionHelper!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoriesBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceImportLocalRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeTool!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourUpdateBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceCloneRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceEmbeddedBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForSshCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteModel!Smalltalk globals removeClassNamed: #AnObsoleteIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryUpdateHelper!Smalltalk globals removeClassNamed: #AnObsoleteGLMMorphicSwappedColorDiffRenderer!Smalltalk globals removeClassNamed: #AnObsoleteIceDirectoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCachedValue!Smalltalk globals removeClassNamed: #AnObsoleteIceHistoryBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourChangesTree!Smalltalk globals removeClassNamed: #AnObsoleteIceEditRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractModel!MCPatchOperation removeSelector: #canBeBrowsed!Text removeSelector: #allItalic!GLMMorphicRenderer removeSelector: #renderSwappedColorDiffPresentation:!GLMGenericAction removeSelector: #selectionAction:!GLMGenericAction removeSelector: #selectionCondition:!GLMGenericAction removeSelector: #showTitle:!MCModification removeSelector: #icon!MCAddition removeSelector: #icon!DateAndTime removeSelector: #asStringYMDHM!DateAndTime removeSelector: #asLocalStringYMDHM!GLMCompositePresentation removeSelector: #swappedColorDiff!MCRemoval removeSelector: #canBeBrowsed!MCRemoval removeSelector: #icon!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAPI!Smalltalk globals removeClassNamed: #AnObsoleteIcePlugin!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubCommand!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubNewPullRequestCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubBadCredentialsError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubRemoveBranchesCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequest!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubGenericError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectItem!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectListModel!Smalltalk globals removeClassNamed: #AnObsoleteIceBaselineInstallerPlugin!IceRepository removeSelector: #pluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceGitLocalRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceGithubRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloPharoPlatform!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitVersionReader!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitLocalRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitCommitWalk!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitFileUtils!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageLoaded!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryForgotten!Smalltalk globals removeClassNamed: #AnObsoleteIceDiff!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageUnloaded!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalRepositoryMissing!Smalltalk globals removeClassNamed: #AnObsoleteIcePlaintextCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIceMethodChange!Smalltalk globals removeClassNamed: #AnObsoleteNothingToCommitException!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackage!Smalltalk globals removeClassNamed: #AnObsoleteIceRemovedClassReference!Smalltalk globals removeClassNamed: #AnObsoleteManifestIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteTIceRepositoryBackend!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceUndefinedRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceTemporaryVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSetChanged!Smalltalk globals removeClassNamed: #AnObsoleteIceTag!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryRegistryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceNetworkRemote!Smalltalk globals removeClassNamed: #AnObsoleteCannotIdentifyVersionForCommit!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreated!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceVersionDoesNotExist!Smalltalk globals removeClassNamed: #AnObsoleteIceFileRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceStructuralChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceError!Smalltalk globals removeClassNamed: #AnObsoleteIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessFileTreeWriter!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageReference!Smalltalk globals removeClassNamed: #AnObsoleteIceClassChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeAborted!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreator!Smalltalk globals removeClassNamed: #AnObsoleteIceClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceMCVersionInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceWorkingCopy!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceWrongUrl!Smalltalk globals removeClassNamed: #AnObsoleteIceRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackageVersion!Smalltalk globals removeClassNamed: #AnObsoleteIcePushed!Smalltalk globals removeClassNamed: #AnObsoleteIceLoadedCode!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryAnnouncement!Smalltalk globals removeClassNamed: #AnObsoleteIceGitUsernameOrEmailNotFound!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpsRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceFullDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceCommited!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceMissingRepositoryEntry!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceDuplicatedRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceSshCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIceSimpleClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageOrganizationChange!Smalltalk globals removeClassNamed: #AnObsoleteYouShouldPullBeforePush!Smalltalk globals removeClassNamed: #AnObsoleteIceRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceBackendWriterAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIceUnbornBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractCommitWalk!Smalltalk globals removeClassNamed: #AnObsoleteIceNoRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceScpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceForeignVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceNoCurrentBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitish!LGitTreeEntry removeSelector: #readStreamDo:!LGitTreeEntry removeSelector: #tree!LGitTreeEntry removeSelector: #name!MCDefinition removeSelector: #iceClass!MCDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCDefinition removeSelector: #addToPackageChangeSet:!MCDefinition removeSelector: #icePackage!MCWorkingCopy removeSelector: #loadedVersion!MCVersion removeSelector: #directoryName!MCGitHubRepository removeSelector: #getOrCreateIcebergRepository!MCGitHubRepository removeSelector: #commitIdFor:ifFound:!MCGitHubRepository removeSelector: #commitId!MCGitHubRepository removeSelector: #httpsUrl!MCGitHubRepository removeSelector: #scpUrl!MCPatchOperation removeSelector: #iceClass!MCPatchOperation removeSelector: #icePackage!MCPatchOperation removeSelector: #addToPackageChangeSet:!MCPatchOperation removeSelector: #asIceChangeSet!LGitTag removeSelector: #asIcebergObjectInRepository:!LGitCredentialsPlaintext removeSelector: #readFrom:!LGitDiff removeSelector: #includesFileNamed:!LGitDiff removeSelector: #filesDo:!MCOrganizationDefinition removeSelector: #iceClass!MCOrganizationDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCOrganizationDefinition removeSelector: #icePackage!LGitCredentialsSSH removeSelector: #readFrom:!MCPostscriptDefinition removeSelector: #addToPackageChangeSet:!MCRepository removeSelector: #commitIdFor:ifFound:!LGitReturnCodeEnum removeSelector: #asBoolean!RPackage removeSelector: #iceRepository!LGitCommit removeSelector: #changesFileNamed:!LGitCommit removeSelector: #asIcebergObjectInRepository:!MCClassDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #method!MCMethodDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #icePackage!FileSystemDirectoryEntry removeSelector: #packageName!MCGitHubRepository class removeSelector: #commitIdFor:!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfIceberg!Smalltalk globals removeClassNamed: #AnObsoleteLGitId!Smalltalk globals removeClassNamed: #AnObsoleteLGitObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushTransferCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinary!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlame!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalUInt8Array!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFileCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkModeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutAPI!Smalltalk globals removeClassNamed: #AnObsoleteLGitIllegalArgument!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDatabase!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEOF!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationInt32!LGitExternalStructure removeSelector: #shouldContinuePrintingOn:!LGitExternalStructure removeSelector: #objectPrintOn:!LGitExternalStructure removeSelector: #printOn:!LGitExternalObject removeSelector: #objectPrintOn:!LGitExternalObject removeSelector: #printOn:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitPrintingTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeEntry!Smalltalk globals removeClassNamed: #AnObsoleteLGitLibrary!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachPayload!Smalltalk globals removeClassNamed: #AnObsoleteLGitTree!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitActionSequence!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffDelta!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommitBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRefSpec!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EPEEL!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackAppendCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitReferenceTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALID!Smalltalk globals removeClassNamed: #AnObsoleteLGitMergeOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitReturnCodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoReturnCodeHandlerDefined!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutMethodBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteHead!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecMatchList!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiff!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutStrategyEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBUFS!Smalltalk globals removeClassNamed: #AnObsoleteLGitBuf!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndexMatchedPathCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfDataCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECERTIFICATE!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCompletionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNMERGED!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchPruneTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitAbstractError!Smalltalk globals removeClassNamed: #AnObsoleteLGitStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemote!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNBORNBRANCH!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndex!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EMODIFIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsPlaintext!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCompletionCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEXISTS!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructWithDefaults!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallReturnHandler!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpenFlagEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransport!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentials!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStatsFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportMessageCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitError!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushStatusForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSHAgent!Smalltalk globals removeClassNamed: #AnObsoleteLGitAnnotatedCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAMBIGUOUS!Smalltalk globals removeClassNamed: #AnObsoleteLGitSubmoduleIgnoreTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgress!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotInitialized!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_OK!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAUTH!Smalltalk globals removeClassNamed: #AnObsoleteLGitErrorTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitUpdateTipsCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdbWritepack!Smalltalk globals removeClassNamed: #AnObsoleteLGitTag!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdateReferenceCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryFile!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchIterator!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritingTreeFailed!Smalltalk globals removeClassNamed: #AnObsoleteLGitFunctionReturn!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunkCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteManifestLibGitCore!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptionsVersionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUSER!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValue!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructure!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructureFieldParser!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdate!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ERROR!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPatch!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFile!Smalltalk globals removeClassNamed: #AnObsoleteLGitConfig!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALIDSPEC!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackCommitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNCOMMITTED!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteAutotagOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECONFLICT!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationUInt32!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueUInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitSignature!Smalltalk globals removeClassNamed: #AnObsoleteLGitReference!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAPPLIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLine!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStats!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneLocalTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EORPHANEDHEAD!LGitGlobal removeSelector: #safeFFICalloutIn:!LGitGlobal removeSelector: #signalNotReady!LGitGlobal removeSelector: #validate:shouldBe:!LGitGlobal removeSelector: #ifNotReady:!LGitGlobal removeSelector: #withReturnHandlerDo:!LGitGlobal removeSelector: #ffiLibrary!LGitGlobal removeSelector: #ffiLibraryName!LGitGlobal removeSelector: #callUnchecked:options:!LGitGlobal removeSelector: #call:options:!LGitGlobal removeSelector: #signalIfNotReady!LGitGlobal removeSelector: #call:!LGitGlobal removeSelector: #ffiNull!LGitGlobal removeSelector: #isReady!LGitGlobal class removeSelector: #ffiLibrary!LGitGlobal class removeSelector: #ffiLibraryName!LGitGlobal class removeSelector: #call:options:!LGitGlobal class removeSelector: #validate:shouldBe:!LGitGlobal class removeSelector: #call:!LGitGlobal class removeSelector: #withReturnHandlerDo:!LGitExternalObject removeSelector: #safeFFICalloutIn:!LGitExternalObject removeSelector: #signalNotReady!LGitExternalObject removeSelector: #validate:shouldBe:!LGitExternalObject removeSelector: #ifNotReady:!LGitExternalObject removeSelector: #withReturnHandlerDo:!LGitExternalObject removeSelector: #ffiLibrary!LGitExternalObject removeSelector: #ffiLibraryName!LGitExternalObject removeSelector: #callUnchecked:options:!LGitExternalObject removeSelector: #call:options:!LGitExternalObject removeSelector: #signalIfNotReady!LGitExternalObject removeSelector: #call:!LGitExternalObject removeSelector: #ffiNull!LGitExternalObject class removeSelector: #ffiLibrary!LGitExternalObject class removeSelector: #ffiLibraryName!LGitExternalObject class removeSelector: #call:options:!LGitExternalObject class removeSelector: #validate:shouldBe:!LGitExternalObject class removeSelector: #call:!LGitExternalObject class removeSelector: #withReturnHandlerDo:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitCalloutTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdb!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalkSortTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ELOCKED!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCallbacks!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallError!Smalltalk globals removeClassNamed: #AnObsoleteLGitFilemodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBAREREPO!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpeningRepositoryError!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCertificateCheckCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffSimilarityMetric!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlob!Smalltalk globals removeClassNamed: #AnObsoleteLGitDeltaTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushNegotiationCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSH!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENOTFOUND!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepository!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalCommitArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredAcquireCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENONFASTFORWARD!Smalltalk globals removeClassNamed: #AnObsoleteLGitTime!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_PASSTHROUGH!Smalltalk globals removeClassNamed: #AnObsoleteLGitOptionsVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ITEROVER!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoCredentialsProvided!Smalltalk globals removeClassNamed: #AnObsoleteLGitDirectionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusList!Smalltalk globals removeClassNamed: #AnObsoleteLGitGlobal!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkCallback!Object removeSelector: #handleLGitReturnCode!String removeSelector: #asLGitExternalString!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfLibGit!!BaselineOfIceberg methodsFor: 'baseline' stamp: ' 7/21/2017 17:44:53'!baseline: spec	<baseline>	spec for: #common do: [ 				spec postLoadDoIt: #resetKMRepository.				spec		configuration: 'OSSubprocess' with: [ spec			versionString: #stable;			repository: 'github://marianopeck/OSSubprocess/repository' ];		configuration: 'ProcessWrapper' with: [ spec			versionString: #stable;			repository: 'http://smalltalkhub.com/mc/Pharo/MetaRepoForPharo50/main' ];		baseline: 'FileTree' with: [ spec			repository: 'github://pharo-vcs/filetree:pharo6.0_dev/repository';			loads: 'Git' ];		baseline: 'LibGit' with: [ spec			repository: 'github://pharo-vcs/libgit2-pharo-bindings:v0.25.1';  			loads: 'default' ];		project: 'LibGit-Tests'          copyFrom: 'LibGit'          with: [ spec loads: #('tests') ];		for: #MacOS do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess') ] ];		for: #Unix do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess' ) ] ];		for: #Windows do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('ProcessWrapper') ] ];		package: 'Iceberg';		package: 'Iceberg-Plugin' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Plugin-GitHub' with: [ spec requires: #('Iceberg-Plugin' 'Iceberg-UI') ];		package: 'Iceberg-Metacello-Integration' with: [ spec requires: #('Iceberg')];		package: 'Iceberg-UI' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Tests' with: [ spec requires: #('Iceberg' 'Iceberg-GitCommand') ];		package: 'Iceberg-UI-Tests' with: [ spec requires: #('Iceberg-UI' 'Iceberg-Tests')];		package: 'Iceberg-GitFileTree' with: [ spec requires: #('Iceberg' 'FileTree') ];		package: 'Iceberg-GitFileTree-Tests' with: [ spec requires: #('Iceberg-GitFileTree' 'Iceberg-Tests') ];		package: 'Iceberg-Libgit' with: [ spec requires: #('Iceberg' 'LibGit') ];		group: 'minimal' with: #('Iceberg' 'Iceberg-Libgit');		group: 'default' with: #(minimal 'Iceberg-Metacello-Integration' 'Iceberg-UI' 'Iceberg-Plugin' 'Iceberg-Plugin-GitHub');		group: 'allTests' with: #('Iceberg-Tests' 'LibGit-Tests' 'Iceberg-GitFileTree-Tests' 'Iceberg-UI-Tests' );		group: 'development' with: #(default 'Iceberg-GitFileTree' allTests)	]! !!BaselineOfIceberg methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:53'!customProjectAttributes	Smalltalk os isMacOS ifTrue: [ ^ #(#MacOS) ].	Smalltalk os isUnix ifTrue: [ ^ #(#Unix) ].	Smalltalk os isWindows ifTrue: [ ^ #(#Windows) ]! !!BaselineOfIceberg methodsFor: 'script' stamp: ' 7/21/2017 17:44:53'!resetKMRepository	KMRepository reset! !"BaselineOfIceberg"!!BaselineOfLibGit methodsFor: 'baseline' stamp: ' 7/21/2017 17:44:56'!baseline: spec  <baseline>  spec    for: #(common)    do: [       spec        package: 'LibGit-Tests' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-GT' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Patches' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Core'.      spec        group: 'default'        with: #('LibGit-Core').		spec			group: 'development'			with: #('default' 'LibGit-Tests' 'LibGit-Patches' 'LibGit-GT').		spec			group: 'tests'			with: #('LibGit-Tests').		spec postLoadDoIt: #postLoadActions ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/21/2017 17:44:56'!changeRepositoryType	| repos newRepo |	(Smalltalk hasClassNamed: #MCGitRepository) ifFalse: [ ^ self ].		repos := MCRepositoryGroup default repositories		select: [ :r | (r description includesSubstring: 'LibGit:master') or: [ 			r description includesSubstring: 'LibGit/master' ] ].	repos ifEmpty: [  ^ self ].		'github-cache/theseion' asFileReference deleteAll.	newRepo := (Smalltalk at: #MCGitRepository) new		repoUrl: 'git@github.com:theseion/LibGit';		ensureDirectory;		yourself.			MCRepositoryGroup allInstances		select: [ :group | group repositories includesAnyOf: repos ]		thenDo: [ :group | 			repos do: [ :repo | group removeRepository: repo ].			group addRepository: newRepo ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/21/2017 17:44:56'!postLoadActions	self changeRepositoryType! !"BaselineOfLibGit"!!LGitExternalArray commentStamp: 'MaxLeske 7/14/2015 09:09' prior: 0!I provide general implementations for my subclasses that represent dedicated arrays of a certain type.!!LGitExternalCommitArray commentStamp: 'MaxLeske 7/13/2015 17:10' prior: 0!I represent an external array of commits.!!LGitExternalStringArray commentStamp: 'MaxLeske 7/13/2015 17:12' prior: 0!I represent an external array of strings. Since strings are of variable size, they can not be easily represented by the general implementation.I take care of converting regular strings to external ones (which allocates and reserves the memory) and reading strings from memory.I override #free to ensure that the memory for the external strings is correctly freed.!!LGitExternalUInt8Array commentStamp: 'MaxLeske 7/15/2015 10:31' prior: 0!My elements are 8 bit unsigned integers.!!LGitExternalEnumerationUInt32 commentStamp: 'MaxLeske 3/17/2014 13:57' prior: 0!See the comment in NBExternalEnumeration. I am a copy of NBExternalEnumeration with the exception that I inherit from Object, not from SharedPool.!!LGitCheckoutStrategyEnum commentStamp: 'MaxLeske 8/13/2015 11:06' prior: 0!/** * Checkout behavior flags * * In libgit2, checkout is used to update the working directory and index * to match a target tree.  Unlike git checkout, it does not move the HEAD * commit for you - use `git_repository_set_head` or the like to do that. * * Checkout looks at (up to) four things: the "target" tree you want to * check out, the "baseline" tree of what was checked out previously, the * working directory for actual files, and the index for staged changes. * * You give checkout one of three strategies for update: * * - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts, *   etc., but doesn't make any actual changes. * * - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to *   make the working directory match the target (including potentially *   discarding modified files). * * - `GIT_CHECKOUT_SAFE` is between these two options, it will only make *   modifications that will not lose changes. * *                         |  target == baseline   |  target !!= baseline  | *    ---------------------|-----------------------|----------------------| *     workdir == baseline |       no action       |  create, update, or  | *                         |                       |     delete file      | *    ---------------------|-----------------------|----------------------| *     workdir exists and  |       no action       |   conflict (notify   | *       is !!= baseline    | notify dirty MODIFIED | and cancel checkout) | *    ---------------------|-----------------------|----------------------| *      workdir missing,   | notify dirty DELETED  |     create file      | *      baseline present   |                       |                      | *    ---------------------|-----------------------|----------------------| * * To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout * notification callback (see below) that displays information about dirty * files.  The default behavior will cancel checkout on conflicts. * * To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a * notification callback that cancels the operation if a dirty-but-existing * file is found in the working directory.  This core git command isn't * quite "force" but is sensitive about some types of changes. * * To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`. * * * There are some additional flags to modified the behavior of checkout: * * - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates *   even if there are conflicts (instead of cancelling the checkout). * * - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not *   in target, baseline, or index, and not ignored) from the working dir. * * - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also *   untracked) from the working directory as well. * * - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that *   already exist.  Files will not be created nor deleted.  This just skips *   applying adds, deletes, and typechanges. * * - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the *   updated files' information to the index. * * - Normally, checkout will reload the index and git attributes from disk *   before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload. * * - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips *   files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and *   GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the *   stage 2 ("ours") or stage 3 ("theirs") version of files in the index. * * - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being *   overwritten.  Normally, files that are ignored in the working directory *   are not considered "precious" and may be overwritten if the checkout *   target contains that file. * * - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing *   files or folders that fold to the same name on case insensitive *   filesystems.  This can cause files to retain their existing names *   and write through existing symbolic links. */!!LGitDeltaTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:32' prior: 0!/** * What type of change is described by a git_diff_delta? * * `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run * `git_diff_find_similar()` on the diff object. * * `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE` * in the option flags (otherwise type changes will be split into ADDED / * DELETED pairs). */!!LGitDiffBinaryTypeEnum commentStamp: 'MaxLeske 8/13/2015 14:28' prior: 0!/** * When producing a binary diff, the binary data returned will be * either the deflated full ("literal") contents of the file, or * the deflated binary delta between the two sides (whichever is * smaller). */!!LGitOptionsVersionsEnum commentStamp: 'MaxLeske 7/17/2015 13:37' prior: 0!I map names to versions for all the option structs.!!LGitProxyTypeEnum commentStamp: '<historical>' prior: 0!/** * The type of proxy to use. */!!LGitRevwalkSortTypeEnum commentStamp: 'MaxLeske 3/1/2015 16:39' prior: 0!/** * Sort the repository contents in no particular ordering; * this sorting is arbitrary, implementation-specific * and subject to change at any time. * This is the default sorting for new walkers. */#define GIT_SORT_NONE			(0)/** * Sort the repository contents in topological order * (parents before children); this sorting mode * can be combined with time sorting. */#define GIT_SORT_TOPOLOGICAL (1 << 0)/** * Sort the repository contents by commit time; * this sorting mode can be combined with * topological sorting. */#define GIT_SORT_TIME			(1 << 1)/** * Iterate through the repository contents in reverse * order; this sorting mode can be combined with * any of the above. */#define GIT_SORT_REVERSE		(1 << 2)!!LGitStatusTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:34' prior: 0!/** * Status flags for a single file. * * A combination of these values will be returned to indicate the status of * a file.  Status compares the working directory, the index, and the * current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags * represents the status of file in the index relative to the HEAD, and the * `GIT_STATUS_WT` set of flags represent the status of the file in the * working directory relative to the index. */!!LGitRefSpec commentStamp: 'MaxLeske 4/18/2014 11:59' prior: 0!Use:	LGitRefSpec fromString: '+refs/heads/*:refs/remotes/origin/*'.Note: The asterisk wildcard (*) matches all refs of a given path (not explicitly documented in the below).From the git-fetch man page:<refspec>           The format of a <refspec> parameter is an optional plus +, followed by the source           ref <src>, followed by a colon :, followed by the destination ref <dst>.           The remote ref that matches <src> is fetched, and if <dst> is not empty string,           the local ref that matches it is fast-forwarded using <src>. If the optional plus           + is used, the local ref is updated even if it does not result in a fast-forward           update.               Note               If the remote branch from which you want to pull is modified in non-linear               ways such as being rewound and rebased frequently, then a pull will attempt a               merge with an older version of itself, likely conflict, and fail. It is under               these conditions that you would want to use the + sign to indicate               non-fast-forward updates will be needed. There is currently no easy way to               determine or declare that a branch will be made available in a repository               with this behavior; the pulling user simply must know this is the expected               usage pattern for a branch.               Note               You never do your own development on branches that appear on the right hand               side of a <refspec> colon on Pull: lines; they are to be updated by git               fetch. If you intend to do development derived from a remote branch B, have a               Pull: line to track it (i.e.  Pull: B:remote-B), and have a separate branch               my-B to do your development on top of it. The latter is created by git branch               my-B remote-B (or its equivalent git checkout -b my-B remote-B). Run git               fetch to keep track of the progress of the remote side, and when you see               something new on the remote branch, merge it into your development branch               with git pull . remote-B, while you are on my-B branch.               Note               There is a difference between listing multiple <refspec> directly on git pull               command line and having multiple Pull: <refspec> lines for a <repository> and               running git pull command without any explicit <refspec> parameters. <refspec>               listed explicitly on the command line are always merged into the current               branch after fetching. In other words, if you list more than one remote refs,               you would be making an Octopus. While git pull run without any explicit               <refspec> parameter takes default <refspec>s from Pull: lines, it merges only               the first <refspec> found into the current branch, after fetching all the               remote refs. This is because making an Octopus from remote refs is rarely               done, while keeping track of multiple remote heads in one-go by fetching more               than one is often useful.Some short-cut notations are also supported.           o    tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests               fetching everything up to the given tag.           o   A parameter <ref> without a colon fetches that ref into FETCH_HEAD, and               updates the remote-tracking branches (if any).!!LGitExternalStructure commentStamp: 'MaxLeske 3/1/2015 20:36' prior: 0!Important: structs in libgit2 are usually freed by libgit2 itself.	We therefore disable freeing of structs during GC to prevent invalid	memory accesses. However, users of any struct need to make sure that	they free the struct (using a manual #free send) iff it is necessary.	Otherwise the structs will leak and we can't reclaim the space once the	object representing the struct has been collected!!LGitCredentialsSSH commentStamp: '<historical>' prior: 0!I'm a set of credentials who asks public/private keys from from files (in case you need something different than what is answered by ssh-agent, provided by LGitCredentialsSSHAgent)!!LGitCredentialsSSHAgent commentStamp: '<historical>' prior: 0!I'm a set of credentials who feeds from the ssh-agent client.!!LGitDiffBinary commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** Structure describing the binary contents of a diff. */!!LGitDiffBinaryFile commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** The contents of one of the files in a binary diff. */!!LGitDiffDelta commentStamp: 'MaxLeske 7/4/2015 17:03' prior: 0!I represent the difference between two entities (e.g. two files). If one of the entities is new or deleted the "nfiles" field will hold be set to 1, otherwise it will be set to 2.!!LGitId commentStamp: '<historical>' prior: 0!I'm an unique identity of any object (commit, tree, blob, tag).https://libgit2.github.com/libgit2/#HEAD/type/git_oidNOTE: This might be replaces by an FFITypeArray in the future.!!LGitRemoteHead commentStamp: 'EstebanLorenzano 1/5/2017 16:00' prior: 0!I'm a description of a reference advertised by a remote server, given out on `ls` calls.https://libgit2.github.com/libgit2/#HEAD/type/git_remote_head!!LGitSignature commentStamp: '<historical>' prior: 0!A LGitSignature represents the information of a specific person for a commit.Instance Variables	email:		ByteString	name:		ByteString	when:		DateAndTime!!LGitProxyOptions commentStamp: '<historical>' prior: 0!/** * Options for connecting through a proxy * * Note that not all types may be supported, depending on the platform * and compilation options. */!!LGitPushOptions commentStamp: 'MaxLeske 8/13/2015 23:46' prior: 0!/** * Controls the behavior of a git_push object. */!!LGitRemoteCallbacks commentStamp: 'MaxLeske 8/13/2015 13:20' prior: 0!/** * The callback settings structure * * Set the callbacks to be called by the remote when informing the user * about the progress of the network operations. */!!LGitSafeFFICalloutAPI commentStamp: 'JanVanDeSandt 5/1/2016 21:18' prior: 0!I'm a variant of FFICalloutAPI that uses a different builder to generate methods with an extra check to see if the object is 'ready' or not.!!LGitRepository commentStamp: '<historical>' prior: 0!A LGitRepository represents a git repository.Instance Variables	handle:		NBExternalObjecthandle	- reference to the external object!!LGitConfig commentStamp: 'NicoPasserini 2/8/2017 00:51' prior: 0!/** Memory representation of a set of config files */typedef struct git_config git_config;https://libgit2.github.com/libgit2/#HEAD/type/git_config!!LGitCommit commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitCommit represents a specific commit and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitTag commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitTag represents a git tag and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitReference commentStamp: '<historical>' prior: 0!A LGitReference represents the reference to a git object. References can be symbolic as for instance HEAD or a branch etc.Instance Variables	handle:			NBExternalObject	repoHandle:	NBExternalObjecthandle	- the reference to the external object representing the referencerepoHandle	- the reference to the repository in which the reference is contained!!LGitNoCredentialsProvided commentStamp: 'EstebanLorenzano 2/8/2017 16:19' prior: 0!I'm an error thrown in callbacks when no credentials has been found.Callbacks supplying credentials HAVE to throw this error and not one created by themselves (because libgit2 aborts processing with this exception and not with others). !!ManifestLibGitCore commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!LGitCredAcquireCallback commentStamp: 'MaxLeske 3/1/2015 16:57' prior: 0!/** * Signature of a function which acquires a credential object. * * - cred: The newly created credential object. * - url: The resource for which we are demanding a credential. * - username_from_url: The username that was embedded in a "user@host" *                          remote url, or NULL if not included. * - allowed_types: A bitmask stating which cred types are OK to return. * - payload: The payload provided when specifying this callback. * - returns 0 for success, < 0 to indicate an error, > 0 to indicate *       no credential was acquired */!!LGitIndexMatchedPathCallback commentStamp: '<historical>' prior: 0!I define a git_index_matched_path_cb.https://libgit2.github.com/libgit2/#HEAD/group/callback/git_index_matched_path_cb!!LGitSafeFFICalloutMethodBuilder commentStamp: 'JanVanDeSandt 5/1/2016 21:17' prior: 0!I'm a variant of FFICalloutMethodBuilder  that adds a call to  #signalIfNotReady  before the actual ffi call.!!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibrary	^LGitLibrary ! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibraryName	^self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'argument validation' stamp: ' 7/21/2017 17:44:56'!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!TLGitCalloutTrait classTrait methodsFor: 'exit code handling' stamp: ' 7/21/2017 17:44:56'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibrary	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibraryName	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiNull	^FFIExternalObject null! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isReady	^ true! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalNotReady	LGitObjectNotInitialized signalWith: self! !!TLGitCalloutTrait methodsFor: 'argument validation' stamp: ' 7/21/2017 17:44:56'!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!TLGitCalloutTrait methodsFor: 'exit code handling' stamp: ' 7/21/2017 17:44:56'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!shouldContinuePrintingOn: aStream	^ true! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!externalNew: numberOfElements	^ self 		externalNewType: self type 		size: numberOfElements! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!onAddress: handle size: numberOfElements	^ self fromHandle: handle type: self type size: numberOfElements! !!LGitExternalArray class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type 	^ self subclassResponsibility! !!LGitExternalArray methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asArray	| array |	array := Array new: self size.	1 to: self size do: [ :index |		array			at: index			put: (self at: index) ].			^ array! !!LGitExternalCommitArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :commit :index |		instance at: index put: commit ].		^ instance! !!LGitExternalCommitArray class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type 	^ LGitCommit! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: anIndex	^ LGitCommit fromHandle: (super at: anIndex)! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: anIndex put: aLGitCommit	^ super at: anIndex put: aLGitCommit getHandle! !!LGitExternalStringArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :element :index |		instance at: index put: element ].		^ instance! !!LGitExternalStringArray class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type	^ 'char*'! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: anInteger	^ (self primAt: anInteger) readString! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: index put: aString	^ super at: index put: aString asLGitExternalString getHandle! !!LGitExternalStringArray methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!free	1 to: self size do: [ :index | 		(self primAt: index) free ].		super free! !!LGitExternalStringArray methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!primAt: anInteger	^ super at: anInteger! !!LGitExternalUInt8Array class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type	^ FFIUInt32! !!LGitExternalUInt8Array methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type 	^ FFIUInt8! !!LGitBlameFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		"Normal blame the default"		GIT_BLAME_NORMAL 0		"Track lines that have moved within a file (like `git blame -M`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_FILE 1		"Track lines that have moved across files in the same commit (like `git blame -C`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES 2		"Track lines that have been copied from another file that exists in the		 * same commit (like `git blame -CC`). Implies SAME_FILE.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES 4		"Track lines that have been copied from another file that exists in *any*		 * commit (like `git blame -CCC`). Implies SAME_COMMIT_COPIES.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES 8		"Restrict the search of commits to those reachable following only the		 * first parents."		GIT_BLAME_FIRST_PARENT 16	)! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_first_parent	^ self basicNew		value: 16;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_normal	^ self basicNew		value: 0;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_any_commit_copies	^ self basicNew		value: 8;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_same_commit_copies	^ self basicNew		value: 4;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_same_commit_moves	^ self basicNew		value: 2;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_same_file	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_BRANCH_LOCAL 1	GIT_BRANCH_REMOTE 2	GIT_BRANCH_ALL 3)! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_branch_all	^ self basicNew		value: 3;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_branch_local	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_branch_remote	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_CHECKOUT_NOTIFY_NONE 0	GIT_CHECKOUT_NOTIFY_CONFLICT 1	GIT_CHECKOUT_NOTIFY_DIRTY 2	GIT_CHECKOUT_NOTIFY_UPDATED 4	GIT_CHECKOUT_NOTIFY_UNTRACKED 8	GIT_CHECKOUT_NOTIFY_IGNORED 16	GIT_CHECKOUT_NOTIFY_ALL 65535)! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_all	^ self basicNew		value: 65535;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_conflict	^ self basicNew		value: 1;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_dirty	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_ignored	^ self basicNew		value: 16;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_untracked	^ self basicNew		value: 8;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_updated	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'enum description' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		GIT_CHECKOUT_NONE  0 "< default is a dry run, no actual updates "		" Allow safe updates that cannot overwrite uncommitted data "		GIT_CHECKOUT_SAFE  "1 bitShift: 0" 1		" Allow all updates to force working directory to look like index "		GIT_CHECKOUT_FORCE  "1 bitShift: 1" 2		" Allow checkout to recreate missing files "		GIT_CHECKOUT_RECREATE_MISSING  "1 bitShift: 2" 4		" Allow checkout to make safe updates even if conflicts are found "		GIT_CHECKOUT_ALLOW_CONFLICTS  "1 bitShift: 4" 16		" Remove untracked files not in index (that are not ignored) "		GIT_CHECKOUT_REMOVE_UNTRACKED  "1 bitShift: 5" 32		" Remove ignored files not in index "		GIT_CHECKOUT_REMOVE_IGNORED  "1 bitShift: 6" 64		" Only update existing files, don't create new ones "		GIT_CHECKOUT_UPDATE_ONLY  "1 bitShift: 7" 128		"		 * Normally checkout updates index entries as it goes; this stops that.		 * Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.		 "		GIT_CHECKOUT_DONT_UPDATE_INDEX  "1 bitShift: 8" 256		" Don't refresh index/config/etc before doing checkout "		GIT_CHECKOUT_NO_REFRESH  "1 bitShift: 9" 512		" Allow checkout to skip unmerged files "		GIT_CHECKOUT_SKIP_UNMERGED  "1 bitShift: 10" 1024		" For unmerged files, checkout stage 2 from index "		GIT_CHECKOUT_USE_OURS  "1 bitShift: 11" 2048		" For unmerged files, checkout stage 3 from index "		GIT_CHECKOUT_USE_THEIRS  "1 bitShift: 12" 4096		" Treat pathspec as simple list of exact match file paths "		GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH  "1 bitShift: 13" 8192		" Ignore directories in use, they will be left empty "		GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES  "1 bitShift: 18" 262144		" Don't overwrite ignored files that exist in the checkout target "		GIT_CHECKOUT_DONT_OVERWRITE_IGNORED  "1 bitShift: 19" 524288		" Write normal merge files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_MERGE  "1 bitShift: 20" 1048576		" Include common ancestor data in diff3 format files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_DIFF3  "1 bitShift: 21" 2097152		" Don't overwrite existing files or folders "		GIT_CHECKOUT_DONT_REMOVE_EXISTING  "1 bitShift: 22" 4194304		" Normally checkout writes the index upon completion; this prevents that. "		GIT_CHECKOUT_DONT_WRITE_INDEX  "1 bitShift: 23" 8388608		"		 * THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED		 "		" Recursively checkout submodules with same options (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES  "1 bitShift: 16" 65536		" Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED  "1 bitShift: 17" 131072)! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_allow_conflicts	^ self basicNew		value: 16;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_conflict_style_diff3	^ self basicNew		value: 2097152;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_conflict_style_merge	^ self basicNew		value: 1048576;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_disable_pathspec_match	^ self basicNew		value: 8192;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_overwrite_ignored	^ self basicNew		value: 524288;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_remove_existing	^ self basicNew		value: 4194304;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_update_index	^ self basicNew		value: 256;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_write_index	^ self basicNew		value: 8388608;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_force	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_no_refresh	^ self basicNew		value: 512;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_recreate_missing	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_remove_ignored	^ self basicNew		value: 64;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_remove_untracked	^ self basicNew		value: 32;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_safe	^ self basicNew		value: 1;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_safe_create	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_skip_locked_directories	^ self basicNew		value: 262144;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_skip_unmerged	^ self basicNew		value: 1024;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_update_only	^ self basicNew		value: 128;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_update_submodules	^ self basicNew		value: 65536;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_update_submodules_if_changed	^ self basicNew		value: 131072;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_use_ours	^ self basicNew		value: 2048;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_use_theirs	^ self basicNew		value: 4096;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(			GIT_CLONE_LOCAL_AUTO 0			GIT_CLONE_LOCAL 1			GIT_CLONE_NO_LOCAL 2			GIT_CLONE_LOCAL_NO_LINKS 3		)! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_local	^ self basicNew		value: 1;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_local_auto	^ self basicNew		value: 0;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_local_no_links	^ self basicNew		value: 3;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_no_local	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_CREDTYPE_USERPASS_PLAINTEXT 1	GIT_CREDTYPE_SSH_KEY 2	GIT_CREDTYPE_SSH_CUSTOM 4	GIT_CREDTYPE_DEFAULT 8)! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_default	^ self basicNew		value: 8;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_ssh_custom	^ self basicNew		value: 4;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_ssh_key	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_userpass_plaintext	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DELTA_UNMODIFIED 0 "no changes"	GIT_DELTA_ADDED 1 "entry does not exist in old version"	GIT_DELTA_DELETED 2 "entry does not exist in new version"	GIT_DELTA_MODIFIED 3 "entry content changed between old and new"	GIT_DELTA_RENAMED 4 "entry was renamed between old and new"	GIT_DELTA_COPIED 5 "entry was copied from another old entry"	GIT_DELTA_IGNORED 6 "entry is ignored item in workdir"	GIT_DELTA_UNTRACKED 7 "entry is untracked item in workdir"	GIT_DELTA_TYPECHANGE 8 "type of entry changed between old and new"	GIT_DELTA_UNREADABLE 9 "entry is unreadable"	GIT_DELTA_CONFLICTED 10 "< entry in the index is conflicted")! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_added	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_conflicted	^ self basicNew		value: 10;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_copied	^ self basicNew		value: 5;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_deleted	^ self basicNew		value: 2;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_ignored	^ self basicNew		value: 6;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_modified	^ self basicNew		value: 3;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_renamed	^ self basicNew		value: 4;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_typechange	^ self basicNew		value: 8;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_unmodified	^ self basicNew		value: 0;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_unreadable	^ self basicNew		value: 9;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_untracked	^ self basicNew		value: 7;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(		" There is no binary delta. "		GIT_DIFF_BINARY_NONE 0		" The binary data is the literal contents of the file. "		GIT_DIFF_BINARY_LITERAL 1		" The binary data is the delta from one side to the other. "		GIT_DIFF_BINARY_DELTA 2	)! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_binary_delta	^ self basicNew		value: 2;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_binary_literal	^ self basicNew		value: 1;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_binary_none	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	<todo: 'enum defines 0 twice (one commented out). Use second enum?'>	^#(	" Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag. "	GIT_DIFF_FIND_BY_CONFIG 0	" Look for renames? (`--find-renames`) "	GIT_DIFF_FIND_RENAMES 1	" Consider old side of MODIFIED for renames? (`--break-rewrites=N`) "	GIT_DIFF_FIND_RENAMES_FROM_REWRITES 2	" Look for copies? (a la `--find-copies`). "	GIT_DIFF_FIND_COPIES 4	" Consider UNMODIFIED as copy sources? (`--find-copies-harder`).	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNMODIFIED when	 * the initial `git_diff` is being generated.	 "	GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED 8	" Mark significant rewrites for split (`--break-rewrites=/M`) "	GIT_DIFF_FIND_REWRITES 16	" Actually split large rewrites into delete/add pairs "	GIT_DIFF_BREAK_REWRITES 32	" Mark rewrites for split and break into delete/add pairs "	GIT_DIFF_FIND_AND_BREAK_REWRITES 48	" Find renames/copies for UNTRACKED items in working directory.	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNTRACKED when the	 * initial `git_diff` is being generated (and obviously the diff must	 * be against the working directory for this to make sense).	 "	GIT_DIFF_FIND_FOR_UNTRACKED 64	" Turn on all finding features. "	GIT_DIFF_FIND_ALL 255	" Measure similarity ignoring leading whitespace (default) "	"GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE 0"	" Measure similarity ignoring all whitespace "	GIT_DIFF_FIND_IGNORE_WHITESPACE 4096	" Measure similarity including all data "	GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE 8192	" Measure similarity only by comparing SHAs (fast and cheap) "	GIT_DIFF_FIND_EXACT_MATCH_ONLY 16384	" Do not break rewrites unless they contribute to a rename.	 *	 * Normally GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-	 * similarity of modified files and split the ones that have changed a	 * lot into a DELETE / ADD pair.  Then the sides of that pair will be	 * considered candidates for rename and copy detection.	 *	 * If you add this flag in and the split pair is *not* used for an	 * actual rename or copy then the modified record will be restored to	 * a regular MODIFIED record instead of being split.	 "	GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY 32768	" Remove any UNMODIFIED deltas after find_similar is done.	 *	 * Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the	 * --find-copies-harder behavior requires building a diff with the	 * GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED	 * records in the final result pass this flag to have them removed.	 "	GIT_DIFF_FIND_REMOVE_UNMODIFIED 65536	)! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_break_rewrites	^ self basicNew		value: 32;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_break_rewrites_for_renames_only	^ self basicNew		value: 32768;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_all	^ self basicNew		value: 255;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_and_break_rewrites	^ self basicNew		value: 48;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_by_config	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_copies	^ self basicNew		value: 4;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_copies_from_unmodified	^ self basicNew		value: 8;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_dont_ignore_whitespace	^ self basicNew		value: 8192;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_exact_match_only	^ self basicNew		value: 16384;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_for_untracked	^ self basicNew		value: 64;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_ignore_whitespace	^ self basicNew		value: 4096;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_remove_unmodified	^ self basicNew		value: 65536;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_renames	^ self basicNew		value: 1;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_renames_from_rewrites	^ self basicNew		value: 2;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_rewrites	^ self basicNew		value: 16;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DIFF_FLAG_BINARY 0 "file(s) treated as binary data"	GIT_DIFF_FLAG_NOT_BINARY 1 "file(s) treated as text data"	GIT_DIFF_FLAG_VALID_ID  2 "`id` value is known correct"	)! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_flag_binary	^ self basicNew		value: 0;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_flag_not_binary	^ self basicNew		value: 1;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_flag_valid_id	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DIFF_FORMAT_PATCH        1 "full git diff"	GIT_DIFF_FORMAT_PATCH_HEADER 2 "just the file headers of patch"	GIT_DIFF_FORMAT_RAW          3 "like git diff --raw"	GIT_DIFF_FORMAT_NAME_ONLY    4 "like git diff --name-only"	GIT_DIFF_FORMAT_NAME_STATUS  5 "like git diff --name-status"	)! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_name_only	^ self basicNew		value: 4;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_name_status	^ self basicNew		value: 5;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_patch	^ self basicNew		value: 1;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_patch_header	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_raw	^ self basicNew		value: 3;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^{	 "These values will be sent to `git_diff_line_cb` along with the line"	#GIT_DIFF_LINE_CONTEXT.   '$ '.	#GIT_DIFF_LINE_ADDITION.  '$+'.	#GIT_DIFF_LINE_DELETION.  '$-'.	#GIT_DIFF_LINE_CONTEXT_EOFNL. '$='."Both files have no LF at end"	#GIT_DIFF_LINE_ADD_EOFNL. '$>'.    "Old has no LF at end new does"	#GIT_DIFF_LINE_DEL_EOFNL. '$<'.    "Old has LF at end new does not"	"The following values will only be sent to a `git_diff_line_cb` when	 * the content of a diff is being formatted through `git_diff_print`.	"	#GIT_DIFF_LINE_FILE_HDR.  '$F'.	#GIT_DIFF_LINE_HUNK_HDR.  '$H'.	#GIT_DIFF_LINE_BINARY.    '$B' "For 'Binary files x and y differ'"	}! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_add_eofnl	^ self basicNew		value: $>;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_addition	^ self basicNew		value: $+;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_binary	^ self basicNew		value: $B;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_context	^ self basicNew		value: $ ;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_context_eofnl	^ self basicNew		value: $=;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_del_eofnl	^ self basicNew		value: $<;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_deletion	^ self basicNew		value: $-;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_file_hdr	^ self basicNew		value: $F;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_hunk_hdr	^ self basicNew		value: $H;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	"Normal diff, the default"	GIT_DIFF_NORMAL 0	"	 * Options controlling which files will be in the diff	"	"Reverse the sides of the diff"	GIT_DIFF_REVERSE 1	"Include ignored files in the diff"	GIT_DIFF_INCLUDE_IGNORED 2	"Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory	 *  will be marked with only a single entry in the diff; this flag	 *  adds all files under the directory as IGNORED entries, too.	"	GIT_DIFF_RECURSE_IGNORED_DIRS 4	"Include untracked files in the diff"	GIT_DIFF_INCLUDE_UNTRACKED 8	"Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked	 *  directory will be marked with only a single entry in the diff	 *  (a la what core Git does in `git status`); this flag adds *all*	 *  files under untracked directories as UNTRACKED entries, too.	"	GIT_DIFF_RECURSE_UNTRACKED_DIRS 16	"Include unmodified files in the diff"	GIT_DIFF_INCLUDE_UNMODIFIED 32	"Normally, a type change between files will be converted into a	 *  DELETED record for the old and an ADDED record for the new; this	 *  options enabled the generation of TYPECHANGE delta records.	"	GIT_DIFF_INCLUDE_TYPECHANGE 64	"Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still	 *  generally show as a DELETED blob.  This flag tries to correctly	 *  label blob->tree transitions as TYPECHANGE records with new_file's	 *  mode set to tree.  Note: the tree SHA will not be available.	"	GIT_DIFF_INCLUDE_TYPECHANGE_TREES 128	"Ignore file mode changes"	GIT_DIFF_IGNORE_FILEMODE 256	"Treat all submodules as unmodified"	GIT_DIFF_IGNORE_SUBMODULES 512	"Use case insensitive filename comparisons"	GIT_DIFF_IGNORE_CASE 1024	"If the pathspec is set in the diff options, this flags means to	 *  apply it as an exact match instead of as an fnmatch pattern.	"	GIT_DIFF_DISABLE_PATHSPEC_MATCH 4096	"Disable updating of the `binary` flag in delta records.  This is	 *  useful when iterating over a diff if you don't need hunk and data	 *  callbacks and want to avoid having to load file completely.	"	GIT_DIFF_SKIP_BINARY_CHECK 8192	"When diff finds an untracked directory, to match the behavior of	 *  core Git, it scans the contents for IGNORED and UNTRACKED files.	 *  If *all* contents are IGNORED, then the directory is IGNORED; if	 *  any contents are not IGNORED, then the directory is UNTRACKED.	 *  This is extra work that may not matter in many cases.  This flag	 *  turns off that scan and immediately labels an untracked directory	 *  as UNTRACKED (changing the behavior to not match core Git).	"	GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS 16384	"When diff finds a file in the working directory with stat	 * information different from the index, but the OID ends up being the	 * same, write the correct stat information into the index.  Note:	 * without this flag, diff will always leave the index untouched.	"	GIT_DIFF_UPDATE_INDEX 32768	"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE 65536		"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED 131072	"	 * Options controlling how output will be generated	"	"Treat all files as text, disabling binary attributes & detection"	GIT_DIFF_FORCE_TEXT 1048576	"Treat all files as binary, disabling text diffs"	GIT_DIFF_FORCE_BINARY 2097152	"Ignore all whitespace"	GIT_DIFF_IGNORE_WHITESPACE 4194304	"Ignore changes in amount of whitespace"	GIT_DIFF_IGNORE_WHITESPACE_CHANGE 8388608	"Ignore whitespace at end of line"	GIT_DIFF_IGNORE_WHITESPACE_EOL 16777216	"When generating patch text, include the content of untracked	 *  files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but	 *  it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that	 *  flag if you want the content of every single UNTRACKED file.	"	GIT_DIFF_SHOW_UNTRACKED_CONTENT 33554432	"When generating output, include the names of unmodified files if	 *  they are included in the git_diff.  Normally these are skipped in	 *  the formats that list files (e.g. name-only, name-status, raw).	 *  Even with this, these will not be included in patch format.	"	GIT_DIFF_SHOW_UNMODIFIED 67108864	"Use the 'patience diff' algorithm"	GIT_DIFF_PATIENCE 268435456	"Take extra time to find minimal diff"	GIT_DIFF_MINIMAL 536870912	"Include the necessary deflate / delta information so that `git-apply`	 *  can apply given diff information to binary files.	"	GIT_DIFF_SHOW_BINARY 1073741824	)! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_disable_pathspec_match	^ self basicNew		value: 4096;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_enable_fast_untracked_dirs	^ self basicNew		value: 16384;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_force_binary	^ self basicNew		value: 2097152;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_force_text	^ self basicNew		value: 1048576;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_case	^ self basicNew		value: 1024;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_filemode	^ self basicNew		value: 256;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_submodules	^ self basicNew		value: 512;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_whitespace	^ self basicNew		value: 4194304;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_whitespace_change	^ self basicNew		value: 8388608;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_whitespace_eol	^ self basicNew		value: 16777216;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_ignored	^ self basicNew		value: 2;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_typechange	^ self basicNew		value: 64;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_typechange_trees	^ self basicNew		value: 128;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_unmodified	^ self basicNew		value: 32;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_unreadable	^ self basicNew		value: 65536;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_unreadable_as_untracked	^ self basicNew		value: 131072;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_untracked	^ self basicNew		value: 8;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_minimal	^ self basicNew		value: 536870912;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_normal	^ self basicNew		value: 0;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_patience	^ self basicNew		value: 268435456;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_recurse_ignored_dirs	^ self basicNew		value: 4;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_recurse_untracked_dirs	^ self basicNew		value: 16;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_reverse	^ self basicNew		value: 1;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_show_binary	^ self basicNew		value: 1073741824;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_show_unmodified	^ self basicNew		value: 67108864;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_show_untracked_content	^ self basicNew		value: 33554432;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_skip_binary_check	^ self basicNew		value: 8192;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_update_index	^ self basicNew		value: 32768;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	"No stats"	GIT_DIFF_STATS_NONE 0	"Full statistics equivalent of `--stat`"	GIT_DIFF_STATS_FULL 1	"Short statistics equivalent of `--shortstat`"	GIT_DIFF_STATS_SHORT 2	"Number statistics equivalent of `--numstat`"	GIT_DIFF_STATS_NUMBER 4	"Extended header information such as creations renames and mode changes equivalent of `--summary`"	GIT_DIFF_STATS_INCLUDE_SUMMARY 8	)! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_full	^ self basicNew		value: 1;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_include_summary	^ self basicNew		value: 8;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_none	^ self basicNew		value: 0;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_number	^ self basicNew		value: 4;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_short	^ self basicNew		value: 2;		yourself! !!LGitDirectionEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DIRECTION_FETCH 0	GIT_DIRECTION_PUSH 1)! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_direction_fetch	^ self basicNew		value: 0;		yourself! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_direction_push	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		GITERR_NONE 0		GITERR_NOMEMORY		1		GITERR_OS				2		GITERR_INVALID		3			GITERR_REFERENCE		4		GITERR_ZLIB			5		GITERR_REPOSITORY	6		GITERR_CONFIG	7		GITERR_REGEX	8		GITERR_ODB	9		GITERR_INDEX			10		GITERR_OBJECT			11		GITERR_NET				12		GITERR_TAG			13		GITERR_TREE			14		GITERR_INDEXER		15		GITERR_SSL				16		GITERR_SUBMODULE	17		GITERR_THREAD		18		GITERR_STASH			19		GITERR_CHECKOUT		20		GITERR_FETCHHEAD	21		GITERR_MERGE			22		GITERR_SSH	23		GITERR_FILTER 24		GITERR_REVERT	25		GITERR_CALLBACK	26		GITERR_CHERRYPICK	27		GITERR_DESCRIBE	28		GITERR_REBASE	29		GITERR_FILESYSTEM	30)! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_callback	^ self basicNew		value: 26;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_checkout	^ self basicNew		value: 20;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_cherrypick	^ self basicNew		value: 27;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_config	^ self basicNew		value: 7;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_describe	^ self basicNew		value: 28;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_fetchhead	^ self basicNew		value: 21;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_filesystem	^ self basicNew		value: 30;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_filter	^ self basicNew		value: 24;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_index	^ self basicNew		value: 10;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_indexer	^ self basicNew		value: 15;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_invalid	^ self basicNew		value: 3;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_merge	^ self basicNew		value: 22;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_net	^ self basicNew		value: 12;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_nomemory	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_none	^ self basicNew		value: 0;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_object	^ self basicNew		value: 11;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_odb	^ self basicNew		value: 9;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_os	^ self basicNew		value: 2;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_rebase	^ self basicNew		value: 29;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_reference	^ self basicNew		value: 4;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_regex	^ self basicNew		value: 8;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_repository	^ self basicNew		value: 6;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_revert	^ self basicNew		value: 25;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_ssh	^ self basicNew		value: 23;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_ssl	^ self basicNew		value: 16;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_stash	^ self basicNew		value: 19;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_submodule	^ self basicNew		value: 17;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_tag	^ self basicNew		value: 13;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_thread	^ self basicNew		value: 18;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_tree	^ self basicNew		value: 14;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_zlib	^ self basicNew		value: 5;		yourself! !!LGitExternalEnumerationInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultRepresentationType	^ FFIInt32 new! !!LGitObjectTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_OBJ_ANY -2	GIT_OBJ_BAD -1	GIT_OBJ__EXT1 0	GIT_OBJ_COMMIT 1	GIT_OBJ_TREE 2	GIT_OBJ_BLOB 3	GIT_OBJ_TAG 4	GIT_OBJ__EXT2 5	GIT_OBJ_OFS_DELTA 6	GIT_OBJ_REF_DELTA 7)! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj__ext1	^ self basicNew		value: 0;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj__ext2	^ self basicNew		value: 5;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_any	^ self basicNew		value: -2;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_bad	^ self basicNew		value: -1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_blob	^ self basicNew		value: 3;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_commit	^ self basicNew		value: 1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_ofs_delta	^ self basicNew		value: 6;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_ref_delta	^ self basicNew		value: 7;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_tag	^ self basicNew		value: 4;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_tree	^ self basicNew		value: 2;		yourself! !!LGitReturnCodeEnum class methodsFor: 'enum description' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(			GIT_OK           0		"< No error "			GIT_ERROR       -1		"< Generic error "			GIT_ENOTFOUND   -3		"< Requested object could not be found "			GIT_EEXISTS     -4		"< Object exists preventing operation "			GIT_EAMBIGUOUS  -5		"< More than one object matches "			GIT_EBUFS       -6		"< Output buffer too short to hold data "			"GIT_EUSER is a special error that is never generated by libgit2			 * code.  You can return it from a callback (e.g to stop an iteration)			 * to know that it was generated by the callback and not by libgit2.			 "			GIT_EUSER       -7			GIT_EBAREREPO         -8	"< Operation not allowed on bare repository "			GIT_EUNBORNBRANCH     -9	"< HEAD refers to branch with no commits "			GIT_EUNMERGED        -10	"< Merge in progress prevented operation "			GIT_ENONFASTFORWARD  -11	"< Reference was not fast-forwardable "			GIT_EINVALIDSPEC     -12	"< Name/ref spec was not in a valid format "			GIT_ECONFLICT        -13	"< Checkout conflicts prevented operation "			GIT_ELOCKED          -14	"< Lock file prevented operation "			GIT_EMODIFIED        -15	"< Reference value does not match expected "			GIT_EAUTH            -16      "< Authentication error "			GIT_ECERTIFICATE     -17      "< Server certificate is invalid "			GIT_EAPPLIED         -18	"< Patch/merge has already been applied "			GIT_EPEEL            -19      "< The requested peel operation is not possible "			GIT_EEOF             -20      "< Unexpected EOF "			GIT_EINVALID         -21      "< Invalid operation or input "			GIT_EUNCOMMITTED     -22	"< Uncommitted changes in index prevented operation "			GIT_PASSTHROUGH      -30	"< Internal only "			GIT_ITEROVER         -31	"< Signals end of iteration with iterator "		)! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eambiguous	^ self basicNew		value: -5;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eapplied	^ self basicNew		value: -18;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eauth	^ self basicNew		value: -16;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ebarerepo	^ self basicNew		value: -8;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ebufs	^ self basicNew		value: -6;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ecertificate	^ self basicNew		value: -17;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_econflict	^ self basicNew		value: -13;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eeof	^ self basicNew		value: -20;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eexists	^ self basicNew		value: -4;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_einvalid	^ self basicNew		value: -21;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_einvalidspec	^ self basicNew		value: -12;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_elocked	^ self basicNew		value: -14;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_emodified	^ self basicNew		value: -15;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_enonfastforward	^ self basicNew		value: -11;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_enotfound	^ self basicNew		value: -3;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_epeel	^ self basicNew		value: -19;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_error	^ self basicNew		value: -1;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eunbornbranch	^ self basicNew		value: -9;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_euncommitted	^ self basicNew		value: -22;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eunmerged	^ self basicNew		value: -10;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_euser	^ self basicNew		value: -7;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_iterover	^ self basicNew		value: -31;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ok	^ self basicNew		value: 0;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_passthrough	^ self basicNew		value: -30;		yourself! !!LGitReturnCodeEnum class methodsFor: 'handlers' stamp: ' 7/21/2017 17:44:56'!handlers	^ handlers ifNil: [ handlers := self setUpHandlers ]! !!LGitReturnCodeEnum class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!setUpHandlers	^ (self declaration associations collect: [ :nameToValue |		nameToValue key -> (LGitCallReturnHandler for: (self perform: nameToValue key)) ]) asDictionary! !!LGitReturnCodeEnum methodsFor: 'handling' stamp: ' 7/21/2017 17:44:56'!handleLGitReturnCode	| handler |	self isOk		ifTrue: [ ^ self ].	handler := self handlers		at: self symbol		ifAbsent: [ LGitNoReturnCodeHandlerDefined signalWith: self ].	^ handler isError		ifTrue: [ handler signalWith: LGitError last ]		ifFalse: [ self ]! !!LGitReturnCodeEnum methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!handlers	^ self class handlers! !!LGitReturnCodeEnum methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!isOk	^ value = 0! !!LGitExternalEnumerationUInt32 class methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asExternalTypeOn: generator	^ FFIExternalEnumerationType 		objectClass: self 		representationType: self representationType! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!buildDeclaration	| dictionary |	self removeOldAccessors.	dictionary := self literalDeclaration.	self compileAccessorsFrom: dictionary.		^ declaration := dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!compileAccessorsFrom: aDictionary	aDictionary keysAndValuesDo: [ :symbol :value |		self class			compile: (String streamContents: [ :stream |				stream					nextPutAll: symbol asString; cr; tab;					nextPutAll: '^ self basicNew'; cr; tab; tab;					nextPutAll: 'value: ';					nextPutAll: value asString;					nextPutAll: ';'; cr; tab; tab;					nextPutAll: 'yourself' ])			classified: 'accessing-values' ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!declaration	^ declaration ifNil: [ declaration := self literalDeclaration ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultRepresentationType	^ FFIUInt32 new! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#()! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromInteger: anInteger	^self basicNew		value: anInteger;		yourself! !!LGitExternalEnumerationUInt32 class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!includes: aSymbol	^ self declaration includesKey: aSymbol! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!initialize	declaration := nil.	representationType := nil.! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!literalDeclaration	| dictionary |	dictionary := self enumDecl in: [ :decl |		decl isDictionary			ifTrue: [ decl ]			ifFalse: [ Dictionary newFromPairs: decl ] ].			self makeSelectorsLegalIn: dictionary.	^ dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!makeSelectorsLegalIn: aDictionary	aDictionary associationsDo: [ :nameToValue |		| selector |		selector := nameToValue key asLowercase asSymbol.		nameToValue key: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!new	^ self shouldNotImplement ! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!removeOldAccessors	declaration ifNil: [ ^ self ].		declaration keys do: [ :selector |		self class removeSelector: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!representationType	^ representationType ifNil: [ representationType := self defaultRepresentationType ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anEnumInst	^ self class == anEnumInst class and: [		self value = anEnumInst value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ self className hash bitXor: self value hash! !!LGitExternalEnumerationUInt32 methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isPartOfBitFlag: anInteger	"A bit flag may be composed of several values, where every bit	represents the state of one flag. Therefore, a 2 bit value can	represent 2 different flags, for instance. The #bitAnd: operation	will mask all other flags.		For some reason the libgit2 folks thought it would make sense to	use flags of value 0 in bit flags. That forces one to check for zero	(on the entire word)	explicitly. WTF."	^ self value isZero		ifTrue: [ anInteger isZero ]		ifFalse: [ (self value bitAnd: anInteger) = self value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printOn: stream	super printOn: stream.	value isInteger 		" temp: due to a uffi bug (?) sometimes value == self"		ifFalse: [ ^ self ].	stream nextPut: $(;		nextPutAll: self symbol printString;		nextPutAll: ' [';		nextPutAll: self value asString;		nextPut: $];		nextPut: $)! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!symbol	<todo: 'now we can handle enums which define the same value multiple times, but in case of this handler, we don''t know which name we need to associate with the return value. This is basically random...'>	^ self class declaration		keyAtValue: self value		ifAbsent: [ nil ]! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value	^ value! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value: anInteger	value := anInteger ! !!LGitFetchPruneTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		"		 * Use the setting from the configuration		 "		GIT_FETCH_PRUNE_UNSPECIFIED 0		"		 * Force pruning on		 "		GIT_FETCH_PRUNE 1		"		 * Force pruning off		 "		GIT_FETCH_NO_PRUNE 2	)! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_no_prune	^ self basicNew		value: 2;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_prune	^ self basicNew		value: 1;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_prune_unspecified	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_FILEMODE_NEW 0	GIT_FILEMODE_TREE 16384	GIT_FILEMODE_BLOB 33188	GIT_FILEMODE_BLOB_EXECUTABLE 33261	GIT_FILEMODE_LINK 40960	GIT_FILEMODE_COMMIT 57344)! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_blob	^ self basicNew		value: 33188;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_blob_executable	^ self basicNew		value: 33261;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_commit	^ self basicNew		value: 57344;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_link	^ self basicNew		value: 40960;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_new	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_tree	^ self basicNew		value: 16384;		yourself! !!LGitOpenFlagEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_REPOSITORY_OPEN_NO_SEARCH 1	GIT_REPOSITORY_OPEN_CROSS_FS 2	GIT_REPOSITORY_OPEN_BARE 4)! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_repository_open_bare	^ self basicNew		value: 4;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_repository_open_cross_fs	^ self basicNew		value: 2;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_repository_open_no_search	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_BLAME_OPTIONS_VERSION_1 1	GIT_CHECKOUT_OPTIONS_VERSION_1 1	GIT_CLONE_OPTIONS_VERSION_1 1	GIT_DIFF_OPTIONS_VERSION_1 1	GIT_DIFF_FIND_OPTIONS_VERSION_1 1	GIT_FETCH_OPTIONS_VERSION_1 1	GIT_PUSH_OPTIONS_VERSION_1 1	)! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_merge_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_PATHSPEC_DEFAULT 0	"forces match to ignore case; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_IGNORE_CASE 1	"forces case sensitive match; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_USE_CASE 2	"disables glob patterns and just uses simple string comparison for matching"	GIT_PATHSPEC_NO_GLOB 4	"means the match functions return error code GIT_ENOTFOUND if no matches are found; otherwise no matches is still success (return 0) but git_pathspec_match_list_entrycount will indicate 0 matches."	GIT_PATHSPEC_NO_MATCH_ERROR 8	"means that the git_pathspec_match_list should track which patterns matched which files so that at the end of the match we can identify patterns that did not match any files."	GIT_PATHSPEC_FIND_FAILURES 16	"means that the git_pathspec_match_list does not need to keep the actual matching filenames. Use this to just test if there were any matches at all or in combination with GIT_PATHSPEC_FIND_FAILURES to validate a pathspec."	GIT_PATHSPEC_FAILURES_ONLY 32)! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_default	^ self basicNew		value: 0;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_failures_only	^ self basicNew		value: 32;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_find_failures	^ self basicNew		value: 16;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_ignore_case	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_no_glob	^ self basicNew		value: 4;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_no_match_error	^ self basicNew		value: 8;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_use_case	^ self basicNew		value: 2;		yourself! !!LGitProxyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(	"/**	 * Do not attempt to connect through a proxy	 *	 * If built against libcurl, it itself may attempt to connect	 * to a proxy if the environment variables specify it.	 */"	GIT_PROXY_NONE 0	"/**	 * Try to auto-detect the proxy from the git configuration.	 */"	GIT_PROXY_AUTO 1	"/**	 * Connect via the URL given in the options	 */"	GIT_PROXY_SPECIFIED 2	)! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_proxy_auto	^ self basicNew		value: 1;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_proxy_none	^ self basicNew		value: 0;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_proxy_specified	^ self basicNew		value: 2;		yourself! !!LGitPushOptionsVersionEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(			LGIT_PUSH_OPTIONS_VERSION_1 1		)! !!LGitPushOptionsVersionEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!lgit_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_REF_INVALID 0	GIT_REF_OID 1	GIT_REF_SYMBOLIC 2	GIT_REF_LISTALL 3)! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_invalid	^ self basicNew		value: 0;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_listall	^ self basicNew		value: 3;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_oid	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_symbolic	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		"		 * Use the setting from the configuration.		 "		GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED 0		"		 * Ask the server for tags pointing to objects we're already		 * downloading.		 "		GIT_REMOTE_DOWNLOAD_TAGS_AUTO 1		"		 * Don't ask for any tags beyond the refspecs.		 "		GIT_REMOTE_DOWNLOAD_TAGS_NONE 2		"		 * Ask for the all the tags.		 "		GIT_REMOTE_DOWNLOAD_TAGS_ALL 3	)! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_all	^ self basicNew		value: 3;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_auto	^ self basicNew		value: 1;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_none	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_unspecified	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_REMOTE_COMPLETION_DOWNLOAD 0	GIT_REMOTE_COMPLETION_INDEXING 1	GIT_REMOTE_COMPLETION_ERROR 2)! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_completion_download	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_completion_error	^ self basicNew		value: 2;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_completion_indexing	^ self basicNew		value: 1;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_SORT_NONE 0	GIT_SORT_TOPOLOGICAL 1	GIT_SORT_TIME 2	GIT_SORT_REVERSE 4	)! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_none	^ self basicNew		value: 0;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_reverse	^ self basicNew		value: 4;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_time	^ self basicNew		value: 2;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_topological	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(		GIT_STATUS_CURRENT  0		GIT_STATUS_INDEX_NEW         "1 bitShift: 0" 1		GIT_STATUS_INDEX_MODIFIED    "1 bitShift: 1" 2		GIT_STATUS_INDEX_DELETED     "1 bitShift: 2" 4		GIT_STATUS_INDEX_RENAMED     "1 bitShift: 3" 8		GIT_STATUS_INDEX_TYPECHANGE  "1 bitShift: 4" 16		GIT_STATUS_WT_NEW            "1 bitShift: 7" 128		GIT_STATUS_WT_MODIFIED       "1 bitShift: 8" 256		GIT_STATUS_WT_DELETED        "1 bitShift: 9" 512		GIT_STATUS_WT_TYPECHANGE     "1 bitShift: 10" 1024		GIT_STATUS_WT_RENAMED        "1 bitShift: 11" 2048		GIT_STATUS_WT_UNREADABLE     "1 bitShift: 12" 4096		GIT_STATUS_IGNORED           "1 bitShift: 14" 16384		GIT_STATUS_CONFLICTED        "1 bitShift: 15" 32768)! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_conflicted	^ self basicNew		value: 32768;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_current	^ self basicNew		value: 0;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_ignored	^ self basicNew		value: 16384;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_deleted	^ self basicNew		value: 4;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_modified	^ self basicNew		value: 2;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_new	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_renamed	^ self basicNew		value: 8;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_typechange	^ self basicNew		value: 16;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_deleted	^ self basicNew		value: 512;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_modified	^ self basicNew		value: 256;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_new	^ self basicNew		value: 128;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_renamed	^ self basicNew		value: 2048;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_typechange	^ self basicNew		value: 1024;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_unreadable	^ self basicNew		value: 4096;		yourself! !!LGitStructVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(		GIT_REMOTE_CALLBACKS_VERSION_1 1	)! !!LGitStructVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_callbacks_version_1	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_SUBMODULE_IGNORE_RESET     -1 "reset to on-disk value"	GIT_SUBMODULE_IGNORE_NONE      1  "any change or untracked == dirty"	GIT_SUBMODULE_IGNORE_UNTRACKED 2  "dirty if tracked files change"	GIT_SUBMODULE_IGNORE_DIRTY     3  "only dirty if HEAD moved"	GIT_SUBMODULE_IGNORE_ALL       4  "never dirty"	GIT_SUBMODULE_IGNORE_DEFAULT   0)! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_all	^ self basicNew		value: 4;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_default	^ self basicNew		value: 0;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_dirty	^ self basicNew		value: 3;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_none	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_reset	^ self basicNew		value: -1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_untracked	^ self basicNew		value: 2;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_TREEWALK_PRE 0	GIT_TREEWALK_POST 1)! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_treewalk_post	^ self basicNew		value: 1;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_treewalk_pre	^ self basicNew		value: 0;		yourself! !!LGitFunctionReturn class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!methodSelector: aSymbol value: anObject	^ self new		methodSelector: aSymbol;		value: anObject;		yourself! !!LGitFunctionReturn methodsFor: 'handling' stamp: ' 7/21/2017 17:44:56'!handleLGitReturnCode	^ self value handleLGitReturnCode! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!methodSelector	^ methodSelector! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!methodSelector: aSymbol	methodSelector := aSymbol! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value	^ value! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value: anObject	value := anObject! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkInitialized	"Make sure that LigGit2 is properly initialized."	self ffiLibrary isInitialized 		ifFalse: [ self ffiLibrary uniqueInstance initializeLibGit2 ]! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!runSequence: aBlock	LGitActionSequence value ifNotNil: aBlock.		LGitActionSequence		value: thisContext sender		during: [			self checkInitialized.			aBlock value ]! !!LGitRefSpec class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromString: aString	^ self new		initializeFromString: aString;		yourself! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!beForced	forced := true! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!destination	^ destination ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!destination: aString	destination := aString! !!LGitRefSpec methodsFor: 'intialization' stamp: ' 7/21/2017 17:44:56'!initializeFromString: aString	<todo: 'use exceptions instead of assertions'>	| stream |	self assert: ('((\+[\w/]+)|([\w/]*))\:[\w/]+' asRegex matches: aString).		stream := aString readStream.	[		(stream peek = $+) ifTrue: [ 			self beForced.			stream next ].		self source: (stream upTo: $:).		self destination: stream upToEnd ] ensure: [ stream close ]! !!LGitRefSpec methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isForced	^ forced ifNil: [ false ]! !!LGitRefSpec methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printOn: aStream	self isForced ifTrue: [ aStream nextPut: $+ ].	aStream		nextPutAll: self source;		nextPut: $:;		nextPutAll: self destination! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!source	^ source ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!source: aString	source := aString! !!Object methodsFor: '*LibGit-Core-FFI-Handling' stamp: ' 7/21/2017 17:44:56'!handleLGitReturnCode	^ self! !!LGitBlameHunk class methodsFor: 'alignment' stamp: ' 7/21/2017 17:44:56'!byteAlignment	^ 1! !!LGitBlameHunk class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	<hack: 'orig_start_line_number is a uint16_t according to spec. The offset of orig_signature however is 56, not 54 (while the first fields are *not* aligned). To fix that, I changed the type of orig_start_line_number to uint32_t'>	^ #(		#FFIUInt16 lines_in_hunk "is the number of lines in this hunk"		LGitId final_commit_id "is the OID of the commit where this line was last changed."		#FFIUInt16 final_start_line_number "is the 1-based line number where this hunk begins, in the final version of the file"		LGitSignature * final_signature				LGitId orig_commit_id "is the OID of the commit where this hunk was found. This will usually be the same as final_commit_id, except when GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES has been specified."		String orig_path "is the path to the file where this hunk originated, as of the commit specified by orig_commit_id."		#FFIUInt32 orig_start_line_number "is the 1-based line number where this hunk begins in the file named by orig_path in the commit specified by orig_commit_id."		LGitSignature * orig_signature				Boolean boundary "is 1 iff the hunk has been tracked to a boundary commit (the root, or the commit specified in git_blame_options.oldest_commit)"	)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!boundary	^ self prim_boundary! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!finalCommitId	"prim version doesn't work"	"^ self prim_final_commit_id"		^ LGitId fromHandle: (handle copyFrom: 3 to: 22)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!finalSignature		^ self prim_final_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!finalStartLineNumber	^ self prim_final_start_line_number! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!numberOfLines	^ self prim_lines_in_hunk! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalCommitId	"prim version doesn't work"	"^ self prim_orig_commit_id"		^LGitId fromHandle: (handle copyFrom: 29 to: 48)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalPath	^ self prim_orig_path readString! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalSignature		^ self prim_orig_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalStartLineNumber	^ self prim_orig_start_line_number! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_boundary	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BOUNDARY! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_boundary: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BOUNDARY put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_FINAL_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FINAL_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_start_line_number	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_start_line_number: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_lines_in_hunk	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_lines_in_hunk: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ORIG_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ORIG_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_PATH) type: ExternalType char asPointerType! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_PATH put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_start_line_number	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_start_line_number: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER put: anObject! !!LGitBuf class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		char * ptr;		size_t asize;		size_t size;	)		"self rebuildFieldAccessors"! !!LGitBuf class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!signature_free: handle 	^ self		call: #(void git_buf_free(void *handle))		options: #(  )! !!LGitBuf methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!free	"Free the memory referred to by the git_buf.	Note that this does not free the git_buf itself, just the memory pointed to by buffer->ptr. This 	will not free the memory if it looks like it was not allocated internally, but it will clear the 	buffer back to the empty state."	self class signature_free: handle! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_asize	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_asize: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE put: anObject! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ptr	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PTR) type: ExternalType char asPointerType! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ptr: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PTR put: anObject getHandle.! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitCheckoutPerfData class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		size_t mkdir_calls;		size_t stat_calls;		size_t chmod_calls;	)! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_chmod_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_chmod_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mkdir_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mkdir_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitCredentials class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	LGitCredentialsTypeEnum credtype;	LGitCredentialsFreeCallout free;	)! !!LGitCredentials methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aStructure	self subclassResponsibility! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!passphrase	^ passphrase! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!passphrase: aString	passphrase := aString! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!username	^ username! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!username: aString	username := aString! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider onto: lgitCredentials	| credentials |	[		credentials := self new.		provider providePlaintextCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ :e | 		LGitError setError: 'Invalid username and/or password provided.'.						^ -1 ]! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!username: username passphrase: passphrase	^ self new		username: username;		passphrase: passphrase;		yourself! !!LGitCredentialsPlaintext methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self passphrase isEmptyOrNil not.	self withReturnHandlerDo: [ 		self 			cred_userpass_plaintext_new: aStructure			username: self username			password: self passphrase ]! !!LGitCredentialsPlaintext methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_userpass_plaintext_new: out username: usernameString password: password 	^self call: #(		LGitReturnCodeEnum git_cred_userpass_plaintext_new(			LGitCredentials * out, 			String username, 			String password)	) options: #(  )! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider onto: lgitCredentials	| credentials |	 	[		credentials := self new.		provider provideSshCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'Invalid ssh keys in provided files.'.				-1 ]! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider username: username onto: lgitCredentials	 ^ self createFrom: provider onto: lgitCredentials! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!username: username passphrase: passphrase publicKeyReference: publicKeyFileReference privateKeyReference: privateKeyFileReference	^ self new		username: username;		passphrase: passphrase;		publicKeyReference: publicKeyFileReference;		privateKeyReference: privateKeyFileReference;		yourself! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self publicKeyReference exists.	self assert: self privateKeyReference exists.	self withReturnHandlerDo: [ 		self 			cred_ssh_key_new: aStructure			username: self username			publickey: self publicKeyReference fullName			privatekey: self privateKeyReference fullName			passphrase: self passphrase ]! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_ssh_key_new: out username: usernameString publickey: publickey privatekey: privatekey passphrase: passphraseString	^self call: 		#(int git_cred_ssh_key_new(			LGitCredentials * out, 			String usernameString, 			String publickey, 			String privatekey, 			String passphraseString)) options: #(  )! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_username_new: out username: usernameString	^ self 		call: #(int git_cred_username_new (LGitCredentials * out, String usernameString)) 		options: #()			! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!privateKeyReference	^ privateKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!privateKeyReference: aFileReference	privateKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!publicKeyReference	^ publicKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!publicKeyReference: aFileReference	publicKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setGitUsernameIn: aStructure	self withReturnHandlerDo: [ 		self cred_username_new: aStructure username: 'git'	]! !!LGitCredentialsSSHAgent class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider username: username onto: lgitCredentials	| credentials |		[  		credentials := self new.		provider provideSshAgentCredentialsTo: credentials.			credentials createWith: username onto: lgitCredentials.		^ 0 ]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'No ssh-agent suitable credentials found.'.		^ -1 ]! !!LGitCredentialsSSHAgent methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aName onto: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: aName isEmptyOrNil not.	self withReturnHandlerDo: [ 		self cred_ssh_key_new: aStructure username: aName ]! !!LGitCredentialsSSHAgent methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_ssh_key_new: out username: aName	^ self call: #(int git_cred_ssh_key_from_agent(LGitCredentials *out, String aName))! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitDiffBinary class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(			uint contains_data;		LGitDiffBinaryFile old_file; "< The contents of the old file."		LGitDiffBinaryFile new_file; "< The contents of the new file."	)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_contains_data	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_contains_data: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA put: anObject! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinaryFile class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		" The type of binary data for this file. "		LGitDiffBinaryTypeEnum type;		" The binary data, deflated. is char* originally, but I do not want to get the \0"		void *data;		" The length of the binary data. "		size_t datalen;		" The length of the binary data after inflation. "		size_t inflatedlen;	)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DATA) type: ExternalType void asPointerType! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DATA put: anObject getHandle.! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_datalen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_datalen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_inflatedlen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_inflatedlen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type	"This method was automatically generated"	^LGitDiffBinaryTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitDiffDelta class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitDeltaTypeEnum status	uint32 flags	"for RENAMED and COPIED, value 0-100"	uint16 similarity	"number of files in this delta"	uint16 nfiles	LGitDiffFile old_file	LGitDiffFile new_file	)! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newFile	^ self prim_new_file! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!numberOfFiles	^ self prim_nfiles! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldFile	^ self prim_old_file! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_nfiles	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_NFILES! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_nfiles: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_NFILES put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_SIMILARITY! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_SIMILARITY put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_status	"This method was automatically generated"	^LGitDeltaTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_STATUS)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_status: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_STATUS put: anObject value! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!status	^ self prim_status! !!LGitDiffFile class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	LGitId id	String path	int64 size	uint32 flags	uint16 mode	uint16 id_abbrev	)! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!id	^ self prim_id! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!path	^ self prim_path readString! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ID length: LGitId byteSize)! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ID put: anObject getHandle length: LGitId byteSize! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mode	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MODE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mode: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MODE put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PATH) type: ExternalType char asPointerType! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PATH put: anObject getHandle.! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_SIZE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!size	^ self prim_size! !!LGitDiffHunk class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	int old_start "Starting line number in old_file"	int old_lines "Number of lines in old_file"	int new_start "Starting line number in new_file"	int new_lines "Number of lines in new_file"	size_t header_len "Number of bytes in header text"	Char128 header "Header text, NUL-byte terminated" 		)! !!LGitDiffHunk class methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initialize	Char128 := FFITypeArray ofType: #char size: 128! !!LGitDiffHunk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx	^ self		call: #(LGitReturnCodeEnum git_patch_get_hunk(LGitDiffHunk * self, LGitWriteBackValueSizeT lines_in_hunk, LGitPatch patch, size_t hunk_idx))		options: #(  )! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newNumberOfLines	^ self prim_new_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newStart	^ self prim_new_start! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldNumberOfLines	^ self prim_old_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldStart	^ self prim_old_start! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header	"This method was automatically generated"	^(FFITypeArray ofType: #FFICharacterType size: 128) fromHandle: (handle copyFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127)! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header: anObject	"This method was automatically generated"	handle replaceFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127 with: anObject getHandle startingAt: 1! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_START put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_START put: anObject! !!LGitDiffLine class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	LGitDiffLineTypeEnum	  origin       "A git_diff_line_t value"	int    old_lineno   "Line number in old file or -1 for added line"	int    new_lineno   "Line number in new file or -1 for deleted line"	int    num_lines    "Number of newline characters in content"	size_t content_len  "Number of bytes of data"	int64 content_offset "Offset in the original file to the content"	String content "Pointer to diff text, not NUL-byte terminated"	) ! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!content	^ (self prim_content getHandle copyFrom: 1 to: self prim_content_len) asString! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newLineNumber	^ self prim_new_lineno! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldLineNumber	^ self prim_old_lineno! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CONTENT) type: ExternalType char asPointerType! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CONTENT put: anObject getHandle.! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_offset	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_offset: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_num_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NUM_LINES! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_num_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NUM_LINES put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_origin	"This method was automatically generated"	^LGitDiffLineTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_ORIGIN)! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_origin: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIGIN put: anObject value! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!size	^ self prim_content_len! !!LGitDiffPerfData class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	uint version	size_t stat_calls "Number of stat() calls performed"	size_t oid_calculations "Number of ID calculations"	)! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid_calculations	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid_calculations: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_VERSION! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject! !!LGitDiffSimilarityMetric class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc"int (*file_signature)(		void **out, const git_diff_file *file,		const char *fullpath, void *payload);	int (*buffer_signature)(		void **out, const git_diff_file *file,		const char *buf, size_t buflen, void *payload);	void (*free_signature)(void *sig, void *payload);	int (*similarity)(int *score, void *siga, void *sigb, void *payload);	void *payload;"	^#(	LGitFileSignatureCallback file_signature;	LGitBufferSignatureCallback buffer_signature;	LGitFreeSignatureCallback free_signature;	LGitSimilarityCallback similarity;	void *payload;	)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_buffer_signature	"This method was automatically generated"	^LGitBufferSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_buffer_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_signature	"This method was automatically generated"	^LGitFileSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FILE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FILE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free_signature	"This method was automatically generated"	^LGitFreeSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FREE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FREE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity	"This method was automatically generated"	^LGitSimilarityCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIMILARITY) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIMILARITY		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitError class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	String message;	LGitErrorTypeEnum klass;	)! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!giterr_clear	^ self call: #(void giterr_clear()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!giterr_last	^ self call: #(void *giterr_last()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!giterr_set_str: string	"GIT_EUSER = -7"	^ self call: #(void giterr_set_str(-7, String string))! !!LGitError class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!last	| externalData |	externalData := self giterr_last.	^ self fromHandle: externalData getHandle! !!LGitError class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!lastMessage	^ self last message! !!LGitError class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setError: aString	self giterr_set_str: aString! !!LGitError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message	^ self isNull		ifFalse: [ self prim_message readString ]		ifTrue: [ 'no error message set by libgit2' ]! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_klass	"This method was automatically generated"	^LGitErrorTypeEnum fromInteger: (handle signedLongAt: OFFSET_PRIM_KLASS)! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_klass: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_KLASS put: anObject value! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_message	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_MESSAGE) type: ExternalType char asPointerType! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_message: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_MESSAGE put: anObject getHandle.! !!LGitError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type	^ self isNull		ifFalse: [ self prim_klass ]		ifTrue: [ nil ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!createAccessorsFor: fieldName 	"Define read/write accessors for the given field"	| code |	code := fieldName,'	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ].		code := fieldName,': anObject	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString , ' put: anObject'.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!fieldNamesAndProtocols	^ Dictionary new! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!fieldSpec	^ LGitExternalStructureFieldParser new  		parseFields: self fieldsDesc structure: self.! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!free: aHandle	aHandle free! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #free:! !!LGitExternalStructure class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromExternalAddress: anAddress	anAddress isNull		ifTrue: [ ^ nil ].	^ self fromHandle: anAddress getHandle! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!generatedFieldProtocolName	^ 'libgit-fields'! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!protocolForField: aString	^ self fieldNamesAndProtocols		at: aString		ifAbsent: [ 'libgit-fields' ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!removeAccessor: aSelector	self package removeMethod: (self		compiledMethodAt: aSelector		ifAbsent: [ ^ self ]).			^ super removeAccessor: aSelector! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!autoRelease	"Some LGit structures need specialised free functions. Use the same autoRelease functionality	as FFIExternalReference to achieve this.	Note, subclasses should implement #resourceData	and #finalizeResourceData: on class side"	FFIExternalResourceManager addResource: self! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalStructure methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isExternal	"answer true if data referenced by receiver located in external heap, or just in object memory "	^ handle isExternalAddress! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!resourceData	^ self getHandle! !!LGitId class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	uint8 data1;	uint8 data2;	uint8 data3;	uint8 data4;	uint8 data5;	uint8 data6;	uint8 data7;	uint8 data8;	uint8 data9;	uint8 data10;	uint8 data11;	uint8 data12;	uint8 data13;	uint8 data14;	uint8 data15;	uint8 data16;	uint8 data17;	uint8 data18;	uint8 data19;	uint8 data20;	)! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromByteArray: aByteArray	^ self new		prim_data1: (aByteArray at: 1);		prim_data2: (aByteArray at: 2);		prim_data3: (aByteArray at: 3);		prim_data4: (aByteArray at: 4);		prim_data5: (aByteArray at: 5);		prim_data6: (aByteArray at: 6);		prim_data7: (aByteArray at: 7);		prim_data8: (aByteArray at: 8);		prim_data9: (aByteArray at: 9);		prim_data10: (aByteArray at: 10);		prim_data11: (aByteArray at: 11);		prim_data12: (aByteArray at: 12);		prim_data13: (aByteArray at: 13);		prim_data14: (aByteArray at: 14);		prim_data15: (aByteArray at: 15);		prim_data16: (aByteArray at: 16);		prim_data17: (aByteArray at: 17);		prim_data18: (aByteArray at: 18);		prim_data19: (aByteArray at: 19);		prim_data20: (aByteArray at: 20);		yourself! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromHexString: aString	^ self fromByteArray: (ByteArray readHexFrom: aString)! !!LGitId methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject		or: [ self class = anObject class			and: [ self compare: anObject ] ]! !!LGitId methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asByteArray	^ (ByteArray new: 20)		at: 1 put: (self prim_data1);		at: 2 put: (self prim_data2);		at: 3 put: (self prim_data3);		at: 4 put: (self prim_data4);		at: 5 put: (self prim_data5);		at: 6 put: (self prim_data6);		at: 7 put: (self prim_data7);		at: 8 put: (self prim_data8);		at: 9 put: (self prim_data9);		at: 10 put: (self prim_data10);		at: 11 put: (self prim_data11);		at: 12 put: (self prim_data12);		at: 13 put: (self prim_data13);		at: 14 put: (self prim_data14);		at: 15 put: (self prim_data15);		at: 16 put: (self prim_data16);		at: 17 put: (self prim_data17);		at: 18 put: (self prim_data18);		at: 19 put: (self prim_data19);		at: 20 put: (self prim_data20);		yourself	! !!LGitId methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asInteger	^ self asByteArray asInteger! !!LGitId methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!asRelativePathString	| string |	string := String new: 41.	string pin.	self		oid_pathfmt: string		id: self.	string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!compare: anId	^ (self 		oid_cmp: self		b: anId) isZero! !!LGitId methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!hexString	| string |	self isExternal 		ifFalse: [ ^handle hex ].	string := String new: 40.	string pin.	self		oid_fmt: string		id: self.		string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!internalize	"Copy the data of this object over to Smalltalk memory if it is currently external.	Now we can keep on using this object after the containing object (Blob, Tree or Commit)	has been freed."	(handle isExternalAddress and: [ handle isNull not ])		ifTrue: [ 			| bytes |			bytes := handle copyFrom: 1 to: self class byteSize.			handle := bytes ]! !!LGitId methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self hexString surroundedBySingleQuotes! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!oid_cmp: a b: b 	^self call: #(int git_oid_cmp(LGitId * self, LGitId * b)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!oid_fmt: out id:  objectId	^self call: #(void git_oid_fmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!oid_pathfmt: out id: id 	^ self call: #(void git_oid_pathfmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data1	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA1! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data10	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA10! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data10: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA10 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data11	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA11! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data11: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA11 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data12	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA12! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data12: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA12 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data13	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA13! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data13: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA13 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data14	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA14! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data14: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA14 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data15	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA15! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data15: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA15 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data16	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA16! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data16: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA16 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data17	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA17! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data17: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA17 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data18	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA18! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data18: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA18 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data19	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA19! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data19: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA19 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data1: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA1 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data2	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA2! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data20	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA20! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data20: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA20 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data2: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA2 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data3	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA3! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data3: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA3 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data4	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA4! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data4: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA4 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data5	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA5! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data5: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA5 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data6	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA6! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data6: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA6 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data7	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA7! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data7: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA7 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data8	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA8! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data8: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA8 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data9	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA9! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data9: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA9 put: anObject! !!LGitOdbWritepack class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	"git_odb_backend *" void *backend; "Using void* because I didn't mapped the structure git_odb_backend"	LGitWritepackAppendCallout append;	LGitWritepackCommitCallout commit;	LGitWritepackFreeCallout free;	)! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!appendWithBuffer: anAddress length: anInteger progress: aTransferProgress	| data callout|	data := self prim_append.	callout := LGitWritepackAppendCallout fromHandle: data getHandle.	^ callout		writepack: self		buffer: anAddress		length: anInteger		progress: aTransferProgress! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!commitWithProgress: aTransferProgress	self withReturnHandlerDo: [		self prim_commit			writepack: self			progress: aTransferProgress ]! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!free	self prim_free writepack: self! !!LGitOdbWritepack methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!odb_write_pack: out db: db progress_cb: progress_cb progress_payload: progress_payload 	^ self		call: #(#LGitReturnCodeEnum git_odb_write_pack(LGitOdbWritepack * self, LGitOdb db, LGitTransferProgressCallback progress_cb, void * progress_payload))		options: #( optMayGC optCoerceNilToNull )! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_append	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_APPEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_append: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_APPEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_backend	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BACKEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_backend: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BACKEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_commit	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_COMMIT) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_commit: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_COMMIT put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitPackbuilderForeachPayload class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitTransferProgress *stats;		LGitTransferProgressCallback *progress_cb;		void *progress_payload;		LGitOdbWritepack *writepack;	)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stats	"This method was automatically generated"	^LGitTransferProgress fromHandle: (handle pointerAt: OFFSET_PRIM_STATS)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stats: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STATS put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_writepack	"This method was automatically generated"	^LGitOdbWritepack fromHandle: (handle pointerAt: OFFSET_PRIM_WRITEPACK)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_writepack: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_WRITEPACK put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!stats	^ self prim_stats! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!stats: aTransferProgress	self prim_stats: aTransferProgress! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!writepack	^ self prim_writepack! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!writepack: aWritepack	self prim_writepack: aWritepack! !!LGitPushUpdate class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		"		 * The source name of the reference		 "		String src_refname;		"		 * The name of the reference to update on the server		 "		String dst_refname;		"		 * The current target of the reference		 "		LGitId src		"		 * The new target for the reference		 "		LGitId dst	)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_DST length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_DST put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DST_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DST_REFNAME put: anObject getHandle.! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_SRC length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_SRC put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SRC_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SRC_REFNAME put: anObject getHandle.! !!LGitRemoteHead class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	"self rebuildFieldAccessors"	^#(	int local; " available locally "	LGitId oid;	LGitId loid;	String name;	"	 * If the server send a symref mapping for this ref, this will	 * point to the target.	"	String symref_target;	)! !!LGitRemoteHead methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name 	^ (self prim_name) readString! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_LOCAL! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_LOCAL put: anObject! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_loid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_LOID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_loid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_LOID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_symref_target	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SYMREF_TARGET) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_symref_target: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SYMREF_TARGET put: anObject getHandle.! !!LGitSignature class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		char * name;		char * email;		LGitTime when;	)! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!name: nameString email: emailString	^ self name: nameString email: emailString when: DateAndTime now! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!name: nameString email: emailString when: dateAndTime	"Allocate an instance on the external heap and initialize it.	Use autoRelease so the data will be freed when the instance is gc'ed."	^ self externalNew			name: nameString;			email: emailString;			dateAndTime: dateAndTime;			autoRelease;			yourself! !!LGitSignature class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!signature_free: handle 	^ self		call: #(void git_signature_free(void *handle))		options: #(  )! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self name = anObject name				and: [ self email = anObject email					and: [ self dateAndTime = anObject dateAndTime ] ] ] ]! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!dateAndTime	^ self prim_when asDateAndTime! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!dateAndTime: aDateAndTime	self prim_when: (LGitTime fromDateAndTime: aDateAndTime)! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!email	^ self prim_email readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!email: aString	self prim_email: aString asLGitExternalString! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ ((self name hash bitXor: self email hash) bitXor: self email hash) bitXor: self dateAndTime hash! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name	^ self prim_name readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name: aString	self prim_name: aString asLGitExternalString! !!LGitSignature methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream		nextPutAll: self name;		nextPutAll: ' <';		nextPutAll: self email;		nextPutAll: '> '.	self dateAndTime printOn: aStream! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_email	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_EMAIL) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_email: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_EMAIL put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_when	"This method was automatically generated"	^ LGitTime fromHandle: (handle referenceStructAt: OFFSET_PRIM_WHEN length: LGitTime byteSize)! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_when: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_WHEN put: anObject getHandle length: LGitTime byteSize! !!LGitStringArray class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitExternalStringArray * strings;		size_t count;	)! !!LGitStringArray class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!strarray_free: handle	"libgit2 will also free all the strings in this struct"	^ self		call: #(void git_strarray_free(void *handle))		options: #()! !!LGitStringArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withAll: stringCollection	"Allocate an instance on the external heap and initialize it with	<stringCollection>. Use autoRelease so the data will be freed when	the instance is gc'ed."	^ self externalNew		count: stringCollection size;		strings: stringCollection;		autoRelease;		yourself! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!count	^ self prim_count! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!count: anInteger	self prim_count: anInteger! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_count	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_count: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT put: anObject! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_strings	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_STRINGS) type: ExternalType void asPointerType! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_strings: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STRINGS put: anObject getHandle.! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!strings	| externalArray |	self count = 0		ifTrue: [ ^ #() ].	externalArray := LGitExternalStringArray 		onAddress: self prim_strings getHandle 		size: self count.	^externalArray asArray! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!strings: aCollection	| array |	array := LGitExternalStringArray fromCollection: aCollection.	self prim_strings: array! !!LGitBlameOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version		uint32 flags "is a combination of the git_blame_flag_t values above."		uint16 min_match_characters "is the lower bound on the number of alphanumeric characters that must be detected as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20. This value only takes effect if any of the GIT_BLAME_TRACK_COPIES_* flags are specified."		LGitId newest_commit "is the id of the newest commit to consider. The default is HEAD."		LGitId oldest_commit "is the id of the oldest commit to consider. The default is the first commit encountered with a NULL parent."		size_t min_line "is the first line in the file to blame. The default is 1 (line numbers start with 1)."		size_t max_line "is the last line in the file to blame. The default is the last line of the file."	)! !!LGitBlameOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_init_options: opts version: version	^ self		callUnchecked: #(int git_blame_init_options(LGitBlameOptions * self, LGitOptionsVersionsEnum version))		options: #( )! !!LGitBlameOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			blame_init_options: self			version: LGitOptionsVersionsEnum git_blame_options_version_1 ]! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_match_characters	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_match_characters: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_newest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEWEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_newest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEWEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oldest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLDEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oldest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLDEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCheckoutOptions class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		uint checkout_strategy; "< default will be a dry run "		int disable_filters;    "< don't apply filters like CRLF conversion "		uint dir_mode;  "< default is 0755 "		uint file_mode; "< default is 0644 or 0755 as dictated by blob "		int file_open_flags;    "< default is O_CREAT | O_TRUNC | O_WRONLY "		uint notify_flags; "< see `git_checkout_notify_t` above "		LGitCheckoutNotifyCallback notify_cb;		void *notify_payload;		" Optional callback to notify the consumer of checkout progress. "		LGitCheckoutProgressCallback progress_cb;		void *progress_payload;		" When not zeroed out, array of fnmatch patterns specifying which		 *  paths should be taken into account, otherwise all files.  Use		 *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.		 "		LGitStringArray paths;		" The expected content of the working directory; defaults to HEAD.		 *  If the working directory does not match this baseline information,		 *  that will produce a checkout conflict.		 "		LGitTree *baseline;		" Like `baseline` above, though expressed as an index.  This		 *  option overrides `baseline`.		 "		LGitIndex *baseline_index; "< expected content of workdir, expressed as an index. "		String target_directory; "< alternative checkout path to workdir "		String ancestor_label; "< the name of the common ancestor side of conflicts "		String our_label; "< the name of the *our* side of conflicts "		String their_label; "< the name of the *their* side of conflicts "		" Optional callback to notify the consumer of performance data. "		LGitCheckoutPerfDataCallback perfdata_cb;		void *perfdata_payload;	)! !!LGitCheckoutOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!checkoutStrategy: aCheckoutStrategyEnum	self prim_checkout_strategy: aCheckoutStrategyEnum value! !!LGitCheckoutOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_init_options: opts version: version 	^ self		callUnchecked: #(int git_checkout_init_options(LGitCheckoutOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCheckoutOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			checkout_init_options: self			version: LGitOptionsVersionsEnum git_checkout_options_version_1 ]! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ancestor_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ancestor_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline_index	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE_INDEX) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline_index: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE_INDEX put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_strategy	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_strategy: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dir_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_DIR_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dir_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DIR_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_disable_filters	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_disable_filters: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_open_flags	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_open_flags: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb	"This method was automatically generated"	^LGitCheckoutNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_our_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OUR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_our_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OUR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_paths	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHS length: LGitStringArray byteSize)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_paths: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHS put: anObject getHandle length: LGitStringArray byteSize! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_cb	"This method was automatically generated"	^LGitCheckoutPerfDataCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PERFDATA_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PERFDATA_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb	"This method was automatically generated"	^LGitCheckoutProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_directory	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_directory: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_their_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_THEIR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_their_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_THEIR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;				"		 * These options are passed to the checkout step. To disable		 * checkout, set the `checkout_strategy` to		 * `GIT_CHECKOUT_NONE`.		 "		LGitCheckoutOptions checkout_opts;		"		 * Options which control the fetch, including callbacks.		 *		 * The callbacks are used for reporting fetch progress, and for acquiring		 * credentials in the event they are needed.		 "		LGitFetchOptions fetch_opts;		"		 * Set to zero (false) to create a standard repo, or non-zero		 * for a bare repo		 "		Boolean bare;		"		 * Whether to use a fetch or copy the object database.		 "		LGitCloneLocalTypeEnum local;		"		 * The name of the branch to checkout. NULL means use the		 * remote's default branch.		 "		String checkout_branch;		"		 * A callback used to create the new repository into which to		 * clone. If NULL, the 'bare' field will be used to determine		 * whether to create a bare repository.		 "		LGitRepositoryCreateCallback repository_cb;		"		 * An opaque payload to pass to the git_repository creation callback.		 * This parameter is ignored unless repository_cb is non-NULL.		 "		void *repository_cb_payload;		"		 * A callback used to create the git_remote, prior to its being		 * used to perform the clone operation. See the documentation for		 * git_remote_create_cb for details. This parameter may be NULL,		 * indicating that git_clone should provide default behavior.		 "		LGitRemoteCreateCallback remote_cb;		"		 * An opaque payload to pass to the git_remote creation callback.		 * This parameter is ignored unless remote_cb is non-NULL.		 "		void *remote_cb_payload;	)! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withCredentialsCallback: aBlock	| credentialsCallback callbacks fetchOptions  |	credentialsCallback := LGitCredAcquireCallback on: aBlock.	callbacks := LGitRemoteCallbacks defaults		credentials: credentialsCallback;		yourself.	fetchOptions := LGitFetchOptions defaults		callbacks: callbacks;		yourself.	^ self defaults		fetchOptions: fetchOptions;		yourself.	! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withCredentialsProvider: provider	| fetchOptions |	fetchOptions := LGitFetchOptions defaults		callbacks: (LGitRemoteCallbacks withProvider: provider);		yourself.	^ self defaults		fetchOptions: fetchOptions		yourself.	! !!LGitCloneOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone_init_options: opts version: version 	^ self		callUnchecked: #(LGitReturnCodeEnum git_clone_init_options(LGitCloneOptions *self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchOptions	^ self prim_fetch_opts! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchOptions: _fetchOptions	fetchOptions := _fetchOptions.	self prim_fetch_opts: fetchOptions! !!LGitCloneOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			clone_init_options: self			version: LGitOptionsVersionsEnum  git_clone_options_version_1 ]! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_bare	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BARE! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_bare: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BARE put: anObject! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_branch	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH) type: ExternalType char asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_branch: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_opts	"This method was automatically generated"	^ LGitCheckoutOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_CHECKOUT_OPTS length: LGitCheckoutOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CHECKOUT_OPTS put: anObject getHandle length: LGitCheckoutOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_fetch_opts	"This method was automatically generated"	^ LGitFetchOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_FETCH_OPTS length: LGitFetchOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_fetch_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FETCH_OPTS put: anObject getHandle length: LGitFetchOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local	"This method was automatically generated"	^LGitCloneLocalTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_LOCAL)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL put: anObject value! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb	"This method was automatically generated"	^LGitRemoteCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REMOTE_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REMOTE_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb	"This method was automatically generated"	^LGitRepositoryCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REPOSITORY_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REPOSITORY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteCallback	^ self prim_remote_cb! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteCallback: aRemoteCallback	self prim_remote_cb: aRemoteCallback! !!LGitDiffFindOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		"Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).		 NOTE: if you don't explicitly set this, `diff.renames` could be set		 to false, resulting in `git_diff_find_similar` doing nothing."		uint32 flags;		" Similarity to consider a file renamed (default 50) "		uint16 rename_threshold;		" Similarity of modified to be eligible rename source (default 50) "		uint16 rename_from_rewrite_threshold;		" Similarity to consider a file a copy (default 50) "		uint16 copy_threshold;		" Similarity to split modify into delete/add pair (default 60) "		uint16 break_rewrite_threshold;		"Maximum similarity sources to examine for a file (somewhat like		 git-diff's `-l` option or `diff.renameLimit` config) (default 200)"		size_t rename_limit;		" Pluggable similarity metric; pass NULL to use internal metric "		LGitDiffSimilarityMetric metric;	)! !!LGitDiffFindOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_find_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_find_init_options(LGitDiffFindOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffFindOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_find_init_options: self			version: LGitOptionsVersionsEnum git_diff_find_options_version_1 ]! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_break_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_break_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_copy_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_copy_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric	"This method was automatically generated"	^ LGitDiffSimilarityMetric fromHandle: (handle referenceStructAt: OFFSET_PRIM_METRIC length: LGitDiffSimilarityMetric byteSize)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_METRIC put: anObject getHandle length: LGitDiffSimilarityMetric byteSize! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_from_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_from_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_limit	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_limit: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitDiffOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version      "version for the struct"		uint32 flags            "defaults to GIT_DIFF_NORMAL"		"options controlling which files are in the diff"		LGitSubmoduleIgnoreTypeEnum ignore_submodules "submodule ignore rule"		LGitStringArray       pathspec     "defaults to include all paths"		LGitDiffNotifyCallback notify_cb		void *notify_payload		"options controlling how to diff text is generated"		uint32    context_lines    "defaults to 3"		uint32    interhunk_lines  "defaults to 0"		uint16    id_abbrev       "default 'core.abbrev' or 7 if unset"		int64   max_size         "defaults to 512MB"		String old_prefix       "defaults to 'a'"		String new_prefix       "defaults to 'b'"	)! !!LGitDiffOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_init_options(LGitDiffOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_init_options: self			version: LGitOptionsVersionsEnum git_diff_options_version_1 ]! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_context_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_context_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ignore_submodules	"This method was automatically generated"	^LGitSubmoduleIgnoreTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ignore_submodules: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES put: anObject value! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_interhunk_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_interhunk_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NEW_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NEW_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb	"This method was automatically generated"	^LGitDiffNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OLD_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OLD_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pathspec	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHSPEC length: LGitStringArray byteSize)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pathspec: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHSPEC put: anObject getHandle length: LGitStringArray byteSize! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitFetchOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version;		"		 * Callbacks to use for this fetch operation		 "		LGitRemoteCallbacks callbacks;		"		 * Whether to perform a prune after the fetch		 "		LGitFetchPruneTypeEnum prune;		"		 * Whether to write the results to FETCH_HEAD. Defaults to		 * on. Leave this default in order to behave like git.		 "		Boolean update_fetchhead;		"		 * Determines how to behave regarding tags on the remote, such		 * as auto-downloading tags for objects we're downloading or		 * downloading all of them.		 *		 * The default is to auto-follow tags.		 "		LGitRemoteAutotagOptionTypeEnum download_tags;		"	    * Proxy options to use, by default no proxy is used.	   "		LGitProxyOptions proxy_opts;		"	  	 * Extra headers for this fetch operation	 	"		LGitStringArray custom_headers;	)! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks	^ self prim_callbacks! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks: _callbacks	callbacks := _callbacks.	self prim_callbacks: callbacks! !!LGitFetchOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!fetch_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_fetch_init_options(LGitFetchOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitFetchOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			fetch_init_options: self			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_download_tags	"This method was automatically generated"	^LGitRemoteAutotagOptionTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_download_tags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_prune	"This method was automatically generated"	^LGitFetchPruneTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_PRUNE)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_prune: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PRUNE put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_fetchhead	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_fetchhead: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD put: anObject! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitMergeOptions class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	"https://libgit2.github.com/libgit2/#HEAD/type/git_merge_options"	^#(		LGitOptionsVersionsEnum version;		uint32 flags; "Should be: git_merge_flag_t"		uint rename_threshold;		uint target_limit;		void* metric; "Should be: git_diff_similarity_metric *"		uint recursion_limit;		String default_driver;		uint32 file_favor; "Should be: git_merge_favor_flag_t"		uint32 file_flags; "Should be: git_merge_file_flag_t"	)! !!LGitMergeOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			merge_init_options: self			version: LGitOptionsVersionsEnum git_merge_options_version_1 ]! !!LGitMergeOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_init_options: opts version: version 	^ self		callUnchecked: #(int git_merge_init_options(			LGitMergeOptions * self, 			LGitOptionsVersionsEnum version))		options: #()! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_default_driver	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER) type: ExternalType char asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_default_driver: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_favor	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_favor: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_METRIC) type: ExternalType void asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_METRIC put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_recursion_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_recursion_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"/**	 * The type of proxy to use, by URL, auto-detect.	 */"	LGitProxyTypeEnum type;	"/**	 * The URL of the proxy.	 */"	String url;	"/**	 * This will be called if the remote host requires	 * authentication in order to connect to it.	 *	 * Returning GIT_PASSTHROUGH will make libgit2 behave as	 * though this field isn't set.	 */"	LGitCredAcquireCallback credentials;	"/**	 * If cert verification fails, this will be called to let the	 * user make the final decision of whether to allow the	 * connection to proceed. Returns 1 to allow the connection, 0	 * to disallow it or a negative value to indicate an error.	 */"   LGitTransportCertificateCheckCallback certificate_check;	"/**	 * Payload to be provided to the credentials and certificate	 * check callbacks.	 */"	void *payload;	)! !!LGitProxyOptions methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			proxy_init_options: self getHandle getHandle			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type	"This method was automatically generated"	^LGitProxyTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_url	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_URL) type: ExternalType char asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_url: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_URL put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!proxy_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_proxy_init_options(void *handle, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitPushOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"	 * If the transport being used to push to the remote requires the creation	 * of a pack file, this controls the number of worker threads used by	 * the packbuilder when creating that pack file to be sent to the remote.	 *	 * If set to 0, the packbuilder will auto-detect the number of threads	 * to create. The default value is 1.	 "	uint pb_parallelism;	"	 * Callbacks to use for this push operation	 "	LGitRemoteCallbacks callbacks;			"	* Proxy options to use, by default no proxy is used.	"	LGitProxyOptions proxy_opts;	"	 * Extra headers for this push operation	"	LGitStringArray custom_headers;)! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks	^ self prim_callbacks! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks: _callbacks	callbacks := _callbacks.	^ self prim_callbacks: callbacks! !!LGitPushOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			push_init_options: self			version: LGitOptionsVersionsEnum git_push_options_version_1 ]! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pb_parallelism	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pb_parallelism: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM put: anObject! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitPushOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!push_init_options: options version: version	self		callUnchecked: #(LGitReturnCodeEnum git_push_init_options(LGitPushOptions * self, LGitOptionsVersionsEnum version))		options: #()! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!defaults	^ super defaults 		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitStructVersionsEnum version;		"		 * Textual progress from the remote. Text send over the		 * progress side-band will be passed to this function (this is		 * the 'counting objects' output.		 "		LGitTransportMessageCallback sideband_progress;		"		 * Completion is called when different parts of the download		 * process are done (currently unused).		 "		LGitCompletionCallback completion;		"		 * This will be called if the remote host requires		 * authentication in order to connect to it.		 *		 * Returning GIT_PASSTHROUGH will make libgit2 behave as		 * though this field isn't set.		 "		LGitCredAcquireCallback credentials;		"		 * If cert verification fails, this will be called to let the		 * user make the final decision of whether to allow the		 * connection to proceed. Returns 1 to allow the connection, 0		 * to disallow it or a negative value to indicate an error.		 "	   LGitTransportCertificateCheckCallback certificate_check;		"		 * During the download of new data, this will be regularly		 * called with the current count of progress done by the		 * indexer.		 "		LGitTransferProgressCallback transfer_progress;		"		 * Each time a reference is updated locally, this function		 * will be called with information about it.		 "		LGitUpdateTipsCallback update_tips;		"		 * Function to call with progress information during pack		 * building. Be aware that this is called inline with pack		 * building operations, so performance may be affected.		 "		LGitPackbuilderProgressCallback pack_progress;		"		 * Function to call with progress information during the		 * upload portion of a push. Be aware that this is called		 * inline with pack building operations, so performance may be		 * affected.		 "		LGitPushTransferProgressCallback push_transfer_progress;		"		 * Called for each updated reference on push. If `status` is		 * not `NULL`, the update was rejected by the remote server		 * and `status` contains the reason given.		 "		LGitPushUpdateReferenceCallback push_update_reference;		"		 * Called once between the negotiation step and the upload. It		 * provides information about what updates will be performed.		 "		LGitPushNegotiationCallback push_negotiation;		"		 * Create the transport to use for this operation. Leave NULL		 * to auto-detect.		 "		LGitTransport transport;		"		 * This will be passed to each of the callbacks in this struct		 * as the last parameter.		 "		void *payload;	)! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!newCertificateCheckCallback	self flag: #fixMe. "I need to skip the verification of certificate because on macOS, 	libgit2 has problems to be compiled with Secure framework, and if compiled with 	openssl instead, openssl for macOS does not checks agains the certificates installed 	at S.O., so it will fail almost always. This is, of course, a workaround... eventually 	libgit2 will work :P"	^ LGitTransportCertificateCheckCallback on: [ :cert :value :host :payload  |		1 ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!newCredentialsCallbackFor: provider	^ LGitCredAcquireCallback		on: [ :output :url :username_from_url :allowed_types :data | 			"Allowed types are defined in git_credtype_t 		https://github.com/libgit2/libgit2/blob/HEAD/include/git2/transport.h#L81-111"			self				putCredentialsType: allowed_types				username: username_from_url				provider: provider				onto: output ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!putCredentialsType: types username: username provider: provider onto: output  	(types anyMask: 1 << 0) ifTrue: [ 		^ LGitCredentialsPlaintext createFrom: provider onto: output ].	(types anyMask: 1 << 1) ifTrue: [ 		^ provider sshCredentialsClass 			createFrom: provider 			username: username			onto: output ].	Transcript logCr: ('I can''t create credentials for type: {1}' format: {types}).	^ -1! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withProvider: provider	^ LGitRemoteCallbacks defaults		credentials: (self newCredentialsCallbackFor: provider);		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!certificateCheck: aCallback	certificateCheckCallback := aCallback.	self prim_certificate_check: aCallback! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!credentials	^ self prim_credentials! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!credentials: aCredentialsCallback	credentialsCallback := aCredentialsCallback.	self prim_credentials: credentialsCallback! !!LGitRemoteCallbacks methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			remote_init_callbacks: self			version: LGitStructVersionsEnum git_remote_callbacks_version_1 ]! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_completion	"This method was automatically generated"	^LGitCompletionCallback forAddress: ((handle pointerAt: OFFSET_PRIM_COMPLETION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_completion: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_COMPLETION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pack_progress	"This method was automatically generated"	^LGitPackbuilderProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PACK_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pack_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PACK_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_negotiation	"This method was automatically generated"	^LGitPushNegotiationCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_negotiation: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_transfer_progress	"This method was automatically generated"	^LGitPushTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_update_reference	"This method was automatically generated"	^LGitPushUpdateReferenceCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_update_reference: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_sideband_progress	"This method was automatically generated"	^LGitTransportMessageCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_sideband_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transfer_progress	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transport	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TRANSPORT) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transport: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TRANSPORT put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_tips	"This method was automatically generated"	^LGitUpdateTipsCallback forAddress: ((handle pointerAt: OFFSET_PRIM_UPDATE_TIPS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_tips: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_UPDATE_TIPS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitStructVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitRemoteCallbacks methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_init_callbacks: opts version: version 	^ self		call: #(LGitReturnCodeEnum git_remote_init_callbacks(LGitRemoteCallbacks * self, LGitStructVersionsEnum version))		options: #(  )! !!LGitStructWithDefaults class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!defaults	^ self externalNew		initializeWithDefaults;		yourself! !!LGitStructWithDefaults methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initialize	super initialize.		"Options are only ever used during a single setup function call.	The contents of the struct are then copied to a libgit2 internal	struct."	self autoRelease! !!LGitStructWithDefaults methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self subclassResponsibility! !!LGitTime class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	int64 time;	int offset;	)! !!LGitTime class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromDateAndTime: aDateAndTime	^ self new 		time: aDateAndTime asUnixTime;		offset: aDateAndTime offset asMinutes asInteger;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self time = anObject time				and: [  self offset = anObject offset ] ] ]! !!LGitTime methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asDateAndTime	^ (DateAndTime fromUnixTime: self time) 		offset: self offset;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ (super hash bitXor: self time) bitXor: self offset! !!LGitTime methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self asDateAndTime printOn: aStream! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!offset	^ self prim_offset! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!offset: anInteger	self prim_offset: anInteger! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_offset	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OFFSET! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_offset: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OFFSET put: anObject! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_time	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_TIME! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_time: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_TIME put: anObject! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!time	^ self prim_time! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!time: anInteger	^ self prim_time: anInteger! !!LGitTransferProgress class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	uint total_objects;	uint indexed_objects;	uint received_objects;	uint local_objects;	uint total_deltas;	uint indexed_deltas;	size_t received_bytes;	)! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_bytes	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_bytes: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS put: anObject! !!LGitSafeFFICalloutAPI methodsFor: 'action' stamp: ' 7/21/2017 17:44:56'!newBuilder	^ LGitSafeFFICalloutMethodBuilder calloutAPI: self! !!String methodsFor: '*libgit-core' stamp: ' 7/21/2017 17:44:56'!asLGitExternalString	| data |	data := ExternalData		fromHandle: (ExternalAddress allocate: self size + 1)		type: ExternalType char asPointerType.	LibC memCopy: self to: data size: self size.	data getHandle byteAt: self size + 1 put: 0.	^ data! !!LGitCredentialsFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!credentials: credentials	^ self		call: #(void #(LGitCredentials * credentials))		options: #(optMayGC)! !!LGitWritepackAppendCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!writepack: writepack buffer: buffer length: length progress: progress		^ self		call:			#(int #(LGitOdbWritepack * writepack , void * buffer , int length , LGitTransferProgress * progress))		options: #(optMayGC)! !!LGitWritepackCommitCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!writepack: writepack progress: progress	^ self		call: #(int #(LGitOdbWritepack *writepack , LGitTransferProgress *progress))		options: #(optMayGC)! !!LGitWritepackFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!writepack: writepack	^ self call: #(void #(LGitOdbWritepack *writepack)) options: #()! !!LGitExternalObject class methodsFor: 'finalization' stamp: ' 7/21/2017 17:44:56'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalObject class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #object_free:! !!LGitExternalObject class methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!fromHandle: aHandle	^self basicNew setHandle: aHandle! !!LGitExternalObject class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_free: handle 	"We pass a handle in here instead of the object. We can't pass the object since that	has already been gc'ed."	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitExternalObject methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isReady	^ self isNull not! !!LGitExternalObject methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!shouldContinuePrintingOn: aStream	self ifNotReady: [ aStream nextPutAll: ' (<not initialized>)' ].		^ self isReady! !!LGitOdb class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #odb_free:! !!LGitOdb class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!odb_free: handle		^ self call: #(void git_odb_free #(void *handle)) options: #()! !!LGitPackBuilder class methodsFor: 'native-boost' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #packbuilder_free:! !!LGitPackBuilder class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_free: handle		^ self		call: #(void git_packbuilder_free #(void *handle))		options: #()! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_foreach: pb cb: cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_foreach #(self , LGitPackbuilderForeachCallback cb ,  void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_insert_commit: pb id: id		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_insert_commit #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_insert_tree: pb id: id		^ self		call: #(LGitReturnCodeEnum git_packbuilder_insert_tree #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_packbuilder_new #(LGitPackBuilder * self , LGitRepository repo))		options: #()! !!LGitRepository class methodsFor: 'native-boost' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #repository_free:! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!new	self error: 'This class should be instantiated with a give path.'! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!on: aFileReference	LGitGlobal checkInitialized.	^ self basicNew		initialize;		initializeOn: aFileReference! !!LGitRepository class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_free: handle		^ self call: #(void git_repository_free #(void *handle)) options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!addRemote: aName url: anUrl	(LGitRemote of: self named: aName url: anUrl) createWithoutSpec! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!allBranches	^ OrderedCollection new: 10 streamContents: [ :stream |		self allBranchesDo: [ :reference | 			stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!allBranchesDo: aBlock	LGitBranchIterator allBranchesOf: self do: aBlock! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!allRemotes	| out |		out := LGitStringArray externalNew autoRelease.	self remote_list: out.	^ out strings collect: [ :each | (LGitRemote of: self named: each) lookup ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!beOpen	isOpen := true! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!branchNames	^ self branches collect: #name! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_lookup: out branch_name: branch_name branch_type: branch_type		^ self		call:			#(LGitReturnCodeEnum git_branch_lookup #(LGitReference * out , self , String branch_name , LGitBranchTypeEnum branch_type))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!branches	^ OrderedCollection new: 10 streamContents: [ :stream |		self branchesDo: [ :reference | stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!branchesDo: aBlock	LGitBranchIterator localBranchesOf: self do: aBlock.! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkout: aString	<todo: 'use proper exceptions'>	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	[ 		| branch |		branch := self lookupLocalBranch: aString ifAbsent: [ self createBranchFromOrigin: aString ].		self checkout_treeish: branch object.		self setHead: branch.	] 	on: LGit_GIT_EINVALIDSPEC, LGit_GIT_ENOTFOUND do: [		"aString is not a valid branch name, so try to find a corresponding treeish using revparse, 		this will handle stuff like 'master~1'"		| commitish | 		commitish := self revparse: aString.		self checkout_treeish: commitish.		self setHeadDetached: commitish.	].! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkoutHead	self withReturnHandlerDo: [ 		self checkout_head_opts: (			LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;				yourself) ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_head_opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_head #(self , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_treeish: treeish	"treeish can be a commit, tag or tree (or NULL to use HEAD)"	self withReturnHandlerDo: [ 		self			checkout_treeish: treeish			opts:				(LGitCheckoutOptions defaults					checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;					yourself) ].! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_treeish: treeish opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_tree #(self , LGitObject treeish , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!clone: aString	| cloneOptions |	cloneOptions := LGitCloneOptions defaults.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone: aString options: cloneOptions	self		clone: aString		options: cloneOptions		to: self repositoryReference! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone: aString options: cloneOptions to: aFileReference	<todo: 'use exceptions instead of assertion'>	self assert: aString isEmptyOrNil not.	self assert: aFileReference notNil.	self assert: cloneOptions notNil.		aFileReference ensureCreateDirectory.		self withReturnHandlerDo: [ 		self 			clone: self			url: aString			local_path: aFileReference pathString			options: cloneOptions ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone: out url: url local_path: local_path options: options		^ self		callUnchecked:			#(LGitReturnCodeEnum git_clone (LGitRepository *out, String url, String local_path, LGitCloneOptions *options))		options: #(optCoerceNilToNull)! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!clone: aString withCredentials: aCredentialsProvider 	| cloneOptions |	cloneOptions := LGitCloneOptions withCredentialsProvider: aCredentialsProvider.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneHttps: aString	<todo: 'use exceptions instead of assertion'>	self assert: (aString beginsWith: 'https://').		self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneLocal: aString	self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneRemote: aRemote signature: aSignature	self		cloneRemote: aRemote		signature: aSignature		branch: 'master'! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneRemote: aRemote signature: aSignature branch: aString	self		cloneRemote: aRemote		signature: aSignature		branch: aString		checkoutOptions: LGitCheckoutOptions defaults! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneRemote: aRemote  signature: aSignature branch: aString checkoutOptions: options	<todo: 'use exceptions instead of assertions'>	self assert: aRemote hasFetchSpec.		self withReturnHandlerDo: [		self 			clone_into: self			remote: aRemote			co_opts: options			branch: aString			signature: aSignature ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneSsh: aString	| credentials cloneOptions |	credentials := LGitRemote credentialsSsh.	cloneOptions := LGitCloneOptions withCredentialsCallback: 		[ :cred :url :username_from_url :allowed_types :data | 			allowed_types = 32 				ifTrue: [ credentials setGitUsernameIn: cred ]				ifFalse: [ credentials createWith: cred ].			0 		].		self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!config	| config |	config := (LGitConfig of: self) autoRelease.	self withReturnHandlerDo: [ self repository_config: config ].	^ config! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!create	self exists ifTrue: [ ^ self ].		self repositoryReference ensureCreateDirectory! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString force: aBoolean	<todo: 'this method belongs somewhere else and should allow to specify the target'>	| reference |	reference := LGitReference of: self.	reference createSymbolic: 'refs/heads/' , aString target: 'refs/dummy' force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString target: aGitReference	<todo: 'this method belongs somewhere else'>	^ self createBranch: aString target: aGitReference force: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString target: aGitReference force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference 		createDirect: 'refs/heads/' , aString 		target: aGitReference object id 		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString targetId: aGitId force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference createDirect: 'refs/heads/' , aString target: aGitId force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranchFromOrigin: branchName	| remoteBranchName remoteBranch localBranch |	remoteBranchName := 'origin/', branchName.	remoteBranch := self lookupRemoteBranch: remoteBranchName.	localBranch := self createBranch: branchName target: remoteBranch.	localBranch setUpstream: remoteBranchName.	^ localBranch! !!LGitRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createPackForReference: aReference	| odb walk packbuilder writepack stats packbuilderPayload progresscb packbuilderCallback |	odb := self database.	walk := (LGitRevwalk of: self)		beSortedByCommitTime;		pushReference: aReference;		yourself.	packbuilder := LGitPackBuilder new.	packbuilder packbuilder_new: packbuilder repo: self.	"hideCallback := LG2RevwalkHideCb on: [ :oid :payload |  ].	LG2RevwalkH uniqueInstance		revwalk_add_hide_cb: walk		hide_cb: hideCallback		payload: nil."	[ walk hasNext ] whileTrue: [ 		| commit tree |		commit := walk next.		tree := commit tree.		packbuilder			packbuilder_insert_commit: packbuilder id: commit id;			packbuilder_insert_tree: packbuilder id: tree id.		commit free.		tree free ].	progresscb := LGitTransferProgressCallback on: [ :progress :data | 0 ].	writepack := LGitOdbWritepack externalNew.	writepack		odb_write_pack: writepack		db: odb		progress_cb: progresscb		progress_payload: ExternalAddress null.	writepack := LGitOdbWritepack fromHandle: writepack getHandle pointer.	stats := LGitTransferProgress externalNew.	packbuilderPayload := LGitPackbuilderForeachPayload externalNew.	packbuilderCallback := LGitPackbuilderForeachCallback		on: [ :buffer :length :payload | payload writepack appendWithBuffer: buffer length: length progress: payload stats ].	packbuilderPayload		writepack: writepack;		stats: stats.	packbuilder packbuilder_foreach: packbuilder cb: packbuilderCallback payload: packbuilderPayload.	writepack commitWithProgress: stats! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createTag: aString targetId: aGitId force: aBoolean	"Create a tag. Based on #createBranch:targetId:force:"	| reference |	reference := LGitReference of: self.	reference		createDirect: 'refs/tags/', aString		target: aGitId		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!database	| database |	database := LGitOdb new.	self withReturnHandlerDo: [		self			repository_odb: database			repo: self ].			^ database! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!defaultSignature	| signaturePointer |	signaturePointer := ExternalAddress new.	self withReturnHandlerDo: [ self signature_default: signaturePointer repo: self ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!deleteAllLooseObjectsForReference: aReference	(self repositoryReference / '.git' / 'objects') children		select: [ :entry | entry basename ~= 'pack' ]		thenDo: [ :entry | entry deleteAll ].		"raise an exception if not resolvable"	self head	"	| walker oid baseReference |	walker := LGitRevwalkType new.	LG2RevwalkH uniqueInstance		revwalk_new: walker		repo: self.	LG2RevwalkH uniqueInstance		revwalk_sorting: walker		sort_mode: 2.	LG2RevwalkH uniqueInstance		revwalk_push_ref: walker		refname: aReference name.	baseReference := aReference repository repositoryReference / '.git' / 'objects'.	oid := LGitId new.	[ (LG2RevwalkH uniqueInstance		revwalk_next: oid		walk: walker) isZero ] whileTrue: [			| fileReference |			fileReference := baseReference resolve: oid asRelativePathString.			fileReference delete.			fileReference parent hasChildren ifFalse: [ fileReference parent delete ] ]"! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!exists	^ self repositoryReference exists! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fastForward	<todo: 'check for conflicts'>	"currently forces fastForward in every case"	self head resolve setTarget: (self lookup: 'FETCH_HEAD')! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchFrom: remoteName 	(LGitRemote of: self named: remoteName) 		lookup; 		fetch! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!head	| head |	head := LGitReference of: self.	self withReturnHandlerDo: [ self repository_head: head of: self ].	^ head! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!index	| index |	index := LGitIndex of: self.	self withReturnHandlerDo: [ self repository_index: index repo: self ].	^ index! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!init	self initBare: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initBare: aBoolean	self withReturnHandlerDo: [		self			repository_init: self			path: self repositoryReference pathString			is_bare: aBoolean ].	self autoRelease ! !!LGitRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeOn: aFileReference	repositoryPath := aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBare	^ self repository_is_bare: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isDirty: aFileReference	^ self index isDirty: aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isEmpty	self exists ifFalse: [ ^ true ].		^ self repository_is_empty: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isInitialized	^ self isReady! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isOpen	^ isOpen ifNil: [ false ]! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isProperRepository	| return |	return := self		repository_open_ext: self		path: self repositoryReference pathString		flags: LGitOpenFlagEnum git_repository_open_no_search		ceiling_dirs: nil.			^ return isOk! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isUnborn	^ self repository_is_unborn: self! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookup: name	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [		self			reference_lookup: reference			repo: self			shorthand: name ].			^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupBranch: name	^ (name includes: $/)		ifTrue: [ self lookupRemoteBranch: (name withoutPrefix: 'refs/remotes/') ]		ifFalse: [ self lookupLocalBranch: name ] ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupBranch: branchName inRemote: remoteName	^ self lookupRemoteBranch: remoteName, '/', branchName! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupBranch: name type: branchType	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [ 		self			branch_lookup: reference			branch_name: name			branch_type: branchType	].	^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupLocalBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_local ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupLocalBranch: name ifAbsent: aBlock	^ [ self lookupLocalBranch: name ]		on: LGit_GIT_ENOTFOUND 		do: aBlock ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupRemoteBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_remote! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!merge: aLGitAnnotatedCommit 	| heads |	heads := (FFIExternalArray externalNewType: LGitAnnotatedCommit size: 1) autoRelease;		at: 1 put: aLGitAnnotatedCommit handle;		yourself.	self withReturnHandlerDo: [		self merge_heads: heads 			length: 1 			merge_options: LGitMergeOptions defaults			checkout_options: LGitCheckoutOptions defaults 	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!mergeBaseBetween: aLGitId and: aLGitId2 	| base |	base := LGitId new.	self withReturnHandlerDo: [ self merge_base: base between: aLGitId and: aLGitId2 ].	^ base! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_base: out between: one and: two	^ self call: #(	LGitReturnCodeEnum git_merge_base #(			LGitId * out, 			self, 			LGitId * one, 			LGitId * two))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_heads: heads length: length merge_options: mergeOptions checkout_options: checkoutOptions		^ self		callUnchecked:			#(LGitReturnCodeEnum git_merge #(				self , 				FFIExternalArray heads ,				int length , 				LGitMergeOptions * mergeOptions ,				LGitCheckoutOptions * checkoutOptions))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!new_signature: out name:name email:email time:time		^ self		call:			#(LGitReturnCodeEnum git_signature_new #(void **out , String name, String email, LGitTime time, 0))		options: #()! !!LGitRepository methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self repositoryReference fullName.	self isBare 		ifTrue: [ aStream nextPutAll: ' [bare]' ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!open	self withReturnHandlerDo: [ 		self			repository_open: self			bare_path: self repositoryReference pathString ].	self beOpen! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!origin	^ (LGitRemote of: self named: 'origin') lookup; yourself! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!packHead	<todo: 'This method is distructive. It will delete *all* objects, including those not in the pack (not reachable from head'>	"USE VERY CAREFULLY"		LGitGlobal runSequence: [ self createPackForReference: self head ].	self deleteAllLooseObjectsForReference: self head! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_lookup: out repo: repo shorthand: shorthand		^ self		call:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * out , self , String shorthand))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!references	self notYetImplemented! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_list: out	^ self 		call: #( int git_remote_list ( LGitStringArray *out, self ) ) 		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!repositoryReference	^ repositoryPath! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_config: config	^ self		call:			#(LGitReturnCodeEnum git_repository_config(LGitConfig *config, self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_head: reference of: repository		^ self		call:			#(LGitReturnCodeEnum git_repository_head #(LGitReference * reference , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_index: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_index #(LGitIndex * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_init: out path: path is_bare: is_bare		^ self		callUnchecked:			#(int git_repository_init #(LGitRepository * out , String path , Boolean is_bare))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_is_bare: repo		^ self call: #(Boolean git_repository_is_bare #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_is_empty: repo		^ self call: #(Boolean git_repository_is_empty #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_is_unborn: repo	^ self call: #( Boolean git_repository_head_unborn (self) ) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_odb: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_odb #(LGitOdb * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_open: out bare_path: bare_path		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open #(LGitRepository * out , String bare_path))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_open_ext: out path: path flags: flags ceiling_dirs: ceiling_dirs		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open_ext #(LGitRepository * out , String path , LGitOpenFlagEnum flags , String ceiling_dirs))		options: #(optCoerceNilToNull optStringOrNull)! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_set_head: refname log_message: log_message		^ self		call:			#(int git_repository_set_head #(self , String refname , String log_message))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_set_head_detached: commitish		^ self		call:			#(int git_repository_set_head_detached #(self, LGitId * commitish))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_workdir: repo		^ self call: #(String git_repository_workdir #(self)) options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!revparse: aString	"See git-rev-parse documentation.	Examples:		repository revparse: 'HEAD' 	# last commit		repository revparse: 'HEAD~5'	# 5 commits back from last commit		repository revparse: 'develop'	# last commit from develop branch	"	| object |	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	object := LGitObject of: self.	self withReturnHandlerDo: [ 		self			revparse_single: object			repo: self			spec: aString ].	^ object concreteObject	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revparse_single: out repo: repo spec: spec		^ self		call:			#(LGitReturnCodeEnum git_revparse_single #(LGitObject * out , self , String spec))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setHead: aLGitReference	self withReturnHandlerDo: [ 		self			repository_set_head: aLGitReference name			log_message: 'set head to refs/heads/' , aLGitReference name ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setHeadDetached: commitish	self withReturnHandlerDo: [ 		self repository_set_head_detached: commitish id	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!signatureWithName: name email: email dateTime: dateTime	| signaturePointer time |	signaturePointer := ExternalAddress new.	time := LGitTime fromDateAndTime: dateTime.	self		withReturnHandlerDo: [ self				new_signature: signaturePointer				name: name				email: email				time: time ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!signature_default: out repo: repo		^ self		call:			#(LGitReturnCodeEnum git_signature_default #(void **out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_list: tag_names repo: repo		^ self		call:			#(LGitReturnCodeEnum git_tag_list #(LGitStringArray * tag_names , LGitRepository repo))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tags	| array strings |	array := LGitStringArray externalNew.	self withReturnHandlerDo: [		self			tag_list: array			repo: self ].	strings := array strings.	array free.	^ strings	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!workingDirectory	^ workingDirectory ifNil: [			workingDirectory := self withReturnHandlerDo: [				(self repository_workdir: self) asFileReference ] ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!workingDirectoryName	^ self isBare			ifTrue: [ nil ]			ifFalse: [ self workingDirectory basename ]! !!LGitAnnotatedCommit class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!annotated_commit_free: handle	^ self		call: #(void git_annotated_commit_free #(void *handle))		options: #()! !!LGitAnnotatedCommit class methodsFor: 'ligbit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #annotated_commit_free:! !!LGitAnnotatedCommit class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromRef: anLGitReference	^ (self of: anLGitReference repository) initializeFromRef: anLGitReference ! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/21/2017 17:44:56'!annotated_commit_from_ref: ref	^ self callUnchecked: #(		int git_annotated_commit_from_ref #(			LGitAnnotatedCommit * self , 			LGitRepository repository ,			LGitReference ref)) 		options: #()! !!LGitAnnotatedCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!annotated_commit_id	 ^ self call: #(LGitId * git_annotated_commit_id #(self)) options: #()! !!LGitAnnotatedCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!id	^ self annotated_commit_id! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/21/2017 17:44:56'!initializeFromRef: anLGitReference	self withReturnHandlerDo: [ 		self annotated_commit_from_ref: anLGitReference	].	self autoRelease! !!LGitBlame class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_free: handle	^ self call: #(void git_blame_free #(void *handle)) options: #()! !!LGitBlame class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #blame_free:! !!LGitBlame class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository on: aFileReference	^ (self of: aRepository)		getForReference: aFileReference;		yourself! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_buffer: out reference: reference buffer: buffer buffer_len: buffer_len		^ self		callUnchecked:			#(FFIInt32 git_blame_buffer #(LGitBlame *self , LGitBlame reference , String buffer , size_t buffer_len))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_file: out repo: repo path: path options: options		^ self		callUnchecked:			#(int git_blame_file #(LGitBlame * self , LGitRepository repo , String path , LGitBlameOptions * options))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_get_hunk_byindex: blame index: index	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byindex #(self , uint32 index))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_get_hunk_byline: blame lineno: lineno	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byline #(self , size_t lineno))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_get_hunk_count: blame		^ self		call: #(uint32 git_blame_get_hunk_count #(self))		options: #()! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!getForReference: aFileReference	^ self withReturnHandlerDo: [		self			blame_file: self			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/)			options: LGitBlameOptions defaults ]! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hunkAt: anInteger	"use 1 based offset"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byindex: self			index: anInteger - 1)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hunkAtLineNumber: anInteger	"first line has index 1"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byline: self			lineno: anInteger)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!numberOfHunks	^ self blame_get_hunk_count: self! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!allBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_all		do: aBlock! !!LGitBranchIterator class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_iterator_free: handle		^ self		call: #(void git_branch_iterator_free #(void *handle))		options: #()! !!LGitBranchIterator class methodsFor: 'native-boost' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #branch_iterator_free:! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!localBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_local		do: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository branchType: aLGitBranchTypeEnum do: aBlock	^ (self of: aRepository)		iterate: aLGitBranchTypeEnum;		branchesDo: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!remoteBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_remote		do: aBlock! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_iterator_new: out repo: repo list_flags: list_flags		^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_iterator_new #(LGitBranchIterator * self , LGitRepository repo , LGitBranchTypeEnum list_flags))		options: #()! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_next: out out_type: out_type	^ self		call:			#(LGitReturnCodeEnum git_branch_next #(				LGitReference * out ,				LGitWriteBackValueUInt * out_type,				LGitBranchIterator self))		options: #()! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!branchesDo: aBlock	| returnCode branchType reference finishedCode isLocal |		returnCode := LGitReturnCodeEnum git_ok.	finishedCode := LGitReturnCodeEnum git_iterover.	branchType := LGitWriteBackValueUInt new.		[ 		reference := LGitReference of: self repository.		returnCode := self branch_next: reference out_type: branchType.		isLocal := branchType value = LGitBranchTypeEnum git_branch_local value.		returnCode = finishedCode 	] 	whileFalse: [ aBlock cull: reference cull: isLocal ]! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!iterate: aLGitBranchTypeEnum	self repository signalIfNotReady.	self withReturnHandlerDo: [		self			branch_iterator_new: self			repo: self repository			list_flags: aLGitBranchTypeEnum ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!author	^ author ifNil: [		author := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!author: anLGitSignature	author := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!commitId	^ commitId ifNil: [ commitId := LGitId new ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!commitId: anLGitId	commitId := anLGitId! !!LGitCommitBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_create: theCommitId repo: repo update_ref: update_ref author: theAuthor committer: theCommitter message_encoding: message_encoding message: theMessage tree: theTree parent_count: parent_count parents: parentsPointer		<todo:		'try to use original function signature instead of passing ExternalAddress as last arg'>	^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_create #(LGitId * theCommitId , LGitRepository repo , String update_ref , LGitSignature * theAuthor , LGitSignature * theCommitter , String message_encoding , String theMessage , LGitTree theTree , int parent_count , void *parentsPointer))		options: #(optCoerceNilToNull)! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committer	^ committer ifNil: [ 		committer := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committer: anLGitSignature	committer := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message	^ message ifNil: [ message := 'empty message' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message: aString	message := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!messageEncoding	^ messageEncoding ifNil: [ 'UTF-8' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!messageEncoding: aString	messageEncoding := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!parents	^ parents ifNil: [ parents := #() ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!parents: aCollection	parents := aCollection! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tree	<todo: 'use proper exceptions'>	^ tree ifNil: [ self error: 'need an existing tree here' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tree: anLGitTree	tree := anLGitTree! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!updateReference	^ updateReference! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!updateReference: aReference	updateReference := aReference! !!LGitCommitBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!writeCommit	| parentsPointer |	self withReturnHandlerDo: [ 		self assert: (self parents allSatisfy: #isReady).		parentsPointer := self parents			ifEmpty: [ ExternalAddress null ]			ifNotEmpty: [ (LGitExternalCommitArray fromCollection: self parents) getHandle ].	self withReturnHandlerDo: [ 		self			commit_create: self commitId			"libgit2 asserts the identity of this repository and the one it retrieves for the tree, so they need to be the same here"			repo: self tree owner 			update_ref: self updateReference			author: self author			committer: self committer			message_encoding: self messageEncoding			message: self message withUnixLineEndings			tree: self tree			parent_count: self parents size			parents: parentsPointer] ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!writtenCommit	<todo: 'use proper exceptions'>	commitId ifNil: [ self error: 'haven''t written the commit yet!!' ].	^ LGitCommit of: self repository fromId: self commitId! !!LGitConfig class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_free: handle	^ self		call: #(void git_config_free #(void *handle))		options: #()! !!LGitConfig class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #config_free:! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_get_string: name output: output	^ self call:			#(LGitReturnCodeEnum git_config_get_string_buf(				LGitBuf* output, 				self, 				String name))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_open_global: out	^ self call: #(int git_config_open_global("LGitConfig **"void **out, self))! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_set_bool: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_bool(				self, 				String name, 				Boolean value))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_set_string: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_string(				self, 				String name, 				String value))		options: #()! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!getString: name ifAbsent: aBlock	^ self getString: name ifPresent: #yourself ifAbsent: aBlock! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!getString: name ifPresent: presentBlock ifAbsent: absentBlock	| buf |	buf := LGitBuf new.	^ [		self config_get_string: name output: buf.		buf prim_ptr readString 			ifNotEmpty: presentBlock			ifEmpty: absentBlock	]	ensure: [ buf free ]! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!openGlobal	| outHandle |	outHandle := ExternalAddress null.	self config_open_global: outHandle.	^ (self class fromHandle: outHandle) autoRelease	! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!setBoolean: aBoolean to: varName! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!setString: name to: value	self config_set_string: name to: value! !!LGitDiff class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_free: handle		^ self call: #(void git_diff_free #(void *handle)) options: #()! !!LGitDiff class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #diff_free:! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!deltaAt: anInteger	"use 1 based offset as in Smalltalk"	^ LGitDiffDelta fromHandle: (		self			diff_get_delta: self			idx: anInteger - 1) getHandle! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffIndexToWorkDir	self diffIndexToWorkDirOptions: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffIndexToWorkDirOptions: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_index_to_workdir: self			repo: self repository			index: self repository index			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffTree: oldTree toTree: newTree	self		diffTree: oldTree		toTree: newTree		options: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffTree: oldTree toTree: newTree options: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_tree_to_tree: self			repo: self repository			old_tree: oldTree			new_tree: newTree			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_blob_to_buffer: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blob_to_buffer #(LGitBlob old_blob , String old_as_path , String buffer , size_t buffer_len , String buffer_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_blobs: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blobs (LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions *options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_buffers: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_buffers #(FFIVoid * old_buffer , size_t old_len , String old_as_path , void *new_buffer , size_t new_len , String new_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_foreach: diff file_cb: file_cb binary_cb: binary_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_foreach #(self , LGitDiffFileCallback file_cb , LGitDiffBinaryCallback binary_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_get_delta: diff idx: idx	<todo: 'use LGitDiffDelta* as return type'>		^ self		call: #(void *git_diff_get_delta #(self , size_t idx))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_get_perfdata: out diff: diff		^ self		call:			#(LGitReturnCodeEnum git_diff_get_perfdata #(LGitDiffPerfData * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_get_stats: out diff: diff		^ self		call: #(LGitReturnCodeEnum git_diff_get_stats #(LGitDiffStats * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_index_to_workdir: diff repo: repo index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_index_to_workdir #(LGitDiff * self , LGitRepository repo , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_is_sorted_icase: diff		^ self call: #(Boolean git_diff_is_sorted_icase #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_num_deltas: diff		^ self call: #(size_t git_diff_num_deltas #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_num_deltas_of_type: diff type: type		^ self		call: #(size_t git_diff_num_deltas_of_type #(self , LGitDeltaTypeEnum type))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_print: diff format: format print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_print #(self , LGitDiffFormatTypeEnum format , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_status_char: status		^ self		call: #(Character git_diff_status_char #(LGitDeltaTypeEnum status))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_index: diff repo: repo old_tree: old_tree index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_tree: diff repo: repo old_tree: old_tree new_tree: new_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_tree #(LGitDiff * diff , LGitRepository repo , LGitTree old_tree , LGitTree new_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_workdir: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_workdir_with_index: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir_with_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!filesDo: filesBlockOrNil binaryFilesDo: binaryBlockOrNil hunksDo: hunksBlockOrNil linesDo: linesBlockOrNil	^ self		diff_foreach: self		file_cb: (filesBlockOrNil 			ifNotNil: [ LGitDiffFileCallback on: filesBlockOrNil ]			ifNil: [ LGitCallback null ])		binary_cb: (binaryBlockOrNil 			ifNotNil: [ 	LGitDiffBinaryCallback on: binaryBlockOrNil ]			ifNil: [ LGitCallback null ])		hunk_cb: (hunksBlockOrNil 			ifNotNil: [ 	LGitDiffHunkCallback on: hunksBlockOrNil ]			ifNil: [ LGitCallback null ])		line_cb: (linesBlockOrNil 			ifNotNil: [ 	LGitDiffLineCallback on: linesBlockOrNil ]			ifNil: [ LGitCallback null ])		payload: ExternalAddress null! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!numberOfDeltas	^ self diff_num_deltas: self! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!patchAt: anInteger	^ LGitPatch		fromDiff: self		at: anInteger! !!LGitDiffStats class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_free: handle		^ self call: #(void git_diff_stats_free #(void *handle)) options: #()! !!LGitDiffStats class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #diff_stats_free:! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_deletions: stats		^ self		call: #(size_t git_diff_stats_deletions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_files_changed: stats		^ self		call: #(size_t git_diff_stats_files_changed #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_insertions: stats		^ self		call: #(size_t git_diff_stats_insertions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_to_buf: out stats: stats format: format width: width		^ self		call:			#(LGitReturnCodeEnum git_diff_stats_to_buf #(LGitBuffer out , self , LGitDiffStatsFormatTypeEnum format , size_t width))		options: #()! !!LGitIndex class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #index_free:! !!LGitIndex class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_free: handle		^ self call: #(void git_index_free #(void *handle)) options: #()! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addAll: pathSpecs	| pathspec |	pathspec := LGitStringArray withAll: pathSpecs.	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!allFilesStatusDo: aBlock	"The callback is passed the path of the file, the status (a combination of the git_status_t values above) and the payload data pointer passed into this function.If the callback returns a non-zero value, this function will stop looping and return that value to caller."	self withReturnHandlerDo: [ 		self			status_foreach: self repository			callback: (LGitStatusCallback on: aBlock)			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkout	self withReturnHandlerDo: [ 		self checkout_index_withOptions: 			(LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;				yourself) ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_index_withOptions: opts	^ self		call: #(LGitReturnCodeEnum 			git_checkout_index(				LGitRepository repository, 				self, 				LGitCheckoutOptions *opts))		options: #()! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!entriesSelect: aBlock	| entries |	entries := OrderedCollection new.	self allFilesStatusDo: [ :path :status :payload |		(aBlock value: path value: status) ifTrue: [ entries add: {path. status. payload} ].		0 ].		^ entries! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!entryCount	^ self index_entrycount: self! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!forceRefresh	self withReturnHandlerDo: [ 		self			index_read: self			force: true ]! !!LGitIndex methodsFor: 'hack' stamp: ' 7/21/2017 17:44:56'!hackOwner: aRepository	"There is a bug in version 0.23 of libgit2, the returned index does not have an 	 owner (a pointer to a repository), as you would expect from the documentation. 	This breaks libgit encapsulation, and will probably fail if updating to a newer 	version, but anyway if we migrate this bug should be fixed."	self flag: #fixMe. "When possible :)"	"	NOTE: is Smalltalk wordSize + 1 because the structure is something like: 	struct git_index {		git_refcount rc; 		...	}		then:		struct git_refcount { 		git_atomic refcount;		void *owner;	}		and finally: 	git_atomic = int -> 32bits	git_atomic = int64_t -> 64bits		So we need to ensure the owner is set properly.	"	self handle 		pointerAt: Smalltalk wordSize + 1		put: repository handle! !!LGitIndex methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasConflicts	^ self index_has_conflicts asBoolean! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hasEntry: aString	^ self withReturnHandlerDo: [ 		self			index_find: nil			index: self			path: aString ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_add_all: index pathspec: pathspec flags: flags callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_add_all #(				self, 				LGitStringArray *pathspec, 				uint flags, 				LGitIndexMatchedPathCallback callback, 				void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_entrycount: index		^ self call: #(size_t git_index_entrycount #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_find: at_pos index: index path: path		^ self		call:			#(LGitReturnCodeEnum git_index_find #(LGitWriteBackValueSizeT *at_pos , self, String path))		options: #(optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_has_conflicts 	^ self call: #(LGitReturnCodeEnum git_index_has_conflicts #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_owner	^ self call: #(LGitRepository * git_index_owner (LGitIndex self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_path	^ self		call: #(String git_index_path #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_read: index force: force		^ self		call: #(LGitReturnCodeEnum git_index_read #(self , Boolean force))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_remove_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_remove_all #(self, LGitStringArray * pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_update_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_update_all #(self, LGitStringArray *pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_write	^ self		call: #(LGitReturnCodeEnum git_index_write #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_write_tree: out index: index		^ self		call: #(LGitReturnCodeEnum git_index_write_tree #(LGitId * out , self))		options: #()! !!LGitIndex methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBeingTracked: aString	| intValue |	(self repository repositoryReference resolve: aString) isDirectory ifTrue: [ ^ true ].		intValue := LGitWriteBackValueUInt new.	self withReturnHandlerDo: [ 		self			status_file: intValue			repo: self repository			path: aString ].	^ (LGitStatusTypeEnum  git_status_wt_new isPartOfBitFlag: intValue value) not! !!LGitIndex methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isDirty: aFileReference	| intValue |	intValue := LGitWriteBackValueInt new.	self withReturnHandlerDo: [		self			status_file: intValue			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/) ].			^ intValue value isZero not! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self index_owner! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!path	^ self index_path! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!removeAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_remove_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_file: status_flags repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_status_file #(LGitWriteBackValueUInt status_flags, LGitRepository repo, String path))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_foreach: repo callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_status_foreach #(LGitRepository repo, LGitStatusCallback callback, void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!updateAll	| pathspec |	pathspec := LGitStringArray withAll: { '*' }.	self withReturnHandlerDo: [ 		self			index_update_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!writeToDisk	self withReturnHandlerDo: [ self index_write ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!writeTreeAndReturnOid	| oid |	oid := LGitId externalNew.	self withReturnHandlerDo: [ 		self			index_write_tree: oid			index: self ].			^ oid! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_create_frombuffer: objectId repo: repo buffer: buffer len: len		^ self		call:			#(LGitReturnCodeEnum git_blob_create_frombuffer #(LGitId * objectId , LGitRepository repo , void  *buffer , size_t len))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_create_fromdisk: objectId repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_blob_create_fromdisk #(LGitId * objectId , LGitRepository repo , FFIExternalString path))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_free: handle		^ self		call: 	#(void git_blob_free(void *handle))		options: #()! !!LGitBlob class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultFilemode	^ LGitFilemodeEnum git_filemode_blob! !!LGitBlob class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #blob_free:! !!LGitBlob class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_blob! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromExternalCollection: aCollection	| id |	self assert: (aCollection class = ByteArray or: [ aCollection class theMetaClass canUnderstand: #asExternalTypeOn: ]).	id := LGitId new.	self		blob_create_frombuffer: id		repo: aRepository		buffer: aCollection		len: aCollection size.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromFile: aFileReference	| id |	id := LGitId new.	self blob_create_fromdisk: id repo: aRepository path: aFileReference fullName.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromString: aString	^ self of: aRepository fromExternalCollection: aString! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/21/2017 17:44:56'!binaryContents	| bytes |	"freeing not required. See #rawBuffer"	bytes := ByteArray new: self rawSize.	LibC memCopy: self rawBuffer to: bytes size: bytes size.	^bytes! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_id: blob		^ self call: #(void * git_blob_id #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_is_binary: blob		^ self call: #(Boolean git_blob_is_binary #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_lookup: blob repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_blob_lookup #(LGitBlob * blob , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_rawcontent: blob		^ self call: #(void * git_blob_rawcontent #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_rawsize: blob		^ self call: #(int64 git_blob_rawsize #(self)) options: #()! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!contents	^ self isBinary		ifTrue:  [ self binaryContents ]		ifFalse: [ self rawBuffer readStringUTF8 ]		! !!LGitBlob methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self blob_id: self! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ self contents hash! !!LGitBlob methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBinary	^ self blob_is_binary: self! !!LGitBlob methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBlob	^ true! !!LGitBlob methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ self		blob_lookup: self 		repo: self repository		id: self id ].	self autoRelease! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!names	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :rootPath :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: entry filename ].		0 ].		^ names! !!LGitBlob methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self id objectPrintOn: aStream! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/21/2017 17:44:56'!rawBuffer	"freeing not required (see http://libgit2.github.com/libgit2/#HEAD/group/blob/git_blob_rawcontent)"	^ self blob_rawcontent: self! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/21/2017 17:44:56'!rawSize	^ self blob_rawsize: self! !!LGitCommit class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_free: handle		^ self call: #(void git_commit_free #(void *handle)) options: #()! !!LGitCommit class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #commit_free:! !!LGitCommit class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_commit! !!LGitCommit class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromHexString: aCommitId	^ self of: aRepository fromId: (LGitId fromHexString: aCommitId)! !!LGitCommit methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!author	^ self commit_author: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!authorStruct	^ self commit_author: self! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_author: commit		^ self		call: #(LGitSignature * git_commit_author #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_committer: commit		^ self		call: #(LGitSignature * git_commit_committer #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_id: commit		^ self call: #(void * git_commit_id #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_lookup: commit repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_lookup #(LGitCommit * commit , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_message: commit		^ self call: #(String git_commit_message #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_message_encoding: commit		^ self		call: #(String git_commit_message_encoding #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_parent_id: commit n: n	<todo: 'using LGitId * as return type causes a crash'>		^ self		call: #(void *git_commit_parent_id #(self , uint n))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_parentcount: commit		^ self call: #(uint git_commit_parentcount #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_raw_header: aCommit	^ self call: #(const char * git_commit_raw_header(self))! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_time: commit		^ self call: #(int64 git_commit_time #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_time_offset: commit		^ self call: #(int git_commit_time_offset #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_tree: tree_out commit: commit		^ self		call: #(LGitReturnCodeEnum git_commit_tree #(LGitTree *tree_out , self))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committer	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committerStruct	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString 	^ self tree entryByPath: aString! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString ifAbsent: aBlock	^ self tree entryByPath: aString ifAbsent: aBlock! !!LGitCommit methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self commit_id: self! !!LGitCommit methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasParents	^ self parents notEmpty! !!LGitCommit methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isCommit	^ true! !!LGitCommit methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isMerge	^ self parents size > 1! !!LGitCommit methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ 		self			commit_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitCommit methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!merge: anotherCommit	"Merge two commits, producing a git_index that reflects the result of the merge."	| index | 	index := LGitIndex of: self repository.	self withReturnHandlerDo: [ 		self merge_result: index commit: anotherCommit options: LGitMergeOptions defaults.	].	"There is a bug on libgit2 and we need to set the owner of the index (because it is not	setting it)"	index hackOwner: self repository.		^ index! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_result: out commit: anotherCommit options: options	^ self call: #(		LGitReturnCodeEnum git_merge_commits(			LGitIndex *out, 			LGitRepository repository, 			LGitCommit self, 			LGitCommit anotherCommit, 			LGitMergeOptions *options))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message	<todo: 'use encoding to properly read the message'>	|  encoding |	encoding := self commit_message_encoding: self.	^ self commit_message: self! !!LGitCommit methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self id hexString in: [ :hexId |		aStream			nextPutAll: (hexId first: 7);			nextPutAll: '...';			nextPutAll: (hexId last: 7);			nextPutAll: ', ';			nextPutAll: self message surroundedBySingleQuotes ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self 		call: #(void *git_commit_owner(self)) 		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!parents	| parentCount |	parentCount := self commit_parentcount: self.	^ Array		new: parentCount		streamContents: [ :stream | 			0 to: parentCount - 1 do: [ :i | 				| parentOid parent |				parentOid := LGitId fromHandle: (self commit_parent_id: self n: i) getHandle.				parent := self class of: self repository fromId: parentOid.				stream nextPut: parent ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!rawHeader 	^ self commit_raw_header: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!time	| time offset |	time := self commit_time: self.	offset := self commit_time_offset: self.	^ LGitTime new		time: time;		offset: offset;		yourself! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tree	| tree |	tree := LGitTree of: self repository.	self commit_tree: tree commit: self.	^ tree! !!LGitObject class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!classFor: aType	^ self subclasses detect: [ :class | class isType: aType ]! !!LGitObject class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #object_free:! !!LGitObject class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ self subclassResponsibility! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!newFromReference: aReference	^self of: aReference repository from: aReference targetId! !!LGitObject class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_free: handle 	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromId: id	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitObject methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!concreteObject	^ (self class classFor: self type) of: self repository fromId: self id! !!LGitObject methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self object_id: self! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!id	| data |	(id notNil or: [ self isNull ]) ifTrue: [ ^ id ].	data := self get_id_data.	id := LGitId fromHandle: data getHandle.	id internalize.	^ id	! !!LGitObject methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeWithId: gitOid	id := gitOid.	self lookup! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBlob	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isCommit	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTag	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTree	^ false! !!LGitObject methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ self		object_lookup: self 		repo: self repository		id: self id 		type: LGitObjectTypeEnum git_obj_any ]! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self id ifNil: [ ^ self ].		aStream nextPutAll: self id hexString! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_dup: dest from: source		^ self		callUnchecked: #(LGitObjectTypeEnum git_object_dup(LGitObject *dest, LGitObject source))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_id: obj		^ self		call: #(void * git_object_id #(self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_lookup: object repo: repo id: oid type: type		^ self		callUnchecked:			#(LGitReturnCodeEnum git_object_lookup #(LGitObject * object , LGitRepository repo , LGitId * oid , LGitObjectTypeEnum type))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_short_id: out		^ self		call: #(LGitObjectTypeEnum git_object_short_id(LGitBuf *out, self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_type: obj		^ self		call: #(LGitObjectTypeEnum git_object_type #(self))		options: #()! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!shortId	| buf shortId |	buf := LGitBuf new.	self object_short_id: buf.	shortId := buf prim_ptr readString.	buf free.	^shortId ! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type	^ self object_type: self! !!LGitTag class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #tag_free:! !!LGitTag class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tag! !!LGitTag class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_free: handle	^ self call: #(void git_tag_free #(void *handle)) options: #()! !!LGitTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name	^ self tag_name! !!LGitTag methodsFor: 'accesing' stamp: ' 7/21/2017 17:44:56'!object	| peeled |	peeled := LGitObject of: self repository.	self tag_peel: peeled.	^ peeled concreteObject! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_name	^ self call: #(String git_tag_name #(self)) options: #()! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_peel: result	^ self		call: #(LGitReturnCodeEnum git_tag_peel #(LGitObject * result, self))		options: #()! !!LGitTree class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultFilemode	^ LGitFilemodeEnum git_filemode_tree! !!LGitTree class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #tree_free:! !!LGitTree class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tree! !!LGitTree class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_free: handle		^ self call: #(void git_tree_free #(void *handle)) options: #()! !!LGitTree methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [ 			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitTree methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!allEntriesDo: aBlock	"The entries will be traversed in the specified order, children subtrees will be automatically loaded as required, and the callback will be called once per entry with the current (relative) root for the entry and the entry data itself.If the callback returns a positive value, the passed entry will be skipped on the traversal (in pre mode). A negative value stops the walk."	self withReturnHandlerDo: [ 		self			tree_walk: self			mode: LGitTreewalkModeEnum git_treewalk_pre			callback: (LGitTreewalkCallback on: aBlock)			payload: ExternalAddress null ]! !!LGitTree methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!entries	| entryCount |	entryCount := self tree_entrycount: self.		^ Array new: entryCount streamContents: [ :stream |		0 to: entryCount - 1 do: [ :i || entry |			entry := self tree_entry_byindex: self idx: i.			entry repository: self repository.			stream nextPut: entry ] ]! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByName: aString 	^ self entryByName: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByName: aString ifAbsent: aBlock	| entry |	entry := self tree_entry_byname: self name: aString.	(entry isNil or: [ entry isNull ])		ifTrue: [ ^aBlock value ].	entry repository: self repository.	^entry! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString 	^ self entryByPath: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString ifAbsent: aBlock	| entry |	entry := LGitTreeEntry of: self repository.	self tree_entry_bypath: entry path: aString.	^ entry isNull		ifTrue: [ aBlock value ]		ifFalse: [ 			entry repository: self repository.			entry ]! !!LGitTree methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self tree_id: self! !!LGitTree methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ super hash bitXor: self id asInteger! !!LGitTree methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isEmpty	^ self entries isEmpty! !!LGitTree methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isLeaf	^ self entries noneSatisfy: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree  ]! !!LGitTree methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTree	^ true! !!LGitTree methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [		self			tree_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!names	<todo: 'decide what to do with this:	- will not work for trees not referenced from head (e.g. in an older commit)	- very slow for large repositories because every entry is visited'>	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :name :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: name ].		0 ].		^ names! !!LGitTree methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream		nextPutAll: 'number of entries: ';		nextPutAll: self size asString! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self tree_owner: self! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!size	^ self tree_entrycount: self! !!LGitTree methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!subTreeEntries	^ self entries select: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree ]! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_byindex: tree idx: idx		^ self		call: #(LGitTreeEntry git_tree_entry_byindex #(self , size_t idx))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_byname: tree name: name		^ self		call: #(LGitTreeEntry git_tree_entry_byname #(self , String name))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_bypath: out path: path		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_bypath #(LGitTreeEntry * out, self, String path))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entrycount: tree		^ self call: #(int git_tree_entrycount #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_id: tree		^ self call: #(void * git_tree_id #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_lookup: out repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_tree_lookup #(LGitTree * out , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_owner: tree		^ self call: #(LGitRepository git_tree_owner #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_walk: tree mode: mode callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_tree_walk #(LGitTree tree , LGitTreewalkModeEnum mode , LGitTreewalkCallback callback , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_patch_free: handle		^ self call: #(void git_patch_free #(void *handle)) options: #()! !!LGitPatch class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #diff_patch_free:! !!LGitPatch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromDiff: aDiff at: anInteger	^ (self of: aDiff repository)		fromDiff: aDiff at: anInteger;		yourself! !!LGitPatch methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fromDiff: aDiff at: anInteger	"use 1 based offset as in Smalltalk"	self withReturnHandlerDo: [		self			patch_from_diff: self			diff: aDiff			idx: anInteger - 1 ].	self autoRelease! !!LGitPatch methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hunkAt: anInteger	| hunk lines |	hunk := LGitDiffHunk externalNew.	lines := LGitWriteBackValueSizeT new.	self withReturnHandlerDo: [		self			patch_get_hunk: hunk			lines_in_hunk: lines patch: self			hunk_idx: anInteger ].			^ hunk! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_blob_and_buffer: out old_blob: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blob_and_buffer #(LGitPatch * self , LGitBlob old_blob , String old_as_path , String buffer , FFIUInt32 buffer_len , String buffer_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_blobs: out old_blob: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobs #(LGitPatch * self , LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_buffers: out old_buffer: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path opts: opts	self flag: #todo. "This one doesnt seems to exist anymore. Instead I think it is git_patch_from_blob_and_buffer"	^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobuffers #(LGitPatch * self , FFIVoid * old_buffer , FFIUInt32 old_len , String old_as_path , String new_buffer , FFIUInt32 new_len , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_diff: out diff: diff idx: idx		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_diff #(LGitPatch * self , LGitDiff diff , size_t idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_get_delta: patch		^ self		call: #(LGitDiffDelta * git_patch_get_delta #(self))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx		^ self		call:			#(LGitReturnCodeEnum git_patch_get_hunk #(				LGitDiffHunk **out , 				LGitWriteBackValueSizeT *lines_in_hunk, 				LGitPatch *patch, 				size_t hunk_idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_get_line_in_hunk: out patch: patch hunk_idx: hunk_idx line_of_hunk: line_of_hunk		^ self		call:			#(LGitReturnCodeEnum git_patch_get_line_in_hunk #(LGitDiffLine * out , self , size_t hunk_idx , size_t line_of_hunk))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_print: patch print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_patch_print #(self , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printDiff	^ String new: 500 streamContents: [ :stream |		self printDiffOn: stream ]! !!LGitPatch methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!printDiffOn: aStream	| callback |	callback := LGitDiffLineCallback on: [ :delta :hunk :line :payload |		aStream nextPutAll: line content. 0 ].		self withReturnHandlerDo: [		self			patch_print: self			print_cb: callback			payload: nil ]! !!LGitPathSpecMatchList class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #pathspec_match_list_free:! !!LGitPathSpecMatchList class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!pathspec_match_list_free: handle		^ self		call: #(void git_pathspec_match_list_free #(void *handle))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!pathspec_match_diff: out diff: diff flags: flags ps: ps		^ self		callUnchecked:			#(int git_pathspec_match_diff #(LGitPathSpecMatchList * self , LGitDiff diff , LGitPathSpecFlagTypeEnum flags , LGitPathSpec ps))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!pathspec_match_list_diff_entry: m pos: pos		^ self		call:			#(LGitDiffDelta git_pathspec_match_list_diff_entry #(LGitPathSpecMatchList m , size_t pos))		options: #()! !!LGitReference class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #reference_free:! !!LGitReference class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_free: handle	^ self		call: #(void git_reference_free #(void *handle))		options: #()! !!LGitReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	self class == anObject class ifFalse: [ ^ false ].		^ self == anObject or: [		(self 			reference_cmp: self 			ref2: anObject) = LGitReturnCodeEnum git_ok  ]	! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!annotatedCommit	^ LGitAnnotatedCommit fromRef: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!basename	^ self name copyAfterLast: $/! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_is_head: branch		^ self call: #(int git_branch_is_head #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_set_upstream: upstream	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_set_upstream #(self , String upstream))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_upstream: out local: local	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_upstream #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createDirect: nameString target: aGitId force: aBoolean	self withReturnHandlerDo: [ 		self			reference_create: self			repo: self repository			name: nameString			id: aGitId			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createSymbolic: nameString target: targetString force: aBoolean	self withReturnHandlerDo: [ 		self			reference_symbolic_create: self			repo: self repository			name: nameString			target: targetString			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!initializeOn: aHandle in: aRepo	handle := aHandle.	self repository: aRepo.! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBranch	^ (self reference_is_branch: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isDirect	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_oid! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isHead	^ (self branch_is_head: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isLocal	^ self reference_is_remote not! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isSymbolic	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_symbolic! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTag	^ self reference_is_tag = 1! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name	^ self reference_name: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object	self isDirect 		ifFalse: [ ^ self resolve object ].	^(LGitObject of: self repository fromId: self targetId) concreteObject! !!LGitReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self name surroundedBySingleQuotes! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self call: #(void * git_reference_owner #(self)) options: #()! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!pushUpstream	| pushRemote | 	^ self repository config 		getString: 'remote.pushDefault'		ifPresent: [ :pushRemoteName |			self repository 				lookupBranch: self upstream basename				inRemote: pushRemoteName ]		ifAbsent: [ self upstream ]! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_cmp: ref1 ref2: ref2		^ self		call: #(LGitReturnCodeEnum git_reference_cmp #(self , LGitReference ref2))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_create: out repo: repo name: name id: id force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_create #(LGitReference * self , LGitRepository repo , String name , LGitId * id , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_is_branch: ref		^ self call: #(int git_reference_is_branch #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_is_remote	^ self call: #(Boolean git_reference_is_remote #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_is_tag		^ self call: #(int git_reference_is_tag #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * self , LGitRepository repo , String name))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_name: ref		^ self call: #(String git_reference_name #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_resolve: out ref: ref		^ self		callUnchecked: #(LGitReturnCodeEnum git_reference_resolve #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_set_target: out ref: ref id: id log_message: log_message		^ self		call:			#(LGitReturnCodeEnum git_reference_set_target #(LGitReference * out , self , LGitId * id , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_symbolic_create: out repo: repo name: name target: target force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_create #(LGitReference * self , LGitRepository repo , String name , String target , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_symbolic_set_target: out ref: ref target: target log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_set_target #(LGitReference * self , LGitReference ref , String target , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_target: ref	<todo: 'using LGitId* as return value causes random crashes'>		^ self call: #(void * git_reference_target #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_type: ref		^ self		call: #(LGitReferenceTypeEnum git_reference_type #(self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!resolve	| resolved |	self isDirect 		ifTrue: [ ^ self ].	resolved := self class of: self repository.	self withReturnHandlerDo: [ self reference_resolve: resolved ref: self ].	^ resolved! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setTarget: aReference	self setTargetId: aReference object id! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setTargetId: aGitId	| newRef |	newRef := LGitReference of: self repository.	self		withReturnHandlerDo: [ 			self				reference_set_target: newRef				ref: self				id: aGitId				log_message: 'set ' , self name , ' to ' , aGitId hexString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setUpstream: upstreamName	self withReturnHandlerDo: [		self branch_set_upstream: upstreamName	]! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!shortName	^ self isLocal 		ifTrue: [ self basename ]		ifFalse: [ self name withoutPrefix: 'refs/remotes/']! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!targetId	| data oId |	data := self reference_target: self.	data getHandle isNull		ifTrue: [ ^ nil ].	oId := LGitId fromExternalAddress: data.	oId internalize.	^ oId! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!upstream	| upstream | 	upstream  := self class of: self repository.	[ self withReturnHandlerDo: [		self branch_upstream: upstream local: self	]] 	on: LGit_GIT_ENOTFOUND do: [ ^ nil ].	^ upstream! !!LGitRemote class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!credentials	^ Credentials ifNil: [ Credentials := SmallDictionary new ]! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/21/2017 17:44:56'!credentialsPlaintext	^ LGitCredentialsPlaintext		username: self username		passphrase: self password! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/21/2017 17:44:56'!credentialsSsh	^ LGitCredentialsSSH		username: self usernameSsh		passphrase: self keyPassPhrase		publicKeyReference: self keyFilePublicPath asFileReference		privateKeyReference: self keyFilePrivatePath asFileReference! !!LGitRemote class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #remote_free:! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePrivatePath	^ self credentials		at: #keyFilePrivatePath		ifAbsentPut: [ UIManager default request: 'Path to your private key file (/home/foo/.ssh/key)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePrivatePath: aString	self credentials		at: #keyFilePrivatePath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePublicPath	^ self credentials		at: #keyFilePublicPath		ifAbsentPut: [ UIManager default request: 'Path to your public key file (/home/foo/.ssh/key.pub)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePublicPath: aString	self credentials		at: #keyFilePublicPath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyPassPhrase	^ self credentials		at: #keyPassPhrase		ifAbsentPut: [ UIManager default request: 'Passphrase of your private key file?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyPassPhrase: aString	self credentials		at: #keyPassPhrase		put: aString! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository named: aString	^ self of: aRepository named: aString url: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository named: nameString url: urlString	^ self		of: aRepository		named: nameString		url: urlString		fetchSpec: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository named: nameString url: urlString fetchSpec: aRefSpec	^ (self of: aRepository)		remoteName: nameString;		url: urlString;		fetchSpec: aRefSpec;		yourself! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!password	^ self credentials		at: #password		ifAbsentPut: [ UIManager default request: 'What''s the password for your account?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!password: aString	self credentials		at: #password		put: aString! !!LGitRemote class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_free: handle		^ self call: #(void git_remote_free #(void *handle)) options: #()! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!resetCredentials	Credentials := nil! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!username	^ self credentials		at: #username		ifAbsentPut: [ UIManager default request: 'What''s your account name?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!username: aString	self credentials		at: #username		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!usernameSsh	^ self credentials		at: #usernameSsh		ifAbsentPut: [ 			UIManager default 				request: 'What''s your username for SSH (probably "git")?'				initialAnswer: 'git' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!usernameSsh: aString	self credentials		at: #usernameSsh		put: aString! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addFetch	self withReturnHandlerDo: [ 		self			remote_add_fetch: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addPush	self withReturnHandlerDo: [ 		self			remote_add_push: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!connectFetch	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: LGitRemoteCallbacks defaults ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!connectFetchWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!connectPushWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_push			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!create	<todo: 'use exceptions instead of assertions'>	self assert: url notNil.	self assert: self repository isReady.		[ self hasFetchSpec		ifFalse: [ self createWithoutSpec ]		ifTrue: [ self createWithFetchSpec ] ]			on: LGit_GIT_EEXISTS			do: [ "all good then" ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createWithFetchSpec	self withReturnHandlerDo: [ 		self			remote_create_with_fetchspec: self			repo: self repository			name: self remoteName			url: self url			fetch: self fetchSpec ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createWithoutSpec	self withReturnHandlerDo: [ 		self			remote_create: self			repo: self repository			name: self remoteName			url: self url ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!delete	self withReturnHandlerDo: [		self			remote_delete: self repository			name: self remoteName ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetch	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks: LGitRemoteCallbacks defaults;				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchSpec	^ fetchSpec! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchSpec: aRefSpec	fetchSpec := aRefSpec! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchWithCredentials: aCredentialsProvider	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks:(LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchWithMessage: aString	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: LGitFetchOptions defaults			reflog_message: aString ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchWithMessage: aString credentials: aCredentialsProvider 	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: (LGitFetchOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: aString ]! !!LGitRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasFetchSpec	^ self fetchSpec notNil ! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ 		self			remote_lookup: self			repo: self repository			name: self remoteName.		self url: self remote_url ].	self flag: #todo. "shouldn't be autoreleased?"! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!ls	"I list all HEADS in connected remotes (you will need to #connectFetch or 	#connectPushWithCredentials: first)"	| out sizeBuf heads size |		sizeBuf := ByteArray new: FFISizeT externalTypeSize.	out := ExternalAddress new.		self withReturnHandlerDo: [ 		self remote_ls: out size: sizeBuf ].		size := sizeBuf signedLongAt: 1.	heads := Array new: size. 	1 to: size do: [ :index | 		heads at: index put: (LGitRemoteHead fromHandle: (out pointerAt: 1)).		out := out + FFIExternalType pointerSize ].		^ heads! !!LGitRemote methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self remoteName! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pullWithFetchOptions: fetchOptions	<todo: 'check for conflicts'>	self repository isReady ifFalse: [  ^ self ].	self lookup.		self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: fetchOptions			reflog_message: 'automatic pull from libgit2' ].		"assume that there are no conflicts and fast-forwad to FETCH_HEAD"	self repository fastForward! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushWithRefSpec: aRefSpec pushOptions: pushOptions	| refspecs return |	refspecs := LGitStringArray withAll: { aRefSpec asString }.	return := self withReturnHandlerDo: [		self			remote_push: self			refspecs: refspecs			opts: pushOptions ].			^ return! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!refSpecs 	| specs |	specs := LGitStringArray externalNew autoRelease.	self withReturnHandlerDo: [ 		self remote_get_fetch_refspecs: specs ].	^ specs strings! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteName	^ remoteName! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteName: aString	remoteName := aString! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_add_fetch: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_fetch #(LGitRepository repo , String remote String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_add_push: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_push #(LGitRepository repo , String remote , String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_connect: remote direction: direction callbacks: remoteCallbacks		^ self		call:			#(LGitReturnCodeEnum git_remote_connect #(self , LGitDirectionEnum direction , LGitRemoteCallbacks * remoteCallbacks))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_create: out repo: repo name: name url: urlString		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create #(LGitRemote * self , LGitRepository repo , String name , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_create_with_fetchspec: out repo: repo name: name url: urlString fetch: fetch		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create_with_fetchspec #(LGitRemote * self , LGitRepository repo , String name , String urlString , String fetch))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_delete: repo name: name		^ self		call:			#(LGitReturnCodeEnum git_remote_delete #(LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_fetch: remote refspecs: refspecs opts: opts reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_fetch #(self , void * refspecs , LGitFetchOptions * opts , String reflog_message))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_get_fetch_refspecs: array	^ self call: #(int git_remote_get_fetch_refspecs(LGitStringArray *array, self))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_lookup #(LGitRemote * self , LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_ls: out size: size	"	Since I will take a lost of addresses, I'm interested on 2nd level of 'out', that's why 	I transform `const git_remote_head ***out` into `void **out`	This is the original function: 		int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)"	^ self call: #( LGitReturnCodeEnum git_remote_ls ( void **out, size_t *size, self ))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_push: remote refspecs: refspecs opts: opts		^ self		call:			#(LGitReturnCodeEnum git_remote_push #(self , LGitStringArray * refspecs , LGitPushOptions * opts))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_set_url: repo remote: remote url: urlString		^ self		call:			#(LGitReturnCodeEnum git_remote_set_url #(LGitRepository repo , String remote , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_update_tips: remote callbacks: remoteCallbacks update_fetchhead: update_fetchhead download_tags: download_tags reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_update_tips #(self , LGitRemoteCallbacks * remoteCallbacks , Boolean update_fetchhead , LGitRemoteAutotagOptionTypeEnum download_tags , String reflog_message))		options: #(optStringOrNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_url	^ self		call: #(String git_remote_url #(self))		options: #()! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setUrl: aString	self withReturnHandlerDo: [ 		self			remote_set_url: self repository			remote: self remoteName			url: aString]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!url	^ url! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!url: aString	url := aString! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!new	self error: 'Use #of: to create an instance of ', self name! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository	^ self basicNew		initialize;		repository: aRepository;		yourself! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!repository	^ repository! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!repository: aRepository	repository := aRepository! !!LGitRevwalk class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #revwalk_free:! !!LGitRevwalk class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository	^ (super of: aRepository)		createNew;		yourself! !!LGitRevwalk class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_free: handle		^ self call: #(void git_revwalk_free #(void *handle)) options: #()! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!basicNext	"Note: in the C code you would check the return code to see when the loop is over.	This method uses instances variables to enable more Smalltalk like looping:	[ walk hasNext ] whileTrue: [ walk next ]."	| previousCommit nextId |	previousCommit := currentCommit.	nextId := self basicNextObjectId.	currentCommit := self hasNext		ifTrue: [			LGitCommit				of: self repository				fromId: nextId ]		ifFalse: [ nil ].		^ previousCommit! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!basicNextObjectId	| nextId returnCode |	nextId := LGitId new.	returnCode := self		revwalk_next: nextId		walk: self.	(returnCode ~= LGitReturnCodeEnum git_iterover and: [ 		returnCode ~= LGitReturnCodeEnum git_ok ]) ifTrue: [ returnCode handleLGitReturnCode ].	hasNext := returnCode ~= LGitReturnCodeEnum git_iterover.		^ nextId! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!basicSort: sortingEnum	sorting := sorting		ifNil: [ sortingEnum value ]		ifNotNil: [ sorting bitOr: sortingEnum value ].			self withReturnHandlerDo: [		self			revwalk_sorting: self			sort_mode: sorting ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!beSortedByCommitTime	self basicSort: LGitRevwalkSortTypeEnum git_sort_time! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!beSortedParentsBeforeChildren	self basicSort: LGitRevwalkSortTypeEnum git_sort_topological! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!beSortedReverse	self basicSort: LGitRevwalkSortTypeEnum git_sort_reverse! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createNew	self withReturnHandlerDo: [		self			revwalk_new: self			repo: self repository ]! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:56'!do: aBlock	[ self hasNext ] whileTrue: [ 		aBlock value: self next	]! !!LGitRevwalk methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasNext	^ hasNext ifNil: [		self basicNext.		hasNext ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hideCommit: aLGitId	self withReturnHandlerDo: [ self revwalk_hide: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hideReference: aReference	self withReturnHandlerDo: [		self			revwalk_hide_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!next	self hasNext ifFalse: [ ^ LGit_GIT_ITEROVER signal ].		^ self basicNext! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushCommit: aLGitId 	self withReturnHandlerDo: [ self revwalk_push: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushHead	self withReturnHandlerDo: [ self revwalk_push_head: self ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushReference: aReference	self withReturnHandlerDo: [		self			revwalk_push_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!reset	self withReturnHandlerDo: [ self revwalk_reset: self ]! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_hide: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_hide #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_hide_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_hide_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_revwalk_new #(LGitRevwalk * self , LGitRepository repo))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_next: out walk: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_next #(LGitId * out , self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_push: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_push #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_push_head: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_push_head #(self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_push_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_push_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_reset: revwalk		^ self call: #(void git_revwalk_reset #(self)) options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_sorting: walk sort_mode: sort_mode		^ self		call: #(void git_revwalk_sorting #(self , uint sort_mode))		options: #()! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:56'!select: selectionBlock thenDo: actionBlock	self do: [ :result | 		(selectionBlock value: result) 			ifTrue: [ actionBlock value: result ] ]! !!LGitStatusList class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #status_list_free:! !!LGitStatusList class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_list_free: handle		^ self		call: #(void git_status_list_free #(void *handle))		options: #()! !!LGitStatusList methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_list_get_perfdata: out status: status		^ self		call:			#(LGitReturnCodeEnum git_status_list_get_perfdata #(LGitPerfData * out , self))		options: #()! !!LGitTreeBuilder class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #treebuilder_free:! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromTree: aTree	self validate: aTree shouldBe: LGitTree.	^ self of: aTree repository fromTree: aTree! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: repository fromTree: aTree	^ (self of: repository)		initializeWithTree: aTree;		yourself! !!LGitTreeBuilder class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_free: handle		^ self		call: #(void git_treebuilder_free #(void *handle))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addEntry: aLGitObject filename: aString	self 		addEntryWithId: aLGitObject id 		filename: aString 		filemode: aLGitObject class defaultFilemode! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addEntryWithId: oidStruct filename: aString filemode: anInteger	self withReturnHandlerDo: [ 			self				treebuilder_insert: (LGitTreeEntry of: self repository)				bld: self				filename: aString				id: oidStruct				filemode: anInteger ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!clear	self treebuilder_clear: self! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createNew	self withReturnHandlerDo: [ 		self 			treebuilder_new: self			repo: self repository			source: self ffiNull handle ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!getEntryNamed: aString	| entry |	entry := self		treebuilder_get: self		filename: aString.	entry repository: self repository.		^ entry! !!LGitTreeBuilder methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeWithTree: aTree	self withReturnHandlerDo: [		self			treebuilder_new: self			repo: self repository			source: (aTree ifNotNil: #handle) ]! !!LGitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newTree	^ LGitTree of: self repository fromId: self write! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_clear: bld		^ self call: #(void git_treebuilder_clear #(self)) options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_get: bld filename: filename		^ self		call: #(LGitTreeEntry git_treebuilder_get #(self , String filename))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_insert: out bld: bld filename: filename id: id filemode: filemode		^ self		call:			#(LGitReturnCodeEnum git_treebuilder_insert #(LGitTreeEntry * out , self , String filename , LGitId * id , LGitFilemodeEnum filemode))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_new: out repo: repo source: source	^ self		callUnchecked:			#(LGitReturnCodeEnum git_treebuilder_new #(LGitTreeBuilder * out , LGitRepository repo , void * source))		options: #(+ optCoerceNilToNull)! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_write: id bld: bld		^ self		call: #(LGitReturnCodeEnum git_treebuilder_write #(LGitId * id , self))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!write	| id errorCode |	id := LGitId new.	errorCode := self		treebuilder_write: id		bld: self.			errorCode ~= 0 ifTrue: [ LGitWritingTreeFailed ].		^ id! !!LGitTreeEntry class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #tree_entry_free:! !!LGitTreeEntry class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_free: handle		^ self		call: #(void git_tree_entry_free #(void *handle))		options: #()! !!LGitTreeEntry methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [		self class == anObject class and: [ 			self isReady and: [ 				anObject isReady and: [ 					self compare: anObject ] ] ] ]! !!LGitTreeEntry methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!compare: aTreeEntry	^ (self		tree_entry_cmp: self		e2: aTreeEntry) isZero! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!entries	^ self object entries! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString 	^ self object entryByPath: aString! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString ifAbsent: aBlock	^ self object entryByPath: aString ifAbsent: aBlock! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fileMode	^ self tree_entry_filemode: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!filename	^ self tree_entry_name: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object	| object |	object := (LGitObject classFor: self type) of: self repository.	self withReturnHandlerDo: [		self			tree_entry_to_object: object			repo: self repository			entry: self ].			^ object! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!objectId	^ LGitId fromExternalAddress: (self tree_entry_id: self)! !!LGitTreeEntry methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream 	aStream nextPutAll: self filename surroundedBySingleQuotes! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!subTreeEntries	^ self object subTreeEntries! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_cmp: e1 e2: e2		^ self		call: #(int git_tree_entry_cmp #(self , LGitTreeEntry e2))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_filemode: entry		^ self		call: #(LGitFilemodeEnum git_tree_entry_filemode #(self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_id: entry		^ self call: #(void * git_tree_entry_id #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_name: entry		^ self call: #(String git_tree_entry_name #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_to_object: object_out repo: repo entry: entry		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_to_object #(LGitObject * object_out , LGitRepository repo , self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_type: entry		^ self		call: #(LGitObjectTypeEnum git_tree_entry_type #(self))		options: #()! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type	^ self tree_entry_type: handle! !!LGitWriteBackValue class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isAbstract	^ self == LGitWriteBackValue! !!LGitWriteBackValueInt class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!typeDecl	^ 'int'! !!LGitWriteBackValueSizeT class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!typeDecl	^ 'size_t'! !!LGitWriteBackValueUInt class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!typeDecl	^ 'uint'! !!LGitAbstractError class methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalWith: anObject	^ self new		object: anObject;		signal;		yourself! !!LGitAbstractError methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initialize	super initialize.	self messageText: LGitError lastMessage! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object	^ object! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object: anObject	object := anObject! !!LGitCallError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isAbstract	^ self == LGitCallError! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!canHandle: aReturnCode	^ self handledReturnCodes anySatisfy: [ :symbol | 		aReturnCode symbol = symbol ]! !!LGitCallReturnHandler class methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!for: aReturnCode	^ (self allSubclasses reject: #isAbstract)		detect: [ :class | class canHandle: aReturnCode ]		ifNone: [ LGitNoReturnCodeHandlerDefined signal ]! !!LGitCallReturnHandler class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!handledReturnCodes	^ { (self name allButFirst: 5) asLowercase asSymbol }! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isAbstract	^ self == LGitCallReturnHandler! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isError	^ true! !!LGitCallReturnHandler class methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalWith: anError	^ self new		messageText: anError message;		object: anError type;		signal;		yourself! !!LGit_GIT_ITEROVER methodsFor: 'signaling' stamp: ' 7/21/2017 17:44:56'!signal	"don't signal, everything is fine"	^ self! !!LGit_GIT_OK class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isError	^ false! !!LGit_GIT_OK methodsFor: 'signaling' stamp: ' 7/21/2017 17:44:56'!signal	"don't signal, everything is fine"	^ self! !!LGitIllegalArgument class methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalWith: anObject shouldBe: aClass	^ self new		object: anObject;		expectedClass: aClass;		signal;		yourself! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!expectedClass	^ expectedClass! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!expectedClass: anObject	expectedClass := anObject! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!messageText	^ 'libgit2 ffi call expects a(n) {1} but instead received {2}'			format: {self expectedClass. self object}! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!rejectClasses^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!rejectRules^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!ruleIfTrueBlocksRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitExternalObject #ifNotReady: #false)) #'2014-11-14T16:52:32.831129+01:00') )! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!ruleIfTrueReturnsRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.91457+01:00') #(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.915066+01:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:56'!ruleRBAbstractClassRuleV1FalsePositive^ #(#(#(#RGMetaclassDefinition #(#'LGitExternalEnumerationUInt32 class' #LGitExternalEnumerationUInt32)) #'2015-07-18T14:21:49.402159+02:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:56'!ruleRBNoClassCommentRuleV1FalsePositive^ #(#(#(#RGClassDefinition #(#LGitPushOptions)) #'2015-07-17T12:59:06.388548+02:00') )! !!LGitBufferSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void **out, LGitDiffFile *file, char *buf, size_t buflen, void *payload))! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!null	^ self new initializeNull! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!on: aBlock	^ self 		signature: self fnSpec 		block: aBlock ! !!LGitCallback methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!initializeNull	thunk := ExternalAddress null! !!LGitCheckoutNotifyCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitCheckoutNotifyTypeEnum why, String path, LGitDiffFile *baseline, LGitDiffFile *target, LGitDiffFile *workdir, void *payload))! !!LGitCheckoutPerfDataCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(void (LGitCheckoutPerfData *perfdata, void *payload))! !!LGitCheckoutProgressCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(void (String path, size_t completed_steps, size_t total_steps, void *payload))! !!LGitCompletionCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitRemoteCompletionTypeEnum type, void *argument))! !!LGitCredAcquireCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitCredentials **cred, String url, String username_from_url, uint allowed_types, void *data))! !!LGitCredAcquireCallback methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitCredAcquireCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aBlock	^[ :credAddress :url :username_from_url :allowed_types :data |		aBlock valueWithArguments: (Array			with: (LGitCredentials fromHandle: credAddress) 			with: url			with: username_from_url			with: allowed_types 			with: data) ]! !!LGitDiffBinaryCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffBinary *binary, void *payload))! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :binary :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffBinary fromHandle: binary) 			value: payload ]! !!LGitDiffFileCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta * delta, float progress, void *payload))! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :progress :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: progress			value: payload ]! !!LGitDiffHunkCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, void *payload))! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aBlock	^[ :deltaAddress :hunkAddress :payload |		aBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: payload ]! !!LGitDiffLineCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, LGitDiffLine *line, void *payload))! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aFourArgBlock	^[ :deltaAddress :hunkAddress :lineAddress :payload |		aFourArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: (LGitDiffLine fromHandle: lineAddress)			value: payload ]! !!LGitDiffNotifyCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiff *diff_so_far, LGitDiffDelta *delta_to_add, String matched_pathspec, void *payload))! !!LGitFileSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void **out, LGitDiffFile *file, String fullpath, void *payload))! !!LGitFreeSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(void (void *sig, void *payload))! !!LGitIndexMatchedPathCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (String path, String matched_pathspec, void *payload))! !!LGitPackbuilderForeachCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (void *buffer, int length, void *payload))! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aBlock	^[ :buffer :length :payload |		aBlock 			value: buffer 			value: length			value: payload ]! !!LGitPackbuilderProgressCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (int stage, uint32 current, uint32 total, void *payload))! !!LGitPushNegotiationCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (LGitPushUpdate **updates, size_t len, void *payload))! !!LGitPushStatusForeachCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (char *arg1, char *arg2, void *arg3))! !!LGitPushTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (uint current, uint total, size_t bytes, void *payload))! !!LGitPushUpdateReferenceCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (String refname, String status, void *data))! !!LGitRemoteCreateCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void **out, LGitRepository repo, String name, String url, void *payload))! !!LGitRepositoryCreateCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (LGitRepository **out, String path, Boolean bare, void *payload))! !!LGitSimilarityCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (int *score, void *siga, void *sigb, void *payload))! !!LGitStatusCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (String path, uint status_flags, void *payload))! !!LGitTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitTransferProgress *stats, void *payload))! !!LGitTransportCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int git_transport_cb(LGitTransport *out, LGitRemote owner, void *param))! !!LGitTransportCertificateCheckCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void *cert, int valid, String host, void *payload))! !!LGitTransportMessageCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (String str, int len, void *payload))! !!LGitTreewalkCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (String name, LGitTreeEntry entry, void *payload))! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aThreeArgBlock	^[ :rootPath :entryAddress :payload |		aThreeArgBlock 			value: rootPath 			value: (LGitTreeEntry fromHandle: entryAddress)			value: payload ]		! !!LGitUpdateTipsCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (String refname, LGitId *a, LGitId *b, void * data))! !!LGitLibrary class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!initialize	"Required to reset the Initialized flag on image startup"	Smalltalk addToStartUpList: self! !!LGitLibrary class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isInitialized	"Answer true when git_libgit2_init has been called in the current session."	^ Initialized ifNil: [ false ]! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/21/2017 17:44:56'!shutDown: quitting	quitting ifFalse: [ ^ self ].	self isInitialized ifFalse: [ ^self ].	self uniqueInstance shutdownLibGit2.! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/21/2017 17:44:56'!startUp: isImageStarting	isImageStarting		ifTrue: [ Initialized := false ]! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeLibGit2	self libgit2_init.	Initialized := true! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_features	"Query compile time options for libgit2."		^self ffiCall: #(int git_libgit2_features())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_featuresAlt	"Query compile time options for libgit2."		| fnc |		fnc := ExternalLibraryFunction		name: 'git_libgit2_features'		module: 'libgit2.0.dylib'		callType: 0		returnType: FFIInt32 new externalTypeWithArity		argumentTypes: {}.			^fnc invokeWithArguments: { }! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_init	^self ffiCall: #(int git_libgit2_init())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_shutdown	^self ffiCall: #(int git_libgit2_shutdown())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_version: major minor: minor rev: rev	"Return the version of the libgit2 library being currently used."	^self ffiCall: #(void git_libgit2_version(LGitWriteBackValueInt major, LGitWriteBackValueInt minor, LGitWriteBackValueInt rev))! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/21/2017 17:44:56'!macModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent / 'Plugins'.	#('libgit2.dylib' 'libgit2.0.dylib')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!shutdownLibGit2	| initsRemaining |		initsRemaining := self libgit2_shutdown.	initsRemaining <= 0		ifTrue: [ Initialized := false ].	^ initsRemaining! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/21/2017 17:44:56'!unixModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent.	#('libgit2.so' 'libgit2.so.0')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!version	"self uniqueInstance version"	| major minor rev |		major := LGitWriteBackValueInt new.	minor := LGitWriteBackValueInt new.	rev := LGitWriteBackValueInt new.		self libgit2_version: major minor: minor rev: rev.	^Array with: major value with: minor value with: rev value! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/21/2017 17:44:56'!win32ModuleName	^ 'libgit2.dll'! !!LGitExternalStructureFieldParser methodsFor: 'parsing' stamp: ' 7/21/2017 17:44:56'!parseFields: fields structure: structClass	| stream type fieldName generator |		stream := fields readStream.	generator := FFICallout new requestor: structClass.	fieldSpec := FFIExternalStructureFieldSpec new.	[ stream atEnd ] whileFalse: [ | arity |		type := generator resolveType: stream next. 		arity := 0.		[stream peek = #* ] whileTrue: [			arity := arity + 1.			stream next ].		type pointerArity: arity.				fieldName := ('prim_', stream next) asSymbol.		fieldName isSymbol ifFalse: [ self error: 'invalid field name'].		(fieldSpec fieldNames includes: fieldName) ifTrue: [ self error: 'duplicate field name' ].		"align := type typeSize min: byteAlign." "if byte align == 1, struct is packed"		"add padding between fields, if needed"		"self sizeAlignedTo: align with: type." 		fieldSpec addField: fieldName type: type. 			stream peek == #';' ifTrue: [ stream next ]].		^ self fieldSpec! !!LGitSafeFFICalloutMethodBuilder methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!generateFFICallout: builder spec: functionSpec	"Before the actual ffi call generate a check to see if the object is ready."	builder 		pushReceiver;		send: #signalIfNotReady.	^ super generateFFICallout: builder spec: functionSpec! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!objectPrintOn: aStream! !!Trait method!objectPrintOn: aStream! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !"LibGit-Core"!!TIceRepositoryBackend commentStamp: 'NicoPasserini 7/4/2016 17:39' prior: 0!Common functionality for Ice repository backends.!!IceMCVersionInfo commentStamp: 'NicoPasserini 9/7/2016 15:19' prior: 0!Adapter to produce an MCVersionInfo that knows how to (lazily) load ancestors from an Iceberg repository.!!ManifestIceberg commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!IceError commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!Base class for all errors in Iceberg.!!CannotIdentifyVersionForCommit commentStamp: 'NicoPasserini 7/26/2016 14:05' prior: 0!This error is signaled when looking for a version in a commit (and its ancestry) has found two versions and can not decide which of them is the desired one. This should not happen if the repository is consistent.!!IceDuplicatedRepository commentStamp: 'NicoPasserini 8/3/2016 14:50' prior: 0!When trying to create a repository I found another one with a conflicting location (i.e. the same director on disk).!!IceGitUsernameOrEmailNotFound commentStamp: '<historical>' prior: 0!I'm an error to be sent when the error that comes from external library can be guessed to be the absense of user.name and user.mail properties.!!IceLocalRepositoryMissing commentStamp: 'NicoPasserini 10/4/2016 17:44' prior: 0!The repository code directory does not exist, maybe because the image was moved. Default action is to clone the repository again, but signal an error and allow for other components to react accordingly.!!IceMergeAborted commentStamp: 'NicoPasserini 8/9/2016 16:35' prior: 0!Attempting to merge arised a conflict so merge was aborted.!!IceMissingRepositoryEntry commentStamp: 'NicoPasserini 11/28/2016 14:05' prior: 0!Directory does not exist in the specified version in the repository.!!IceNoRemoteBranch commentStamp: 'NicoPasserini 8/3/2016 14:51' prior: 0!The operation you tried (for example push) requires that your branch has a configured upstream (something like origin/branchName), but is has none.!!IceVersionDoesNotExist commentStamp: 'NicoPasserini 11/28/2016 14:39' prior: 0!Version does not exist, probably the package was created in a later commit or it was deleted.!!IceWrongUrl commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!We can not parse the origin URL you have introduced. Maybe you made a typo, or maybe we do not support that kind of URLs.!!IceRepositoryAnnouncement commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Groupes different announcements that can happen in a repository.!!IceCommited commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has commited.!!IcePushed commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has been pushed.!!IceRepositoryModified commentStamp: 'NicoPasserini 10/5/2016 15:56' prior: 0!Announces an unspecified change to a repository.!!IceAbstractCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:25' prior: 0!Base class for shared code between different commit walk implementations.!!IceAbstractDiff commentStamp: 'NicoPasserini 5/12/2016 17:23' prior: 0!Parent class for any comparison between two versions of the code (working copy, commit or other) and comprising any level of granularity (a whole repository, a package, a class, etc.).!!IceChangeSet commentStamp: 'NicoPasserini 5/9/2016 18:11' prior: 0!I represent a (maybe unitary) set of changes to be handled by the Iceberg framework. I am the top class of a composite pattern.A change should be defined as1. the difference between two versions of the code (currently two MCSnapthots for an IcePackageChangeSet)2. a filter from a bigger change set (for example we can create a class change set which is a subset of a package change set, all other subclasses from IceStructuralChangeSet).3. an explicit set of changes (see IceSimpleChangeSet).Public API and Key Messages- elements: returns a set of change sets which are my children, for example the change set related to a package contains the change sets for each class in the package.- (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	elements:		<Object>    Implementation Points!!IcePackageChangeSet commentStamp: 'NicoPasserini 5/12/2016 17:32' prior: 0!Provides a filtered version of a diff, restricted to a package.!!IceDiff commentStamp: 'NicoPasserini 5/12/2016 17:10' prior: 0!I model (and track) the diff between the working copy and the last commit in a given repository.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!IceAbstractVersion commentStamp: 'NicoPasserini 10/20/2016 15:48' prior: 0!Base class for different types of versions, namely: IceVersion (normal versions) and IceForeignVersion (versions not managed by Ice).!!IceForeignVersion commentStamp: 'NicoPasserini 9/14/2016 18:01' prior: 0!Place holder for an Iceberg version. When you get an instance of me instead of a real ice package version, this means that we can not correlate the current version of the code loaded into the image with a version in the corresponding Iceberg repository.!!IceSavedPackageVersion commentStamp: 'NicoPasserini 9/26/2016 11:11' prior: 0!A version of a package as saved in a repository. We have one of this for each commit in a repository which modifies the specified package.Internal representation- commit is the commit from which I loaded this version. - originatingCommit is the commit in which this version was first introduced, it is useful for comparing this version to another one.!!IceTemporaryVersion commentStamp: 'NicoPasserini 11/28/2016 14:49' prior: 0!Temporary versions are created in two situations:1) As  a temporary place holder for a version. Someone asked for a version but the package is still being loaded, at some point a real version will replace me. In the meanwhile I can respond to some messages as a version would do.2) For packages that are added to the repository but not yet saved. In this case the version will be replaced with a real version on next commit.!!IceBackendWriterAdapter commentStamp: 'NicoPasserini 9/26/2016 15:01' prior: 0!Adapter for having MCFileTreeWriters being able to write into Iceberg backend repositories without introducing unpleasant modifications in them.!!IceClassReference commentStamp: 'NicoPasserini 5/18/2016 12:20' prior: 0!This class is just for organizing class references together in a hierarchy, see subclases for more info.!!IceRemovedClassReference commentStamp: 'NicoPasserini 5/18/2016 12:19' prior: 0!A reference to a class that has been removed, but can be handled polymorphically with references to existing classes (see IceSimpleClassReference)!!IceSimpleClassReference commentStamp: 'NicoPasserini 5/18/2016 12:18' prior: 0!Wraps a Pharo class, to allow to handle it polymorphicaly with other references to classes (see IceRemovedClassReference)!!IceCommitish commentStamp: 'NicoPasserini 9/16/2016 14:08' prior: 0!A commit-ish is some object that ultimately points to a commit in a repository: could be a real commit, a branch, a tag.!!IceBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!This can be a local o remote branch, see subclasses. When I am used as a commitish, you must understand that the commit I point to can change over time.!!IceLocalBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!Models a local branch in the repository.!!IceRemoteBranch commentStamp: 'NicoPasserini 12/6/2016 11:42' prior: 0!Models a remote tracking branch.Please note that a "remote tracking" branch is in fact in the local repository, but it is not intended to work on it, but just to mirror a branch in a remote repository. You can not really checkout this branch, neither commit on it, it is read only.When cheking out a branch, if it is a remote tracking branch, a local branch will be created.!!IceCommitInfo commentStamp: 'NicoPasserini 6/6/2016 17:30' prior: 0!Holds the information about a commit in a git repository.!!IceLoadedCode commentStamp: 'NicoPasserini 9/16/2016 14:14' prior: 0!The loaded code of a repository can have three different shapes:- Nothing is loaded yet (represented by an instance of me).- All loaded packages using versions from the same commit (should be the most common situation).- You cherry-picked versions comming from differents commits (not recomended but supported).As commitish, I point to the code as it was loaded from the repository. Notice that after that moment both the code in the image as well as the origin of the code could have changed (in case that I load a branch, the branch can have new commits after I loaded it).!!IceTag commentStamp: 'NicoPasserini 11/3/2016 17:20' prior: 0!Representation of a tag!!IceUnbornBranch commentStamp: 'NicoPasserini 12/5/2016 16:47' prior: 0!I represent the "HEAD commit" of a new repository, i.e. one without any branches or commits. Once you commit on me, your repository will have just one commit and one branch named 'master'.!!IceUnknownBranch commentStamp: 'EstebanLorenzano 7/19/2017 14:20' prior: 0!I'm an unknown branch. I implement an "null pattern" to provide correct output for non-existing local repositories.!!IceWorkingCopy commentStamp: 'NicoPasserini 9/16/2016 14:13' prior: 0!A commitish pointing to the current version of the code.!!IceCredentialsProvider commentStamp: 'NicoPasserini 11/7/2016 15:01' prior: 0!I am in charge of remembering credentials information, configuration and providing it as required by the different backend implementations.I have a counter to avoid for trying for ever with the same credentials.!!IceMetacelloRepositoryAdapter commentStamp: 'NicoPasserini 9/30/2016 15:01' prior: 0!Adapter for allowing metacello to use Iceberg to download packages and versions.!!IcePackageReference commentStamp: 'NicoPasserini 5/25/2016 12:00' prior: 0!I represent a package, that could be in an IceRepository or in the image.Public API and Key Messages- isLoaded tells if the package is currently loaded in the image.In the future we should add load/unload here.We could also add commit, but in general is better to commit at the project level and not at the package level.!!IcePlaintextCredentials commentStamp: 'NicoPasserini 11/22/2016 14:35' prior: 0!I keep a username and a password for connecting to a repository.!!IceRemote commentStamp: 'NicoPasserini 11/17/2016 12:30' prior: 0!I represent a reference to an upstream repository, i.e. the repository to which you want to push/pull. Usually I am called a  'remote' but I could also be local. Most frequently each repository has at least one remote named 'origin'.I am abstract, my subclasses provide access to different kinds of remotes.Right now I just provide information about the different parts of the url, I could get smarter in the future.Internal Representation and Key Implementation Points.    Instance Variables	url:		<String>!!IceFileRemote commentStamp: 'NicoPasserini 7/1/2016 11:41' prior: 0!I am a 'remote' repository which is stored locally in your machine and accessed through a 'file://' url.!!IceNetworkRemote commentStamp: 'NicoPasserini 11/18/2016 13:39' prior: 0!Base abstract class for SCP and HTTPS remotes.!!IceHttpRemote commentStamp: 'TorstenBergmann 2/23/2017 10:33' prior: 0!A remote repository created out of a HTTP  url, such as 'http://localhost/owner/repository.git'.!!IceHttpsRemote commentStamp: 'NicoPasserini 11/18/2016 12:39' prior: 0!A remote repository created out of a HTTPS  url, such as 'https://github.com/npasserini/iceberg.git'.!!IceScpRemote commentStamp: 'NicoPasserini 7/1/2016 11:40' prior: 0!A remote repository created out of a SCP url, such as 'git@github.com:npasserini/iceberg.git'.!!IceUndefinedRemote commentStamp: 'EstebanLorenzano 3/29/2017 17:32' prior: 0!I'm an undefined remote. I exist when a repository is created from scratch and then there is no remote assigned to it yet.!!IceRepository commentStamp: 'NicoPasserini 10/25/2016 15:10' prior: 0!I represent an interface to a git repository. My main responsibilities are:- Load/update both baselines and individual packages from the repository.- Commit changes to the local repository and publish them to a remote repository.- Browse other versions of the loaded packages.- Handle branchesFor the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- loadPackage: packageName- createBranch: newBranchNameSample usage:    Git new origin: 'git@github.com:npasserini/pharo-git-test.git'.    git loadPackage: 'Pharo-Git-Test'. Instance Variables- origin: A string representing the url of a remote git repository (used as origin)- repository:	An IceGitTreeGitRemoteRepository, which provides underlying git operations.- location: <FileReference> The directory of the local repository.- commitDictionary: <Dictionary of IceCommitInfo> Cached dictonary from commitId (hex string) to  all commits in the current branch (in the local repo).- subdirectory: <String> The subdirectory of the local repository which is handled by the underlying GitFileTree- versionDescriptors: <List of GitFileTreePackageEntry> cached list of all package versions saved in the (currently selected branch) of the (local) repository.- announcer: <Announcer>- branch: <IceBranch> currently selected branch. - loadedCode:  <IceLoadedCode> Contains information about the loaded code for each package in this repository. (TODO: maybe handle special cases about loading different versions loaded for different packages, see: https://github.com/npasserini/iceberg/issues/139).Implementation Points!!IceRepositoryCreator commentStamp: 'EstebanLorenzano 12/7/2016 18:46' prior: 0!I create repositories. I do this (trying in this order):- with a location and url defined, I check if it can be a repository and in positive case, I answer the repository, or I can do a clone+checkout (into location) and answer the resulting repository.- with a remote defined , I can take url and location and perform the correct actions.You can also define  branchName to checkout a specific branch.!!IceSavedPackage commentStamp: 'NicoPasserini 6/13/2016 15:57' prior: 0!Can give information about a package that is saved in a repository, for example: - isLoaded if the package has been loaded into the image.- isModified if the package has local changes to be commited- incommingCommigs information about commits in the repository that are newer than the version loaded into the image.!!IceSshCredentials commentStamp: 'NicoPasserini 11/22/2016 14:34' prior: 0!I am a container for the credentials needed for connecting to a git repository via ssh/scp.!!Iceberg commentStamp: 'NicoPasserini 4/28/2016 14:10' prior: 0!I am a cache providing access to several Ice objects, such as packages, repositories, working copies, etc.Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!TIceRepositoryBackend classTrait methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:57'!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/21/2017 17:44:57'!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/21/2017 17:44:57'!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!TIceRepositoryBackend methodsFor: 'descriptions' stamp: ' 7/21/2017 17:44:57'!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!TIceRepositoryBackend methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!TIceRepositoryBackend methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!LGitCredentialsSSH methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!readFrom: credentials	self username: credentials username.	self passphrase: credentials keyPassphrase.  	self publicKeyReference: credentials publicKey asFileReference.	self privateKeyReference: credentials privateKey asFileReference! !!MCWorkingCopy methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!loadedVersion	self ancestors do: [ :ancestor |		(self repositoryGroup 			versionWithInfo: ancestor			ifNone: [ MCRepositoryGroup default versionWithInfo: ancestor ifNone: [] ])			ifNotNil: [ :version | ^ version ]	].! !!IceMCVersionInfo class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!package: package message: commitMessage	^ self new fromPackage: package message: commitMessage! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/21/2017 17:44:57'!uuidFromCommit: aCommit package: aPackage.	^ self uuidFromSHA: (SHA1 new hashStream: (ReadStream on: aCommit id, aPackage name))! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/21/2017 17:44:57'!uuidFromSHA: cid	"Return an adequate uuid from a git commit ID. Copied from GitFileTree."	^ UUID nilUUID		in: [ :uuid |			1 to: 16 do: [ :i | uuid at: i put: (cid at: i) ].			uuid at: 9 put: (16r80 bitOr: ((uuid at: 9) bitAnd: 16r3F)).	"Type"			uuid at: 7 put: (16r50 bitOr: ((uuid at: 7) bitAnd: 16r0F)).	"Version 5 : SHA-1 Namespace (git)."			uuid ]! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ commit! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!fromCommit: aCommit package: aPackage	"This method can be used for first initializing a version info or to update a partially initialized version info."	"See #fromPackage:message:"	commit := aCommit.	package := aPackage.	   	date := commit datetime asDate.   	time := commit datetime asTime.		name := ('{1}-{2}.{3}' format: {		package name. 		commit compatibleUsername. 		commit datetime asUnixTime 	}).		id := self class uuidFromCommit: aCommit package: aPackage.   	message := commit comment.   	author := commit compatibleUsername! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!fromPackage: package message: commitMessage	"This creates a partial version info. Full version info can not be created until we commit into a repository, 	but current fileout tools require it, so we first create an incomplete info and after committing it will be completed	by sending #fromCommit:package:		To improve this implementation we should review the fileout process."	name := ('{1}-{2}.{3}' format: {package name. Author fullName. 'unknown'}).	message := commitMessage.! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iceVersion	^ commit versionFor: package! !!IceMCVersionInfo methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!loadAncestorsAndStepChildren	self shouldBeImplemented ! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!MCClassDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!classCategory	"Avoid direct use of #category, because MCClassDefinitions and 	MCMethodDefinition use the same message for different things. "	^ self category! !!MCVersion methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!directoryName	^ (MCFileTreeRepository parseName: self info name) first , '.package'! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:57'!ruleRBReturnsBooleanAndOtherRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepositoryModel #canPush #false)) #'2016-10-25T18:44:14.262953+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:57'!ruleRBTempsReadBeforeWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepository #outgoingCommits #false)) #'2016-06-16T17:24:18.524965+02:00') #(#(#RGMethodDefinition #(#IceMCGitRepository #outgoingCommits #false)) #'2016-07-06T15:14:46.350843+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:57'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#IceGitFileTreeCommitWalk)) #'2016-09-21T17:13:36.812598+02:00') )! !!IceMetadatalessStCypressWriter class methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!on: aStream	^ self new stream: aStream! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeClassDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeClassDefinition: definition ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeDefinitions: aCollection	| classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |	self writeBasicDefinitions: aCollection.	extensionClasses := OrderedCollection new.	extensionMethodDefinitions := OrderedCollection new.	methodHolders := self classDefinitions , self traitDefinitions.	self methodDefinitions		keysAndValuesDo:			[ :className :extensionMethods | 			methodHolders				at: className				ifAbsent:					[ extensionClasses add: className.					extensionMethodDefinitions addAll: extensionMethods ] ].	extensionClasses		do: [ :className | self methodDefinitions removeKey: className ].	self		writeMethodHolderDefinitions: self traitDefinitions		extension: '.trait'		to: ''		do:			[ :definition :classPath | self writeTraitDefinition: definition to: classPath ].	self		writeMethodHolderDefinitions: self classDefinitions		extension: '.class'		to: ''		do:			[ :definition :classPath | self writeClassDefinition: definition to: classPath ].	classDirExtension := '.extension'.	extensionMethodMap := Dictionary new.	extensionMethodDefinitions		do:			[ :methodDefinition | 			| classPath |			(extensionMethodMap				at: methodDefinition className				ifAbsent:					[ extensionMethodMap						at: methodDefinition className						put: OrderedCollection new ]) add: methodDefinition.			classPath := methodDefinition className , classDirExtension				, self fileUtils pathNameDelimiter asString.			self writeExtensionClassDefinition: methodDefinition to: classPath ].	extensionMethodMap		keysAndValuesDo:			[ :className :classMethodDefinitions | 			| classPath filenameMetaMap |			filenameMetaMap := self fileNameMapFor: classMethodDefinitions.			classMethodDefinitions				do:					[ :methodDefinition | 					| filename methodPath |					filename := (filenameMetaMap at: methodDefinition classIsMeta)						at: methodDefinition selector.					classPath := methodDefinition className , classDirExtension						, self fileUtils pathNameDelimiter asString.					methodPath := classPath						,							(methodDefinition classIsMeta								ifTrue: [ 'class' ]								ifFalse: [ 'instance' ])						, self fileUtils pathNameDelimiter asString.					self						writeMethodDefinition: methodDefinition						to: methodPath						filename: filename ] ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeMethodProperties: classMethodDefinitions	"We don't want to write that."	self shouldNotImplement! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeTraitDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeTraitDefinition: definition ]! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addChange: aChange! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addToPackageChangeSet: anIcePackageChangeSet 	anIcePackageChangeSet addChangedClass: self iceClass! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceClass	^ IceClassReference forDefinition: self! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	^ self iceClass ifNotNil: #package! !!MCPostscriptDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addToPackageChangeSet: anIcePackageChangeSet 	"By doing nothing, this definition will not be shown in the changes tree."! !!MCMethodDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!classCategory	^ self actualClass ifNotNil: #category ifNil: [ RPackage defaultPackageName ]! !!MCMethodDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	^ self isExtensionMethod 		ifTrue: [ Iceberg packageForCategoryNamed: (self protocol withoutPrefix: '*') ]		ifFalse: [ self iceClass package ] ! !!MCMethodDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!method	^ self actualClass >> self selector! !!IceMetadatalessFileTreeWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!snapshotWriterClass	^ IceMetadatalessStCypressWriter! !!IceMetadatalessFileTreeWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!writeVersion: aVersion	"We have to do that to avoid writing the version info."	| members |	directory := (members := MCFileTreeRepository		parseName: aVersion info name) last.	self deleteExistingPackageStructureFor: members.	self fileUtils ensureDirectoryExists: self packageFileDirectory.	self initializePackageFileDirectoryCache.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!MCGitHubRepository class methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aWorkingCopy	^ aWorkingCopy repositoryGroup repositories 		detect: [ :repo | repo isKindOf: self ] 		ifFound: #commitId		ifNone: nil! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitId	"This kind of repo is associated to a specific commit that was downloaded, 	sadly the only way to know it is to parse the directory name."	| repoRoot |	repoRoot := self repoPath isEmpty ifTrue: [ self directory ] ifFalse: [ self directory parent ].	^ repoRoot basename copyAfterLast: $-.! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	(aMCWorkingCopy repositoryGroup includes: self)		ifTrue: [ aBlockClosure value: self commitId ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!getOrCreateIcebergRepository	| remoteUrl remote |	remoteUrl := self perform: Iceberg remoteTypeSelector.	remote := IceRemote url: remoteUrl.	^ IceRepository registry 		detect: [ :repo | repo origin referencesSameRemoteLocationAs: remote ]		ifNone: [			(IceRepositoryCreator new 				url: remoteUrl;				subdirectory: repoPath;				branchName: self projectVersion;				createRepository)				register ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!httpsUrl	^ 'https://github.com/', projectPath, '.git'! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!scpUrl	^ 'git@github.com:', projectPath, '.git'! !!MCRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	"Do nothing. By default MCRepositories can not provide a commitId for you."! !!RPackage methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceRepository	^ Iceberg repositoryForPackage: self! !!MCClassTraitDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!classCategory	^ self category! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!asIcebergObjectInRepository: backend	^ backend iceCommitFrom: self! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!changesFileNamed: fileName	| lookup myVersion parentVersions |	lookup := [:commit | [ commit entryByPath: fileName ] on: Error do: [ nil ]].	myVersion := lookup value: self.	parentVersions := self parents collect: lookup.		^ (myVersion 		ifNil: [ parentVersions includes: nil ]		ifNotNil: [ parentVersions anySatisfy: [ :version | 				version notNil and: [ version objectId = myVersion objectId ]]]) not! !!FileSystemDirectoryEntry methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!packageName 	^ self asFileReference basenameWithoutExtension! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!files	| deltaFiles |		deltaFiles := Set new.	self filesDo: [ :delta :ignored1 :ignored2 | 		deltaFiles add: delta newFile path.		0 "Continue" ].	^ deltaFiles! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!filesDo: aBlockClosure 	^ self filesDo: aBlockClosure binaryFilesDo: aBlockClosure hunksDo: nil linesDo: nil		! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!includesFileNamed: path	^ (self filesDo: [ :delta :second :third | 		| modifiedFileName |		modifiedFileName := delta newFile path.		(modifiedFileName beginsWith: path) asAlien	]) asBoolean.! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!name	^ self filename! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!readStreamDo: aBlock	aBlock value: (ReadStream on: self object contents asString)! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!tree	^ self object! !!LGitTag methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!asIcebergObjectInRepository: backend	^ IceTag named: self name inRepository: backend frontend! !!IceGitUsernameOrEmailNotFound class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!guessKind: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' 		or: [ anError messageText = 'Failed to parse signature - Signature cannot have an empty name or email' ] ])		ifTrue: [ self signal ].	notBlock value! !!IceLocalRepositoryMissing class methodsFor: 'exceptioninstantiator' stamp: ' 7/21/2017 17:44:57'!signalFor: repository	^ self new 		repository: repository;		signal! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageText	^ self name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: anObject	name := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner	^ owner! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner: anObject	owner := anObject! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageText	^ 'There is no version for package: {1} in  commit {2}' 		format: { 			self version packageName.			self version commit shortId		}! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!version	^ version! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!version: anObject	version := anObject! !!LGitReturnCodeEnum methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!asBoolean	^ self value = 0 ifTrue: false ifFalse: 		[ self value = 1 ifTrue: true ifFalse: 		[ self error: self printString, ' can''t be converted to a boolean' ]]! !!IcePackageLoaded class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!version: version 	^ self new loadedVersion: version! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedVersion	^ loadedVersion! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedVersion: anObject	loadedVersion := anObject! !!IceRepositoryAnnouncement class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: repository	^ self new repository: repository; yourself! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceRepositoryRegistryModified class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository	^ self new repository: aRepository; yourself! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!LGitCredentialsPlaintext methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!readFrom: credentials	self username: credentials username.	self passphrase: credentials password.  ! !!MCOrganizationDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addOrganisationChange: aChange! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceClass	^ nil! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	"TODO: Refactor this, see https://github.com/npasserini/iceberg/issues/42"	self categories 		ifNotEmpty: [ ^ Iceberg packageForCategoryNamed: (self categories anyOne) ]	 	ifEmpty: nil! !!MCPatchOperation methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addToPackageChangeSet: anIcePackageChangeSet 	self definition addToPackageChangeSet: anIcePackageChangeSet ! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!asIceChangeSet	^ IceMethodChange new 		operation: self; 		yourself.! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceClass	^ self definition iceClass! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	^ self definition icePackage! !!IceAbstractCommitWalk class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forRepository: repository	^ self new repository: repository; yourself! !!IceAbstractCommitWalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitFrom: result	^ self repository iceCommitFrom: result! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!commits	| commits |	commits := OrderedCollection new.	self commitsDo: [ :commit | commits add: commit ].	^ commits! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!commitsDo: aBlock 	self rawResultsDo: [ :result | aBlock value: (self commitFrom: result) ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!includesCommit: aCommit	self commitsDo: [ :commit | 		commit id = aCommit id ifTrue: [ ^ true ]].	^ false! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!maxNumber	^ maxNumber! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!maxNumber: anObject	maxNumber := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!modifyingPackage	^ modifyingPackage! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!modifyingPackage: anObject	modifyingPackage := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!upto: aCommitish	aCommitish hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoBranch: anIceBranch 	self uptoCommit: anIceBranch lastCommit! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoBranches: branches	^ branches do: [ :branch | self uptoBranch: branch ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoCommits: commits	commits do: [ :commit | self uptoCommit: commit  ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoVersion: version	version hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!versionsFor: package	self modifyingPackage: package.	^ self commits collect: [ :commit | commit versionFor: package ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock	self modifyingPackage: package.	self commitsDo: [ :commit | 		| version | 		version := commit versionFor: package.		(selectBlock value: version) ifTrue: [ ^ version ]	].	^ ifNoneBlock value  ! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ announcer! !!IceAbstractDiff methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!description	^ self name! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!elements	^ elements ifNil: [ 		elements := self initialElements sorted: [ :a :b | a description < b description ] ]! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	^ self subclassResponsibility ! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	announcer := Announcer new.! !!IceAbstractDiff methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	elements ifNotNil: [ elements do: #refresh ].	elements := nil.	announcer announce: IceChangeSetChanged new.! !!IceAbstractDiff methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!whenChangedDo: aBlock	announcer when: IceChangeSetChanged do: aBlock! !!IceChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel 	aDiffModel		contextClass: nil;		leftText: '';		rightText: ''.! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ self organizationDescription: self newOrganization! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!newOrganization	^ newOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!newOrganization: anObject	newOrganization := anObject! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!oldOrganization	^ oldOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!oldOrganization: anObject	oldOrganization := anObject! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!organizationDescription: tags 	^ String streamContents: [ :stream |		stream nextPutAll:	'Package tags: '.		tags do: [ :elem | 			stream nextPutAll: String crlf;				nextPutAll: String tab;				nextPutAll: elem.	]]! !!IcePackageOrganizationChange methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!removedCategories	^ self oldOrganization difference: self newOrganization ! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ self organizationDescription: self oldOrganization! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	aDiffModel		contextClass: nil;		leftText: (self organizationDescription: self newOrganization);		rightText: (self organizationDescription: self oldOrganization).! !!IceClassChangeSet class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!class: aClass parent: anIcePackageChangeSet 	^ self new 		targetClass: aClass; 		parent: anIcePackageChangeSet; 		yourself.! !!IceClassChangeSet methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!analyseChanges	| newChanges |	newChanges := self parent changes select: [ :operation | 		operation iceClass = self targetClass ].		newChanges		detect: [ :operation | operation definition isClassDefinition ]		ifFound: [ :classDef | 			classDefinition := classDef. 			changes := newChanges copyWithout: classDef.		]		ifNone: [ changes := newChanges ].! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self targetClass browse! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browseReferences	self targetClass browseReferences! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ self targetClass canBeBrowsed! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ self targetClass canBrowseReferences! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changes	^ changes ifNil: [ self analyseChanges. changes ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!classDefinition	^ classDefinition ifNil: [ self analyseChanges. classDefinition ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self targetClass description! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ self classDefinition 		ifNotNil: #icon		ifNil: [	self isExtension			ifTrue: [ Smalltalk ui icons iconNamed: #protocolExtension ] 			ifFalse: [ self targetClass icon ]]! !!IceClassChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	^ self changes collect: #asIceChangeSet! !!IceClassChangeSet methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!isExtension	^ parent package name ~= self packageName! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ self classDefinition ifNotNil: #diffToSource! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	^ self classDefinition! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ self targetClass package! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self targetClass packageName! !!IceClassChangeSet methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		nextPutAll: targetClass description;		nextPut: $)		! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass	^ targetClass! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass: anObject	targetClass := anObject! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ self classDefinition ifNotNil: #diffFromSource! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	self classDefinition		ifNil: [ super updateDiff: aDiffModel ]		ifNotNil: [ :cd |			aDiffModel				contextClass: nil;				leftText: cd diffToSource;				rightText: cd diffFromSource		]! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self method browse! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ self operation canBeBrowsed! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ false! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!description	^ operation definition selector! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ self operation icon! !!IceMethodChange methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	^ {}! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!method	^ self operation definition method! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ self operation diffToSource! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	^ operation! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation: anObject	operation := anObject! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ self operation definition actualClass package! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package name! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: operation definition summary;		nextPut: $)! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ self operation diffFromSource! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	aDiffModel		contextClass: self operation targetClass;		leftText: self operation diffToSource;		rightText: self operation diffFromSource.! !!IcePackageChangeSet class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!package: aPackage parent: anIceDiff 	^ self new 		package: aPackage;		parent: anIceDiff;		yourself! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/21/2017 17:44:57'!addChange: change	changes add: change! !!IcePackageChangeSet methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!addChangedClass: anIceClassReference 	changedClasses add: anIceClassReference ! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/21/2017 17:44:57'!addOrganisationChange: change	change isAddition ifTrue: [ ^ self newOrganization: change definition categories ].	change isRemoval ifTrue: [ ^ self oldOrganization: change definition categories ].	self error: 'Can not handle definition'.! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!analyseChanges	| newChanges |	newChanges := self basicChanges.	newChanges ifEmpty: [ 		(self package isLoaded 			and: [ self package isModified			and: [(self parent myVersion isKindOf: IceWorkingCopy) 			and: [ self parent theirVersion isKindOf: IceLoadedCode ]]])			ifTrue: [ self package workingCopy modified: false ]].		changes := OrderedCollection new.	newChanges do: [ :change | 		change definition 			addAnalysisToPackageChangeSet: self			change: change ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!basicChanges	| mine theirs |	self package isLoaded ifFalse: [ ^ #() ].	mine := self parent mySnapshot: self package.	theirs := (self package isExported 		ifTrue: [ self parent theirSnapshot: self package ]		ifFalse: [ MCSnapshot empty ]).	^ (mine notNil and: [ theirs notNil ]) 		ifTrue: [ (MCPatch fromBase: theirs target: mine) operations ]		ifFalse: [ #() ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!basicOrganizationChange	^ organizationChange ifNil: [ organizationChange := IcePackageOrganizationChange new. ]! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self package browse! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ true! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ false! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!changedClasses	^ (self changes collect: #iceClass as: Set) 		sorted: [ :a :b | a description > b description ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!changes	^ changes ifNil: [ 		self analyseChanges. 		changes ]! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!description	^ self package packageName! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasChanged	^ self changes notEmpty or: [ self organizationChange notNil ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasChanges	^ self elements notEmpty! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: 		(self hasChanges 			ifTrue: [ #dirtyMonticelloPackage ]			ifFalse: [ #emptyPackage  ])! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	changedClasses := Set new.	self changes do: [ :change | change addToPackageChangeSet: self ].	^ changedClasses collect: [:class | IceClassChangeSet class: class parent: self ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isExtension: changeSet	^  changeSet package ~= self package correspondingRPackage! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ organizationChange ifNotNil: #myVersion! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newOrganization: aCollectionOfTags	self basicOrganizationChange newOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!oldOrganization: aCollectionOfTags	self basicOrganizationChange oldOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	"This operation is not modeled in MC"	^ nil! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!organizationChange	^ organizationChange ifNil: [ self analyseChanges. organizationChange ]! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package: anObject	package := anObject! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package name! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self package packageName;		nextPut: $)! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	changes := nil.	organizationChange := nil.	super refresh.! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ organizationChange ifNotNil: #theirVersion! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	organizationChange 		ifNotNil: [ :change | change updateDiff: aDiffModel ]		ifNil: [ super updateDiff: aDiffModel ]! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self asString! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parent	^ parent! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parent: anObject	parent := anObject! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forRepository: aRepository 	^ self new 		repository: aRepository;		myVersion: IceCommitish image;		theirVersion: aRepository loadedCode;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forRepository: aRepository commit: anIceCommitInfo	^ self new 		repository: aRepository;		theirVersion: anIceCommitInfo;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!from: myCommitish to: theirsCommitish	^ self new 		repository: myCommitish repository;		myVersion: myCommitish;		theirVersion: theirsCommitish;		yourself.! !!IceDiff methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canRevertChanges	^ self myVersion canRevertChanges ! !!IceDiff methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!changedPackages	^ self elements select: #hasChanged thenCollect: #package! !!IceDiff methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createChangeSetFor: package	^ IcePackageChangeSet package: package parent: self! !!IceDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	| changedPackages |	changedPackages := self myVersion changedPackagesTo: self theirVersion.	^ changedPackages collect: [ :package | self createChangeSetFor: package ]! !!IceDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	myVersion := IceCommitish image.! !!IceDiff methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mySnapshot: package	^ self myVersion snapshotFor: package	! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!myVersion	^ myVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!myVersion: anObject	myVersion := anObject! !!IceDiff methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self repository location pathString;		nextPut: $)! !!IceDiff methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	self repository refresh.	elements ifNotNil: [ elements do: #refresh ].	announcer announce: IceChangeSetChanged new.! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject.	repository announcer weak		subscribe: IceCommited send: #refresh to: self! !!IceDiff methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!revertChange: anIceMethodChange 	self myVersion revertChange: anIceMethodChange.	self refresh.! !!IceDiff methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!theirSnapshot: package 	^ theirVersion ifNotNil: [ 		theirVersion snapshotFor: package ]! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ theirVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!theirVersion: anObject	theirVersion := anObject! !!IceAbstractVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forPackage: package	^ self new package: package; yourself! !!IceAbstractVersion methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!beCurrent	"By default do not to anything, version should have a package manager that makes them current without Iceberg intervention."! !!IceAbstractVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ #()! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package: anObject	package := anObject! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self package repository! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!snapshot	^ [ self mcVersion snapshot ] on: IceVersionDoesNotExist do: [ MCSnapshot empty ]! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!updated	^ self! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ nil! !!IceForeignVersion methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ self package workingCopy gtDisplayString ! !!IceForeignVersion methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk	"Do nothing. I can't filter a commit walk because I do not know my commit."! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcVersion	^ mcVersion ifNil: [ mcVersion := self package workingCopy loadedVersion ]! !!IceForeignVersion methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: 			(mcVersion 				ifNotNil: [ mcVersion printString ] 				ifNil: [ self package name ]);		nextPut: $).! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forPackage: package	"Use fromCommit:package: instead"	self shouldNotImplement ! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!fromCommit: commit package: package	^ self new		commit: commit;		package: package;		yourself! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	self species = another species ifFalse: [ ^ false ].		"If I both load commits are equal, we are the same version."	self commit = another commit ifTrue: [ ^ true ]. 	"If not, look for actual origination commits and compare them."	^ self originatingCommit = another originatingCommit.! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!author	^ self info author! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!beCurrent 	"Ensure that the working copy points to the right info."	self package workingCopy versionInfo: self info.	! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ commit! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit: anIceCommit	commit := anIceCommit ! !!IceSavedPackageVersion methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ self commit description ! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entry	^ entry! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entry: anObject	entry := anObject.	entry repository: self repository! !!IceSavedPackageVersion methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self commit! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	"Returns only the commits modifying this package."	^ self repository newCommitWalk 		fromHead;		uptoVersion: self; 		versionsFor: self package! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!info	^ info ifNil: [ info := IceMCVersionInfo new fromCommit: self commit package: package ]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!info: anObject	info := anObject! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isAncestorOf: anotherVersion	^ self commit isAncestorOf: anotherVersion commit! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isAncestorOfCommitId: anotherCommitId	^ self commit isAncestorOf: (self repository commitAt: anotherCommitId)! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isNewerThan: another	^ self info timeStamp > another info timeStamp! !!IceSavedPackageVersion methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!load	self mcVersion load.	self repository versionLoaded: self.! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!mcVersion	^ self repository backend mcVersionFor: self! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!nextVersionName	^ ('{1}-{2}.{3}' format: {		self package packageName. 		self author. 		self info versionNumber + 1	})! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!originatingCommit	^ originatingCommit ifNil: [ originatingCommit := 		self repository newCommitWalk 			fromCommit: self commit;			modifyingPackage: self package;			firstCommit 		]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package packageName! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!parent	^ (self repository newCommitWalk 		fromCommit: self commit; 		modifyingPackage: self package;		maxNumber: 2;		commits)		second "First commit will be my own commit, the second is my parent"		versionFor: self package.! !!IceSavedPackageVersion methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: self package name.	commit ifNotNil: [ 		aStream 		nextPutAll: ', loaded from: ';		nextPutAll: commit shortId ].			originatingCommit ifNotNil: [ 		aStream 			nextPutAll: ', committed in: ';			nextPutAll: originatingCommit shortId ].			aStream nextPut: $).! !!IceTemporaryVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!commit	"I am a temporary version, I am not related to any commit or it is unknown. 	When computing a reference commit I must be ignored."	^ nil! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!snapshot	"I am only a temporary version, I can't provide a meaningful snapshot"	^ MCSnapshot empty! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!updated	| newVersion |	newVersion := self package computeLoadedVersion.	self package repository loadedCode versionLoaded: newVersion.	^ newVersion! !!IceBackendWriterAdapter class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: anIceBackend	^ self new backend: anIceBackend; yourself.! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend	^ backend! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend: anObject	backend := anObject! !!IceBackendWriterAdapter methodsFor: 'accesing' stamp: ' 7/21/2017 17:44:57'!directory	^ self backend codeDirectory ! !!IceBackendWriterAdapter methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!propertyFileExtension	^ MCFileTreeRepository defaultPropertyFileExtension! !!IceClassReference class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forDefinition: anMCDefinition	^ anMCDefinition actualClass 		ifNil: [ IceRemovedClassReference for: anMCDefinition ]		ifNotNil: [:class | IceSimpleClassReference new targetClass: class ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= other	^ other class = self class and: [ other description = self description ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!hash	^ self description hash! !!IceRemovedClassReference class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aMCClassDefinition 	^ self new		targetClassName: aMCClassDefinition className;		packageName: aMCClassDefinition classCategory		yourself! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	IceTool uiManager 		abort: ('Class {1} was removed from the system' format: { self targetClassName })		title: 'Unable to browse class'! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ false! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ false! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self targetClassName ! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeRemove ! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ packageName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName: anObject	packageName := anObject! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClassName	^ targetClassName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClassName: anObject	targetClassName := anObject! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self targetClass browse! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browseReferences	self systemNavigation browseAllCallsOnClass: self targetClass! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ true! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ true! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self targetClass name! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #class! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self targetClass package name! !!IceSimpleClassReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		print: self targetClass;		nextPut: $)! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass	^ targetClass! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass: anObject	targetClass := anObject! !!IceBranch class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isRemoteBranchName: branchName	^ ((branchName beginsWith: 'refs/remotes/') 		or: [ branchName beginsWith: 'remotes/' ])! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName inRepository: repo	^ self 		named: branchName		local: (self isRemoteBranchName: branchName) not		inRepository: repo! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName local: isLocal inRepository: repo	^ (isLocal ifTrue: IceLocalBranch ifFalse: IceRemoteBranch)		named: branchName inRepository: repo.! !!IceBranch methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= anotherBranch	self species = anotherBranch species ifFalse: [ ^ false ].	self repository = anotherBranch repository ifFalse: [ ^ false ].	^ self name = anotherBranch name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend	^ self repository backend! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesToCommitInfo: aCommitish	^ aCommitish changedPackagesToCommitInfo: self lastCommit! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commits	^ self repository newCommitWalk fromBranch: self; commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitsNotIn: anotherBranch	^ self repository newCommitWalk		fromBranch: self;		uptoBranch: anotherBranch;		commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!includesCommit: commit	^ self lastCommit isDescendantOf: commit! !!IceBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLocal	^ false! !!IceBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isRemote	^ false! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!lastCommit	"The first commit in the list was the last in time."	^ self repository newCommitWalk fromBranch: self; firstCommit! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: anObject	name := anObject! !!IceBranch methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $).! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package	^ self lastCommit snapshotFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock 	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package detect: selectBlock ifNone: ifNoneBlock ! !!IceLocalBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName inRepository: repo	^ self new 		name: (branchName withoutPrefix: 'refs/heads/'); 		repository: repo; 		yourself! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!basename	^ self name! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!committish	^ (self name includesSubstring: 'detached')		ifTrue: [ ('\(detached from ([0-9a-f]+)\)' asRegex) matches: self name; subexpression: 2 ]		ifFalse: [ self name ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ self upstream		ifNotNil: [ self upstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommitsFrom: aRemote 	^ (self upstreamFor: aRemote) 		ifNotNil: [ :remoteUpstream | remoteUpstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLocal	^ true! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommits: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	self upstream 		ifNotNil: [ walk uptoBranch: self upstream ]		ifNil: [ walk uptoBranches: (			self repository localBranches copyWithout: self) ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote do: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	(self upstreamFor: aRemote)		ifNotNil: [ :aRemoteBranch | walk uptoBranch: aRemoteBranch ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!upstream	^ upstream ifNil: [ 		self backend upstream 			ifNotNil: [ :upstreamName |				upstream := (IceRemoteBranch named: upstreamName inRepository: self repository) ] ]! !!IceLocalBranch methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!upstreamFor: aRemote	^ aRemote 		upstreamForBranch: self		backend: self backend! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName inRepository: repo	^ self new 		name: ((branchName withoutPrefix: 'refs/') withoutPrefix: 'remotes/'); 		repository: repo; 		yourself! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!remoteName: remoteName branchName: branchName inRepository: aRepository 	^ self new 		name: remoteName, '/', branchName; 		repository: aRepository; 		yourself! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!basename	^ self name copyAfterLast: $/! !!IceRemoteBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isRemote	^ true! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteName	^ self name copyUpToLast: $/! !!IceCommitInfo class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!createFrom: aGitLogLine	^ self new 		initializeFrom: aGitLogLine;		yourself.! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	^ another species = self species and: [ self commitId = another commitId ]! !!IceCommitInfo methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!backend	^ self repository backend! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesTo: aCommitish	"If is first commit, it will have no parents. Answer all packages because 	 all are 'changed'"	aCommitish ifNil: [ ^ self repository savedPackages ].	^ aCommitish changedPackagesToCommitInfo: self ! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesToCommitInfo: aCommitInfo	| files packageNames |	files := self backend changedFilesBetween: self and: aCommitInfo.	packageNames := (files 		select: [ :each | each includesSubstring: '.package' ] 		thenCollect: [ :each | | packageName |			packageName := each copyFrom: 1 to: (each findString: '.package') - 1.			(packageName includesSubstring: '/') 				ifTrue: [ packageName copyAfterLast: $/ ]				ifFalse: [ packageName ] ])		asSet.	^ packageNames sorted		select: [ :each | self repository includesPackageNamed: each  ] 		thenCollect: [ :each | self repository packageNamed: each ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!comment	^ comment! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!comment: anObject	comment := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitId	^ commitId! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitId: anObject	commitId := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!compatibleUsername	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ self username reject: [ :each | each = Character space ]	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datetime	^ datetime! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datetime: anObject	datetime := anObject! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ String streamContents: [ :stream | 		stream 			nextPutAll: self shortId; 			nextPutAll: ' (';			nextPutAll: self printShortTime;			nextPut: $) ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffFromHead	^ IceDiff from: self repository headCommit to: self! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffTo: aCommitInfo	^ IceDiff from: self to: aCommitInfo! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffToParent	^ self diffTo: (self parents 			ifNotEmpty: #first			ifEmpty: [ nil ])! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!hash	^ self id hash! !!IceCommitInfo methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!id	^ commitId! !!IceCommitInfo methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeFrom: aGitLogLine	"Reads commit info out of a git commit log line, such as: '|f659e2851cb84eb6812b19e5a820c06fb509b0d5|Nicolás Passerini|2016-05-27 09:20:49 +0200|ea6c151|Updated test method with version 2'. 	This lines are obtained with git log options: '--format=|%H|%an|%ai|%p|%s' as in IceRepository>>incomingCommits. "	| elements |	elements := $| split: aGitLogLine.	self		commitId: (elements at: 2);		username: (elements at: 3);		datetime: (DateAndTime readFrom: (elements at: 4) readStream );		parentIds: ((Character space split: (elements at: 5) trim) select: #notEmpty);		comment: (elements at: 6)! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isAncestorOf: anotherCommit	"Warning: this method considers that a commit is ancestor of itself."	^ self = anotherCommit 		or: [ anotherCommit isDescendantOf: self]! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!isCurrent	^ repository loadedCode referenceCommit = self ! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isDescendantOf: aCommit	^ self repository newCommitWalk		fromCommit: self;		includesCommit: aCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self isAncestorOf: repository loadedCode referenceCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!isMerged	^ repository branch includesCommit: self! !!IceCommitInfo methodsFor: 'detached head' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!load	(self changedPackagesTo: self repository loadedCode referenceCommit)		collect: [ :package | self versionFor: package ]		thenDo: [:version | version load ]! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge	self repository merge: self! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseWith: anotherCommit	^ self repository commitAt: 		(self repository backend mergeBaseBetween: self id and: anotherCommit id)! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergeInto: aBranch	self repository 		merge: self		into: aBranch! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ self shortId! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!ownVersions	^ self repository savedPackages collect: [ :package | 		self versionFor: package ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!packageNames	^ self repository backend packagesPresentOn: self! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentIds	^ parentIds! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentIds: anObject	parentIds := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parents	^ parents ifNil: [ 		parents := parentIds 			collect: [ :parentId | self repository commitAt: parentId ] ]! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self commitId first: 7);		nextPutAll: ', ';		print: self datetime;		nextPutAll: ', ';		nextPutAll: comment;		nextPut: $)		 ! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printShortTime	^ self datetime asDate = Date today	ifTrue: [ self datetime asTime asString ]	ifFalse: [ self datetime asDate asString ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!shortId	^ commitId first: 7! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package 	^ (self versionFor: package) ifNotNil: #snapshot! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!status	self isCurrent ifTrue: [ ^ 'Current' ].	self isLoaded ifTrue: [ ^ 'Loaded' ].	self isMerged ifTrue: [ ^ 'Not loaded' ].	^ 'Not merged'! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ username! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: anObject	username := anObject! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: package	^ IceSavedPackageVersion fromCommit: self package: package! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsChangedSince: anotherCommit	| changes | 		changes := OrderedCollection new.	self repository loadedPackages do: [ :package | 		| myVersion theirVersion |		myVersion := self versionFor: package.		theirVersion := anotherCommit versionFor: package.		(myVersion = theirVersion)			ifFalse: (changes add: myVersion)	].		^ changes! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromCommit: self;		versionsFor: package! !!IceCommitish class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!image	^ IceWorkingCopy instance! !!IceCommitish methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canRevertChanges	^ false! !!IceCommitish methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesTo: aCommitish	"This method will implement a double dispatch, since the strategies to resolve deltas 	 change if you are comparing: 		- loaded code -> working copy		- a commit -> a branch 		- a commit -> a commit	 and they need to be treated differently"	^ self subclassResponsibility! !!IceCommitish methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffWith: aCommitish	^ IceDiff from: self to: aCommitish ! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommitsFrom: aRemote	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ self outgoingCommits: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommits: aBlockClosure 	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote 	^ self outgoingCommitsTo: aRemote do: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote do: aBlock	^ #()! !!IceCommitish methodsFor: 'detached head' stamp: ' 7/21/2017 17:44:57'!refresh	"Do nothing. This provides polymorphism with IceBranches, in a repo with a detached head."! !!IceLoadedCode class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: repository	^ self basicNew 		repository: repository; 		initialize; 		yourself! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesToWorkingCopy: aWorkingCopy	| lastCommit commitPackageNames loadedPackageNames added removed |		lastCommit := self repository branch lastCommit.	commitPackageNames := lastCommit packageNames.	loadedPackageNames := self repository loadedPackages collect: #name.	added := (loadedPackageNames \ commitPackageNames) 		collect: [ :each | self repository packageNamed: each ]. 	"this will give me the removals, but I'm still don't know what to do with them	 (because if I just add it it will show them as added not as removed)"	"removed := (commitPackageNames \ loadedPackageNames)		reject: [ :each | self repository includesPackageNamed: each ]		thenCollect: [ :each | IceSavedPackage named: each repository: self repository ]."	^ added, (self loadedVersions keys select: #isModified)! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!commited: newCommit changingPackages: packages	self repository addCommit: newCommit.	packages do: [ :package | self versionLoaded: (newCommit versionFor: package) ].	referenceCommit := newCommit.	repository announcer announce: IceCommited new.! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!commitsNotLoaded	^ self repository newCommitWalk		fromHead;		upto: self referenceCommit;		commits ! !!IceLoadedCode methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!computeReferenceCommit	| candidates |		"1. If no code has been loaded, take HEAD commit as reference."	self loadedVersions isEmpty ifTrue: [ ^ self repository headCommit ].			"2. Happy path: see if all loaded code has the same updation commit. 	If we can't compute an updation commit for some loaded code, it means that it has been 	probably loaded from another kind of repository, we just ignore it."	candidates := (self loadedVersions collect: [:version | version commit] as: Set) reject: #isNil.	candidates size = 1 ifTrue: [ ^ candidates anyOne ].	"3. None of the loaded versions produced a non nil candidate, just use the HEAD commit"		candidates isEmpty ifTrue: [ ^ self repository headCommit ].	"4. We could try other strategies... but this should be good for now."		^ candidates detectMax: #datetime! !!IceLoadedCode methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ self loadedVersions 		ifEmpty: ['No package loaded']		ifNotEmpty: [ self referenceCommit description ] ! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedVersions	^ loadedVersions ifNil: [ 		loadedVersions := Dictionary new.		repository loadedPackages do: [ :pkg | self versionLoaded: pkg computeLoadedVersion ].			loadedVersions 	]! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseWith: aCommit	^ self referenceCommit mergeBaseWith: aCommit! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!referenceCommit	^ referenceCommit ifNil: [ referenceCommit := self computeReferenceCommit ]! !!IceLoadedCode methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!refresh	loadedVersions := nil.	referenceCommit := nil.! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package	^ (self versionFor: package) snapshot! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: package 	^ self loadedVersions 		at: package 		ifPresent: #updated		ifAbsent: [ self loadedVersions at: package put: package computeLoadedVersion ]		! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!versionLoaded: version	self loadedVersions at: version package put: version.	version beCurrent.	"Reset reference commit so that it gets recomputed the next time it is needed"	referenceCommit := nil.! !!IceTag class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: aTagName inRepository: anIceRepository 	^ self new name: aTagName; repository: anIceRepository; yourself! !!IceTag methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!commit	^ commit ifNil: [ commit := self repository newCommitWalk fromTag: self; firstCommit ]! !!IceTag methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self repository backend revparseCommit: self name! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: anObject	name := anObject! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceTag methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: package	^ self commit versionFor: package! !!IceTag methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!versionsFor: package 	^ self commit versionsFor: package! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self name! !!IceUnbornBranch methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self ! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ '<New branch>'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNames	^ #()! !!IceUnbornBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: aPackage 	^ #()! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self name! !!IceUnknownBranch methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self ! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ '<Unknown>'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNames	^ #()! !!IceUnknownBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: aPackage 	^ #()! !!IceWorkingCopy class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!instance	^ Instance ifNil: [ Instance := self new ]! !!IceWorkingCopy methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canRevertChanges	^ true! !!IceWorkingCopy methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesTo: aCommitish	^ aCommitish changedPackagesToWorkingCopy: self! !!IceWorkingCopy methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!revertChange: anIceMethodChange	| loader |	loader := MCPackageLoader new.	anIceMethodChange operation inverse applyTo: loader.	loader load.! !!IceWorkingCopy methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package	^ package workingCopy snapshot! !!IceCredentialsProvider class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!default	^ self providerType new! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plaintextCredentials	^ PlaintextCredentials ifNil: [ PlaintextCredentials := IcePlaintextCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plaintextCredentials: anObject	PlaintextCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!providerType	^ ProviderType ifNil: [ ProviderType := IceCredentialsProvider ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!providerType: anObject	ProviderType := anObject! !!IceCredentialsProvider class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!settingsOn: aBuilder 	<systemsettings>	(aBuilder setting: #useCustomSsh)		parent: #Iceberg;		noOrdering;		target: self;		label: 'Use custom SSH keys';		description: 'Check if you want to have your own pair of keys (id_rsa and id_rsa.pub), without using the ssh-agent';		with: [			(aBuilder setting: #username)				target: self;				targetSelector: #sshCredentials;				label: 'SSH Username';				description: 'If you are trying to connect to github through ssh (something like git@github.com:owner/projectName), the username should be `git`'.			(aBuilder setting: #publicKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Public SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa.pub'.			(aBuilder setting: #privateKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Private SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa'.			(aBuilder setting: #keyPassphrase)				target: self;				targetSelector: #sshCredentials;				label: 'Passphrase of your SSH key'.		].		(aBuilder group: #'Plaintext Credentials')		parent: #Iceberg;		noOrdering;		with: [ 			(aBuilder setting: #username)				target: self;				targetSelector: #plaintextCredentials;				label: 'Github username';				description: 'Your github username'.			(aBuilder setting: #password)				target: self;				targetSelector: #plaintextCredentials;				type: #Password;				label: 'Your github password, if you want Iceberg to remember it, but be aware that this does not pretend to be safe.'.		]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentials	^ SshCredentials ifNil: [ SshCredentials := IceSshCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentials: anObject	SshCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentialsClass	self useCustomSsh ifTrue: [ ^ LGitCredentialsSSH ].	^ LGitCredentialsSSHAgent	! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!useCustomSsh	^ UseCustomSsh ifNil: [ UseCustomSsh := false ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!useCustomSsh: aBoolean	UseCustomSsh := aBoolean! !!IceCredentialsProvider methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	tries := 0.! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plaintextCredentials	^ self class plaintextCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentials	^ self class sshCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentialsClass	^ self class sshCredentialsClass! !!IceMetacelloRepositoryAdapter class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: anIceRepository 	^ self new repository: anIceRepository; yourself! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addTo: aMCRepositoryGroup 	^ aMCRepositoryGroup addBasicRepository: self! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canUpgradeTo: anMCGitBasedRepository 	"Copied from MCGitBasedNetworkRepository"  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath 	and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aWorkingCopy ifFound: aBlock	self flag: #todo. "Do nothing?"! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self repository backend description! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!getOrCreateIcebergRepository	^ self repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!goferPriority	^ 8! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!goferReferences	^ self repository savedPackages collect: [ :package | 		GoferResolvedReference name: package latestVersion info name repository: self ]! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasNoLoadConflicts: anMCGitBasedRepository	"Copied from MCGitBasedNetworkRepository"  	(anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].	^ self projectPath = anMCGitBasedRepository projectPath and: [		self repoPath = anMCGitBasedRepository repoPath and: [ 			self projectVersion = anMCGitBasedRepository projectVersion ] ]! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/21/2017 17:44:57'!isCache	"User for Kommiter and Versionner"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/21/2017 17:44:57'!isRemote	"User for Komitter"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isValid	^ true! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectPath	^ self repository origin projectPath! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectVersion	^ self repository branchName! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repoPath	^ self repository subdirectory ! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryDescription	^ self repository description! !!IceMetacelloRepositoryAdapter methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!repositoryVersionString	^ self repository headCommit id! !!IceMetacelloRepositoryAdapter methodsFor: 'versions' stamp: ' 7/21/2017 17:44:57'!versionFrom: aVersionName 	| packageName package version |	packageName := (MCFileTreeRepository parseName: aVersionName) first.	package := self repository packageNamed: packageName.		version := package latestVersion.	version info name = aVersionName ifFalse: [		version := package versions detect: [ :ver | ver info name = aVersionName ]].		^ version mcVersion				! !!IcePackageReference class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: aPackageName	^ self new 		packageName: aPackageName;		yourself! !!IcePackageReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= anotherPackage	^ anotherPackage species = self species 	and: [ self packageName = anotherPackage packageName ]! !!IcePackageReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	(RPackageOrganizer default packageNamed: self name) browse! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!changesIn: commitish comparedToBase: baseCommitish	^ (MCPatch 		fromBase: (baseCommitish snapshotFor: self)		target: (commitish snapshotFor: self))		operations! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ RPackageOrganizer default includesPackageNamed: packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName: anObject	packageName := anObject! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printDescriptionOn: aStream	aStream nextPut: $(;		nextPutAll: packageName;		nextPutAll: ', ';		nextPutAll: (self isLoaded ifTrue: 'loaded' ifFalse: 'not loaded');		nextPut: $)		! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name.	self printDescriptionOn: aStream! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!workingCopy	^ self isLoaded ifTrue: [		MCWorkingCopy forPackage: (MCPackage named: self packageName)]! !!IcePlaintextCredentials methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPresent	^ self username isEmpty not and: [ self password isEmpty not ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password	^ password ifNil: [ password := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password: anObject	password := anObject! !!IcePlaintextCredentials methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!readFrom: credentials	self username: credentials username.	self password: credentials password! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ username ifNil: [ username := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: anObject	username := anObject! !!IceFileRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ aRepositoryUrl beginsWith: 'file:'! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ { 'Origin' -> path pathString }! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ 'local filesystem'! !!IceFileRemote methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!organizer	^ 'local'! !!IceFileRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	| matcher |	matcher := 'file\://(.*)' asRegex.	(matcher matches: url) 		ifTrue: [ 			path := (matcher subexpression: 2) asFileReference.			projectName := path basename.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse  "file:" url: ', url ]! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ path basename! !!IceHttpRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ (aRepositoryUrl beginsWith: self protocolID, '://') ! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	"Returns the HTTP default port"		^80! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!protocolID	"Return the protocol identifier"		^'http'! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	| matcher |	matcher := '((http|https)\://)(([\w]+)@)*([\w.]+)(\:([\d]+))*(/[\w]+)*/([\w\-]+)/([\w\-.]+(.git)?)' asRegex.	(matcher matches: url) 		ifTrue: [					user := matcher subexpression: 5.			host := matcher subexpression: 6.			port := (matcher subexpression: 8)				ifNotNil: [: x | x asInteger ] 				ifNil: [ self class defaultPort ].				 			path := (matcher subexpressions: 9)				inject: OrderedCollection new 				into: [:coll :each  | coll add: each allButFirst. coll ]. 			owner := matcher subexpression: 10.			projectName := self stripPossibleExtension: (matcher subexpression: 11) ]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!stripPossibleExtension: aString	^ (aString endsWith: '.git')		ifTrue: [ aString allButLast: 4 ]		ifFalse: [ aString ]! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	"Returns the HTTPS default port"		^443! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!protocolID	"Return the protocol identifier"		^'https'! !!IceHttpsRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: aRemote	^ (super referencesSameRemoteLocationAs: aRemote)		or: [ self url = aRemote httpsUrl ] ! !!IceNetworkRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aString 	"I am abstract I can't handle any url."	^ false! !!IceNetworkRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	^self subclassResponsibility! !!IceNetworkRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicUrl: aString	url := (aString endsWith: '.git') 		ifTrue: [ aString ]		ifFalse: [ aString, '.git' ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ { 		'Origin' -> self url.		'Remote User' -> self userName.		'Remote host' -> (self port = self class defaultPort ifTrue: [ self host ] ifFalse: [self host, ':', self portName]).		'Repo Owner' -> self owner.	} ! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ host! !!IceNetworkRemote methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!organizer	^ self owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner	 ^ owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!path	^path ifNil: [ path := OrderedCollection new ].! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!port	^port ifNil: [ self class defaultPort ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!portName	^self port asString! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectPath	^ self owner, '/', self projectName! !!IceNetworkRemote methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: another	^ (self url withoutSuffix: '.git') = (another url withoutSuffix: '.git')! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!user	^user! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!userName	^user ifNil: [ '' ]	! !!IceScpRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	"Very simplistic implementation that does not cover all cases"	^ (aRepositoryUrl beginsWith: 'git@' )		or: [aRepositoryUrl beginsWith: 'ssh://']! !!IceScpRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	^ 22! !!IceScpRemote methodsFor: 'private - patches' stamp: ' 7/21/2017 17:44:57'!httpsUrl	^ 'https://{1}/{2}.git' format: { self host . self projectPath }! !!IceScpRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	| matcher |	matcher := '(ssh\://)?(git@)?([\w.]+)(\:|/)/?([\w\-]+)/([\w\-]+)(\.git)?' asRegex.	(matcher matches: url) 		ifTrue: [			host := matcher subexpression: 4.			owner := matcher subexpression: 6.			projectName := matcher subexpression: 7.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceScpRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: aRemote	^ ((super referencesSameRemoteLocationAs: aRemote)		or: [ self httpsUrl = aRemote httpsUrl ])			! !!IceRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ self subclassResponsibility ! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!name: aName url: anUrl	^ (self url: anUrl)		remoteName: aName;		yourself! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!url: aRepositoryUrl	self allSubclasses  		detect: [ :subclass | subclass canHandleUrl: aRepositoryUrl ]		ifFound: [ :subclass | ^ subclass new url: aRepositoryUrl ]		ifNone: [ IceWrongUrl signal: 'Remote repository scheme not supported: ', aRepositoryUrl ]! !!IceRemote methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	^ self species = another species and: [ self referencesSameRemoteLocationAs: another ]	! !!IceRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicUrl: aString	url := aString! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ #()! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ self subclassResponsibility! !!IceRemote methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!httpsUrl	"This method is used to compare exchangeable addresses (https:// and git@). 	 So it has sense in my children, and is notably used on #isSameUrl: 	 implementations"	^ self url! !!IceRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isOrigin	^ self remoteName = 'origin'! !!IceRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSame: aRemote	^ (self referencesSameRemoteLocationAs: aRemote)		and: [ self remoteName = aRemote remoteName ]! !!IceRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	^ self subclassResponsibility ! !!IceRemote methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: stream	stream 		<< (self remoteName ifNil: [ 'noname' ]) 		<< ' (' << self url << ')'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectBasename	^ self projectName withoutSuffix: '.git'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ projectName! !!IceRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: another	"Base/trivial implementation is that two urls are the same if they are equal, 	but some subclasses have more complicated logic to detect two urls pointing to the same remote"	^ self url = another url	! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteName	^ remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteName: anObject	remoteName := anObject! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!upstreamForBranch: aBranch backend: backend	^ backend 		lookupBranchNamed: aBranch name 		inRemote: self remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url	^ url! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url: aString	self basicUrl: aString.	self parseUrl! !!IceUndefinedRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ false! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ nil! !!IceUndefinedRemote methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	url := 'No remote url'.	projectName := 'No name'.	remoteName := 'No remote'! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!upstreamForBranch: aBranch backend: backend	^ nil! !!IceRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!backend: aBackend	"This should be the only way to create a repository. Usually, this creator is called on 	 IceRepositoryCreator>>#createRepository."	^ self new 		backend: aBackend;		yourself! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultBackend	^ self defaultBackendType		ifNotNil: [ :className | 			Smalltalk				at: className				ifAbsent: [ IceError signal: 'Selected Iceberg backend is missing: ', className ] ]				ifNil: [ 			| backend | 			backend := self detectDefaultBackend.			self defaultBackend: backend.			backend ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultBackend: class	self defaultBackendType: class name! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!defaultBackendType	^ DefaultBackendType ifNil: [ DefaultBackendType := #IceLibgitLocalRepository ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!defaultBackendType: anObject	DefaultBackendType := anObject! !!IceRepository class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!detectDefaultBackend	"Error if not backend"	TIceRepositoryBackend traitUsers 		ifEmpty: [ ^ IceError signal: 'There are no configured backend type' ].		"Detect default backend"	Smalltalk globals 		at: #IceLibgitLocalRepository		ifPresent: [ :class | ^ class ].		^ TIceRepositoryBackend traitUsers anyOne! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!localRepositoriesLocation	^ ((FileLocator respondsTo: #localDirectory) 		ifTrue: [ FileLocator localDirectory / #iceberg ]		ifFalse: [ FileLocator imageDirectory / #'iceberg-cache' ]) asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!registerRepository: aRepository	^ self registry add: aRepository! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!registry	^ Registry ifNil: [ Registry := OrderedCollection new ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoriesLocation 	^ self shareRepositoriesBetweenImages 		ifTrue: [ self sharedRepositoriesLocation ]		ifFalse: [ self localRepositoriesLocation ] ! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!reset	Registry := nil.	Iceberg announcer announce: IceRepositoryForgotten new.! !!IceRepository class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!settingsOn: aBuilder 	<systemsettings>	(aBuilder pickOne: #'defaultBackendType')		parent: #Iceberg;		target: self;		label: 'Backend type';		description: 'Select your preferred way to access git repositories from Iceberg: the git command line (OSSubprocess) or the libgit2 library';		domainValues: 			((TIceRepositoryBackend traitUsers collect: [:class | class description -> class name ]) 				ifEmpty: { 'No backend' -> nil }).		(aBuilder setting: #shareRepositoriesBetweenImages)		parent: #Iceberg;		target: self;		label: 'Share repositories between images';		description: 'Check if you want to have your git repositories cloned by default in a single location that is shared between all your Pharo images';		with: [			(aBuilder setting: #sharedRepositoriesLocationString)				target: self;				type: #Directory;				label: 'Location for shared repositories';				description: 'A directory where you have your git repositories'.		].		! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!shareRepositoriesBetweenImages	^ ShareRepositoriesBetweenImages ifNil: [ ShareRepositoriesBetweenImages := false ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!shareRepositoriesBetweenImages: anObject	ShareRepositoriesBetweenImages := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocation	^ SharedRepositoriesLocation ifNil: [ 		SharedRepositoriesLocation := (FileLocator home / #iceberg) asFileReference ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocation: anObject	SharedRepositoriesLocation := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocationString	^ self sharedRepositoriesLocation fullName! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocationString: aString	SharedRepositoriesLocation := aString asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!unregisterRepository: aRepository ifAbsent: aBlock	^ self registry 		remove: aRepository 		ifAbsent: aBlock ! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!addCommit: newCommit	newCommit repository: self.	self commitDictionary 		at: newCommit id 		put: newCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addFilesToIndex: aListOfPaths	^ self backend 		addFilesToIndex: aListOfPaths! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addPackage: aWorkingCopy	^ self savedPackagesDictionary		at: aWorkingCopy packageName		ifAbsentPut: [			IceSavedPackage 				named: aWorkingCopy packageName 				repository: self ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addPackageNamed: packageName	^ self savedPackagesDictionary		at: packageName		ifAbsentPut: [ IceSavedPackage named: packageName repository: self ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!addRemote: aRemote  	^ self backend addRemote: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!allBranches	^ self backend allBranches	! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ announcer! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer: anObject	announcer := anObject! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend	^ backend! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend: aBackend	aBackend validate.	aBackend frontend: self.	backend := aBackend! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!basicMerge: aCommitish	"Try automatic merge handled by the (git?) repository itself. 	Will raise an IceMergeAborted in case that automatic merge 	detects conflicts that have to be solved manually."	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend merge: aCommitish id.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicOrigin	self isValid ifFalse: [ ^ nil ].	^ [ self backend origin ]		on: LGit_GIT_ENOTFOUND 		do: [ :e | nil ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!beSystemRepository	system := true! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	self isValid ifFalse: [ ^ IceUnknownBranch new ].	^ self backend branch! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self branch name! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!branchesForCheckout	"Returns a list of the most useful branches for being checked out"	| branches |	branches := self backend allBranches.	^ branches select: [ :br |		br isLocal or: [ branches noneSatisfy: [:b | b isLocal and: [ b basename = br basename ]]]	].! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!branchesForMerge: aCommit	"Returns a list of local branches to which we could merge the received commit"	^ self allBranches		select: [:each | (each includesCommit: aCommit) not ].! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/21/2017 17:44:57'!checkForRegistryConflicts	self class registry 		detect: [ :repo | repo location = self location ]		ifFound: [ :repo | self origin = repo origin			ifTrue: [ 				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} and with the same origin URL. If you really whant create another one, please locate it in a different directory.'					 format: {self location pathString}) ]			ifFalse: [				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} but with a different origin URL.You provided {2} and the original repository''s url is {3}.'					 format: {self location. self origin. repo origin}) ]].! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!checkoutBranch: branchName	self backend checkoutBranch: branchName! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitAt: commitId	commitId size = 40 		ifTrue: [ 			^ self commitDictionary 				at: commitId				ifAbsent: [ self lookupCommit: commitId ]].	"Commit id is an abbreviation, sequential search"		(self commitDictionary keys 		select: [ :key | key beginsWith: commitId ]) 		in: [ :possibleKeys | 			possibleKeys size = 1 				ifTrue: [ ^ self commitDictionary at: possibleKeys anyOne ] 				ifFalse: [ possibleKeys isEmpty 					ifTrue: [ ^ self lookupCommit: commitId ] 					ifFalse: [ self error: 'Ambiguous commit hexString: ', commitId  ]]		]! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitAt: commitId ifAbsentPut: aBlock	^ self commitDictionary at: commitId ifAbsentPut: [ 		| newCommit |		newCommit := aBlock value.		newCommit repository: self; yourself 	]! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitCherryPick: pickedCollection withMessage: message	^ self 		commitCherryPick: pickedCollection		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitCherryPick: pickedCollection withMessage: message andParents: parentCommitishList	"Commits a snapshot of definitions (can be a cherry-pick). 	 I need to group definitions in packages and create new versions for those packages, 	 which is annoying but is the price of using MC definitions :)"	| changesByPackage versions |		versions := OrderedCollection new.	changesByPackage := SmallDictionary new.	"Collect changes by package"	pickedCollection 		do: [ :each | (changesByPackage at: each packageName ifAbsentPut: [ Set new ]) add: each ].		"Create patched versions for each package"	changesByPackage 		keysAndValuesDo: [ :packageName :changes | | workingCopy snapshot patcher |			workingCopy := (RPackageOrganizer default packageNamed: packageName) mcWorkingCopy.			snapshot := (self packageNamed: packageName) loadedVersion snapshot.			patcher := MCPatcher snapshot: snapshot.			pickedCollection 				select: [ :each | each operation notNil ]				thenDo: [ :each | each operation applyTo: patcher ].			versions add: (MCVersion new				setPackage: workingCopy package				info: (IceMCVersionInfo package: workingCopy package message: message)				snapshot: patcher patchedSnapshot				dependencies: #()) ].		"save versions"	versions do: [ :each | self backend internalStoreVersion: each ].	"now perform commit"	self doCommitMcVersions: versions withMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitDictionary	^ commitDictionary! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!commitIndexWithMessage: message andParents: parentCommitishList	| packages newCommit |	packages := self stagedPackages.	newCommit := self backend		commitIndexWithMessage: message andParents: parentCommitishList.	self loadedCode 		commited: newCommit changingPackages: packages.	^ newCommit! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitPackages: packagesToCommit withMessage: message	^ self 		commitPackages: packagesToCommit		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitPackages: packagesToCommit withMessage: message andParents: parentCommitishList	| savedVersions |		savedVersions := packagesToCommit collect: [ :package | 		self internalSavePackage: package withMessage: message ].		self		doCommitMcVersions: savedVersions 		withMessage: message 		andParents: parentCommitishList! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitPackagesAndMarkAsMerged: aCommitish	^ self 		commitPackages: self modifiedPackages		withMessage: 'Merging with ', aCommitish id		andParents: { self headCommit . aCommitish }! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitPackagesWithMessage: message	self modifiedPackages 		ifEmpty: [ NothingToCommitException signal ]		ifNotEmpty: [ :packages |			self 				commitPackages: packages				withMessage: message ]! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitsNotLoaded	self backend isUnborn ifTrue: [ ^ #() ].	^ self loadedCode commitsNotLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!contentOfFileNamed: aPathString commit: aCommitId	^ self backend 		contentOfFileNamed: aPathString		commit: aCommitId! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createBranch: branchName	self backend createBranch: branchName.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self origin url, '[', self branchName, ']'! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!detachRemote: aRemote	(self pushRemote isSame: aRemote) ifTrue: [ self pushRemote: nil ].	(self pullRemote isSame: aRemote) ifTrue: [ self pullRemote: nil ]! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!directoryForPackage: mcPackage	| package |	package := self packageNamed: mcPackage name.	^ self subdirectory isEmptyOrNil		ifTrue: [ package directoryName ]		ifFalse: [ self subdirectory, '/', package directoryName ]! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!doCommitMcVersions: versions withMessage: message andParents: parentCommitishList	self addFilesToIndex: (versions collect: [ :version | self directoryForPackage: version package ]).	^ self commitIndexWithMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!ensureBranch: branchName	(self hasLocalBranchNamed: branchName)		ifFalse: [ self createBranch: branchName ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	self fetchFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetchFrom: aRemote		self backend fetchFrom: aRemote.	self refresh.! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/21/2017 17:44:57'!forget	(self class unregisterRepository: self ifAbsent: [ nil ])		ifNotNil: [ Iceberg announcer announce: (IceRepositoryForgotten repository: self) ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasLocalBraches	^ self localBranches isNotEmpty! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasLocalBranchNamed: aString	^ self backend localBranchNames includes: aString! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headCommit	^ self branch lastCommit! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!includesCommit: anIceCommit	^ [ self commitAt: anIceCommit id. true ] 		on: LGit_GIT_ENOTFOUND do: [ false ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!includesPackageNamed: aString	^ self savedPackagesDictionary includesKey: aString! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	self pullRemote ifNil: [ ^ #() ].	^ self incomingCommitsFrom: self pullRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommitsFrom: aRemote	^ (SortedCollection sortBlock: [ :a :b | a datetime > b datetime ])		addAll: self commitsNotLoaded;		addAll: (self branch incomingCommitsFrom: aRemote);		yourself! !!IceRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	system := false. "by default, this is not a system repository"	commitDictionary := Dictionary new.	self initializeAnnouncer.	loadedCode := IceLoadedCode repository: self.! !!IceRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeAnnouncer	announcer 		ifNil: [ announcer := Announcer new ]		ifNotNil: [	announcer subscriptions reset ].	announcer weak		when: IceCommited, IcePackageLoaded 		send: #refresh 		to: self! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!internalSavePackage: package withMessage: commitMessage	"Save a package to the underlying store but do not commit"	| workingCopy newVersion |	workingCopy := 	package workingCopy.	"This hack is copied from MCWorkingCopy code, I do not know why it is necessary."	workingCopy modified: true; modified: false.		(workingCopy repositoryGroup includes: self backend) 		ifFalse: [ workingCopy repositoryGroup addRepository: self backend ].	newVersion := MCVersion new		setPackage: workingCopy package		info: (IceMCVersionInfo package: package message: commitMessage)		snapshot: workingCopy package snapshot		dependencies: #(). "Note we do not track Monticello dependencies."	self backend internalStoreVersion: newVersion.	SystemAnnouncer uniqueInstance		announce: (MCVersionSaved version: newVersion repository: self backend).		^ newVersion ! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isCodeMissing	^ self backend isCodeMissing! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!isFilePartOfAPackage: aFileReferenceRelativeToRepositoryDirectory	| packageSuffix segments |	packageSuffix := '.package'.	segments := aFileReferenceRelativeToRepositoryDirectory path segments.	^ self subdirectory isEmptyOrNil		ifTrue: [ segments first endsWith: packageSuffix ]		ifFalse: [  (segments first = self subdirectory) and: [ segments second endsWith: packageSuffix ] ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isMissing	^ self backend isMissing ! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!isModified	^ self loadedPackages anySatisfy: #isModified! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPullRemote: aRemote	^ self pullRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPushRemote: aRemote	^ self pushRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSystemRepository	"Indicated if this repository is a system repository (for example, 'pharo' itself).	 This is useful because we do not want to treat all repositories the same. System 	 repositories, although present, shouldn't be visible by default (unless desired), 	 for example"	^ system! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isValid	self flag: #todo. "Make this tests more solid"	^ self isMissing not		and: [ self isCodeMissing not ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedCode	^ loadedCode! !!IceRepository methodsFor: 'working copies' stamp: ' 7/21/2017 17:44:57'!loadedPackages	^ self savedPackages select: #isLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!localBranches	^ self backend localBranchNames collect: [ :branchName | 		IceLocalBranch named: branchName inRepository: self ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ self backend location! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: aFileReference	self backend location: aFileReference.	aFileReference ifNil: [ ^ self ].	name := nil. "New location may mean new repository with new name"	self refresh.	! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!lookupCommit: commitId	^ self backend newCommitWalk 		fromCommitId: commitId; 		firstCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: aCommitish	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other types of commitish."	[ self basicMerge: aCommitish ]		on: IceMergeAborted		do: [ :error | self mergeConflictsWith: aCommitish ] ! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: aCommitish into: aBranch	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other 	 types of commitish."	self backend 		merge: aCommitish id 		into: aBranch basename! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseWith: aCommitInfo	^ self loadedCode mergeBaseWith: aCommitInfo! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergeConflictsWith: aCommitish	"Use version merger to create a new version. 	If all conflicts are resolved, commit it to the repository, 	marking it as parent to the received commitish."	| versionsChangedInCommit |	versionsChangedInCommit := aCommitish versionsChangedSince: (self mergeBaseWith: aCommitish).	(MCVersionMerger new		addVersions: (versionsChangedInCommit collect: #mcVersion);		merge)		ifTrue: [ self commitPackagesAndMarkAsMerged: aCommitish ]! !!IceRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!metacelloAdapter	^ IceMetacelloRepositoryAdapter for: self! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!modifiedPackages	^ self loadedPackages 		select: [ :package | package workingCopy needsSaving ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name ifNil: [ name := self origin projectBasename ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: aString	"Change the name of the repository as is seen inside image (real project name resides 	 externally, in repository). This can be confusing, but some times you need it to create new 	 repositories from image (before creating repository externally... which means no remote)"	name := aString! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!newCommitWalk	^ self backend newCommitWalk! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!origin	^ self basicOrigin 		ifNil: [ IceUndefinedRemote new ]! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ self branch outgoingCommits ! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote	^ self branch outgoingCommitsTo: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!packageNamed: packageName	^ self savedPackagesDictionary at: packageName! !!IceRepository methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self origin url;		nextPut: $)! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pull	self pullFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pullFrom: aRemote	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend pullFrom: aRemote.	self refresh.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pullRemote	^ pullRemote ifNil: [ pullRemote := self pushRemote ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pullRemote: aRemote	pullRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!push	self pushTo: self pushRemote! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pushRemote	^ pushRemote ifNil: [ pushRemote := self basicOrigin ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pushRemote: aRemote	pushRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushTo: aRemote		self backend pushTo: aRemote.	self refresh.	self announcer announce: IcePushed new! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!refresh	self branch refresh.	self loadedCode refresh.	commitDictionary := Dictionary new.	savedPackages := nil.	self announcer announce: (IceRepositoryModified for: self)! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/21/2017 17:44:57'!register	self checkForRegistryConflicts.	self class registerRepository: self.	Iceberg announcer announce: (IceRepositoryCreated repository: self).	^ self ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!remotes	self isValid ifFalse: [ ^ #() ].	^ self backend remotes ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!removeRemote: aRemote	self backend removeRemote: aRemote.	self detachRemote: aRemote! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!revparse: aString 	"Right now this is necessary because Metacello provides a tag objectId instead of a commitId"	^ self backend revparse: aString! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!saveContent: aString inWorkingCopyFile: aRelativePathString	| outputFile |	outputFile := (self backend repositoryDirectory fullName , '/' , aRelativePathString) asFileReference.	outputFile writeStreamDo: 		[ :stream |		stream nextPutAll: aString ].	self addFilesToIndex: { aRelativePathString }.	^ outputFile! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!savedPackages	^ self savedPackagesDictionary values! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!savedPackagesDictionary	^ savedPackages ifNil: [ savedPackages := self backend lookupPackages ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!stagedFiles	^ self backend stagedFiles! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!stagedPackageNames	^ self stagedFiles 		select: [ :fileRef | self isFilePartOfAPackage: fileRef ]		thenCollect: [ :fileRef | 			self subdirectory isEmptyOrNil 				ifTrue: [ fileRef path segments first asFileReference basenameWithoutExtension ] 				ifFalse: [ fileRef path segments second asFileReference basenameWithoutExtension ] ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!stagedPackages	^ self stagedPackageNames		select: [ :each | self includesPackageNamed: each ]		thenCollect: [ :packageName | self packageNamed: packageName ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ self backend subdirectory! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory: aString	self backend subdirectory: aString.	self refresh! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!updatePackage: packageName 	self backend pull.	(self packageNamed: packageName) loadLatest.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: aName email: anEmail global: globalBoolean	^ self backend 		username: aName 		email: anEmail 		global: globalBoolean! !!IceRepository methodsFor: 'versions handling' stamp: ' 7/21/2017 17:44:57'!versionLoaded: version 	loadedCode versionLoaded: version.	self announcer announce: (IcePackageLoaded version: version).	self refresh! !!IceRepository methodsFor: 'working copies' stamp: ' 7/21/2017 17:44:57'!workingCopies	^ self loadedPackages collect: #workingCopy! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!workingCopyDiff	^ IceDiff forRepository: self! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!workingCopyDiffToCommit: anIceCommitInfo	^ IceDiff forRepository: self commit: anIceCommitInfo! !!IceRepositoryCreator class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultSubdirectory	^ ''! !!IceRepositoryCreator class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isGitRoot: aReference	self flag: #todo. "This does not understand submodules"	^ aReference isDirectory 		and: [ (aReference directoriesMatching: '.git') notEmpty		and: [ (aReference / '.git' / 'config') exists ] ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ branchName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName: anObject	branchName := anObject! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createNewRepositoryNamed: aString	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	(locationToUse exists 		and: [ locationToUse hasChildren ])		ifTrue: [ IceError signal: ('{1} is not empty.' format: {locationToUse fullName}) ].			locationToUse ensureCreateDirectory.	self subdirectory  		ifNotEmpty: [ (locationToUse / self subdirectory) ensureCreateDirectory ].	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	backend init.	^ (IceRepository backend: backend)		name: aString;		yourself! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	(locationToUse exists not or: [ locationToUse hasChildren not ])		ifTrue: [ 			backend 				cloneRepositoryFrom: self remoteToUse 				branch: self branchName ].	^ IceRepository backend: backend! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!defaultLocation	| remoteToUse |	remoteToUse := self remoteToUse.	^ IceRepository repositoriesLocation 		/ remoteToUse organizer 		/ remoteToUse projectName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ location! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: anObject	location := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!locationToUse	^ self location ifNil: [ self defaultLocation ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!remoteToUse	self remote ifNotNil: [ ^ self remote ].	self url ifNotNil: [ ^ IceRemote url: self url ]. 	^ nil! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storageClass	^ storageClass ifNil: [ storageClass := IceRepository defaultBackend ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storageClass: aClass	storageClass := aClass! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ subdirectory ifNil: [ self class defaultSubdirectory ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory: anObject	subdirectory := anObject! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url	^ url! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url: anObject	url := anObject! !!IceRepositoryCreator methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validate	"Validate something is provided to create the repo (I need url OR location OR remote), 	 but the 3 cannot be nil"	(self location isNil 		and: [ self remoteToUse isNil ])		ifTrue: [ IceError signal: 'No location/url or remote defined.' ].			"Validate if I will add a local repository (url isNil and location isNotNil)... testing the 	 local directory actually exists"	(self remoteToUse isNil 		and: [ self location notNil 		and: [ self location exists 		and: [ (self class isGitRoot: self location) not ] ] ])		ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: { self location fullName }) ]! !!IceSavedPackage class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: packageName repository: repository	^ self new 		package: (IcePackageReference named: packageName); 		repository: repository; 		yourself! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	^ self species = another species 		and: [ self repository = another repository 		and: [ self name = another name ]]! !!IceSavedPackage methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	^ self package browse! !!IceSavedPackage methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!computeLoadedVersion	| workingCopyAncestors |	workingCopyAncestors := self package workingCopy ancestors.	workingCopyAncestors ifEmpty: [ ^ IceTemporaryVersion forPackage: self ].	self workingCopy ancestors		detect: [ :ancestor | 			(ancestor respondsTo: #iceVersion) and: [ 			(ancestor commit notNil) and: [			self repository includesCommit: ancestor commit ]]]		ifFound: [ :ancestor | ^ ancestor iceVersion ].	self workingCopy repositoryGroup repositories do: [ :mcRepo |		mcRepo 			commitIdFor: self workingCopy 			ifFound: [ :commitish | 				[ 					| commit |					commit := (self repository revparse: commitish).					^ commit versionFor: self 				] 				on: LGit_GIT_ENOTFOUND 				do: [					"If we cannot parse commitish, we asume that it is a commit ID which is unknown for this repo, 					so we just ignore it. Maybe we should consider other cases and handle them adecquately."				]]	].			^ IceForeignVersion forPackage: self.! !!IceSavedPackage methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!directoryName	^ package packageName, '.package'! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!directoryPathString	^ self repository subdirectory isEmptyOrNil 		ifTrue: [ self directoryName ]		ifFalse: [ self repository subdirectory, '/',  self directoryName ].! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!hash	^ self name hash! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ self loadedVersion incomingCommits ! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isExported	| location |	location := self location.	^ location exists and: [ location hasChildren ]! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self package isLoaded! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isModified	^ self package workingCopy modified! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!latestVersion	^ self repository headCommit versionFor: self! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!loadLatest	self latestVersion load.	! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!loadedVersion	^ self repository loadedCode versionFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	| location |	 	location := self repository location.	(self directoryPathString substrings: '/')		do: [ :each | location := location / each ].	^ location! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ self package packageName! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ self repository branch outgoingCommits: [ :walk | walk modifyingPackage: self ]! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package: anObject	package := anObject! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package packageName! !!IceSavedPackage methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name.	self package printDescriptionOn: aStream! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!reload	self latestVersion load.	! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDisk	self isLoaded ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDisk: force	(self isLoaded and: [ force not ]) ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!unload	self workingCopy unload.	self repository announcer 		announce: IcePackageUnloaded new.	self repository refresh! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: aCommitId	^ (self repository commitAt: aCommitId) versionFor: self! !!IceSavedPackage methodsFor: 'versions' stamp: ' 7/21/2017 17:44:57'!versionLike: selectBlock ifNone: ifNoneBlock	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch 		versionsFor: self 		detect: selectBlock 		ifNone: ifNoneBlock ! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versions	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch versionsFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!workingCopy	^ self package workingCopy! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultPrivateKey 		self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultPublicKey	self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa.pub') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultUsername	^ 'git'! !!IceSshCredentials methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPresent	^ self username notEmpty 		and: [ self publicKey notEmpty 		and: [ self privateKey notEmpty ] ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!keyPassphrase	^ keyPassphrase ifNil: [ keyPassphrase := '' ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!keyPassphrase: anObject	keyPassphrase := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!privateKey	^ privateKey ifNil: [ privateKey := self class defaultPrivateKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!privateKey: anObject	privateKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!publicKey	^ publicKey ifNil: [ publicKey := self class defaultPublicKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!publicKey: anObject	publicKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ username ifNil: [ username := self class defaultUsername ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: anObject	username := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ icebergAnnouncer ifNil: [ icebergAnnouncer := Announcer new ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!enableMetacelloIntegration	^ EnableMetacelloIntegration ifNil: [ EnableMetacelloIntegration := true ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!enableMetacelloIntegration: anObject	EnableMetacelloIntegration := anObject! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!icebergRepositoriesURLs	^ {		'git@github.com:npasserini/iceberg.git'. 		'git@github.com:npasserini/filetree.git'.		'git@github.com:npasserini/LibGit.git'	}! !!Iceberg class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:57'!initialize	| tree nodes |	tree := SystemSettingsPersistence default settingTree.	nodes := tree deeplySelect: [ :node | node receiverPackage name beginsWith: 'Iceberg' ].	SystemSettingsPersistence updateSettingNodes: nodes.! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!mcRepositoryFor: aLocationString	^ (IceMetacelloRepositoryType for: aLocationString) mcRepository ! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageForCategoryNamed: categoryName	| systemPackage |	systemPackage := RPackageOrganizer default packageMatchingExtensionName: categoryName.	^ self packageNamed: systemPackage name! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNamed: packageName	^ IcePackageReference named: packageName! !!Iceberg class methodsFor: 'maintenance' stamp: ' 7/21/2017 17:44:57'!rebuildRepositories	IceRepository registry do: [ :repo | 		repo initialize.		"repo branch: nil."		repo commitDictionary.		repo loadedPackages do: [ :pkg | repo versionLoaded: pkg computeLoadedVersion ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteTypeSelector	"Should be #scpURL or #httpsURL"	^ RemoteTypeSelector ifNil: [ RemoteTypeSelector := #scpUrl ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteTypeSelector: anObject	RemoteTypeSelector := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryForPackage: anRPackage 	| existingRepositories possibleRepositoryTypes |		existingRepositories := (MCWorkingCopy forPackage: anRPackage mcPackage) repositoryGroup repositories.	possibleRepositoryTypes := TIceRepositoryBackend traitUsers, 		{ IceMetacelloRepositoryAdapter. 		  MCGitHubRepository }.		possibleRepositoryTypes do: [ :class |		existingRepositories 			detect: [ :repo | repo isKindOf: class ]			ifFound: [ : repo |  ^ repo getOrCreateIcebergRepository ] ].	self error: ('Could not find a git repository for {1}' format: {anRPackage name})	! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!settingsOn: aBuilder 	<systemsettings>	(aBuilder group: #Iceberg)		parent: #SCM;		with: [ 			(aBuilder setting: #enableMetacelloIntegration)				target: self;				order: 0.1;				label: 'Enable Metacello integration';				description: 'If selected, Metacello github// repositories will be loaded using iceberg';"				icon: (Smalltalk ui icons iconNamed: #smallConfigurationIcon);"				with: [ 					(aBuilder pickOne: #remoteTypeSelector)						label: 'Remote type';						description: 'When creating an Iceberg repository out of a github:// URL choose whether you want to user an SCP URL (i.e. with the form ''git@github.com:<username>/<project>.git'') or an HTTPS URL (i.e. with the form ''https://github.com/<username>/<project>.git''';						domainValues: {							'SCP (git@github.com:<username>/<project>.git)' -> #scpUrl.							'HTTPS (https://github.com/<username>/<project>.git)' -> #httpsUrl						}.				].			(aBuilder setting: #showSystemRepositories) 				order: 0.2;				label: 'Include system repositories by default';				description: 'If checked then system repositories (like ''pharo'') will be shown in repositories list by default';				target: self.		]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!showSystemRepositories	^ ShowSystemRepositories ifNil: [ ShowSystemRepositories := false ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!showSystemRepositories: aBoolean	ShowSystemRepositories := aBoolean! !!Iceberg class methodsFor: 'updating' stamp: ' 7/21/2017 17:44:57'!update	#(Iceberg LGitRepository MCFileTreeGitRepository) do: [:className | 		Smalltalk 			at: className 			ifPresent: [ :class | class package iceRepository pull ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!workingCopyForPackageNamed: packageName	^ (self packageNamed: packageName) workingCopy! !"Iceberg"!!IcePlugin commentStamp: '<historical>' prior: 0!I'm a base for all kind of plugins. I can define - repositoryActions (actions that will be added to IceRepositoriesBrowser, repositories section)- ... (TBD)!!IceBaselineInstallerPlugin commentStamp: 'EstebanLorenzano 4/7/2017 12:36' prior: 0!I'm a plugin who allows Baselines to be installed from Iceberg (just right-click and install).It adds two options to packages tab of repositories browser: - Install baseline (default)- Install baseline...2nd one allows to pick groups to install!!IcePharoFogbugzPlugin commentStamp: 'EstebanLorenzano 2/13/2017 16:59' prior: 0!I'm a pluging to handle fogbugz issues integration. It just add options to easily handle the creation of branchs with the "convention" issue naming format (number-plus-normalised-title): 12345-a-sample-of-issue-branchNOTE: In the future we can add other fogbugz elements (like list issues, etc.), but since API is very slow we will consider it very carefully. !!IcePluginManager commentStamp: '<historical>' prior: 0!I keep plugins configured for a repository. WARNING: Managers are kept in a week dictionary with Repository as a key, reason why plugins can't have any kind of reference that could cause a memory leak. Consider using stateless plugins or instance copies of relevant information instead.!!IcePharoFogbugzModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for issue number to create correct branchs for Pharo Development.!!IceRepository methodsFor: '*Iceberg-Plugin' stamp: ' 7/21/2017 17:44:57'!pluginManager	^ IcePluginManager managerFor: self! !!IceBaselineInstallerPlugin class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baselinePrefix	^ 'BaselineOf'! !!IceBaselineInstallerPlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	^ true! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!installBaseline: icePackage groups: anArray	| packageDir baselineName |		packageDir := icePackage location parent fullName.	baselineName := icePackage name allButFirst: self class baselinePrefix size.	Metacello new		repository: 'gitlocal://', packageDir;		baseline: baselineName;		load: anArray! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!installBaselineGroups: icePackage	| groupsString groups |		groupsString := self pickGroupsOnCancel: [ ^ self ].	groups := groupsString 		ifNotNil: [ (groupsString substrings: ',') collect: #trimBoth as: Array ]		ifNil: [ #() ].	self installBaseline: icePackage groups: groups! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!installDefaultBaseline: icePackage	self installBaseline: icePackage groups: #()! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!installDefaultBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installDefaultBaseline: presentation selection entity ];		showTitle: 'Install baseline (default)'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!installGroupsBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installBaselineGroups: presentation selection entity ];		showTitle: 'Install baseline...'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageActionsFor: icePackage	^ (icePackage packageName beginsWith: self class baselinePrefix) 		ifTrue: [ { self installDefaultBaselineAction. self installGroupsBaselineAction } ]		ifFalse: [ #() ]! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pickGroupsOnCancel: aBlock	| result |	result := UIManager default 		request: 'Groups to install (a comma separated string)' 		initialAnswer: '' 		title: 'Enter groups to install'.	result ifNil: [ ^ aBlock value ].	^ result! !!IcePharoFogbugzPlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	"ATTENTION: Bad practice!!		We cannot resolve remotes during repository creation so we unfortunately need this	pluggin enabled for all repositories. Please do not create own pluggins enabled for all	repositories unless you have a very, very, very good reason."		^ true! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasPharoInOrigin: aRepository	| origin |	origin := aRepository origin.	^ (origin host = 'github.com')		and: [ origin owner = 'pharo-project'		and: [ origin projectName = 'pharo' ] ]! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasPharoInRemotes: aRepository	^ aRepository remotes anySatisfy: [ :aRemote |		self pharoURLs includes: aRemote url ].! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	^ (self hasPharoInOrigin: aRepository) or: [ self hasPharoInRemotes: aRepository ]! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newFogbugzIssue: aRepository then: aBlock	IcePharoFogbugzModel new 		onAccept: [ :branchName | 			aRepository createBranch: branchName.			aBlock value ];		openWithSpec.! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newIssueFixAction	^ GLMGenericAction new		action: [ :presentation | 			self 				newFogbugzIssue: presentation selection repository				then: [ presentation pane browser update ] ];		category: 'Pharo';		showTitle: 'Create new branch from FogBugz issue...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself	! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newPullRequest: aRepository	"(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRepository pushRemote;		execute"! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newPullRequestAction	"This actions are copied from GitHub plugin, but presented here to make it easier"	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'Pharo';		showTitle: 'Create pull request...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pharoURLs	"list of repository URLs for official Pharo upstream"	^ #(		'git@github.com:pharo-project/pharo.git' 		'https://github.com/pharo-project/pharo.git'	)! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryActions	^ { 	self newIssueFixAction.	}! !!IcePlugin class methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!allAvailableFor: aRepository	^ self allSubclasses select: [ :each | each isAvailableFor: aRepository ]! !!IcePlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	^ self subclassResponsibility! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageActionsFor: aPackage	"answer a list of glamour actions (GLMAction) that defines operations in the packages panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteActionsFor: aRemote	"answer a list of glamour actions (GLMAction) that defines operations in the remotes tab panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryActions	"answer a list of glamour actions (GLMAction) that defines operations in the repository panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!managerFor: aRepository	^ self managers 		at: aRepository 		ifAbsentPut: [ self basicNew initializeRepository: aRepository ].! !!IcePluginManager class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!managers 	^ Managers ifNil: [ Managers := WeakKeyDictionary new ]! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #managerFor:'! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addPlugin: aPlugin 	plugins := plugins copyWith: aPlugin! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!availablePluginsFor: aRepository	^ (IcePlugin allAvailableFor: aRepository) 		collect: #new		as: Array! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeRepository: aRepository.	self initialize.	plugins := self availablePluginsFor: aRepository! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!packageActionsFor: aPackage	^ self plugins		inject: #() 		into: [ :all :each | all, (each packageActionsFor: aPackage) ]! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plugins 	^ plugins! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!remoteActionsFor: aRemote	^ self plugins 		inject: #() 		into: [ :all :each | all, (each remoteActionsFor: aRemote) ]! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!repositoryActions	^ self plugins 		inject: #() 		into: [ :all :each | all, (each repositoryActions) ]			! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 660@35! !!IcePharoFogbugzModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec>		^ SpecLayout composed		newRow: [ :row |			row 				add: #issueNumberText width: 50;				add: #issueText;				add: #createButton width: 80 ] height: self inputTextHeight! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'New branch from FogBugz issue'! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!unknownTitle	^ 'INVALID-ISSUE'! !!IcePharoFogbugzModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createBranch	| branchName |		branchName := '{1}-{2}' format: { 		issueNumberText text trim. 		issueText text trim }.	acceptBlock ifNotNil: [ acceptBlock value: branchName ].	self window delete! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton	^ createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton: anObject	createButton := anObject! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IcePharoFogbugzModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	issueNumberText := self newTextInput autoAccept: true.	issueText := self newTextInput autoAccept: true.	createButton := self newButton.			issueNumberText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueNumberText textHolder 		whenChangedDo: [ :text | self validateIssue: text ].		createButton 		label: 'Create';		icon: #add asIcon;		action: [ self createBranch ].			self focusOrder 		add: issueNumberText;		add: issueText;		add: createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueNumberText	^ issueNumberText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueNumberText: anObject	issueNumberText := anObject! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueText	^ issueText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueText: anObject	issueText := anObject! !!IcePharoFogbugzModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock 	acceptBlock := aBlock! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!sanitizeTitle: aString	| separators safeSeparator |		aString isEmptyOrNil ifTrue: [ ^ self class unknownTitle ].		safeSeparator := $-.	separators := { Character space. Character tab. $_. safeSeparator }.	^ String streamContents: [ :str | 		aString do: [ :c |			(separators includes: c) ifTrue: [ str nextPut: safeSeparator ].			c isAlphaNumeric ifTrue: [ str nextPut: c ] ] ]! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ self class title! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!updateText: aString 	issueText text: aString! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validateIssue: aString	| number |	aString size = 5 ifFalse: [ ^ self ].	aString isAllDigits ifFalse: [ ^ self ].	number := aString asNumber.		(issue isNil or: [ issue number ~= number ])		ifTrue: [ 			issue := PharoIssue number: number.			[ 	"Fork to allow UI to continue"				issue downloadTitle.				World defer: [ self updateText: (self sanitizeTitle: issue title) ] ] fork ]	! !"Iceberg-Plugin"!!IceMetacelloRepositoryType commentStamp: '<historical>' prior: 0!I'm a base class to provide different type of MCRepositories from iceberg, so metacello can do his work of installing packages.My children define specific types, visit them to have more details of what you can do.!!IceGitLocalRepositoryType commentStamp: 'EstebanLorenzano 12/12/2016 10:43' prior: 0!I resolve git local repositories (repositories already existing on your disk).A gitlocal repositoy is composed of: gitlocal://full/path/to/repositorygitlocal  		- The git local identifierfull/path/...	- This is a path to the place where the sources are. 	For example, if you have a  repository in '/dev/voyage', which also has sources in subdirectory 'mc', your full path will be: '/dev/voyage/mc'. A part of my responsibilities is to find the git root  in the path provided.Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'gitlocal://Users/esteban/Dev/Repository/voyage/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceGithubRepositoryType commentStamp: 'EstebanLorenzano 12/12/2016 10:44' prior: 0!I resolve Github repositories.A github repositoy is composed of: github://username/repository[:commitish][/subdir]github  		- The github identifierusername 	- The github userrepository	- The guthub repositorycommitish	- an optional commitish (a branch, a tag, a commit id)subdir		- an optional subdirectory where the packages exist.		Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'github://pharo-nosql/voyage:master/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceMetacelloPharoPlatform commentStamp: '<historical>' prior: 0!I'm a class to add support for iceberg to metacello.!!IceGitLocalRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ 'gitlocal'! !!IceGitLocalRepositoryType methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isGitRoot: aReference	^ IceRepositoryCreator isGitRoot: aReference! !!IceGitLocalRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcRepository	| repository tuple extractedLocation |		tuple := self splitRootAndSubdirectoryFromLocation.	extractedLocation := tuple first asFileReference asAbsolute.	repository := IceRepository registry 		detect: [ :each | each location asAbsolute = extractedLocation ]		ifNone: [ 			(IceRepositoryCreator new 				location: tuple first;				subdirectory: tuple second;				createRepository)				register ].				^ repository metacelloAdapter! !!IceGitLocalRepositoryType methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!splitRootAndSubdirectoryFromLocation	| root subDir |		(self location beginsWith: (self class type, '://'))			ifFalse: [ self error: 'Invalid URL (It should be ', self class type, '://...)' ].	root := (self location allButFirst: self class type size + 3) asFileReference.	subDir := #().	[ root isNil or: [ self isGitRoot: root ] ] 		whileFalse: [ 			subDir := subDir copyWithFirst: root basename.			root := root parent ].	root ifNil: [ self error: 'I can''t find a .git/config file.' ].		^ { 		root. "a FileReference"		String streamContents: [ :stream | subDir asStringOn: stream delimiter: '/' ] "a String" }! !!IceGithubRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ 'github'! !!IceGithubRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcRepository	| baseRepo |		baseRepo := MCGitHubRepository location: self location.	(Iceberg icebergRepositoriesURLs includes: baseRepo scpUrl)		ifTrue: [ 			"Do not use Iceberg to load iceberg code, 			see https://github.com/npasserini/iceberg/issues/168"			^ baseRepo ]		ifFalse: [  			Transcript 				show: 'Creating iceberg-metacello adapter for: ';				show: self location; 				cr.			^ baseRepo getOrCreateIcebergRepository metacelloAdapter ]		! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!allTypes	^ self allSubclasses ! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleType: aType 	^ self allTypes		anySatisfy: [ :each | each isSuitableForType: aType ]  	! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!extractTypeOf: aString 	^ aString copyUpTo: $:! !!IceMetacelloRepositoryType class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aLocationString	^ (self allSubclasses		detect: [ :each | each isSuitableForLocation: aLocationString ])		location: aLocationString! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSuitableForLocation: aLocationString	^ self isSuitableForType: (self extractTypeOf: aLocationString) ! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSuitableForType: aType	^ self type = aType! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!location: aLocationString	self = IceMetacelloRepositoryType 		ifTrue: [ self error: 'I''m an abstract class, use one of my children instead.' ].		^ self basicNew		initializeLocation: aLocationString;		yourself! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ self subclassResponsibility! !!IceMetacelloRepositoryType methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeLocation: aString	location := aString.	self initialize! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ location! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcRepository	self subclassResponsibility! !!IceMetacelloPharoPlatform class methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	 self select! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/21/2017 17:44:57'!createRepository: aRepositorySpec	| type |	type := aRepositorySpec type.	type = 'ftp' ifTrue: [ | description headerSize index host directory |		description := aRepositorySpec description.		headerSize := 'ftp://' size.		index := description indexOf: $/ startingAt: headerSize + 1.		host := description copyFrom: headerSize + 1 to: index - 1.		directory := description copyFrom: index + 1 to: description size.		^ MCFtpRepository			host: host 			directory: directory 			user: aRepositorySpec username			password: aRepositorySpec password ].				(Iceberg enableMetacelloIntegration 		and: [ IceMetacelloRepositoryType canHandleType: type ])		ifTrue: [ ^ Iceberg mcRepositoryFor: aRepositorySpec description ].				^ super createRepository: aRepositorySpec! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/21/2017 17:44:57'!extractTypeFromDescription: description	(description beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].	IceMetacelloRepositoryType allTypes 		detect:  [ :each | each isSuitableForLocation: description  ] 		ifFound: [ :class | ^ class type ].	^ super extractTypeFromDescription: description! !"Iceberg-Metacello-Integration"!!TIceTool commentStamp: 'NicoPasserini 9/2/2016 15:27' prior: 0!Utilities for Iceberg GUI tools.!!IceAskForPlaintextCredentialsModel commentStamp: 'NicoPasserini 11/15/2016 15:25' prior: 0!A dialog for asking plaintext credentials (username and password) to the user.!!IceAskForSshCredentialsModel commentStamp: 'EstebanLorenzano 2/8/2017 17:52' prior: 0!A dialog for asking ssh credentials to the user.!!IceAskForUsernameAndEmailModel commentStamp: '<historical>' prior: 0!I'm a dialog for asking "user.name" and "user.email" .!!IceCommitInfoModel commentStamp: '<historical>' prior: 0!I'm a simple spec model to show IceCommitInfo details. (self for: aCommitInfo) openWithSpec.!!IceCommitModel commentStamp: 'NicoPasserini 8/25/2016 14:47' prior: 0!Spec model for commit (and related) operations.!!IceCherryPickCommitModel commentStamp: '<historical>' prior: 0!Spec model for commit (and related) operations using cherry-pick.!!IceCreateRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 17:51' prior: 0!Base class for avoiding code duplications between dialogs that create repositories. !!IceCloneRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:44' prior: 0!Dialog for cloning a repository from a remote URL!!IceEditRepositoryModel commentStamp: '<historical>' prior: 0!I'm an edition dialog. I allow users to edit what is editable on an IceRepository. !!IceImportLocalRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:45' prior: 0!Dialog for creating an Iceberg repository out of an existing local git repository.!!IceNewRepositoryModel commentStamp: '<historical>' prior: 0!I'm a repository creation dialog. I allow users to create a repository from scratch. !!IceLocationModel commentStamp: '<historical>' prior: 0!I'm an abstract model to provide locations (directories or files). I need to be included in other components (search references to my children for examples)!!IceDirectoryModel commentStamp: '<historical>' prior: 0!I'm a model to choose directories.!!IceFileModel commentStamp: '<historical>' prior: 0!I'm a model to choose files.!!IceRemoteModel commentStamp: '<historical>' prior: 0!I'm a dialog for adding remotes to repositories.!!IceGlamourSynchronizer commentStamp: 'EstebanLorenzano 2/2/2017 16:22' prior: 0!I am the syncronizer window. I am called to perform any of the basic operations of iceberg: - commit (save changes)- update (load new changes from incomming commit versions)- publish (send to central repository local commits)usually I'm called from the repositories browser, when selecting the "syncronize" option from contextual menu.!!IceTool commentStamp: 'NicoPasserini 9/2/2016 15:26' prior: 0!Utility base class for building Iceberg GUI tools.It might be better to use TIceTool instead.!!IceGlamourCommitBrowser commentStamp: '<historical>' prior: 0!I allow userts to commit current changes.!!IceGlamourPublishBrowser commentStamp: '<historical>' prior: 0!I allow users to see and publish existing local commits.!!IceGlamourUpdateBrowser commentStamp: 'NicoPasserini 10/13/2016 17:28' prior: 0!This browser allows you to see the new commits  in your [upstream](../../../wiki/Some-keys-to-understand-Git-nomenclature#upstream), browse the changes and merge them into your current branch (or load them without merging).!!IceHistoryBrowser commentStamp: 'NicoPasserini 8/23/2016 14:34' prior: 0!Shows information about branches, history of commits and the changes in each commit.!!IceBranchBrowser commentStamp: '<historical>' prior: 0!I'm a browser to compare a branch with current installed sources.!!IceRepositoriesBrowser commentStamp: 'NicoPasserini 7/24/2016 20:12' prior: 0!Main entry point to the Iceberg UI tools, shows the list of the known repositories, allows to see a resume of the status of each of them and to open the repository synchronizer.Shows- all known repositorires- resume of the status of each package in each repositoryActions - create and forget repositories- refresh repository status- synchronize a repository- load / unload packages in a repository!!IceInteractiveCredentialsProvider commentStamp: 'NicoPasserini 11/15/2016 12:15' prior: 0!A credentials provider that asks the user for credentials.!!IceRemoteAdded commentStamp: 'EstebanLorenzano 1/6/2017 09:12' prior: 0!I'm an announce that happens  when a remote has been added.!!SwappedColorDiffMorph commentStamp: 'YuriyTymchuk 4/7/2017 11:32' prior: 0!I swap colors for the original giff morph, so the additions are green and removals are red!!GLMSwappedColorDiffPresentation commentStamp: 'EstebanLorenzano 5/8/2017 13:57' prior: 0!A glamour presentation  for the swapped diff morph!!IceAbstractBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:25' prior: 0!Description--------------------I am an abstract class to define a common API for my subclasses that will manage some actions for some branch view of Iceberg. My subclasses will encapsulate a branch or a remote.I am use in the branch view of the main browser of Iceberg.Public API and Key Messages--------------------- #children				It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches.- #nameToDisplay		String to show to the user.- #status 				Status to show to the user about incomming/unpublished commits.!!IceBranchGroupModel commentStamp: 'CyrilFerlicot 7/9/2017 03:35' prior: 0!Description--------------------I represent a group of branches. I am used in two principal cases. 1) We want to group the branches of a remote2) We want to group the local branchesExamples--------------------	"For a remote"	IceBranchGroupModel repository: anIceRepository remote: anIceRemote.		"For local branches"	IceBranchGroupModel localFromRepository: anIceRepository Internal Representation and Key Implementation Points.--------------------    Instance Variables	branches:		<aBlockOrSymbol>	This block takes the repository as parameter and should return the branches of the group	groupName:		<aString>			Name of the group. In case I represent a remote it will be the remote name, else it will probably be "Local"	repository:		<anIceRepository>	The repository where to get the branches!!IceBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:36' prior: 0!Description--------------------I represent an unique branch. I should be contained in an IceBranchGroupModel.Examples--------------------	IceBranchModel parent: anIceBranchGroupModel branch: anIceBranch Internal Representation and Key Implementation Points.--------------------    Instance Variables	branch:				<anIceBranch>				The branch I should display info for.	parentGroup:		<anIceBranchGroupModel>	The branch group inside of which I am.!!IceChangesTreeResetSelectionHelper commentStamp: '<historical>' prior: 0!I am a helper to reset selections on changes tree browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					do: [ presentation selection: nil ] ] ]... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ]removing the outer context problems .!!IceDiffChangeTreeBuilder commentStamp: '<historical>' prior: 0!I'm a builder to help users to build reusable diff-changes-tree elements.I'm used in several parts, notable in the syncronize window and in th e history browser.!!IceMergeTool commentStamp: 'NicoPasserini 12/13/2016 11:44' prior: 0!This is a very basic merge tool, just for keeping some state and coordinating interation between the 'real' merge tools. Internal Representation- source: <IceCommit> indicating the source of the changes to be merged (TODO: should be a commitish).- targetBranch: <IceBranch> where we want to merge the commits. If not provided the tool will raise a dialog to ask for it.- onMerge: <block or symbol> will be executed after a successfull merge.!!IceRepositoryUpdateHelper commentStamp: 'EstebanLorenzano 12/23/2016 15:50' prior: 0!I am a helper to create update cycles on repositories browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		do: [ :ann | 			table 				updateOn: IceRepositoryAnnouncement 				from: ann repository announcer ].... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).removing the outer context problems :)!!GLMMorphicSwappedColorDiffRenderer commentStamp: 'EstebanLorenzano 5/5/2017 12:19' prior: 0!A glamour renderer for the swapped diff morph!!TIceTool classTrait methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!uiManager	^ UIManager default! !!TIceTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!uiManager	^ self class uiManager! !!MCModification methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeUpdate! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!selectionAction: actionSelector	"action selector will be sent to the presentation selection. 	If it accepts one argument, the presentation will be sent."	^ self		action: [ :presentation | 			presentation selection				ifNotNil: [ :sel | (MessageSend receiver: sel selector: actionSelector) cull: presentation ] ];		enabledCondition:				[ :presentation | "This is a minimal condition, that can be overriden (refined) later" presentation selection notNil ]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!selectionCondition: selectionCondition	"selectionCondition can be anything that can respond #cull: such as a block or unary symbol.	It will only be evaluated if the presentation has a (not nil) selected element."		^ self enabledCondition: [ :presentation | 		presentation selection notNil and: [ 			selectionCondition cull: presentation selection ]]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!showTitle: aTitle	^ self title: aTitle; showTitle! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'callbacks' stamp: ' 7/21/2017 17:44:57'!actOnPresentationRefreshRequest: anAnnouncement	tableMorph window ifNil: [ ^ self ].	tableMorph window isActive ifFalse: [ ^ self ].	(tableMorph window boundsInWorld containsRect: tableMorph boundsInWorld) ifFalse: [ ^ self ].  " tableModel resetElements."	tableModel resetDataCache.	tableMorph refresh! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!createDataSourceFrom: aPresentation	^ GLMCherryPickTreeDataSource new! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!specificTableMorphInitializiation	super specificTableMorphInitializiation.	tableModel glamourPresentation isAllSelected		ifTrue: [ tableModel selectAll ]! !!IceAskForPlaintextCredentialsModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col newRow: [:row | row add: #usernameLabel width: 80; add: #usernameInput ] height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 80; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight	]! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ IcePlaintextCredentials new 		username: self username;		password: self password;		yourself.! !!IceAskForPlaintextCredentialsModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (350@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForPlaintextCredentialsModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	usernameLabel := self newLabel label: 'Username: '.	usernameInput := self newTextInput autoAccept: true.		passwordLabel := self newLabel label: 'Password: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		help: 'Please note that storing your credentials is handy but unsafe';		state: true.		self focusOrder		add: usernameInput;		add: passwordInput;		add: storeCheckbox! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password 	^ passwordInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!passwordInput	^ passwordInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!passwordLabel	^ passwordLabel! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storeCheckbox	^ storeCheckbox ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storeCredentials	^ storeCheckbox state ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Please log in to git'! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ usernameInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!usernameInput	^ usernameInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!usernameLabel	^ usernameLabel! !!IceAskForSshCredentialsModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #usernameLabel width: 100; add: #usernameInput ] height: self inputTextHeight;			newRow: #publicKeyLocation height: self inputTextHeight;			newRow: #privateKeyLocation  height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 100; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight ]! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ IceSshCredentials new 		username: self username;		publicKey: self publicKey;		privateKey: self privateKey;		keyPassphrase: self password;		yourself.! !!IceAskForSshCredentialsModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 5		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForSshCredentialsModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	usernameLabel := self newLabel label: 'SSH Username: '.	usernameInput := self newTextInput autoAccept: true.		publicKeyLocation := self instantiate: IceFileModel.	publicKeyLocation 		label: 'Public SSH Key: ';		chooseTitle: 'Public SSH Key (id_rsa.pub)'.	privateKeyLocation := self instantiate: IceFileModel.	privateKeyLocation 		label: 'Private SSH Key: ';		chooseTitle: 'Private SSH Key (id_rsa)'.	passwordLabel := self newLabel label: 'SSH Passphrase: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		state: true.		self focusOrder		add: usernameInput;		add: publicKeyLocation;		add: privateKeyLocation;		add: passwordInput;		add: storeCheckbox! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password 	^ passwordInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordInput	^ passwordInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordInput: anObject	passwordInput := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordLabel	^ passwordLabel! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordLabel: anObject	passwordLabel := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!privateKey	^ privateKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!privateKeyLocation	^ privateKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!privateKeyLocation: anObject	privateKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!publicKey	^ publicKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!publicKeyLocation	^ publicKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!publicKeyLocation: anObject	publicKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!storeCheckbox	^ storeCheckbox ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storeCredentials	^ storeCheckbox state ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Please provide SSH keys'! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ usernameInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!usernameInput	^ usernameInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!usernameLabel	^ usernameLabel! !!IceAskForUsernameAndEmailModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #nameLabel width: 100; add: #nameInput ] height: self inputTextHeight;			newRow: [:row | row add: #emailLabel width: 100; add: #emailInput ] height: self inputTextHeight;			add: #globalCheckbox height: self inputTextHeight;			add: #acceptButton height: self buttonHeight  ]! !!IceAskForUsernameAndEmailModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	self username isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.name is required.' ].	self email isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.email is required.' ].			acceptBlock 		value: self username 		value: self email		value: self isGlobal.		self window delete.! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!email	^ self emailInput text trimBoth! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailInput	^ emailInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailInput: anObject	emailInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailLabel	^ emailLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailLabel: anObject	emailLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!globalCheckbox	^ globalCheckbox! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!globalCheckbox: anObject	globalCheckbox := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (400@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForUsernameAndEmailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	nameLabel := self newLabel label: 'user.name'.	nameInput := self newTextInput 		ghostText: 'John Doe';		autoAccept: true.	emailLabel := self newLabel label: 'user.email'.	emailInput := self newTextInput 		ghostText: 'johndoe@mail.net';				autoAccept: true.	globalCheckbox := self newCheckBox		label: 'Save properties as global?';		state: false.	acceptButton := self newButton		label: 'Set properties';		action: [ self accept ];		yourself.					self focusOrder		add: nameInput;		add: emailInput;		add: globalCheckbox;		add: acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isGlobal	^ self globalCheckbox state! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameInput	^ nameInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameInput: anObject	nameInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameLabel	^ nameLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameLabel: anObject	nameLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	"aBlock will receive 3 arguments: name, email, global flag"	acceptBlock := aBlock! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Please provide required properties'! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ self nameInput text trimBoth! !!IceCommitInfoModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #dateLabel width: 80; add: #datePanel ] height: 25;				newRow: [:row | row add: #idLabel width: 80; add: #idPanel ] height: 25;				newRow: [:row | row add: #parentsLabel width: 80; add: #parentsPanel ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorPanel ] height: 25;				newRow: [:row | row add: #commentLabel width: 80; add: #commentPanel ] ];		yourself! !!IceCommitInfoModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aCommit	^ self basicNew 		initializeCommit: aCommit;		yourself! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorLabel	^ authorLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorLabel: anObject	authorLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorPanel	^ authorPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorPanel: anObject	authorPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentLabel	^ commentLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentLabel: anObject	commentLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentPanel	^ commentPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentPanel: anObject	commentPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ commit! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!dateLabel	^ dateLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!dateLabel: anObject	dateLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datePanel	^ datePanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datePanel: anObject	datePanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idLabel	^ idLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idLabel: anObject	idLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idPanel	^ idPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idPanel: anObject	idPanel := anObject! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeCommit: aCommit	commit := aCommit.	self initialize! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	idLabel := self newLabel.	idPanel := self newTextInput enabled: false.	dateLabel := self newLabel.	datePanel := self newTextInput enabled: false.	authorLabel := self newLabel.	authorPanel := self newTextInput enabled: false.	commentLabel := self newLabel.	commentPanel := self newText enabled: false.	parentsLabel := self newLabel.	parentsPanel := self newTextInput enabled: false.		idLabel label: 'Commit Id'.	idPanel text: self commit id asString, ' [', self commit shortId, ']'.	dateLabel label: 'Date & time'.	datePanel text: self commit datetime asLocalStringYMDHM.	authorLabel label: 'Author'.	authorPanel text: self commit username.	commentLabel label: 'Comment'.	commentPanel text: self commit comment.	parentsLabel label: 'Parent(s)'.	parentsPanel text: (self commit parents collect: #shortId) asCommaString	! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsLabel	^ parentsLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsLabel: anObject	parentsLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsPanel	^ parentsPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsPanel: anObject	parentsPanel := anObject! !!IceCherryPickCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicCommitWithMessage: aString	| picked |	self flag: #todo. "I need to check if picked = all changes (in that case, is not 	needed the pick and I can just go 'business as usual')"	cherryPickBlock ifNotNil: [ picked := cherryPickBlock value ].	"Nothing was picked, continue as usual"	picked ifNil: [ ^ super basicCommitWithMessage: aString ].	self repository 		commitCherryPick: picked  		withMessage: aString! !!IceCherryPickCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!withSelectedCherryPick: aBlock	cherryPickBlock := aBlock! !!IceCommitModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | col			add: #message;			newRow: [ :row | row				add: #commitButton;				add: #commitPushButton			] height: self toolbarHeight		]! !!IceCommitModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageGhostText	^ 'Please enter commit message.'! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicCommitWithMessage: aString	self repository 		commitPackages: self model changedPackages		withMessage: aString! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicCommitWithMessage: text ifCancel: cancelBlock	[		[ self basicCommitWithMessage: text asString ]		on: IceGitUsernameOrEmailNotFound 		do: [ :e |			self configGitUsernameAndEmailOnCancel: cancelBlock.			e retry ].		self resetText ]	on: NothingToCommitException 	do: [ :e | UIManager default inform: 'There is nothing to commit.' ]! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self model repository branchName! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitButton	^ commitButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitPushButton	^ commitPushButton! !!IceCommitModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!commitPushing: pushBoolean	| text |		(text := self messageText) ifEmpty: [ ^ self ].	UIManager default		informUserDuring: [ :bar | 			bar label: ('Commiting changes to {1}' format: {self repository}).			self basicCommitWithMessage: text ifCancel: [ ^ self ].			pushBoolean ifTrue: [ | remote |				remote := self repository pushRemote.				bar label: ('Pushing changes to {1}' format: {remote}).				self pushRepository: self repository andThen: [ ]. 				UIManager default inform: ('Uploaded changes to {1}' format: {remote}) ] ]! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!configGitUsernameAndEmailOnCancel: cancelBlock	| passed |	passed := false.	(IceAskForUsernameAndEmailModel new 		onAccept: [ :username :email :global |			self repository 				username: username				email: email				global: global.			passed := true ];			openWithSpec)		modalRelativeTo: World.			passed ifFalse: cancelBlock! !!IceCommitModel methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!contractedNameFor: diff	"If the name of a branch is too long it is better to contract it in order to limit the UI glitches."	^ diff repository branchName contractTo: 20! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	model := nil asValueHolder.	model whenChangedDo: [ :diff | commitButton label: 'Commit onto ' , (self contractedNameFor: diff) ].	model whenChangedDo: [ :diff | commitPushButton label: 'Commit and Push onto ' , (self contractedNameFor: diff) ].	super initialize! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	commitButton action: [ self commitPushing: false ].	commitPushButton action: [ self commitPushing: true ]! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	message := self newText		autoAccept: true;		whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ];		whenTextChanged: [ | enable |			enable := self messageText notEmpty.			commitButton enabled: enable.			commitPushButton enabled: enable ];		yourself.	commitButton := self newButton		label: 'Commit';		enabled: false;		yourself.	commitPushButton := self newButton		label: 'Commit and push';		enabled: false;		yourself.			self focusOrder 		add: message;		add: commitButton;		add: commitPushButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!message	^ message! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!messageText	^ self message text! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!model	^ model value! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!model: aDiff	model value: aDiff ! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self model repository! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!resetText	self message text: ''! !!IceCloneRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buildDefaultSpec: col	col		newRow: [:row | row			add: #remoteUrlLabel width: 100;			add: #remoteUrl ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceCloneRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	[		| repository |				repository := IceRepositoryCreator new 			remote: (IceRemote url: remoteUrl text trim);			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceCloneRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	remoteUrlLabel := self newLabel label: 'Remote URL'.	remoteUrl := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	self focusOrder add: remoteUrl.	super initializeWidgets.	! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!remoteUrl	^ remoteUrl! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!remoteUrlLabel	^ remoteUrlLabel! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'Clone repository by URL'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buildDefaultSpec: col	col		newRow: #localDirectoryLocation		height: self inputTextHeight;				newRow: [:row | row 			add: #subdirectoryLabel width: 100;			add: #subdirectory ]		height: self inputTextHeight;					add: #createButton height: self buttonHeight ! !!IceCreateRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Create repository'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | self buildDefaultSpec: col ]! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton	^ createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton: anObject	createButton := anObject! !!IceCreateRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	self subclassResponsibility! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultLocation	^ IceRepository repositoriesLocation pathString! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	createButton action: [ self createRepository ]! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	localDirectoryLocation := self instantiate: IceDirectoryModel.	localDirectoryLocation 		label: 'Local directory';		chooseTitle: 'Choose local repository';		location: self defaultLocation.		subdirectoryLabel := self newLabel label: 'Code subdirectory'.	subdirectory := self newTextInput autoAccept: true.		createButton := self newButton		label: self class buttonLabel;		yourself.		self focusOrder 		add: localDirectoryLocation;		add: subdirectory;		add: createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!localDirectoryLocation	^ localDirectoryLocation! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!localDirectoryLocation: anObject	localDirectoryLocation := anObject! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	| location |	location := localDirectoryLocation location.	^ (location notNil and: [ location pathString ~= self defaultLocation ])		ifTrue: [ ^ location ]		ifFalse: [ nil ]! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: anObject	localDirectoryLocation location: anObject! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ subdirectory! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!subdirectoryLabel	^ subdirectoryLabel! !!IceEditRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Edit repository'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new 	self error: 'Use #repository:'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository	^ self basicNew		initializeRepository: aRepository;		yourself! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!codeDirectory	^ self subdirectory text	! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!codeDirectory: aString	self subdirectory text: aString	! !!IceEditRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	self repository location = self location 		ifFalse: [ self repository location: self location ].	self repository subdirectory = self codeDirectory		ifFalse: [ self repository subdirectory: self codeDirectory ].	self window delete. 	acceptBlock ifNotNil: [ acceptBlock cull: self ]! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	super initializePresenter.	self location: (self repository location ifNil: [ IceRepository repositoriesLocation ]).	self codeDirectory: self repository subdirectory.! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeRepository: aRepository	repository := aRepository.	self initialize! !!IceEditRepositoryModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock 	acceptBlock := aBlock! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'Edit repository'! !!IceImportLocalRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	self location ifNil: [ 		UIManager default 			abort: 'Please select a repository location'			title: 'Could not create repository'. 		^ self ].	[		| repository |				repository := IceRepositoryCreator new 			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'Import local repository into Iceberg'! !!IceNewRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buildDefaultSpec: col	col		newRow: [:row | row			add: #projectNameLabel width: 100;			add: #projectNameInput ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceNewRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Create repository'! !!IceNewRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	[		| repository |			self projectName isEmptyOrNil 		ifTrue: [ Error signal: 'Project name is required' ].		repository := IceRepositoryCreator new 			location: self location / self projectName;			subdirectory: subdirectory text;			createNewRepositoryNamed: self projectName.		repository register.		self window delete.		acceptBlock ifNotNil: [ acceptBlock cull: self ] ]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ].! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceNewRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	projectNameLabel := self newLabel label: 'Project name'.	projectNameInput := self newTextInput 		ghostText: 'project'; 		autoAccept: true.	self focusOrder add: projectNameInput.	super initializeWidgets! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ localDirectoryLocation location! !!IceNewRepositoryModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ self projectNameInput text! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameInput	^ projectNameInput! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameInput: anObject	projectNameInput := anObject! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameLabel	^ projectNameLabel! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameLabel: anObject	projectNameLabel := anObject! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'New repository'! !!IceDirectoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!chooseReference	^ UIManager default 		chooseDirectory: self chooseTitle 		path: self location! !!IceFileModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!chooseReference	^ (UIManager default 		chooseFileName: self chooseTitle 		extensions: nil 		path: self location 		preview: nil)		ifNotNil: [ :file | file asFileReference  ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultChooseDialogTitle	^ 'Choose directory'! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultLabel	^ 'Directory'! !!IceLocationModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newRow: [ :row | 			row 				add: #locationLabel width: 100; 			 	add: #locationInput; 				add: #chooseButton width: self iconWidth ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iconWidth	^ 24! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!choose	self chooseReference ifNotNil: [ :reference | 		self location: reference.		self locationInput text: reference pathString ]! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!chooseButton	^ chooseButton! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!chooseButton: anObject	chooseButton := anObject! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!chooseReference 	self subclassResponsibility! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!chooseTitle	^ chooseTitle ifNil: [ self class defaultChooseDialogTitle ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!chooseTitle: aString	chooseTitle := aString! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!icon	^ #open asIcon! !!IceLocationModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	locationLabel := self newLabel label: self label.	locationInput := self newTextInput autoAccept: true.	chooseButton := self newButton icon: self icon.		locationInput whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	chooseButton action: [ self choose ].		self focusOrder add: locationInput	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!label	^ label ifNil: [ self class defaultLabel ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!label: aString	label := aString.	self locationLabel label: aString	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ locationInput text trim 		ifNotEmpty: [ :value | value asFileReference ]		ifEmpty: [ nil ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: aReferenceOrString	locationInput text: aReferenceOrString asFileReference pathString! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationInput	^ locationInput! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationInput: anObject	locationInput := anObject! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationLabel	^ locationLabel! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationLabel: anObject	locationLabel := anObject! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #nameLabel width: 80; add: #namePanel ] height: 25;				newRow: [:row | row add: #urlLabel width: 80; add: #urlPanel ] height: 25;				add: #addButton height: self buttonHeight ];		yourself! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Add remote'! !!IceRemoteModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	| remoteName remoteUrl |		remoteName := self namePanel text trim.	remoteName ifEmpty: [ 		UIManager default alert: 'You need to specify a remote name.' title: 'Error'. ^ self ].	remoteUrl := self urlPanel text trim.	remoteUrl ifEmpty: [		UIManager default alert: 'You need to specify a remote url.' title: 'Error'. ^ self ].		self window delete.	acceptBlock ifNotNil: [ 		acceptBlock cull: (IceRemote name: remoteName url: remoteUrl) ]! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addButton	^ addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addButton: anObject	addButton := anObject! !!IceRemoteModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceRemoteModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	nameLabel := self newLabel. 	namePanel := self newTextInput ghostText: 'user-remote'; autoAccept: true.	urlLabel := self newLabel.	urlPanel := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	addButton := self newButton.		nameLabel label: 'Remote name'.	urlLabel label: 'Remote URL'.	addButton label: 'Add remote'.	addButton action: [ self accept ].		self focusOrder 		add: namePanel;		add: urlPanel;		add: addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameLabel	^ nameLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameLabel: anObject	nameLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!namePanel	^ namePanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!namePanel: anObject	namePanel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock 	acceptBlock := aBlock! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlLabel	^ urlLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlLabel: anObject	urlLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlPanel	^ urlPanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlPanel: anObject	urlPanel := anObject! !!ToolShortcutsCategory methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!openIceberg	<shortcut>	^ KMKeymap shortcut: PharoShortcuts current openIcebergShortcut action: [ IceRepositoriesBrowser  open ]! !!IceRemote methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!branchesFrom: aRepository	"I return all the branches of my remote from a repository"	^ aRepository branches		select: [ :branch | branch isRemote and: [ branch remoteName = self remoteName ] ]! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!asLocalStringYMDHM	^ self asLocal asStringYMDHM! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!asStringYMDHM	^ String streamContents: [ :aStream |		self printYMDOn: aStream.		aStream nextPut: Character space.		self hour printOn: aStream base: 10 length: 2 padded: true.		aStream nextPut: $:.		self minute printOn: aStream base: 10 length: 2 padded: true ]! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!renderCherryPickTreePresentation: aPresentation 	^ GLMMorphicCherryPickTreeRenderer render: aPresentation from: self! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!renderSwappedColorDiffPresentation: aPresentation	^ GLMMorphicSwappedColorDiffRenderer render: aPresentation from: self! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!allSelected	allSelected := true! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cherryPick	^ (self pane port: #cherryPick) value! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cherryPick: aValuable	^ (self pane port: #cherryPick) value: aValuable! !!GLMCherryPickTreePresentation methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	allSelected := false! !!GLMCherryPickTreePresentation methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAllSelected	^ allSelected! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onChangeOfCherryPick: aBlock	self onChangeOfPort: #cherryPick act: aBlock! !!GLMCherryPickTreePresentation methodsFor: 'rendering' stamp: ' 7/21/2017 17:44:57'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderCherryPickTreePresentation: self! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!cherryPickTree	^ self custom: GLMCherryPickTreePresentation new! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!swappedColorDiff	^ self custom: GLMSwappedColorDiffPresentation new	! !!IceGlamourSynchronizer class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 850@600! !!IceGlamourSynchronizer class methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!synchronize: anIceRepository	self new openOn: anIceRepository.! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	^ self repository branch! !!IceGlamourSynchronizer methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose	(self custom: GLMStacker new) with: [ :browser |		browser initialExtent: self initialExtent.		browser updateOn: Announcement from: [ :repo | repo announcer weak ].		browser aPane: #commit.		browser transmit 			transformed: #workingCopyDiff; 			to: #commit;			andShow: [ :a | a 				title: 'Commit your changes'; 				custom: IceGlamourCommitBrowser new ].		browser aPane: #update.		browser transmit 			to: #update;			andShow: [ :a | a 				title: 'Update'; 				custom: IceGlamourUpdateBrowser new ].		browser aPane: #publish.		browser transmit 			to: #publish;			andShow: [ :a | a 				title: 'Push'; 				custom: IceGlamourPublishBrowser new ].	]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ self repository location! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote ifNil: [ self repository pushRemote ]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: aRemote	remote := aRemote! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ (self pane port: #entity) value! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Synchronizing {1} -- branch: {2} -- remote: {3}' 		format: {			self location gtDisplayString.			self branch.			self remote }		! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!titleIcon	^ IceTool icon! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addCommitInfoTo: browser	browser transmit 		from: #commits; 		to: #diff; 		andShow: [ :a |			a morph				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ].! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser withTitle: diffTitle	browser transmit 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff				title: diffTitle;				display: [:change | self buildDiffInput: change ]]! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildDiffInput: change	^ { 		change myVersion ifNil: ''. 		change theirVersion ifNil: ''	}! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!configureBrowser: browser	"Do nothing, since the purpose of this browsers is to be embedded"! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!titleIcon	"Do nothing, since the purpose of this browsers is to be embedded"	^ nil! !!IceGlamourCommitBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser		row: [ :row | 			row				column: #changes; 				column: #commit ];		row: #diff.	browser transmit 		to: #changes;  		andShow: [ :a :diff |			self selectedElements: nil.			(IceDiffCherryPickChangeTreeBuilder new 				diff: diff;				onSelectCherryPick: [ :aSet | self selectedElements: aSet ];				buildOn: a)				title: 'Local changes' ].	browser transmit 		to: #commit;		andShow: [ :a :diff | 			a morph				title: 'Commit changes';				morph: [					IceCherryPickCommitModel new 						model: diff;						withSelectedCherryPick: [ self selectedElements ];						buildWithSpec ] ].	self addDiffTo: browser withTitle: 'Left: working copy / Right: local repository'! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectedElements	^ selectedElements! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectedElements: anObject	selectedElements := anObject! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo | 			(IceDiffChangeTreeBuilder new				entity: commitInfo; 				diff: (commitInfo ifNotNil: [ commitInfo diffWith: repo branch upstream ]);				buildOn: a)				title: 'Outgoing changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser 	! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeCommitsListIn: composite	composite fastTable		title: 'New local commits to be published';		display: #outgoingCommits;		column: 'User' evaluated: #username width: 120;		column: 'Date & time' evaluated: [:commit | commit datetime asLocal asStringYMDHM ] width: 120;		column: 'Comment' evaluated: #comment;		updateOn: IceCommited, IcePushed from: #announcer;		addAction: self pushAction;		addSelectionAction: self mergeIntoAction! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!pushAction	 ^ GLMGenericAction new			action: [ :presentation :repository | 				self 					pushRepository: repository					andThen: [ presentation selection: nil ]];			icon: GLMUIThemeExtraIcons glamorousRightSide;			shortcut: $p;			showTitle: 'Publish all'				! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildDiffInput: change	"The diff from an incoming change comes with the versions switched, 	so I have to switch them again."	^ { 		change theirVersion ifNil: ''.		change myVersion ifNil: ''. 	}! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo |.			(IceDiffChangeTreeBuilder new				entity: commitInfo;				diff: (commitInfo ifNotNil: [ commitInfo diffWith: (repo mergeBaseWith: commitInfo) ]); 				buildOn: a)				title: 'Incoming changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser ! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeCommitsListIn: composite	composite fastTable		title: 'New commits to be imported';		display: #incomingCommits;		column: 'User' evaluated: #username width: 120;		column: 'SHA' evaluated: #shortId width: 60;		column: 'Date & time' evaluated: [:commit | commit datetime asLocalStringYMDHM ] width: 100;		column: 'Status' evaluated: #status width: 80;		column: 'Comment' evaluated: #comment;		updateOn: IcePackageLoaded from: #announcer;		addAction: self fetchAction;		addAction: self pullAction;		addSelectionAction: self loadAction;		addSelectionAction: self mergeAction! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!fetchAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository fetch.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $f;		title: 'Fetch new versions'; 		showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!loadAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection load. 			presentation selection: nil ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged ]];		icon: #changeBlock asIcon;		shortcut: $l;		title: 'Load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!mergeAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection merge.			presentation selection: nil.			presentation pane browser update. ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged not ] ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge and load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!pullAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository pull.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $p;		title: 'Pull'; 		showTitle! !!IceBranchBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceBranchBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Branch browser'! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 850@600! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'History browser'! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new 		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffFromHead ]); 		buildOn: a)		title: 'Changes since selection'.	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffToParent ]);		buildOn: a)		title: 'Changes vs. parent' ! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addChangesTreesTo: browser	browser transmit 		from: #commits;		to: #changes; 		andShow: [ :a :commitInfo |			self addChangesTreeTo: a with: commitInfo ].! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBranchesIn: composite	composite fastTable		title: 'Branches';		display: #branchesForCheckout;		column: 'Name' evaluated: [ :branch :repo | 			self 				descriptionTextForBranch: branch				repository: repo ]		! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #branches span: 2; 				column: #commits span: 3; 				column: #changes span: 3]; 		row: #diff.		browser transmit to: #branches; andShow: [ :a | self composeBranchesIn: a ].	browser transmit from: #branches; to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeCommitsIn: composite	composite fastTable		title: 'Commits';		display: #commits;		column: 'Date & time' 			evaluated: [:commit | 				commit datetime asLocalStringYMDHM asText 					in: [ :text | 						commit isLoaded 							ifTrue: [ text ] 							ifFalse: [ text allBold ] ] ] 			width: 120;		column: 'Id' evaluated: #shortId width: 50;		column: 'User' evaluated: #username width: 120;		column: 'Parents' evaluated: [ :commit | ', ' join: (commit parents collect: #shortId) ] width: 100;		column: 'Comment' evaluated: #comment width: 300;				addSelectionAction: self inspectAction;		addSelectionAction: self mergeIntoCurrentBranchAction;		addSelectionAction: self mergeIntoAction.! !!IceHistoryBrowser methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!descriptionTextForBranch: aBranch repository: repo	| text |		self flag: #todo. "This is a duplication of IceRepositoryModel>>descriptionTextForBranch:. 	This can be solved by using an IceBranchModel instead the branch directly"	text := aBranch name asText.	(repo branch = aBranch)		ifTrue: [ text allBold ].			^ text! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/21/2017 17:44:57'!inspectAction	^ GLMGenericAction new		action: [ :presentation | presentation selection inspect ]; 		shortcut: $i; 		title: 'Inspect'; 		yourself! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/21/2017 17:44:57'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/21/2017 17:44:57'!mergeIntoCurrentBranchAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				targetBranch: presentation selection repository branch;				onMerge: [					presentation selection: nil.					presentation pane browser update ];				run ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $M;		title: 'Merge into current branch'; 		showTitle! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/21/2017 17:44:57'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/21/2017 17:44:57'!menuCommandOn: aBuilder 	"Add a custom menu item to the world menu"		<worldMenu> 		(aBuilder item: #'Iceberg')		order: 0.18; 		icon: self icon;  		parent: #'Tools';		keyText: 'o, i';		action: [ self open ].! !!IceRepositoriesBrowser class methodsFor: 'opening' stamp: ' 7/21/2017 17:44:57'!open	"self open"	^ self new open! !!IceRepositoriesBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Iceberg repositories'! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/21/2017 17:44:57'!abort: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addGlobalMenu	self		act: [ 			SettingBrowser new 				changePackageSet: { (RPackageOrganizer default packageNamed: 'Iceberg') }; 				open; 				expandAll ] 		icon: #configuration asIcon		entitled: 'Global Settings'! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addLocalRepository	IceImportLocalRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!addLocalRepositoryAction	^ GLMGenericAction new		action: [ self addLocalRepository ];		icon: #packageAdd asIcon;		shortcut: $a;		title: 'Add local repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!addPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			self addPackageToRepository: repo repository.			presentation update ];		icon: #add asIcon;		shortcut: $a;		title: 'Add package'; showTitle! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addPackageToRepository: repo	| options descriptionBlock |		descriptionBlock := [ :wc | 		wc modified 			ifTrue: ['* ', wc packageName]			ifFalse: [ wc packageName ]].	options := MCWorkingCopy allManagers difference: repo workingCopies.	(self class chooseFrom: options displaying: descriptionBlock) 		ifNotNil: [ :workingCopy | repo addPackage: workingCopy ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!addRemoteAction	^ GLMGenericAction new		action: [ :presenter | 			presenter selection addRemoteThen: [ :remote | 				self announce: (IceRemoteAdded remote: remote) ] ];		selectionCondition: #isOperative;		showTitle: 'Add remote...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addRepositoryBranchesTo: composite	| branches |	(branches := composite fastTreeTable)		title: 'Branches';		display: [ :repository | 			| localisations |			localisations := repository remotes collect: [ :remote | IceBranchGroupModel repository: repository remote: remote ] as: OrderedCollection.			repository hasLocalBraches				ifTrue: [ localisations addFirst: (IceBranchGroupModel localFromRepository: repository) ].			localisations ];		children: #children;		column: 'Name' evaluated: #nameToDisplay;		column: 'Status' evaluated: #status;		allExpanded.	"actions"	branches addAction: self branchCreateNewAction.		"selection actions"	branches		addSelectionAction: self branchSwitchAction;		addSelectionAction: self branchCompareWithCurrentAction! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addRepositoryInfoTo: composite	composite fastTable		title: 'General';		display: #detailedInfo;		column: 'Name' evaluated: #key width: 80;		column: 'Value' evaluated: #value! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addRepositoryRemotesTo: composite	| remotes |		(remotes := composite fastTable)		title: 'Remotes';		display: #remotes;		column: 'Name' evaluated: [ :remote :model | model descriptionTextForRemote: remote] width: 80;		column: 'URL' evaluated: #url width: 380;		column: 'Status' evaluated: [ :remote :model | model statusForRemote: remote ];		updateOn: IceRemoteAdded from: #announcer.			"actions"	remotes addAction: self remoteAddAction.	"selection actions"	remotes 		addSelectionAction: self remoteMakePullingAction;		addSelectionAction: self remoteMakePushingAction;		addSelectionAction: self remoteFetchAction;		addSelectionAction: self remotePullAction;		addSelectionAction: self remotePushAction;		addSelectionAction: self remoteRemoveAction.	"Plugin actions"	remotes dynamicActionsOnSelection: [ :presentation | 		presentation entity pluginRemoteActionsFor: presentation selection ]! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/21/2017 17:44:57'!alert: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/21/2017 17:44:57'!branchCompareWithCurrentAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection compareCurrentToMe.			presentation pane browser update ];		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil: #isBranchModel ];		showTitle: 'Compare with current branch';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/21/2017 17:44:57'!branchCreateNewAction	^ GLMGenericAction new		action: [ :presentation :model | 			model createNewBranchThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Create branch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/21/2017 17:44:57'!branchSwitchAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection switchToMe.			presentation pane browser update ];		showTitle: 'Switch to this branch';		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil:  #isBranchModel ];		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!browsePackageAction	^ GLMGenericAction new		selectionAction: #browse;		selectionCondition: #isLoaded;		showTitle: 'Browse package';		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepository	IceCloneRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryAction	^ GLMGenericAction new		action: [ self cloneRepository ];		icon: #add asIcon;		shortcut: $c;		title: 'Clone repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryAgainAction	^ GLMGenericAction new		selectionAction: #restore;		selectionCondition: #isMissing;		showTitle: 'Clone repository again';		shortcut: $R;		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose	self addGlobalMenu.	super compose! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: #repositories; 		row: #info.	browser transmit 		to: #repositories; 		andShow: [ :presentation | 			self composeRepositoriesIn: presentation ].	browser transmit 		from: #repositories; 		to: #info; 		andShow: [ :a |			(a custom: GLMWrapper new)				show: [ :wrapper | self composeRepositoryInfoIn: wrapper ];				when: [ :model | model isValid ].			(a custom: GLMWrapper new) 				show: [ :wrapper | self composeNotValidIn: wrapper ];				when: [ :model | model isValid not ] ].		! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeNotValidIn: composite	composite actionList		title: [ :repo | 'Repository {1} is invalid.' format: { repo descriptionText } ];		beVertical;		act: [ :presentation :model | 			model editRepositoryThen: [ 				"scale to top browser"				presentation pane browser pane browser update ] ] entitled: 'Edit...';		act: [ :presentation :model | 				model restore. 				presentation pane browser pane browser update ] entitled: 'Clone';		act: [ :presentation :model | 			model forgetThen: [ 				presentation pane browser pane browser update ] ] entitled: 'Forget'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composePackagesListIn: composite	composite fastTable		title: 'Packages';		display: #savedPackages;		column: 'Name' evaluated: #nameText width: 200;		column: 'Status' evaluated: #status;		addAction: self reloadAllPackagesAction;		addAction: self addPackageAction;		addSelectionAction: self browsePackageAction;		addSelectionAction: self loadPackageAction;		addSelectionAction: self unloadPackageAction;		addSelectionAction: self reloadPackageAction;		addSelectionAction: self unloadAndRemovePackageAction;		addSelectionAction: self removePackageAction;		addSelectionAction: self removePackageFromDiskAction;		enableFilter: [ :packageModel :pattern | packageModel packageName includesSubstring: pattern caseSensitive: false ];		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection ifNotNil: [ 				presentation entity pluginPackageActionsFor: presentation selection entity ]];		updateOn: IceCommited from: #announcer! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeRepositories: repositories in: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	repositories do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeRepositoriesIn: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	self repositoryRegistry do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeRepositoryInfoIn: composite	self addRepositoryInfoTo: composite.	self composePackagesListIn: composite.	self addRepositoryRemotesTo: composite.	self addRepositoryBranchesTo: composite.	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!createNewBranchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection createNewBranchThen: [] ];		selectionCondition: #isOperative;		showTitle: 'Create new branch...';		shortcut: $B.! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!editRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection editRepositoryThen: [				presentation pane browser pane update ] ];		showTitle: 'Edit repository...';		shortcut: $e;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!fetchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection fetch.			presentation update ];		selectionCondition: #isOperative;		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch incoming comits';		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetchAllRepositories	UIManager default informUserDuring: [ :bar |		| repositoriesCount |		repositoriesCount := IceRepository registry size.		bar max: repositoriesCount + 1.				IceRepository registry doWithIndex: [ :repository :index|			bar label: 				('Looking for incoming commigs in all repositories ({1} of {2})'					format: {index. repositoriesCount}).			bar current: index.						repository fetch.		]]	 ! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!fetchAllRepositoriesAction	^ GLMGenericAction new 		action: [ self fetchAllRepositories ];		icon: #glamorousLeftSide asIcon;		shortcut: $F;		showTitle: 'Fetch all'		! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!forgetRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection forgetThen: [ 				presentation pane browser pane update ] ];		showTitle: 'Forget repository...'; 		shortcut: $x; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!inspectRepositoryAction	^ GLMGenericAction new		selectionAction: #inspectRepository;		showTitle: 'Inspect';		shortcut: $i;		yourself! !!IceRepositoriesBrowser methodsFor: 'private testing' stamp: ' 7/21/2017 17:44:57'!isRepositoryVisible: aRepository	^ aRepository isSystemRepository not 		or: [ Iceberg showSystemRepositories ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!loadPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			presentation selection loadLatest.			presentation update ]; 		icon: #add asIcon;		shortcut: $l; 		title: 'Load package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded not ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newRepository	IceNewRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!newRepositoryAction	^ GLMGenericAction new		action: [ :presentation | self newRepository ];		icon: #smallNew asIcon;		shortcut: $n;		title: 'New repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'scripting opening' stamp: ' 7/21/2017 17:44:57'!open	IceRepository defaultBackend 		verifyBackendAvailabilityIfNot: [ :requiredVersion :currentVersion | 			^ UIManager default 				alert: ('This version of Iceberg requires libgit2 {1} to run (you have {2}).Please update your PharoVM before continue.' format: { requiredVersion. currentVersion }) ].	self openOn: Object new! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pullAction	^ GLMGenericAction new		selectionAction: #pull;		selectionCondition: #isOperative;		icon: GLMUIThemeExtraIcons glamorousLeftSide;		showTitle: 'Pull incoming commits'; 		shortcut: $p; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pullFromAction	^ GLMGenericAction new		selectionAction: #pullFrom;		selectionCondition: #isOperative;		showTitle: 'Pull from...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pushAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushThen: [ presentation pane browser update ]];		selectionCondition: #canPush;		icon: #glamorousRightSide asIcon;		showTitle: 'Push outgoing commits'; 		shortcut: $P; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pushToAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushToThen: [ presentation pane browser update ]];		selectionCondition: #isOperative;		"icon: GLMUIThemeExtraIcons glamorousRightSide;"		showTitle: 'Push to...';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!refreshRepositoryAction	^ GLMGenericAction new		selectionAction: #refresh;		showTitle: 'Refresh repository';		shortcut: $r! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!reloadAllPackagesAction	^ GLMGenericAction new		action: [ :presentation :model | 			model reloadAllLoadedPackages. 			presentation update ];		condition: [ :presentation :repo | (repo entity savedPackages select: #isLoaded) notEmpty ];		icon: #refresh asIcon;		shortcut: $e;		title: 'Reload all'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!reloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection reload.			presentation update ]; 		icon: #refresh asIcon;		shortcut: $r; 		title: 'Reload package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteAddAction	^ GLMGenericAction new		action: [ :presentation :model | 			model addRemoteThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Add remote'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteFetchAction	^ GLMGenericAction new		action: [ :presentation :model | 			model fetchRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteMakePullingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePullRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default pull remote'; 		enabledCondition: [ :presentation :model | 			(model isPullRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteMakePushingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePushRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default push remote'; 		enabledCondition: [ :presentation :model | 			(model isPushRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remotePullAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pullRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Pull'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remotePushAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pushRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousRightSide asIcon;		showTitle: 'Push'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteRemoveAction	^ GLMGenericAction new		action: [ :presentation :model | 			model 				removeRemote: presentation selection				then: [ presentation pane browser update ] ];		icon: #remove asIcon;		showTitle: 'Remove'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!removePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from repository (do not unload)'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!removePackageFromDiskAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded not ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!repositoryRegistry 	^ IceRepository registry! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!showHistoryAction	^ GLMGenericAction new		selectionAction: #browseHistory;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		showTitle: 'Show history...';		shortcut: $h! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!switchBranchAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection ifNotNil: [:repo | repo switchBranch ].			presentation pane browser pane update ];		enabledCondition: [ :presentation | 			presentation selection notNil ];			selectionCondition: #isOperative;		showTitle: 'Switch branch...';		shortcut: $b.! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/21/2017 17:44:57'!synchronize: repository	"This hack is a workaround because port #strongSelection of glamour generates multiple events for a single double-click."	(lastSynchronization isNil 		or: [ (DateAndTime current - lastSynchronization first) seconds > 1		or: [ lastSynchronization second  ~= repository ]])		ifTrue: [ 			lastSynchronization := { DateAndTime current. repository }.			IceGlamourSynchronizer synchronize: repository ]	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!synchronizeRepositoryAction	^ GLMGenericAction new		selectionAction: #synchronize;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		shortcut: $s;		title: 'Synchronize repository...'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!unloadAndRemovePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				unloadAndRemoveFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Unload & remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!unloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection unload.			presentation update ]; 		icon: #delete asIcon;		shortcut: $u; 		title: 'Unload package'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!visibleRepositoryModels	^ self repositoryRegistry 		select: [ :each | self isRepositoryVisible: each  ]		thenCollect: [ :repo | IceRepositoryModel modelFor: repo ]! !!IceTool class methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!chooseFrom: options displaying: descriptionBlock 	"Description block is used both for sorting and for displaying"		| sortedOptions index  |	sortedOptions := options asSortedCollection: [:wc1 :wc2 | (descriptionBlock value: wc1) < (descriptionBlock value: wc2) ].	index := self uiManager chooseFrom: (sortedOptions collect: descriptionBlock).	^ index > 0 		ifTrue: [ sortedOptions at: index ]		ifFalse: [ nil ]! !!IceTool class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ RealEstateAgent standardWindowExtent! !!IceTool class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceTool class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ nil! !!IceTool methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose 	self tabulator with: [ :browser |		self configureBrowser: browser.		self composeBrowserOn: browser  ]! !!IceTool methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser 	self subclassResponsibility! !!IceTool methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!configureBrowser: browser	"hack to add initial properties (as initialExtent) to browsers"		browser initialExtent: self initialExtent! !!IceTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceTool methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				onMerge: [					presentation selection: nil.					presentation pane browser update 				];				run		];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ self class title! !!IceTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!titleIcon	^ self class icon! !!IceInteractiveCredentialsProvider class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:57'!initialize	"self initialize"	IceCredentialsProvider providerType: self.! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!askForPlaintextCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForPlaintextCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class plaintextCredentials: credentials ].			response readFrom: credentials.		];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!askForSshCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForSshCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class sshCredentials: credentials ].			response readFrom: credentials ];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	tries := 0! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!providePlaintextCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self plaintextCredentials isPresent		ifTrue: [ credentials readFrom: self plaintextCredentials ]		ifFalse: [ self askForPlaintextCredentials: credentials ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!provideSshAgentCredentialsTo: credentials	"Just check for tries to ensure we do not enter an infinite cycle in libgit2"	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'No ssh-agent credentials found.' ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!provideSshCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self sshCredentials isPresent		ifTrue: [ credentials readFrom: self sshCredentials ]		ifFalse: [ self askForSshCredentials: credentials ].! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cellColumn: column row: rowIndex	| item cell |	item := self elementAt: rowIndex.	cell := FTIndentedCellMorph new.	cell indentBy: item depth * 16.	cell 		addMorphBack: (self buttonFor: item);		addMorphBack: (CheckboxButtonMorph new			selected: (self isSelected: item data);			target: [ self toggleSelectionOf: item ];			actionSelector: #value;			yourself);		addMorphBack: (self createCellMorphFor: item).	^ cell! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createCellMorphFor: item	| morph rowElements |	rowElements := OrderedCollection new.	(self iconFor: item data) ifNotNil: [ :icon | rowElements add: icon asMorph ].	rowElements		add: (self formatedDisplayValueOf: item data) asMorph asReadOnlyMorph;		addAll: (self tagMorphsFrom: self glamourPresentation for: item data).	morph := self createInnerCellMorph.	rowElements do: [ :each | morph addMorphBack: each ].	^ morph				! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createInnerCellMorph	^ Morph new 		layoutPolicy: TableLayout new;		color: Color transparent;		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		cellPositioning: #leftCenter;		cellInset: 5;		listCentering: #leftCenter;		wrapCentering: #leftCenter;		yourself! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!deselectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection remove: each data ifAbsent: [] ].	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	selection := Set new! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!isSelected: anObject	^ selection includes: anObject! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/21/2017 17:44:57'!selectAll	self rootsItems do: [ :each | 		self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!selectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection add: each data ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectAllWithChildren: aCollection	selection := Set new.	aCollection do: [ :each | self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selected: aCollection	selection := aCollection asSet! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selection	^ selection! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!tableRefresh	self table ifNil: [ ^ self ].	super tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!toggleSelectionOf: item	(self isSelected: item data) 		ifTrue: [ self deselectAllChildrenOf: item ]		ifFalse: [ self selectAllChildrenOf: item ].	self glamourPresentation cherryPick: selection.	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/21/2017 17:44:57'!updateSelectionWithCollectBlock: aBlock	self table ifNil: [ ^ self ].	super updateSelectionWithCollectBlock: aBlock! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!withAllChildrenOf: item	^ item children		inject: { item }		into: [ :all :each | all, (self withAllChildrenOf: each) ]! !!IceRemoteAdded class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!remote: aRemote	^ self new remote: aRemote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/21/2017 17:44:57'!additionColor	^ super removalColor! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/21/2017 17:44:57'!removalColor	^ super additionColor ! !!GLMSwappedColorDiffPresentation methodsFor: 'rendering' stamp: ' 7/21/2017 17:44:57'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderSwappedColorDiffPresentation: self! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ false! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeRemove! !!MCAddition methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeAdd! !!MCPatchOperation methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ true! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	"It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches."	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isBranchModel	^ false! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameToDisplay	^ self subclassResponsibility ! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	^ self subclassResponsibility! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!localFromRepository: aRepository	^ self		repository: aRepository		branches: #localBranches		groupName:			('Local' asText				allBold;				yourself)! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository branches: aCollection groupName: aString	^ self new		repository: aRepository;		branches: aCollection;		groupName: aString;		yourself! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository remote: aRemote	^ self repository: aRepository branches: [ :repository | aRemote branchesFrom: repository ] groupName: aRemote asString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branches	^ branches cull: self repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branches: aBlockOrSymbol	branches := aBlockOrSymbol! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	^ self branches collect: [ :branch | IceBranchModel parent: self branch: branch ]! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!groupName	^ groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!groupName: aString	groupName := aString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameToDisplay	^ self groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anIceRepository	repository := anIceRepository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	^ self branches size asString , ' branches'! !!IceBranchModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!parent: anIceBranchGroupModel branch: anIceBranch	^ self new		parentGroup: anIceBranchGroupModel;		branch: anIceBranch;		yourself! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	^ branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch: anIceBranch	branch := anIceBranch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	^ #()! !!IceBranchModel methodsFor: 'action' stamp: ' 7/21/2017 17:44:57'!compareCurrentToMe	self repository compareCurrentBranchWithBranch: self branch! !!IceBranchModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isBranchModel	^ true! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameToDisplay	^ self repository descriptionTextForBranch: self branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentGroup	^ parentGroup! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentGroup: anIceBranchGroupModel	parentGroup := anIceBranchGroupModel! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self parentGroup repository! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	| incoming outgoing allStatus |		incoming := self branch incomingCommits size.	outgoing := self branch outgoingCommits size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ allStatus asCommaString! !!IceBranchModel methodsFor: 'action' stamp: ' 7/21/2017 17:44:57'!switchToMe	self repository switchBranchTo: self branch! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!clearModels	"Clear the model cache, this is needed for correct testing"	modelCache := nil.! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!compactIfNeeded	| newModelCache |	self models size > 250 ifFalse: [ ^ self ].	newModelCache := self models select: [ :each | each notNil ].	modelCache := newModelCache	! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!modelFor: entity	| model |	"We are using WeakValueDictionary to keep this sinchronized (in case you have more than 	 one window open, you want always same model). Now, it has to be cleaned when windows are 	 no longer around, but associations will be nil... so we cannot use a simple ifAbsentPut:. 	 Yep, ugly... but effective."		model := self models at: entity name ifAbsent: [ nil ].	^ model ifNil: [ 		self compactIfNeeded.		self models 			at: entity name			put: (self basicNew 				entity: entity; 				initialize; 				yourself) ]! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!models	"since a repository can have same name as a package (and we keep models by name), 	 I need to keep this as an instance of class and not a variable (who would be 	 shared by all hierarchy and because of that prone to errors)"	^ modelCache ifNil: [ modelCache := WeakValueDictionary new ]! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #modelFor:'! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ self entity announcer! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorError	^ Color red! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorIncoming	^ Color brown! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorModified	^ Color r: 0 g: 0.5 b: 0! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorNotLoaded	^ Color darkGray! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorOutgoing	^ Color blue! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity	^ entity! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity: anObject	entity := anObject! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!highlight: aString	[ 		| text modified incoming outgoing |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		incoming := self incomingCommits notEmpty.		outgoing := self outgoingCommits notEmpty.		modified ifTrue: [ text prepend: '* ' ].		modified | incoming | outgoing ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		incoming ifTrue: [ ^ text makeAllColor: self colorIncoming ].		outgoing ifTrue: [ ^ text makeAllColor: self colorOutgoing ].		^ text	]	on: Error do: [ ^ aString ]! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ incomingCommits value! !!IceAbstractModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	"NOTE: this was before [ self entity incomingCommits ], but this is not happy 	 with weak announcements (they will remain forever)... so we change them for 	 WeakMessageSend instances to avoid problems"	incomingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #incomingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak.		outgoingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #outgoingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLoaded	self subclassResponsibility ! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isMissing	^ self repository isMissing! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isOperative	^ self repository isMissing not! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!makeError: aString	^ aString asText allBold makeAllColor: self colorError	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ outgoingCommits value	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	self subclassResponsibility! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	"entity could be a repository or a package"	[		| status incoming outgoing | 		self verifyDirectoryStructureIfMissing: [ :message | ^ message ].				self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				incoming := self incomingCommits size.		incoming > 0 ifTrue: [ status add: ('{1} incoming' format: { incoming })].				outgoing := self outgoingCommits size.		outgoing > 0 ifTrue: [ status add: ('{1} not published' format: { outgoing })].		^ status ifEmpty: 'Up to date' ifNotEmpty: [ ', ' join: status ]	] 	on: Error do: [ :error | ^ self makeError: error description ]! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!verifyDirectoryStructureIfMissing: aBlock	self repository isMissing 		ifTrue: [ ^ aBlock value: (self makeError: 'Local repository missing') ].	self repository isCodeMissing		ifTrue: [ ^ aBlock value: (self makeError: 'Code directory missing') ].! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browse	^ self package browse! !!IcePackageModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!highlight: aString	[ 		| text modified |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		modified ifTrue: [ text prepend: '* ' ].		modified ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		^ text	]	on: Error do: [ ^ aString ]! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self package isLoaded! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!loadLatest	self package loadLatest! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!nameText	^ self highlight: self packageName! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!package	^ entity! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package name! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!reload	self package reload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDisk	self entity removeFromDisk! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDiskThen: aBlock	(UIManager default confirm: ('You are going to remove package {1} from disk. Are you sure?' format: { self entity name }))		ifFalse: [ ^ self ].	self entity removeFromDisk: true.	aBlock value! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self entity repository! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!status	"entity could be a repository or a package"	[		| status | 		self repository isMissing ifTrue: [ ^ 'Local repository missing' asText allBold makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				^ status 			ifNotEmpty: [ status asCommaString ]			ifEmpty: [ 'Up to date' ] ] 	on: Error do: [ :error | ^ error description asText makeAllColor: self colorError ]! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!unload	self package unload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!unloadAndRemoveFromDiskThen: aBlock	self unload.	self removeFromDiskThen: [].	aBlock value! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!registry	^ IceRepository registry collect: [ :repository | self modelFor: repository ]! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!tagDefaultPull	^ 'Pull'! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!tagDefaultPush	^ 'Push'! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!addRemoteThen: aBlock	IceRemoteModel new 		setModal: true;		repository: self repository;		onAccept: [ :remote |			self repository addRemote: remote. 			aBlock cull: remote ];		openWithSpec! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self repository branch name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branches	^ self repository allBranches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browseHistory	IceHistoryBrowser openOn: self repository! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canPush	[ 		^ self isOperative 			and: [ self outgoingCommits notEmpty 			and: [ self incomingCommits isEmpty ] ]	]	on: Error do: [ ^ false ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!compareCurrentBranchWithBranch: aBranch	IceBranchBrowser openOn: aBranch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createNewBranchThen: aBlock	| selection |	selection := UIManager default		request: 'Please provide the name of the new branch to be created'		initialAnswer: ''		title: 'Create new branch'.	selection ifNotNil: [ 		selection 			ifEmpty: [ 				UIManager default 					abort: 'Branch name can not be empty.' 					title: 'Create new branch'. ]			ifNotEmpty: [ 				self repository createBranch: selection.				aBlock cull: self repository branch ] ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!descriptionText	^ self highlight: self repository name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!descriptionTextForBranch: aBranch	^ aBranch isRemote		ifTrue: [ aBranch basename ]		ifFalse: [ | text |			text := aBranch name asText.			(self isCurrentBranch: aBranch)				ifTrue: [ text allBold ].			text ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!descriptionTextForRemote: aRemote	^ aRemote remoteName! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ 	self repository origin detailedInfo, { 		'Location' -> self repository location pathString. 		'Pulling from' -> (self repository pullRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]). 		'Pushing to' -> (self repository pushRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]).		'On branch' -> self repository branchName.	} ! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!editRepositoryThen: aBlock	(IceEditRepositoryModel repository: self repository) 		onAccept: aBlock;		openWithSpec! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	^ self repository fetch! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!fetchRemote: aRemote 	self repository fetchFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!forgetThen: aBlock	(UIManager default confirm:			('Are you sure to remove repository: {1}?(Packages will not be deleted, nor the repository from the file system)'				format: { self repository origin url })		label: 'Removing Iceberg Repository')	ifTrue: [ 		self repository forget.		aBlock cull: self ]! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasLocalBraches	^ self repository hasLocalBraches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!inspectRepository	self repository inspect! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isCurrentBranch: aBranch	^ self repository branch = aBranch! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self repository loadedPackages isNotEmpty ! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPullRemote: aRemote	^ self repository isPullRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPushRemote: aRemote	^ self repository isPushRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isValid	^ self repository isValid! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedCodeDescription	self verifyDirectoryStructureIfMissing: [ :message | ^ message ].	^ self repository loadedCode description! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!localBranches	^ self repository localBranches! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!makePullRemote: aRemote	self repository pullRemote: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!makePushRemote: aRemote	self repository pushRemote: aRemote! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pickBranch 	| branches |	 	branches := self repository branchesForCheckout.	^ UIManager default		chooseFrom: (branches collect: #name)		values: branches		message: 'Select the new branch you want to switch to:' 		title: 'Checkout branch'! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pickRemote: aTitle	| remotes |	 	remotes := self repository remotes.	^ UIManager default		chooseFrom: (remotes collect: #remoteName)		values: remotes		message: 'Select the remote you want to use:' 		title: aTitle! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/21/2017 17:44:57'!pluginActions	^ self repository pluginManager repositoryActions! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/21/2017 17:44:57'!pluginPackageActionsFor: icePackage	^ self repository pluginManager packageActionsFor: icePackage! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/21/2017 17:44:57'!pluginRemoteActionsFor: aRemote	^ self repository pluginManager remoteActionsFor: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pull	self validateCanPull ifFalse: [ ^ self ].	self repository pull! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pullFrom	| remote |	self validateCanPull ifFalse: [ ^ self ].	remote := self pickRemote: 'Pull from'.	remote ifNil: [ ^ self ].	self repository pullFrom: remote.! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!pullRemote: aRemote	self repository pullFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!pushRemote: aRemote	self repository pushTo: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushThen: aBlock	self 		pushTo: self repository pushRemote 		then: aBlock! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pushTo: aRemote then: aBlock	"We need an existing remote as premise to do the push (new repositories can have this 	 situation)"	aRemote ifNil: [ 		^ UIManager default			abort: 'There is no remote to publish, please add one (in "remotes" tab).'			title: 'Publishing aborted' ].	[ 		UIManager default informUserDuring: [ :bar | 			bar label: ('Publishing local commits to {1}' format: { aRemote url }).			self repository pushTo: aRemote. 			aBlock value ] ] 	on: YouShouldPullBeforePush	do: [ 		UIManager default			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushToThen: aBlock	| remote |	remote := self pickRemote: 'Push to'.	remote ifNil: [ ^ self ].	self pushTo: remote then: aBlock! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	self repository refresh! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!reloadAllLoadedPackages	self repository savedPackages 		select: #isLoaded 		thenDo: [ :each | each reload ].! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remotes	^ self repository remotes! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!removeRemote: aRemote then: aBlock	(self confirm: (('You are going to remove remote {1}. Are you sure?') format: {aRemote}))		ifFalse: [ ^ self ].	self repository removeRemote: aRemote.	aBlock cull: aRemote! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self entity! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!restore	self repository backend cloneRepository.	self repository refresh.! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!savedPackages	^ [self repository savedPackages collect: [ :package | IcePackageModel modelFor: package ]]		on: Error do: [ :error | 			self inform: ('Error computing saved packages for repository: {1}. {2}'				format: { self repository name. error }).			#()		]! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!shouldCreateLocalBranchFromRemote 	^ UIManager default		confirm: 'You are trying to switch to a remote branch.' , String cr , 			'Do you want to create a local branch for it?' , String cr ,			'Note: if you do not create a local branch, you will be in a detached head and you won''t be abe to commit code!!'		label: 'Checkout remote branch'! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!statusForRemote: aRemote	| incoming outgoing allStatus |		incoming := (self repository incomingCommitsFrom: aRemote) size.	outgoing := (self repository outgoingCommitsTo: aRemote) size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ ((self tagsForRemote: aRemote), allStatus) asCommaString! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!switchBranch	| branch |	branch := self pickBranch.	branch ifNil: [ ^ self ].	self switchBranchTo: branch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!switchBranchTo: branch	branch isRemote		ifTrue: [ self repository localBranches 				detect: [:aBranch | aBranch name = branch basename ]				ifFound: [ UIManager default inform: 'Cannot switch to this branch. A local branch with the same name already exists!!'.								self flag: 'We should probably go into detached head state.' ]				ifNone: [ self shouldCreateLocalBranchFromRemote 					ifTrue: [ self repository backend withRepoDo: [ :repo | repo createBranchFromOrigin: branch basename ].								self repository checkoutBranch: branch basename ]					ifFalse: [ self shouldBeImplemented ] ] ]		ifFalse: [ self repository checkoutBranch: branch basename ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!synchronize	IceGlamourSynchronizer synchronize: self repository! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!tagsForRemote: aRemote	| tags |		tags := OrderedCollection new.	(self isPushRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPush ]. 	(self isPullRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPull ]. 		^ tags asArray! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validateCanPull	self repository isModified		ifTrue: [ 			^ IceTool uiManager				confirm:					'Your repository has uncommited changes. Merging incoming commits will changeyour current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'				label: 'You might loose your current changes!!'				trueChoice: 'Proceed anyway'				falseChoice: 'Cancel'				cancelChoice: nil				default: false ].	^ true! !!IceCachedValue class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aBlock	^ self new updateAction: aBlock! !!IceCachedValue class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!timeout	^ 30 seconds! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	updating := false! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!invalidateOn: announcementType from: announcer	announcer subscribe: announcementType send: #reset to: self! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!isValid	^ lastUpdated isNotNil and: [ (DateAndTime current - lastUpdated) < self class timeout ]! !!IceCachedValue methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!reset	lastUpdated := nil! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!updateAction: anObject	updateAction := anObject! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!value	self isValid ifTrue: [ ^ value ].	updating ifTrue: [ ^ 'Loading...' asText allItalic ].	[ 		updating := true.		value := updateAction value.		lastUpdated := DateAndTime current.		^ value	]	ensure: [ updating := false ]! !!IceChangesTreeResetSelectionHelper class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceChangesTreeResetSelectionHelper methodsFor: 'executing' stamp: ' 7/21/2017 17:44:57'!execute: ann	self presentation selection: nil! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation	^ presentation! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation: anObject	presentation := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browseAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browse ];		condition: [ :presentation :entity | 			presentation selection notNil 				and: [ presentation selection canBeBrowsed ]];		icon: #nautilus asIcon;		shortcut: $b;		title: 'Browse'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browseReferencesAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browseReferences ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection canBrowseReferences ]];		shortcut: $n;		title: 'Browse references'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildOn: aPresenter	^ aPresenter fastTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [  				self diff announcer 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!diff	^ diff! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!diff: anObject	diff := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!elements 	^ self diff elements select: #hasChanges! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity	^ entity ifNil: [ self diff ]! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity: anObject	entity := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refreshTreeAction	^ GLMGenericAction new		action: [ self entity refresh ];		icon: #glamorousRefresh asIcon;		shortcut: $r;		title: 'Refresh tree'; showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!revertChangeAction	^ GLMGenericAction new		action: [ :presentation | self entity revertChange: presentation selection ];		condition: [ self entity canRevertChanges ];		icon: #glamorousUndo asIcon;		title: 'Revert change'; 		showTitle! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildOn: aPresenter	^ aPresenter cherryPickTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		allSelected;		onChangeOfCherryPick: [ :presentation | self selectedCherryPick: presentation cherryPick ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [				self diff announcer 					subscribe: IceChangeSetChanged					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onSelectCherryPick: aBlock	cherryPickBlock := aBlock! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectedCherryPick: aSet	cherryPickBlock ifNil: [ ^ self ].	cherryPickBlock value: aSet! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!chooseTargetBranch	| branches |		self targetBranch ifNotNil: [ ^ self targetBranch ].		branches := self repository branchesForMerge: self source.	^ targetBranch := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { source shortId })		title: 'Merge your changes into another branch'.! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!confirmContinueWithDirtyRepository	^ self uiManager		confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'		label: 'You might loose your current changes!!'		trueChoice: 'Proceed anyway'		falseChoice: 'Cancel'		cancelChoice: nil		default: false! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!informAutomaticMergeImpossible	self uiManager		abort: 'Automatic merge is not possible, to merge manually please first checkout branch ', self targetBranch name, ' and then retry.' 		title: 'Automatic merge impossible'! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onMerge	^ onMerge! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onMerge: anObject	onMerge := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository ifNil: [ repository := self source repository ]! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	^ repository := anObject! !!IceMergeTool methodsFor: 'merging' stamp: ' 7/21/2017 17:44:57'!run	"Merge selected commit into another branch"	self repository isModified ifTrue: [ 		self confirmContinueWithDirtyRepository ifFalse: [ ^ self ]].	self chooseTargetBranch ifNil: [ ^ self ].	[ source mergeInto: self targetBranch ]		on: IceMergeAborted		do: [ 			self targetBranch name = repository branchName 				ifTrue: [ repository mergeConflictsWith: source ]				ifFalse: [ self informAutomaticMergeImpossible. ^ self ]].	self onMerge value ! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!source	^ source! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!source: anObject	source := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetBranch	^ targetBranch! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetBranch: anObject	targetBranch := anObject! !!IceRepositoryUpdateHelper class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceRepositoryUpdateHelper methodsFor: 'executing' stamp: ' 7/21/2017 17:44:57'!execute: ann	self presentation		updateOn: IceRepositoryAnnouncement 		from: [ ann repository announcer weak ]! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation	^ presentation! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation: anObject	presentation := anObject! !!PharoShortcuts methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!openIcebergShortcut	^ $o meta, $i meta! !!Text methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!allItalic	"Force this whole text to be italic."	string isEmpty ifTrue: [ ^ self ].	^ self addAttribute: TextEmphasis italic from: 1 to: string size.! !!GLMMorphicSwappedColorDiffRenderer methodsFor: 'rendering' stamp: ' 7/21/2017 17:44:57'!render: aPresentation	| textMorph |	textMorph := (SwappedColorDiffMorph		from: aPresentation displayValue first		to: aPresentation displayValue last		contextClass: aPresentation contextClassValue)			layoutFrame: (LayoutFrame identity);			vResizing: #spaceFill;			hResizing: #spaceFill;			yourself.	^textMorph! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !"Iceberg-UI"!!IceGitHubPullRequestBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show a pull request in detailt. Since a PR is not much more than a branch, I extend the branch browser :)!!IceGitHubPullRequestListBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show all open pull requests in a repository.!!IceGitHubError commentStamp: 'EstebanLorenzano 2/1/2017 17:15' prior: 0!I'm an error that happens when something fails when performing a GitHub action.!!IceGitHubBadCredentialsError commentStamp: '<historical>' prior: 0!I'm an error that happens when credentials are bad.!!IceGitHubGenericError commentStamp: '<historical>' prior: 0!I'm an error that happens when something went wrong on GitHub API operations.!!IceGitHubJSONDataSource commentStamp: '<historical>' prior: 0!I'm a generic datasource to show in a table results of a JSON. I'm intended to be used to show information from GitHub API, but I'm generic enough to be used which any kind of JSON structure.!!IceGitHubPullRequestDataSource commentStamp: '<historical>' prior: 0!I'm a datasource for pull request status, to be used when showing pull requests details. See IceGitHubPullRequestDetailModel!!IceGitHubAcceptPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog for collecting data to accept a pull request.!!IceGitHubCreatePullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for data relevant to create a pull request.!!IceGitHubPullRequestActionsModel commentStamp: '<historical>' prior: 0!I'm an actions toolbar, to be used with IceGitHubPullRequestBrowser.!!IceGitHubPullRequestDetailModel commentStamp: '<historical>' prior: 0!I'm a spec model to present a detailed view of a Pull Request.!!IceGitHubRejectPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to collect data about a pull request rejection.!!IceGitHubSelectListModel commentStamp: '<historical>' prior: 0!I'm a dialog to select a list of anything (used by branches now).!!IceGitHubAPI commentStamp: '<historical>' prior: 0!I represent an access point to the GitHub API. I provide different high level abstractions to interact with GitHub, following the speciphications you can find here: https://developer.github.com/v3/!!IceGitHubAPIPaginatedResult commentStamp: '<historical>' prior: 0!I'm a paginated answer from github (he sends results in pages and includes information in headers)!!IceGitHubCommand commentStamp: '<historical>' prior: 0!I'm a generic command to perform plugin actions for GitHub.My children define the real behavior, and they need to implement #execute.!!IceGitHubNewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to create a Pull Request!!IceGitHubRemoveBranchesCommand commentStamp: '<historical>' prior: 0!I'm a command to remove branches from remotes.!!IceGitHubViewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to show the pull request review browser.!!IceGitHubPullRequest commentStamp: '<historical>' prior: 0!I'm a pull request from github API. I represent (more or less), what is described here: https://developer.github.com/v3/pulls/#list-pull-requests!!IceGitHubPullRequestDefinition commentStamp: '<historical>' prior: 0!I am a pull request. I can be sent using ==#sendWithCredentials:== protocol.!!IceGitHubSelectItem commentStamp: '<historical>' prior: 0!I'm a helper to keep selected items in a list.!!IceGitHubPullRequestPlugin commentStamp: '<historical>' prior: 0!I define the plugin GitHub - Pull Request!!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!acceptPullRequest	IceGitHubAcceptPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				acceptMessage: model message 				type: model type ];		openWithSpec	! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ 			commitInfo diffTo: (commitInfo repository commitAt: self baseSHA)  ]);		buildOn: a)		title: 'Changes vs. destination' .	super addChangesTreeTo: a with: commitInfo! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseSHA	^ self pullRequest baseSHA! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff;		row: #actions size: 35.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser.		browser transmit to: #actions; andShow: [ :a | 		a morph			morph: [ 				IceGitHubPullRequestActionsModel new 					onMerge: [ self mergePullRequestIntoImage ];					onAccept: [ self acceptPullRequest ];					onReject: [ self rejectPullRequest ];					buildWithSpec ] ]! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergePullRequestIntoImage	(UIManager default confirm: ('I will create a new local branch named {1}. Should I continue?' format: { self pullRequest branchName }))	ifFalse: [ ^ self ].	self pullRequest mergeIntoImage! !!IceGitHubPullRequestBrowser methodsFor: 'scripting opening' stamp: ' 7/21/2017 17:44:57'!open	self openOn: self pullRequest branch! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequest	^ pullRequest! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequest: anObject	pullRequest := anObject! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!rejectPullRequest	IceGitHubRejectPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				rejectMessage: model message  ];		openWithSpec! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Browsing pull request: #{1} {2}' format: { self pullRequest number. self pullRequest title  }! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 700@700! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildOn: browser	browser 		row: #pullRequests;		row: #detail span: 2.			browser transmit to: #pullRequests; andShow: [ :a |		a fastTable 			title: 'Open pull requests';			addAction: self refreshAction;			selectionAct: [ :presentation | 				self viewPullRequest: presentation selection ] 				entitled: 'Review pull request...';			onChangeOfPort: #strongSelection act: [ :presentation | 				self viewPullRequest: presentation selection ];			column: '#' evaluated: #number width: 50;			column: 'State' evaluated: #state width: 50;			column: 'Author' evaluated: #author width: 120;			column: 'Title' evaluated: #title ].			browser transmit from: #pullRequests; to: #detail; andShow: [ :a |		a morph 			title: [ :pr | '#{1} {2}' format: {pr number. pr title} ];			morph: [ :presentation :pr | (IceGitHubPullRequestDetailModel for: pr) buildWithSpec ] ]! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose	self tabulator with: [ :browser |		browser initialExtent: self initialExtent.		self buildOn: browser ]! !!IceGitHubPullRequestListBrowser methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!fetchPullRequests	^ (IceGitHubAPI new		getPullRequests: self remote owner project: self remote projectName) all		collect: [ :each | 			(IceGitHubPullRequest fromJSON: each)				repository: self repository;				yourself ]! !!IceGitHubPullRequestListBrowser methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceGitHubPullRequestListBrowser methodsFor: 'scripting opening' stamp: ' 7/21/2017 17:44:57'!open	^ self openOn: self pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequests	^ pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequests: anObject	pullRequests := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!refreshAction	^ GLMGenericAction new		action: [ :presentation |			UIManager default				informUser: 'Refreshing pull request list' 				during: [ self refreshPullRequests ].			presentation update ];		icon: #refresh asIcon;		title: 'Refresh'; 		showTitle! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!refreshPullRequests	self pullRequests: self fetchPullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Pull requests on {1} ({2})' format: { self remote remoteName. self remote url }! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!titleIcon	^ self class icon! !!IceGitHubPullRequestListBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequest: aPullRequest	UIManager default 		informUser: ('Opening pull request {1} {2}' format: { aPullRequest number. aPullRequest title })		during: [  			IceGitHubPullRequestBrowser new 			pullRequest: aPullRequest;			open ]! !!IceGitHubBadCredentialsError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAppropriateFor: aResponse 	^ aResponse status = 401! !!IceGitHubBadCredentialsError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageBody	^ 'Credentials provided are wrong'! !!IceGitHubError class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!errorClassFor: aResponse	^ self allSubclasses 		detect: [ :each | each isAppropriateFor: aResponse  ]		ifNone: [ self ]! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aResponse	^ (self errorClassFor: aResponse) new 		response: aResponse;		yourself	! !!IceGitHubError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAppropriateFor: aResponse	^ false! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!signalFor: aResponse	^ (self for: aResponse) signal! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!code	^ self response status! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!contents	^ self response contents! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!customError: aDictionary	^ aDictionary at: #message		! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!errorToString: aDictionary 	(aDictionary at: #code) = 'custom' ifTrue: [ ^ self customError: aDictionary ].	(aDictionary at: #code) = 'invalid' ifTrue: [ ^ self invalidError: aDictionary ].		^ self unknownError: aDictionary	! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!invalidError: aDictionary	^ 'Invalid field: ', (aDictionary at: #field)			! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!jsonContents	^ jsonContents ifNil: [ jsonContents := STON fromString: self contents ]		! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageBody	| errors |	errors := self jsonContents at: #errors ifAbsent: [ ^ '' ].	^ String streamContents: [ :stream | 		errors			do: [ :each | stream << (self errorToString: each) ] 			separatedBy: [ stream cr ] ].! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageText	^ self jsonContents at: #message! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!response	^ response! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!response: anObject	response := anObject! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!unknownError: aDictionary	^ String streamContents: [ :stream | 		(aDictionary associations sorted: [ :a :b | a key < b key  ])			do: [ :each | stream << each key << ': ' << each value ]			separatedBy: [ stream << ', ' ] ]! !!IceGitHubGenericError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAppropriateFor: aResponse	^ aResponse status = 422! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!actionColumn: column	elements := elements sorted: [ :a :b |		(a at: column id) < (b at: column id) ]		! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cellColumn: column row: rowIndex 	^ FTCellMorph new  		addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;		yourself	! !!IceGitHubJSONDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!columnTitleFor: column	^ column id capitalized! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headerColumn: column	column id ifNil: [ ^ nil ].	^ SimpleButtonMorph new		layoutPolicy: RowLayout new; 		listDirection: #leftToRight; 		wrapCentering: #center;		cellInset: 5@0;		layoutInset: 5@0;		label: (self columnTitleFor: column);		target: self;		actionSelector: #actionColumn:;		arguments: {column};		yourself! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!actionColumn: column	column id = #target_url ifTrue: [ ^ self ].	^ super actionColumn: column	! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cellColumn: column row: rowIndex 	column id = #target_url ifTrue: [ ^ self targetUrlCellColumn: column rowIndex: rowIndex ].	column id = #state ifTrue: [ ^ self statusCellColumn: column rowIndex: rowIndex ].	column id = #context ifTrue: [ ^ self contextCellColumn: column rowIndex: rowIndex ].	^ super cellColumn: column row: rowIndex ! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!columnTitleFor: column	column id = #target_url ifTrue: [ ^ '' ].	^ super columnTitleFor: column! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!contextCellColumn: column rowIndex: rowIndex	| context |	context := (self elementAt: rowIndex) at: column id.	(context includesSubstring: 'travis-ci')		ifTrue: [ context := 'travis-ci' ].	^ FTCellMorph new  		addMorphBack: context asMorph;		yourself		! !!IceGitHubPullRequestDataSource methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!copyToClipboard: url	Clipboard clipboardText: url.	UIManager default inform: ('Url {1} copied to clipboard' format: { url })! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!statusCellColumn: column rowIndex: rowIndex	| status |	status := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		cellInset: 5;		addMorphBack: (self iconForStatus: status) asMorph;		addMorphBack: status asStringMorph;		yourself	! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!targetUrlCellColumn: column rowIndex: rowIndex	| url |	url := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		addMorphBack: (			IconicButton new				target: self;				actionSelector: #copyToClipboard:;				arguments: { url };				labelGraphic: (#smallCopy asIcon scaledToSize: 12@12);				color: Color transparent;				helpText: ('Copy url {1} to clipboard' format: { url });				borderWidth: 0;				yourself);		yourself	! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				newRow: [:row | row add: #typeLabel width: 80; add: #typeList ] height: 25;				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultType	^ 'merge'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Accept pull request'! !!IceGitHubAcceptPullRequestModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ 500@250! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	super initializePresenter.	self typeList 		items: self class availableTypes;		displayBlock: [ :each | each  ];		setSelectedItem: self class defaultType! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	typeLabel := self newLabel.	typeList := self newDropList.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	typeLabel label: 'Merge type'.	acceptButton label: 'Accept pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: typeList;		add: acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!message	^ self messageText text asString! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel	^ messageLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText	^ messageText! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText: anObject	messageText := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ self typeList selectedItem! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeLabel	^ typeLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeLabel: anObject	typeLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeList	^ typeList! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeList: anObject	typeList := anObject! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #titleLabel width: 80; add: #titlePanel ] height: 25;				newRow: [:row | 					row 						newColumn: #headLabel width: 80;						newColumn: [ :col2 | 							col2 newRow: [ :row2 | 								row2									add: #headForkList;									add: #headBranchList ] ] ] height: 25;				newRow: [:row | 					row 						newColumn: #baseLabel width: 80;						newColumn: [ :col2 |							col2 newRow: [ :row2 |								row2 									add: #baseForkList;									add: #baseBranchList ] ] ] height: 25;				newRow: [:row | row add: #bodyLabel width: 80; add: #bodyPanel ];				add: #addButton height: self buttonHeight  ];		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #repository:credentials:'! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository credentials: aCredentials headRemote: aRemote	^ self basicNew 		initializeRepository: aRepository 			credentials: aCredentials			headRemote: aRemote;		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'New pull request'! !!IceGitHubCreatePullRequestModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	| title |		title := self titlePanel text trim.	title ifEmpty: [ 		UIManager default alert: 'You need to specify a title for the pull request.' title: 'Error'. 		^ self ].		acceptBlock ifNotNil: [ 		acceptBlock cull: self createPullRequest ].		self window delete! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!addButton	^ addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!addButton: anObject	addButton := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableBranchNames	^ availableBranchNames ifNil: [ availableBranchNames := self obtainAvailableBranchNames ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableRemotes	"retrieves available remotes to perform the PR"	^ availableRemotes ifNil: [ availableRemotes := self obtainAvailableRemotes ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseBranchList	^ baseBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseBranchList: anObject	baseBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!baseBranchNames	^ self baseBranches collect: [ :each | each at: #name ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!baseBranches	^ baseBranches ifNil: [ 		baseBranches := self requestBaseBranches ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseDefaultBranchName	^ self gitBase at: #'default_branch' ! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseForkList	^ baseForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseForkList: anObject	baseForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseLabel	^ baseLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseLabel: anObject	baseLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseRemote	"This is the 'base' remote (the place where the repository is forked). This is used to 	 suggest fork PR destination (base)"	^ baseRemote ifNil: [ baseRemote := self obtainBaseRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyLabel	^ bodyLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyLabel: anObject	bodyLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyPanel	^ bodyPanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyPanel: anObject	bodyPanel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	^ self repository branch! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!createPullRequest	^ IceGitHubPullRequestDefinition new 		credentials: self credentials;		title: self titlePanel text trim;		headRemote: self headForkList selectedItem;		headBranchName: self headBranchList selectedItem;		baseRemote: self baseForkList selectedItem;		baseBranchName: self baseBranchList selectedItem;		body: self bodyPanel text asString trim;		yourself! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ credentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials: aCredentials	credentials := aCredentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultBaseBranchName	self hasParent ifFalse: [ ^ self baseDefaultBranchName ].	^ self baseBranchNames 		detect: [ :each | each = self branch basename ] 		ifNone: [ self baseDefaultBranchName ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultHeadBranchName	^ self branch basename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!gitBase	| info |	^ (info := self gitRepositoryInfo) 		at: #parent		ifAbsent: [ info ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!gitRepositoryInfo	^ gitRepositoryInfo ifNil: [ 		gitRepositoryInfo := self requestGitRepositoryInfo ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!hasParent	^ self gitRepositoryInfo includesKey: #parent! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headBranchList	^ headBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headBranchList: anObject	headBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headForkList	^ headForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headForkList: anObject	headForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headLabel	^ headLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headLabel: anObject	headLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headRemote 	^ headRemote  ifNil: [ self repository pushRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ 500@300! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	super initializePresenter.	self titlePanel text: self branch basename.	self headForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self headRemote.	self headBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultHeadBranchName.	self baseForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self baseRemote.	self baseBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultBaseBranchName! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeRepository: aRepository credentials: aCredentials headRemote: aRemote	repository := aRepository.	credentials := aCredentials.	headRemote := aRemote.	self initialize! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	titleLabel := self newLabel.	titlePanel := self newTextInput autoAccept: true.	headLabel := self newLabel.	headForkList := self newDropList.	headBranchList := self newDropList.	baseLabel := self newLabel.	baseForkList := self newDropList.	baseBranchList := self newDropList.	bodyLabel := self newLabel.	bodyPanel := self newText autoAccept: true.	addButton := self newButton.			titleLabel label: 'Title'.	headLabel label: 'From (Head)'.	baseLabel label: 'To (Base)'.	bodyLabel label: 'Comment'.	addButton label: 'Create pull request'.	addButton action: [ self accept ].		self focusOrder 		add: titlePanel;		add: headForkList;		add: headBranchList;		add: baseForkList;		add: baseBranchList;		add: bodyPanel;		add: addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainAvailableBranchNames	^ ((self repository allBranches 		collect: #basename as: Set)		addAll: self baseBranchNames;		asArray)		sort.	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainAvailableRemotes	| remotes |		remotes := self repository remotes.	(remotes includes: self baseRemote)		ifFalse: [ remotes := remotes copyWith: self baseRemote ].	^ remotes	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainBaseRemote	| base |	base := self gitBase.	^ IceRemote url: ((base at: #'git_url') copyReplaceAll: 'git://' with: 'https://')! !!IceGitHubCreatePullRequestModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/21/2017 17:44:57'!requestBaseBranches	^ IceGitHubAPI new 		credentials: self credentials;		getBranches: self baseRemote owner project: self baseRemote projectBasename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/21/2017 17:44:57'!requestGitRepositoryInfo	| remote |	remote := self headRemote.	^ IceGitHubAPI new 		credentials: self credentials;		getRepository: remote owner 			project: remote projectBasename! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titleLabel	^ titleLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titleLabel: anObject	titleLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titlePanel	^ titlePanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titlePanel: anObject	titlePanel := anObject! !!IceGitHubPullRequestActionsModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec>	^ SpecLayout composed		newRow: [ :row | 			row				add: #mergeButton;				add: #acceptButton;				add: #rejectButton ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	mergeButton := self newButton.	acceptButton := self newButton.	rejectButton := self newButton.			mergeButton 		label: 'Merge into image';		action: [ mergeBlock value ].	acceptButton 		label: 'Accept pull request';		action: [ acceptBlock value ].	rejectButton 		label: 'Reject pull request';		action: [ rejectBlock value ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeButton	^ mergeButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeButton: anObject	mergeButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onMerge: aBlock	mergeBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onReject: aBlock	rejectBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!rejectButton	^ rejectButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!rejectButton: anObject	rejectButton := anObject! !!IceGitHubPullRequestDetailModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #urlLabel width: 80; add: #urlText ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorText ] height: 25;				newRow: [:row | row add: #fromLabel width: 80; add: #fromText ] height: 25;				newRow: [:row | row add: #toLabel width: 80; add: #toText ] height: 25;				newRow: [:row | row add: #mergeableLabel width: 80; add: #mergeablePanel ] height: 25;				newRow: [:row | row add: #statusLabel width: 80; add: #statusPanel ] height: 25;				newRow: [:row | row add: #checksTable ];				newRow: [:row | row add: #bodyText ] ];		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aPullRequest	^ self basicNew 		initializePullRequest: aPullRequest;		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #for:'! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorLabel	^ authorLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorLabel: anObject	authorLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorText	^ authorText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorText: anObject	authorText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyText	^ bodyText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyText: anObject	bodyText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!checksTable	^ checksTable! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!checksTable: anObject	checksTable := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromLabel	^ fromLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromLabel: anObject	fromLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromText	^ fromText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromText: anObject	fromText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iconForMergeable: mergeable	mergeable = true ifTrue: [ ^ #smallOk asIcon ].	^ #smallCancel asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	self retrieveStatuses.	self retrieveDetail.! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePullRequest: aPullRequest	pullRequest := aPullRequest.	self initialize	! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	urlLabel := self newLabel label: 'Url'.	authorLabel := self newLabel label: 'Author'.	fromLabel := self newLabel label: 'From'.	toLabel := self newLabel label: 'Into'.	mergeableLabel := self newLabel label: 'Mergeable'.	statusLabel := self newLabel label: 'Status'.	urlText := self newTextInput 		enabled: false;		text: self pullRequest url.	authorText  := self newTextInput 		enabled: false;		text: self pullRequest author.	fromText  := self newTextInput 		enabled: false;		text: self pullRequest headLabel.	toText  := self newTextInput 		enabled: false;		text: self pullRequest baseLabel.	mergeablePanel := self newMergeablePanel.	statusPanel := self newStatusPanel.	checksTable := self newChecksTable.	bodyText := self newText 		enabled: false;		text: self pullRequest body.! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!mergeableLabel	^ mergeableLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!mergeableLabel: anObject	mergeableLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeablePanel	^ mergeablePanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeablePanel: anObject	mergeablePanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newChecksTable	^ FTTableMorph new 		addColumn: ((FTColumn id: #target_url) width: 18);		addColumn: ((FTColumn id: #state) width: 65);		addColumn: ((FTColumn id: #context) width: 100);		addColumn: (FTColumn id: #description);		cellInset: 5;		beResizable;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter		! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newMergeablePanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newStatusPanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequest	^ pullRequest! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!retrieveDetail		self mergeablePanel widget addMorphBack: 'Loading...' asMorph.	[ | detail mergeable |  		[  			detail := self pullRequest detail.			mergeable := detail at: #mergeable ]		on: Error do: [ :e | mergeable := nil ].		UIManager default defer: [ 			self mergeablePanel widget				removeAllMorphs;				addMorphBack: (self iconForMergeable: mergeable) asMorph;				addMorphBack: (self textForMergeable: mergeable) asMorph ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!retrieveStatuses	self statusPanel widget addMorphBack: 'Loading...' asMorph.	[ 	| status generalStatus statuses |		[		status := self pullRequest status.		generalStatus := status at: 'state'.		statuses := status at: 'statuses' ]	on: Error do: [ :e | 		generalStatus := 'Unknown'.		statuses := #() ].		UIManager default defer: [ 		self statusPanel widget			removeAllMorphs;			addMorphBack: (self iconForStatus: generalStatus) asMorph;			addMorphBack: generalStatus asMorph.	 	self checksTable widget dataSource: (IceGitHubPullRequestDataSource elements: statuses) ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusLabel	^ statusLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusLabel: anObject	statusLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusPanel	^ statusPanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusPanel: anObject	statusPanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!textForMergeable: mergeable	mergeable = true ifTrue: [ ^ 'Yes' ].	mergeable = false ifTrue: [ ^ 'There are conflicts' ].	^ mergeable asString	! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toLabel	^ toLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toLabel: anObject	toLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toText	^ toText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toText: anObject	toText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlLabel	^ urlLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlLabel: anObject	urlLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlText	^ urlText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlText: anObject	urlText := anObject! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultType	^ 'merge'! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Accept pull request'! !!IceGitHubRejectPullRequestModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ 500@250! !!IceGitHubRejectPullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	acceptButton label: 'Reject pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!message	^ self messageText text asString! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel	^ messageLabel! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText	^ messageText! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText: anObject	messageText := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Select'! !!IceGitHubSelectListModel class methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!defaultExtent 	^ 550@500! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec>	^ SpecLayout composed		newColumn:[ :col | 			col  				newRow: #listPanel;				newRow: #selectButton height: self buttonHeight ];		yourself! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Select...'! !!IceGitHubSelectListModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!confirmSelection	acceptBlock ifNotNil: [ 		acceptBlock value: selectedItems ].	self window delete! !!IceGitHubSelectListModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createCheckboxFor: anObject	^ CheckboxMorph 		on: (IceGitHubSelectItem list: selectedItems item: anObject) 		selected: #value 		changeSelected: #value:! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!displayBlock: aBlock 	self listPanel displayBlock: aBlock! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	selectedItems := Set new.	super initialize.	self title: self class title! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	listPanel := self instantiate: FastTableModel.	listPanel icons: [ :each | self createCheckboxFor: each ].	selectButton := self newButton.		selectButton 		label: self class buttonLabel;		action: [ self confirmSelection ].		self focusOrder 		add: listPanel;		add: selectButton! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!items: aCollection	self listPanel items: aCollection! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!listPanel	^ listPanel! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!listPanel: anObject	listPanel := anObject! !!IceGitHubSelectListModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!selectButton	^ selectButton! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!selectButton: anObject	selectButton := anObject! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!selectLabel: aString	self selectButton label: aString! !!IceGitHubAPI class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainCredentials	| newCredentials provider |		provider := IceCredentialsProvider default.	newCredentials := IcePlaintextCredentials new.	IceCredentialsProvider default providePlaintextCredentialsTo: newCredentials.	^ newCredentials! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!acceptPullRequest: owner project: projectName number: aNumber data: aDictionary	^ self 		put: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString, '/merge'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!addComment: owner project: projectName number: aNumber data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/issues/', aNumber asString, '/comments'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!addPullRequest: owner project: projectName data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/pulls'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!contentsWithValidationDo: aBlock	^ (self responseWithValidationDo: aBlock) contents! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ credentials ifNil: [ credentials := self class obtainCredentials ]! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials: anObject	credentials := anObject! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!delete: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			delete;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!deleteBranch: owner project: projectName name: branchName	^ self delete: 'repos/', owner, '/', projectName, '/git/refs/heads/', branchName! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!get: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getBranch: owner project: projectName name: branchName	^ self get: 'repos/', owner,'/', projectName, '/branches/', branchName! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getBranches: owner project: projectName	^ self get: 'repos/', owner,'/', projectName, '/branches'! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!getPaginated: aString 	^ IceGitHubAPIPaginatedResult api: self request: aString! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getPullRequests: owner project: projectName	^ self getPaginated: 'repos/', owner, '/', projectName, '/pulls'		! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!getRaw: aString 	^ self responseWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getRepository: owner project: projectName	^ self get: 'repos/', owner,'/', projectName! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!jsonContentsWithValidationDo: aBlock	^ STON fromString: (self contentsWithValidationDo: aBlock)! !!IceGitHubAPI methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newRequestTo: aString	^ ZnClient new 		in: [ :this | 			self credentials ifNotNil: [ 				this 					username: self credentials username 					password: self credentials password ] ]; 		headerAt: 'Accept' put: 'application/vnd.github.v3+json';		url: 'https://api.github.com/', aString;		yourself! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!patch: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			patch;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!post: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			post;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!put: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			put;			response ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!responseWithValidationDo: aBlock	| response |		response := aBlock value.	response isSuccess 		ifFalse: [ IceGitHubError signalFor: response ].	^ response! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!updatePullRequest: owner project: projectName number: aNumber data: aDictionary 	^ self 		patch: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPIPaginatedResult class methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!api: anAPI request: aString	^ self new 		api: anAPI;		request: aString;		yourself		! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!all	| stream |	stream := Array new writeStream.	[ self hasNext ] 	whileTrue: [ stream << self next ].	^ stream contents! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!api	^ api! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!api: anObject	api := anObject! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!hasNext	^ result isNil or: [ self parseMorePages: (result headers at: 'Link' ifAbsent: [ nil ]) ]! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!next 	nextPage ifNil: [ nextPage := 1 ].	[ result := self api getRaw: (self request asUrl ? (#page -> nextPage asString)) asString ]	ensure: [ nextPage := nextPage + 1].	^ STON fromString: result contents! !!IceGitHubAPIPaginatedResult methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseMorePages: aString 	"github does not send 'Links' header if there are no pages, and it does not sends 'next' link	 if we are at the last page"	aString ifNil: [ ^ false ].	^ (aString substrings: ',') anySatisfy: [ :each | each includesSubstring: 'rel="next"' ] ! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!request	^ request! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!request: anObject	request := anObject! !!IceGitHubCommand class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository 	^ self new repository: aRepository ! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials 	^ credentials ifNil: [ credentials := self obtainCredentials ]! !!IceGitHubCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute 	self subclassResponsibility! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!github	^ IceGitHubAPI new 		credentials: self credentials;		yourself! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainCredentials	^ IceGitHubAPI obtainCredentials! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!reportError: error	UIManager default 		alert: error messageBody		title: 'Error creating pull request: ', error messageText! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: aRepository	repository := aRepository! !!IceGitHubNewPullRequestCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute 	(self validateMakePullRequestOn: self repository) ifFalse: [ ^ #() ].		(IceGitHubCreatePullRequestModel 		repository: self repository 		credentials: self credentials		headRemote: self remote)		setModal: true; 		onAccept: [ :pullRequest | 			[ 				pullRequest send.				UIManager default inform: 'Pull request created.' ]			on: IceGitHubError do: [ :e | self reportError: e ] ];		openWithSpec ! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceGitHubNewPullRequestCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validateMakePullRequestOn: aRepository	| status |		status := OrderedCollection new: 2.	aRepository isModified 		ifTrue: [ status add: 'Uncommited changes' ].	(aRepository outgoingCommitsTo: (aRepository pushRemote)) 		ifNotEmpty: [ :commits | '{1} not published' format: { commits size } ].	status ifEmpty: [ ^ true ].		^ UIManager default 		confirm: (('{1} has ongoing modifications ({2}). Do you want to continue anyway?') format: { aRepository name. status asCommaString })! !!IceGitHubRemoveBranchesCommand class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository remote: aRemote	^ self new 		repository: aRepository;		remote: aRemote;		yourself! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!cacheAllBranches	self remoteBranches do: [ :each | | branchName |		branchName := each at: 'name'.		branchesByName 			at: branchName 			ifAbsentPut: [ self remoteBranch: branchName ] ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute 	UIManager default 		informUser: ('Retrieving branch information from {1}' format: { self remote url })		during: [ self cacheAllBranches ].	IceGitHubSelectListModel new 		setModal: true;		title: ('Select branches to remove on remote {1}' format: {self remote remoteName});		selectLabel: 'Remove branches';		items: self remoteBranches;		displayBlock: [ :each | 			'{1} ({2})' format: { 				each at: 'name'. 				self timeSinceLastCommit: each } ];		onAccept: [ :selection | self removeBranches: selection ];		openWithSpec! !!IceGitHubRemoveBranchesCommand methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize 	super initialize.	branchesByName := OrderedDictionary new! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: aRemote	remote := aRemote! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!remoteBranch: aName	^ self requestRemoteBranch: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!remoteBranches	^ branches ifNil: [ branches := self requestRemoteBranches ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranch: json	| branchName |		branchName := json at: 'name'.	IceGitHubAPI new 		credentials: self credentials;		deleteBranch: self remote owner 			project: self remote projectBasename			name: branchName.	UIManager default inform: ('Branch {1} removed.' format: { branchName })			! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranches: aCollection	[ 		aCollection do: [ :each | self removeBranch: each ] ]	on: IceGitHubError do: [ :e | self reportError: e ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!requestRemoteBranch: aName	^ IceGitHubAPI new		getBranch: self remote owner 		project: self remote projectBasename		name: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!requestRemoteBranches	^ IceGitHubAPI new		getBranches: self remote owner 		project: self remote projectBasename! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!timeSinceLastCommit: json	| branchName branchJson lastCommitDate |	branchName := json at: 'name'.	branchJson := branchesByName at: branchName.	lastCommitDate := ((((branchJson at: 'commit') at: 'commit') at: 'author') at: 'date') asDateAndTime.	^ '{1} days' format: { (Date today - lastCommitDate) days }! !!IceGitHubViewPullRequestCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute	UIManager default 		informUser: ('Retrieving pull requests from {1}' format: { self remote })  		during: [ 			IceGitHubPullRequestListBrowser new				repository: self repository;				remote: self remote;				refreshPullRequests;				open ]! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceGitHubPullRequest class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!fromJSON: aDictionary	^ self basicNew		initializeWithJSON: aDictionary;		yourself! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!acceptMessage: messageString type: typeString	IceGitHubAPI new 		acceptPullRequest: self owner 			project: self projectName			number: self number			data: { 				#commit_title -> (messageString lines 					ifNotEmpty: [ :each | each first trimBoth ] 					ifEmpty: [ '' ]). 				#commit_message -> (messageString lines 					ifNotEmpty: [ :lines | (lines allButFirst joinUsing: String lf) trimBoth ] 					ifEmpty: [ '' ]). 				#sha-> self headSHA.				#merge_method -> typeString } asDictionary! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addComment: messageString	IceGitHubAPI new 		addComment: self owner 			project: self projectName			number: self number			data: { #body -> messageString } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!author	^ (self jsonAt: 'user') at: 'login'! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseLabel	^ (self jsonAt: #base) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseSHA	^ (self jsonAt: #base) at: #sha! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!body	^ self jsonAt: #body! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	fetched ifFalse: [ self fetch ].	^ branch ifNil: [		branch := IceRemoteBranch			remoteName: self remote remoteName 			branchName: ((self jsonAt: #head) at: #ref)			inRepository: self repository.		branch ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self branch basename! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detail	^ detail ifNil: [		detail := IceGitHubAPI new get: ((self jsonAt: #url) allButFirst: 23) ]! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	[ ^ self repository fetchFrom: self remote ]	ensure: [ fetched := true ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headLabel	^ (self jsonAt: #head) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headSHA	^ (self jsonAt: #head) at: #sha! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	fetched := false! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWithJSON: aDictionary	json := aDictionary.	self initialize! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!json	^ json! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!jsonAt: aKey	^ self json at: aKey! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergeIntoImage	self repository 		ensureBranch: self branchName;		checkoutBranch: self branchName;		merge: self branch lastCommit! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!number	^ self jsonAt: #number! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner 	^ (((self jsonAt: #base) at: #repo) at: #owner) at: #login! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ ((self jsonAt: #base) at: #repo) at: #name! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!rejectMessage: messageString	messageString trimBoth 		ifNotEmpty: [ self addComment: messageString ].	IceGitHubAPI new 		updatePullRequest: self owner 			project: self projectName			number: self number			data: { #state -> #closed } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	| remote |	remote := IceRemote 		name: self author		url: (((self jsonAt: #head) at: #repo) at: #ssh_url).	^ self repository remotes 		detect: [ :each | each = remote ]		ifFound: [ :each | each ]		ifNone: [ 			self repository addRemote: remote.			remote ].		! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!state	^ self jsonAt: #state! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	^ status ifNil: [ 		status := IceGitHubAPI new 			get: 'repos/', self owner, '/', self projectName, '/commits/', self headSHA, '/status' ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ self jsonAt: #title! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url	^ self jsonAt: #url! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseBranchName	^ baseBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseBranchName: anObject	baseBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseRemote	^ baseRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseRemote: anObject	baseRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!body	^ body! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!body: anObject	body := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ credentials! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials: anObject	credentials := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headBranchName	^ headBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headBranchName: anObject	headBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headRemote	^ headRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headRemote: anObject	headRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!send	| pullRequestData |	pullRequestData := { 		'title' -> self title.		'head' -> (self headRemote owner, ':', self headBranchName).		'base' -> self baseBranchName.		'body' -> self body.	} asDictionary.		IceGitHubAPI new 		credentials: self credentials;		addPullRequest: self baseRemote owner 			project: self baseRemote projectBasename 			data: pullRequestData! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ title! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title: anObject	title := anObject! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!list: selectedItems item: anObject	^ self basicNew 		initializeList: selectedItems item: anObject;		yourself! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #list:item:'! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!addItem	(list includes: item) ifTrue: [ ^ self ].	list add: item ! !!IceGitHubSelectItem methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeList: aCollection item: anObject	list := aCollection.	item := anObject.	self initialize! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!removeItem	(list includes: item) ifFalse: [ ^ self ].	list remove: item ! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!value 	^ list includes: item! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!value: aBoolean	aBoolean 		ifTrue: [ self addItem ]		ifFalse: [ self removeItem ]	! !!IceGitHubPullRequestPlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	"validate if this is a github repository"	^ aRepository origin host = 'github.com'! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newPullRequest: aRepository 	^ self newPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newPullRequest: aRepository remote: aRemote	(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newPullRequestAction	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newPullRequestRemoteAction	^ GLMGenericAction new		action: [ :presentation :model |			self newPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteActionsFor: aRemote	^ { 	self newPullRequestRemoteAction.	self viewPullRequestsRemoteAction.	self removeOldBranchesRemoteAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranches: aRepository	self removeBranches: aRepository remote: aRepository pushRemote! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranches: aRepository remote: aRemote	(IceGitHubRemoveBranchesCommand 		repository: aRepository 		remote: aRemote)		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!removeOldBranchesAction	^ GLMGenericAction new		action: [ :presentation | self removeBranches: presentation selection repository ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!removeOldBranchesRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self removeBranches: model remote: presentation selection ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryActions	^ { 	self newPullRequestAction. 	self viewPullRequestsAction.	self removeOldBranchesAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequest: aRepository 	^ self viewPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequest: aRepository remote: aRemote	(IceGitHubViewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequestsAction	^ GLMGenericAction new		action: [ :presenter | self viewPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequestsRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self viewPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !"Iceberg-Plugin-GitHub"!!IceLibgitVersionReader commentStamp: 'NicoPasserini 7/7/2016 11:58' prior: 0!Reads an MCVersion from a git repository (its blob, not a working copy!!) using libgit bindings.Currently we only support metadata-less repositories.!!IceLibgitCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:26' prior: 0!Utility class for searching through a commit history taking advantage of git revwalk utilities. Found and returned commits will be added to the commit cache of the corresponding IceRepository.!!IceLibgitFileUtils commentStamp: 'NicoPasserini 7/7/2016 12:15' prior: 0!Emulates other 'file utils' classes by reading from a git repository (its blob, not a working copy'). Allows for reading any tree (from any commit) in the repository.!!IceLibgitLocalRepository commentStamp: 'NicoPasserini 6/28/2016 10:56' prior: 0!Adapter which allows an IceRepository to use libgit as underlying storage.!!Trait method!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!Trait method!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!Trait method!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!Trait method!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!Trait method!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!Trait method!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!Trait method!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!Trait method!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!Trait method!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!Trait method!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!IceLibgitTreeBuilder commentStamp: 'NicoPasserini 7/12/2016 11:29' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	builder:		<Object>	changes:		<Object>	children:		<Object>	entryName:		<Object>	originalTree:		<LGitTree> Contains the original contents on which this builder bases. Warning: this will not reflect the actual contents of the builder. Use #buildTree instead.	parent:		<Object>    Implementation Points!!IceSemanticVersion commentStamp: '<historical>' prior: 0!I represent the semver (http://semver.org) of libgit2. Since I exist just to be able to compare versions, I'm limited (reason why I'm not promoted to a more general package).!!IceLibgitStCypressWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitStCypressWriter methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:57'!propertyFileExtension  ^ MCFileTreeRepository defaultPropertyFileExtension! !!IceLibgitStCypressWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    self fileUtils        writeStreamFor: fileName , ext        in: directory        do: [ :fs |             self setFileStream: fs.            visitBlock value ]! !!IceLibgitVersionReader class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!compatibleAuthorNameOf: aString	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ aString reject: [ :each | each = Character space ]! !!IceLibgitVersionReader class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!on: aCommitOrTree iceVersion: iceVersion	^ (self on: aCommitOrTree) 		iceVersion: iceVersion; 		yourself! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ stream! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitVersionReader methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasMonticelloMetadata	^ false! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iceVersion	^ iceVersion! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iceVersion: anObject	iceVersion := anObject.	self packageDirectory: iceVersion package directoryPathString	! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadVersionInfo	^ info := self iceVersion info! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNameFromPackageDirectory	^ iceVersion packageName! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!versionName	^ ('{1}-{2}.{3}' format: {		self packageNameFromPackageDirectory. 		self commit compatibleUsername. 		self versionNumber	})! !!IceLibgitWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!addString: string at: fileNameOrPath encodedTo: ignored    "fileNameOrPath may have one or two elements"    "encodeTo: arg, because FileTree uses UTF8 by default"	| split path fileName |	split := fileNameOrPath lastIndexOf: $/.	path := fileNameOrPath first: split.	fileName := fileNameOrPath copyFrom: split + 1.		(self packageFileDirectory entryByPath: path)		addEntryNamed: fileName withContents: string.! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!snapshotWriterClass	^ IceLibgitStCypressWriter! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!subPackageFileDirectoryFor: directoryNameOrPath	^ self packageFileDirectory entryByPath: directoryNameOrPath ! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!writeVersion: aVersion	directory := aVersion package name, '.package'.	self packageFileDirectory deleteAll.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!commitsDo: aBlock 	self maxNumber 		ifNil: [ super commitsDo: aBlock ]		ifNotNil: [ | count |			count := 0.			super commitsDo: [ :commit |				aBlock value: commit.				count := count + 1.				count == self maxNumber ifTrue: [ ^ self ]			]		]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!firstCommit	^ self commitsDo: [ :commit | ^ commit ] ! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromBranch: branch	[ self revwalk pushReference: (lgitRepository lookupBranch: branch name) ]		on: LGit_GIT_EINVALIDSPEC do: [			"branch real branch, so try to find a corresponding treeish using revparse, 			this will handle stuff like 'master~1'"			self fromLGitId: (lgitRepository revparse: branch name) id		]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromCommit: commit	self fromCommitId: commit id! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromCommitId: commitId	self fromLGitId: (LGitId fromHexString: commitId)! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromHead	self revwalk pushHead! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromLGitId: lGitId	self revwalk pushCommit: lGitId! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromTag: tag	self revwalk.	^ self fromLGitId: (lgitRepository revparse: tag name) id! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!rawResultsDo: aBlockClosure 	self revwalk 		select: [ :result | self shouldInclude: result ]		thenDo: aBlockClosure! !!IceLibgitCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!revwalk	^ revwalk ifNil: [		repository withRepoDo: [ :repo |			"Keep a reference to the repo so that it does not get garbage collected 			(that would free C memory and make leave the revwalk object dumb)"			lgitRepository := repo. 			^ revwalk := LGitRevwalk of: repo.		] 	]! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!shouldInclude: aLGitCommit 	^ self modifyingPackage 		ifNil: [ true ]		ifNotNil: [ :package | 			aLGitCommit changesFileNamed: package directoryPathString ]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoCommit: commit	self revwalk hideCommit: (LGitId fromHexString: commit id)! !!IceLibgitFileUtils class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!current    ^ Current ifNil: [ Current := self new ]! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!deleteAll: aTreeBuilder     ^ aTreeBuilder deleteAll! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!directoryExists: aLGitTreeEntry 	^ aLGitTreeEntry type = LGitObjectTypeEnum git_obj_tree! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!directoryFromEntry: treeEntry 	^ treeEntry object! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!directoryFromPath: aString relativeTo: aCommitOrTree	^ aCommitOrTree 		entryByPath: aString 		ifAbsent: [ 			IceMissingRepositoryEntry new name: aString; owner: aCommitOrTree; signal ] ! !!IceLibgitFileUtils methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!pathNameDelimiter	^ $/! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!readStreamFor: fileName in: tree do: aBlock	(tree entryByPath: fileName) readStreamDo: aBlock! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!writeStreamFor: fileName in: directory do: aBlock 	directory addEntryNamed: fileName withContents: (String streamContents: aBlock).! !!IceLibgitLocalRepository class methodsFor: 'descriptions' stamp: ' 7/21/2017 17:44:57'!description	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!newRepositoryAt: aFileReference origin: anIceRemoteRepository subdirectory: aString	^ self new		location: aFileReference;		origin: anIceRemoteRepository;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!newRepositoryAt: aFileReference subdirectory: aString	^ self new		location: aFileReference;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseCommitInfo: aLGitCommit	^ IceCommitInfo new		commitId: aLGitCommit id hexString;		username: aLGitCommit committer name;		datetime: aLGitCommit time asDateAndTime;		parentIds: (aLGitCommit parents collect: [ :parent | parent id hexString ]);		comment: aLGitCommit message! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/21/2017 17:44:57'!requiredLibGit2MinimumVersion	^ IceSemanticVersion 		major: 0 		minor: 25 		patch: 1! !!IceLibgitLocalRepository class methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!shortName	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/21/2017 17:44:57'!verifyBackendAvailabilityIfNot: aBlock	| presentVersion requiredVersion |		presentVersion := IceSemanticVersion fromArray: LGitLibrary uniqueInstance version.	requiredVersion := self requiredLibGit2MinimumVersion.		requiredVersion <= presentVersion 		ifFalse: [ ^ aBlock cull: requiredVersion cull: presentVersion ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addFilesToIndex: aListOfPaths	self withRepoDo: [ :repo | 		| index |		index := repo index.		index addAll: aListOfPaths.		index writeToDisk.	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addRemote: aRemote	self withRepoDo: [ :repo |		repo addRemote: aRemote remoteName url: aRemote url ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!addTo: aMCRepositoryGroup 	"For now do not add me as an MCRepository"! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!allBranches	self withRepoDo: [ :repo | 			^ OrderedCollection new: 10 streamContents: [ :stream |			repo allBranchesDo: [ :br :isLocal | 				stream nextPut: (					IceBranch 						named: br name 						local: isLocal						inRepository: self frontend) ]]]	! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	"The branch variable and this accessor are useful when you do not have a real git repository yet. Once created it might be safer to use #currentBranch instead."	^ self lookupHead! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!canReadFileNamed: aString 	^ aString endsWith: '.package'! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!changedFilesBetween: aCommitish and: otherCommitish	"Answer a list of files that changed between two commits"	| fromTree toTree |		self withRepoDo: [ :repo | | diff |		fromTree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		toTree := (LGitCommit of: repo fromId: (LGitId fromHexString: otherCommitish id)) tree.				diff := LGitDiff of: repo.		diff diffTree: fromTree toTree: toTree. 		^ diff files ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!checkoutBranch: newBranchName 	self withRepoDo: [ :repo |		repo checkout: newBranchName ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepository	self cloneRepositoryFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryFrom: aRemote	^ self cloneRepositoryFrom: aRemote branch: nil! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryFrom: aRemote branch: aBranchName	| url |		url := aRemote url.	LGitGlobal runSequence: [ 		| repo cloneOptions |		repo := LGitRepository on: self location.		cloneOptions := LGitCloneOptions withCredentialsProvider: IceCredentialsProvider default.				repo clone: url options: cloneOptions.		aBranchName ifNotNil: [ 			repo checkout: aBranchName ].		(LGitRemote of: repo named: 'origin')			lookup;			setUrl: url ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitIdFrom: aLGitCommit 	^ aLGitCommit id hexString! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!commitIndexWithMessage: message andParents: parentCommitishList	self withRepoDo: [ :repo | 		| signature commitId indexTreeId |		[ signature := repo defaultSignature ]		on: LGit_GIT_ENOTFOUND do: [ :e | 			IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].		indexTreeId := repo index writeTreeAndReturnOid.		 		commitId := (LGitCommitBuilder of: repo)			tree: (LGitTree of: repo fromId: indexTreeId);			message: message;			parents: (repo isUnborn				ifTrue: [ #() ]				ifFalse: [ self libGitCommitsFrom: repo for: parentCommitishList ]);			"'HEAD' branch could not exist yet. No problem, libgit will create it, 			but we have to remember it to notify the frontend."			updateReference: ([ repo head name ] 				on: LGit_GIT_EUNBORNBRANCH				do: [ 'refs/heads/', self branch nameForFirstCommit ]);			author: signature;			committer: signature;			writeCommit;			commitId.					 ^ self class parseCommitInfo: (LGitCommit of: repo fromId: commitId) ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitsInBranch: branchName do: aBlock	"Iterates commit in a branch, in reverse chronological order (latest first)"	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushReference: (repo lookupBranch: branchName);			beSortedReverse;			do: aBlock ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitsInCurrentBranchDo: aBlock	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushHead;			do: aBlock.	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!contentOfFileNamed: aPathString commit: aCommitId	self withRepoDo: [ :repo |		| commit |		commit := LGitCommit of: repo fromHexString: aCommitId.		^ (commit entryByPath: aPathString) object contents	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createBranch: branchName	self withRepoDo: [ :repo |		| newBranch |		newBranch := repo createBranch: branchName target: repo head.		repo setHead: newBranch ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!currentBranch	"#currentBranch will look for the branch in the actual repository,	#branch is the branch that was set to me manually. Normally they should return the same value,	but if the repository does not yet exist, #currentBranch will fail."	self withRepoDo: [ :repo |		^ repo head basename	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	self fetchFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetchFrom: aRemote	self withRepoDo: [ :repo | 		(LGitRemote of: repo named: aRemote remoteName) 			lookup; 			fetchWithCredentials: IceCredentialsProvider default ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!frontend	^ frontend! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!frontend: anObject	frontend := anObject! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!guessUsernameOrEmailNotFound: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' ])		ifTrue: [ IceGitUsernameOrEmailNotFound signal ].	notBlock value! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!init	"Initialize new repository (git init)"	LGitGlobal runSequence: [ 		(LGitRepository on: self location) init ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!internalStoreVersion: aMCVersion 	IceMetadatalessFileTreeWriter 		fileOut: aMCVersion 		on: (IceBackendWriterAdapter for: self).! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isCodeMissing	^ self subdirectory isEmptyOrNil 		ifTrue: [ self isMissing ]		ifFalse: [ (self repositoryDirectory / self subdirectory) exists not  ]! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isUnborn	self withRepoDo: [ :repo | ^ repo isUnborn ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!libGitCommitsFrom: aLGitRepository for: aListOfCommitish	^ aListOfCommitish collect: 		[ :commitish | 		LGitCommit of: aLGitRepository fromId: (LGitId fromHexString: commitish id) ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!localBranchNames	self withRepoDo: [ :repo | ^ repo branches collect: #basename ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ location! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: anObject	location := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!lookupBranchNamed: branchName inRemote: remoteName	self withRepoDo: [ :repo |		[ repo lookupRemoteBranch: remoteName, '/', branchName ]			on: LGit_GIT_ENOTFOUND do: [ ^ nil ].				^ IceRemoteBranch 			remoteName: remoteName			branchName: branchName			inRepository: self frontend	]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!lookupHead	self withRepoDo: [ :repo | 		| head |		repo isUnborn ifTrue: [ ^ IceUnbornBranch new ].		head := repo head.		^ head isBranch 			ifTrue: [ IceLocalBranch named: head basename inRepository: self frontend ] 			ifFalse: [ head object asIcebergObjectInRepository: self ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!mcVersionFor: iceVersion	self withRepoDo: [ :repo | 		| commit |		commit := LGitCommit of: repo fromId: (LGitId fromHexString: iceVersion commit id).		[ ^ (IceLibgitVersionReader 				on: commit				iceVersion: iceVersion) 				version ] 			on: IceMissingRepositoryEntry 			do: [ IceVersionDoesNotExist new version: iceVersion; signal ]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: commitId	self withRepoDo: [ :repo | 		| myCommit theirCommit mergeBase |		"Decide if we can fast-forward or we must do a real merge"				myCommit := repo head object.		theirCommit := LGitCommit of: repo fromHexString: commitId.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: theirCommit.				repo head resolve setTargetId: theirCommit id.			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.				mergedIndex hasConflicts 					ifTrue: [ 						"Abort merge and signal for manual merge. 						Index is not saved and repository will be discarded, 						so no further action is needed to abort the merge" 						IceMergeAborted signal 					]					ifFalse: [						"Commit mergedIndex"						signature := repo defaultSignature.						treeId := mergedIndex writeTreeAndReturnOid.						repo checkout_treeish: (LGitTree of: repo fromId: treeId).									(LGitCommitBuilder of: repo)							tree: (LGitTree of: repo fromId: treeId);							message: 'Merge with ', commitId;							parents: { myCommit. theirCommit };							updateReference: repo head name;							author: signature;							committer: signature;							writeCommit.							]			]	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseBetween: aCommitId and: anotherCommitId 	self withRepoDo: [ :repo |		^ (repo 				mergeBaseBetween: (LGitId fromHexString: aCommitId) 				and: (LGitId fromHexString: anotherCommitId)) 				hexString ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!newCommitWalk	^ IceLibgitCommitWalk forRepository: self! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!origin	| remotes |	remotes := self remotes.	remotes ifEmpty: [ ^ nil  ].	^ remotes		detect: [ :each | each isOrigin ]		ifNone: [ remotes first ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	self withRepoDo: [ :repo |		| currentBranch commits walk |				commits := OrderedCollection new.		currentBranch := repo lookupBranch: self branch name.			walk := (LGitRevwalk of: repo)			pushReference: currentBranch;			hideReference: currentBranch upstream			yourself.					[ walk hasNext ] whileTrue: [ 			commits add: walk next		].		^ commits	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!packagesPresentOn: aCommitish	"Answer a list of package names present on this commit"	self withRepoDo: [ :repo | | tree dir sourceEntries |		tree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		self flag: #todo. "this needs to change with multiple dirs"		dir := self subdirectory.		sourceEntries := dir isEmptyOrNil			ifTrue: [ tree entries ]			ifFalse: [ (tree entryByPath: dir) entries ]. 		^ ((sourceEntries 			collect: [ :each | each filename ])			select: [ :each | each endsWith: '.package' ])			collect: [ :each | each copyFrom: 1 to: (each findString: '.package') - 1 ] ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pull	self pullFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pullFrom: aRemote	self withRepoDo: [ :repo | 		| gitRemote myCommit theirCommit mergeBase |		"Fetch"		gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		gitRemote fetchWithCredentials: IceCredentialsProvider default.				"Decide if we can fast-forward or we must do a real merge"		myCommit := repo head object.		theirCommit := repo head upstream object.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: repo head upstream object.				repo fastForward			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.								"Commit index"				signature := repo defaultSignature.				treeId := mergedIndex writeTreeAndReturnOid.					(LGitCommitBuilder of: repo)					tree: (LGitTree of: repo fromId: treeId);					message: 'Merge with ', repo head upstream name;					parents: { myCommit. theirCommit };					updateReference: repo head name;					author: signature;					committer: signature;					writeCommit.					]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!push	self pushTo: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushTo: aRemote	self withRepoDo: [ :repo |		| gitRemote reference remoteBranchName |				gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		reference := repo head.			remoteBranchName := reference name. "TODO: https://github.com/npasserini/iceberg/issues/90"				gitRemote			pushWithRefSpec: (LGitRefSpec new				source: reference name;				destination: remoteBranchName;				yourself)			pushOptions: (LGitPushOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: IceCredentialsProvider default);				yourself).		"Since the push created the branch in the remote, we can now add an upstream to this branch."		reference upstream ifNil: [ 			reference setUpstream: aRemote remoteName, '/', reference basename ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!readableFileNames	self shouldBeImplemented.! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!remoteUrl	self withRepoDo: [ :repo | ^ repo origin url ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remotes	| gitRemotes |	self withRepoDo: [ :repo | gitRemotes := repo allRemotes ].	^ gitRemotes collect: [ :each | 		(IceRemote url: each url)			remoteName: each remoteName;			yourself ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeRemote: aRemote	self withRepoDo: [ :repo |		(LGitRemote of: repo named: aRemote remoteName) 			lookup;			delete ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryDirectory	^ self location! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!revparse: aString 	self withRepoDo: [ :repo | 		^ (repo revparse: aString) asIcebergObjectInRepository: self	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!revparseCommit: aString 	self withRepoDo: [ :repo | 		^ self iceCommitFrom: (repo revparse: aString) object 	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!stagedFiles	| statusMask modifiedPaths |	statusMask :=  (LGitStatusTypeEnum git_status_index_new value)				| (LGitStatusTypeEnum git_status_index_modified value)				| (LGitStatusTypeEnum git_status_index_deleted value)				| (LGitStatusTypeEnum git_status_index_typechange value)				| (LGitStatusTypeEnum git_status_index_renamed value).		self withRepoDo: 		[ :repo | 		modifiedPaths := repo index 			entriesSelect: [ :path :status | (status & statusMask) > 0 ] ].	^ modifiedPaths 		collect: [ :entry | entry first asFileReference ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!storeVersion: aMCVersion 	self withRepoDo: [ :repo | 		| treeBuilder signature parentCommit head |		head := repo head.		parentCommit := head object.		treeBuilder := IceLibgitTreeBuilder on: parentCommit tree.		IceLibgitWriter fileOut: aMCVersion on: (treeBuilder entryByPath: self subdirectory).				signature := repo defaultSignature.		(LGitCommitBuilder of: repo)			tree: treeBuilder buildTree;			message: aMCVersion info message;			parents: { parentCommit };			updateReference: head;			author: signature;			committer: signature;			writeCommit.			]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ subdirectory! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory: anObject	subdirectory := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!upstream	self withRepoDo: [ :repo | ^ repo head upstream ifNotNil: #name ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: aName email: anEmail global: globalBoolean	"set user.name and user.email properties. 	 this could be a nonsense with other backends, but git has them and needs them :)"	self withRepoDo: [ :repo | | config |		config := repo config.		globalBoolean ifTrue: [ config := config openGlobal ].		config 			setString: 'user.name' to: aName;			setString: 'user.email' to: anEmail ]! !!IceLibgitLocalRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!validate	"TODO"! !!IceLibgitLocalRepository methodsFor: 'private auxiliar' stamp: ' 7/21/2017 17:44:57'!withRepoDo: aBlock	LGitGlobal runSequence: [ 		| repo |		repo := (LGitRepository on: self location) open.		aBlock value: repo ]! !!IceLibgitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!on: aLGitTree	"Creates a tree builder on the root of the repository"	^ self new initializeWithTree: aLGitTree! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/21/2017 17:44:57'!addEntryNamed: name withContents: aString	self builder 		addEntry: (LGitBlob of: self repository fromString: aString)		filename: name.			self changes add: name.	hasChanges := true! !!IceLibgitTreeBuilder methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildTree	self children keysAndValuesDo: [ :childEntryName :childBuilder |		childBuilder hasChanges ifTrue: [ 			self builder 				addEntry: childBuilder buildTree				filename: childEntryName		]	].	^ self builder newTree! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!builder	^ builder ifNil: [ 		builder := LGitTreeBuilder 			of: self repository			fromTree: self initialTree ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changes	^ changes ifNil: [ changes := OrderedCollection new ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	^ children ifNil: [ children := Dictionary new ]! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/21/2017 17:44:57'!deleteAll	self builder clear.! !!IceLibgitTreeBuilder methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!directory	^ self ! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!entryByName: aString	^ self children 		at: aString 		ifAbsentPut: [  			self class new 				initializeWithParent: self 				entryName: aString ]! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!entryByPath: aString	^ (aString = '.' )		ifTrue: [ self ]		ifFalse: [( ($/ split: aString) reject: #isEmpty)			inject: self 			into: [ :treeBuilder :name | treeBuilder entryByName: name ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entryName	^ entryName! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!hasChanges	^ hasChanges		or: [ initialTree isNil "It means that this is a new tree"		or: [ self children anySatisfy: #hasChanges ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!initialTree	^ initialTree! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	hasChanges := false.	! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/21/2017 17:44:57'!initializeWithParent: anIceTreeBuilder entryName: aString	| treeEntry |	parent := anIceTreeBuilder.	entryName := aString.	treeEntry := parent builder getEntryNamed: entryName.	treeEntry isReady "i.e. the entry alredy exists in parent tree"		ifTrue: [ initialTree := treeEntry tree ]		ifFalse: [ 			"The entry didn't exist so this is a new entry"			hasChanges := true ]! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/21/2017 17:44:57'!initializeWithTree: aLGitTree	"This is a builder on the root of a repository"	initialTree := aLGitTree ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parent	^ parent! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(.	self printPathOn: aStream.	aStream nextPut: $)! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printPathOn: aStream	parent 		ifNil: [ 			aStream nextPutAll: initialTree repository workingDirectoryName ]		ifNotNil: [ 				parent printPathOn: aStream.			aStream nextPut: $/;				nextPutAll: entryName ] ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ parent 		ifNotNil: [ self parent repository ]		ifNil: [ self initialTree owner ]! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!fromArray: anArray	^ self 		major: anArray first 		minor: anArray second 		patch: anArray third! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!major: majorNumber minor: minorNumber patch: patchNumber	^ self basicNew 		initializeMajor: majorNumber 			minor: minorNumber 			patch: patchNumber;		yourself! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use one of my siblings'! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!< aMagnitude 	"Answer whether the receiver is less than the argument."	| version |	version := aMagnitude iceSemanticVersion.	^ self major < version major		or: [ self minor < version minor 		or: [ self patch < version patch ] ]! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!= aMagnitude 	"Compare the receiver with the argument and answer with true if the 	receiver is equal to the argument. Otherwise answer false."	| version |		version := aMagnitude iceSemanticVersion.	^ self major = version major 		and: [ self minor = version minor		and: [ self patch = version patch ] ] ! !!IceSemanticVersion methodsFor: 'hash' stamp: ' 7/21/2017 17:44:57'!hash	^ ((self species hash		bitXor: self major)		bitXor: self minor)		bitXor: self patch! !!IceSemanticVersion methodsFor: 'converting' stamp: ' 7/21/2017 17:44:57'!iceSemanticVersion	^ self! !!IceSemanticVersion methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeMajor: majorNumber minor: minorNumber patch: patchNumber	major := majorNumber.	minor := minorNumber. 	patch := patchNumber! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!major	^ major! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!minor	^ minor! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!patch	^ patch! !!IceSemanticVersion methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: stream 	stream 		<< self major asString 		<< '.' << self minor asString 		<< '.' << self patch asString! !!Magnitude methodsFor: '*Iceberg-Libgit' stamp: ' 7/21/2017 17:44:57'!iceSemanticVersion	^ IceSemanticVersion major: self asInteger minor: 0 patch: 0! !"Iceberg-Libgit"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.585.mcz') load.ScriptLoader new update60509.!----End fileIn----!----QUIT----2017-07-21T17:45:10.565386+02:00 Pharo.image priorSource: 383265!----QUIT----2017-07-21T17:45:21.503773+02:00 Pharo.image priorSource: 1264177!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/24/2017 12:47' prior: 33937868!commentForCurrentUpdate ^ '20268 update iceberg v0.5.5	https://pharo.fogbugz.com/f/cases/20268'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/24/2017 12:48'!script60510	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-Plugin-GitHub-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.56.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1437.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/24/2017 12:48'!update60510	"self new update60510"	self withUpdateLog: '20268 update iceberg v0.5.5	https://pharo.fogbugz.com/f/cases/20268'.	self loadTogether: self script60510 merge: false.	#('Iceberg-UI' 'Iceberg-Plugin-GitHub' 'Iceberg-Plugin' 'Iceberg-Metacello-Integration' 'Iceberg-Libgit' 'Iceberg' 'BaselineOfIceberg' 'LibGit-Core' 'BaselineOfLibGit') do: [ :each | each asPackage removeFromSystem ].Metacello new  baseline: 'Iceberg';  repository: 'github://pharo-vcs/iceberg:v0.5.5';  load.(Smalltalk classNamed: #Iceberg) enableMetacelloIntegration: false.	self flushCaches.! !ScriptLoader removeSelector: #update60509!ScriptLoader removeSelector: #script60509!"ScriptLoader60"!Smalltalk globals removeClassNamed: #AnObsoleteGLMSwappedColorDiffPresentation!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfoModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryUpdateHelper!Smalltalk globals removeClassNamed: #AnObsoleteGLMCherryPickTreePresentation!Smalltalk globals removeClassNamed: #AnObsoleteGLMCherryPickTreeDataSource!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForPlaintextCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceChangesTreeResetSelectionHelper!Smalltalk globals removeClassNamed: #AnObsoleteIceFileModel!Smalltalk globals removeClassNamed: #AnObsoleteIceHistoryBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageModel!Smalltalk globals removeClassNamed: #AnObsoleteIceImportLocalRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourChangesTree!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourPublishBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchGroupModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCloneRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractBrowser!Smalltalk globals removeClassNamed: #AnObsoleteSwappedColorDiffMorph!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForUsernameAndEmailModel!Smalltalk globals removeClassNamed: #AnObsoleteIceDiffCherryPickChangeTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteModel!Smalltalk globals removeClassNamed: #AnObsoleteIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceInteractiveCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteGLMMorphicCherryPickTreeRenderer!Smalltalk globals removeClassNamed: #AnObsoleteIceCachedValue!IceMergeTool removeSelector: #pushRepository:andThen:!IceMergeTool removeSelector: #uiManager!IceMergeTool removeSelector: #mergeIntoAnotherBranch:andThen:!IceMergeTool class removeSelector: #uiManager!Smalltalk globals removeClassNamed: #AnObsoleteTIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceDirectoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeTool!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractModel!Smalltalk globals removeClassNamed: #AnObsoleteIceEditRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourCommitBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractBranchModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCherryPickCommitModel!Smalltalk globals removeClassNamed: #AnObsoleteGLMMorphicSwappedColorDiffRenderer!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourSynchronizer!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteAdded!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForSshCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceDiffChangeTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceLocationModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoriesBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceNewRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourUpdateBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCreateRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceEmbeddedBrowser!ToolShortcutsCategory removeSelector: #openIceberg!IceRemote removeSelector: #branchesFrom:!PharoShortcuts removeSelector: #openIcebergShortcut!GLMCompositePresentation removeSelector: #cherryPickTree!GLMCompositePresentation removeSelector: #swappedColorDiff!GLMMorphicRenderer removeSelector: #renderCherryPickTreePresentation:!GLMMorphicRenderer removeSelector: #renderSwappedColorDiffPresentation:!GLMGenericAction removeSelector: #selectionAction:!GLMGenericAction removeSelector: #selectionCondition:!GLMGenericAction removeSelector: #showTitle:!MCPatchOperation removeSelector: #canBeBrowsed!MCAddition removeSelector: #icon!Text removeSelector: #allItalic!MCModification removeSelector: #icon!DateAndTime removeSelector: #asStringYMDHM!DateAndTime removeSelector: #asLocalStringYMDHM!MCRemoval removeSelector: #canBeBrowsed!MCRemoval removeSelector: #icon!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestActionsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubViewPullRequestCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAcceptPullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubNewPullRequestCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubJSONDataSource!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAPIPaginatedResult!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectListModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectItem!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestListBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestDetailModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequest!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubCreatePullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubRemoveBranchesCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestDataSource!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubGenericError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAPI!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubBadCredentialsError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubRejectPullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestDefinition!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceBaselineInstallerPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzModel!IceRepository removeSelector: #pluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceGithubRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloPharoPlatform!Smalltalk globals removeClassNamed: #AnObsoleteIceGitLocalRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitFileUtils!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitLocalRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitVersionReader!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceSemanticVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitCommitWalk!Magnitude removeSelector: #iceSemanticVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreated!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceVersionDoesNotExist!Smalltalk globals removeClassNamed: #AnObsoleteIceFileRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceStructuralChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceError!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceGitUsernameOrEmailNotFound!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIceClassChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeAborted!Smalltalk globals removeClassNamed: #AnObsoleteIceRemovedClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreator!Smalltalk globals removeClassNamed: #AnObsoleteManifestIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceUnknownBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceWrongUrl!Smalltalk globals removeClassNamed: #AnObsoleteIceTemporaryVersion!Smalltalk globals removeClassNamed: #AnObsoleteIcePushed!Smalltalk globals removeClassNamed: #AnObsoleteIceLoadedCode!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryAnnouncement!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryForgotten!Smalltalk globals removeClassNamed: #AnObsoleteTIceRepositoryBackend!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpsRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceCommited!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceMissingRepositoryEntry!Smalltalk globals removeClassNamed: #AnObsoleteIcePlaintextCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceDuplicatedRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceSshCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessFileTreeWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageOrganizationChange!Smalltalk globals removeClassNamed: #AnObsoleteYouShouldPullBeforePush!Smalltalk globals removeClassNamed: #AnObsoleteIceClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceMCVersionInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceUnbornBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractCommitWalk!Smalltalk globals removeClassNamed: #AnObsoleteIceNoRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceScpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackageVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceNoCurrentBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitish!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageLoaded!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceUndefinedRemote!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageUnloaded!Smalltalk globals removeClassNamed: #AnObsoleteIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalRepositoryMissing!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageReference!Smalltalk globals removeClassNamed: #AnObsoleteIceMethodChange!Smalltalk globals removeClassNamed: #AnObsoleteNothingToCommitException!Smalltalk globals removeClassNamed: #AnObsoleteIceSimpleClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackage!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceWorkingCopy!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceBackendWriterAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSetChanged!Smalltalk globals removeClassNamed: #AnObsoleteIceTag!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryRegistryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceNetworkRemote!Smalltalk globals removeClassNamed: #AnObsoleteCannotIdentifyVersionForCommit!Smalltalk globals removeClassNamed: #AnObsoleteIceForeignVersion!LGitTreeEntry removeSelector: #readStreamDo:!LGitTreeEntry removeSelector: #tree!LGitTreeEntry removeSelector: #name!MCDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCDefinition removeSelector: #iceClass!MCDefinition removeSelector: #addToPackageChangeSet:!MCDefinition removeSelector: #icePackage!LGitReturnCodeEnum removeSelector: #asBoolean!MCOrganizationDefinition removeSelector: #iceClass!MCOrganizationDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCOrganizationDefinition removeSelector: #icePackage!MCVersion removeSelector: #directoryName!MCGitHubRepository removeSelector: #getOrCreateIcebergRepository!MCGitHubRepository removeSelector: #commitIdFor:ifFound:!MCGitHubRepository removeSelector: #commitId!MCGitHubRepository removeSelector: #httpsUrl!MCGitHubRepository removeSelector: #scpUrl!MCPatchOperation removeSelector: #icePackage!MCPatchOperation removeSelector: #iceClass!MCPatchOperation removeSelector: #addToPackageChangeSet:!MCPatchOperation removeSelector: #asIceChangeSet!LGitTag removeSelector: #asIcebergObjectInRepository:!LGitCredentialsPlaintext removeSelector: #readFrom:!LGitDiff removeSelector: #includesFileNamed:!LGitDiff removeSelector: #files!LGitDiff removeSelector: #filesDo:!LGitCredentialsSSH removeSelector: #readFrom:!LGitCommit removeSelector: #changesFileNamed:!LGitCommit removeSelector: #asIcebergObjectInRepository:!MCClassDefinition removeSelector: #classCategory!MCPostscriptDefinition removeSelector: #addToPackageChangeSet:!MCRepository removeSelector: #commitIdFor:ifFound:!RPackage removeSelector: #iceRepository!MCWorkingCopy removeSelector: #loadedVersion!MCClassTraitDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #method!MCMethodDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #icePackage!FileSystemDirectoryEntry removeSelector: #packageName!MCGitHubRepository class removeSelector: #commitIdFor:!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfIceberg!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBAREREPO!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiff!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineCallback!LGitExternalStructure removeSelector: #shouldContinuePrintingOn:!LGitExternalStructure removeSelector: #objectPrintOn:!LGitExternalStructure removeSelector: #printOn:!LGitExternalObject removeSelector: #objectPrintOn:!LGitExternalObject removeSelector: #printOn:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitPrintingTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitBuf!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpeningRepositoryError!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCompletionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENOTFOUND!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueUInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchPruneTypeEnum!LGitExternalObject removeSelector: #safeFFICalloutIn:!LGitExternalObject removeSelector: #signalNotReady!LGitExternalObject removeSelector: #validate:shouldBe:!LGitExternalObject removeSelector: #ifNotReady:!LGitExternalObject removeSelector: #withReturnHandlerDo:!LGitExternalObject removeSelector: #ffiLibrary!LGitExternalObject removeSelector: #ffiLibraryName!LGitExternalObject removeSelector: #callUnchecked:options:!LGitExternalObject removeSelector: #call:options:!LGitExternalObject removeSelector: #signalIfNotReady!LGitExternalObject removeSelector: #call:!LGitExternalObject removeSelector: #ffiNull!LGitExternalObject class removeSelector: #ffiLibrary!LGitExternalObject class removeSelector: #ffiLibraryName!LGitExternalObject class removeSelector: #validate:shouldBe:!LGitExternalObject class removeSelector: #call:options:!LGitExternalObject class removeSelector: #call:!LGitExternalObject class removeSelector: #withReturnHandlerDo:!LGitGlobal removeSelector: #safeFFICalloutIn:!LGitGlobal removeSelector: #signalNotReady!LGitGlobal removeSelector: #validate:shouldBe:!LGitGlobal removeSelector: #ifNotReady:!LGitGlobal removeSelector: #withReturnHandlerDo:!LGitGlobal removeSelector: #ffiLibrary!LGitGlobal removeSelector: #ffiLibraryName!LGitGlobal removeSelector: #callUnchecked:options:!LGitGlobal removeSelector: #call:options:!LGitGlobal removeSelector: #signalIfNotReady!LGitGlobal removeSelector: #call:!LGitGlobal removeSelector: #ffiNull!LGitGlobal removeSelector: #isReady!LGitGlobal class removeSelector: #ffiLibrary!LGitGlobal class removeSelector: #ffiLibraryName!LGitGlobal class removeSelector: #call:options:!LGitGlobal class removeSelector: #validate:shouldBe:!LGitGlobal class removeSelector: #call:!LGitGlobal class removeSelector: #withReturnHandlerDo:!LGitCredentials removeSelector: #safeFFICalloutIn:!LGitCredentials removeSelector: #signalNotReady!LGitCredentials removeSelector: #validate:shouldBe:!LGitCredentials removeSelector: #ifNotReady:!LGitCredentials removeSelector: #withReturnHandlerDo:!LGitCredentials removeSelector: #ffiLibrary!LGitCredentials removeSelector: #ffiLibraryName!LGitCredentials removeSelector: #callUnchecked:options:!LGitCredentials removeSelector: #call:options:!LGitCredentials removeSelector: #signalIfNotReady!LGitCredentials removeSelector: #call:!LGitCredentials removeSelector: #ffiNull!LGitCredentials removeSelector: #isReady!LGitCredentials class removeSelector: #ffiLibrary!LGitCredentials class removeSelector: #ffiLibraryName!LGitCredentials class removeSelector: #call:options:!LGitCredentials class removeSelector: #validate:shouldBe:!LGitCredentials class removeSelector: #call:!LGitCredentials class removeSelector: #withReturnHandlerDo:!LGitExternalStructure removeSelector: #safeFFICalloutIn:!LGitExternalStructure removeSelector: #signalNotReady!LGitExternalStructure removeSelector: #validate:shouldBe:!LGitExternalStructure removeSelector: #ifNotReady:!LGitExternalStructure removeSelector: #withReturnHandlerDo:!LGitExternalStructure removeSelector: #ffiLibrary!LGitExternalStructure removeSelector: #ffiLibraryName!LGitExternalStructure removeSelector: #callUnchecked:options:!LGitExternalStructure removeSelector: #call:options:!LGitExternalStructure removeSelector: #signalIfNotReady!LGitExternalStructure removeSelector: #call:!LGitExternalStructure removeSelector: #ffiNull!LGitExternalStructure removeSelector: #isReady!LGitExternalStructure class removeSelector: #validate:shouldBe:!LGitExternalStructure class removeSelector: #withReturnHandlerDo:!LGitExternalStructure class removeSelector: #ffiLibrary!LGitExternalStructure class removeSelector: #ffiLibraryName!LGitExternalStructure class removeSelector: #call:options:!LGitExternalStructure class removeSelector: #call:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitCalloutTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitUpdateTipsCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENONFASTFORWARD!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemote!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_PASSTHROUGH!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndex!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneLocalTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitFileSignatureCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsPlaintext!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoCredentialsProvided!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfDataCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructWithDefaults!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallError!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpenFlagEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructureFieldParser!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStatsFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitSimilarityCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitError!Smalltalk globals removeClassNamed: #AnObsoleteLGitDatabase!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndexMatchedPathCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSHAgent!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEOF!Smalltalk globals removeClassNamed: #AnObsoleteLGitAnnotatedCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCompletionCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitSubmoduleIgnoreTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitActionSequence!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgress!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ITEROVER!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EPEEL!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitErrorTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdbWritepack!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALID!Smalltalk globals removeClassNamed: #AnObsoleteLGitTag!Smalltalk globals removeClassNamed: #AnObsoleteLGitDeltaTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryFile!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoReturnCodeHandlerDefined!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchIterator!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitFunctionReturn!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitIllegalArgument!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptionsVersionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBUFS!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValue!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentials!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCertificateCheckCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdate!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECERTIFICATE!Smalltalk globals removeClassNamed: #AnObsoleteLGitPatch!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushStatusForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFile!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNMERGED!Smalltalk globals removeClassNamed: #AnObsoleteLGitConfig!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunkCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNBORNBRANCH!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackCommitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitBufferSignatureCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteAutotagOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EMODIFIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueSizeT!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationUInt32!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitSignature!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEXISTS!Smalltalk globals removeClassNamed: #AnObsoleteLGitReference!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdateReferenceCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLine!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransport!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStats!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutStrategyEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdb!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalkSortTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCallbacks!Smalltalk globals removeClassNamed: #AnObsoleteLGitAbstractError!Smalltalk globals removeClassNamed: #AnObsoleteLGitFilemodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitLibrary!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAMBIGUOUS!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructure!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffSimilarityMetric!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotInitialized!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlob!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitFreeSignatureCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSH!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAUTH!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepository!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalCommitArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTime!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallReturnHandler!Smalltalk globals removeClassNamed: #AnObsoleteLGitOptionsVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutMethodBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritingTreeFailed!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusList!Smalltalk globals removeClassNamed: #AnObsoleteLGitDirectionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitId!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUSER!Smalltalk globals removeClassNamed: #AnObsoleteLGitObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinary!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlame!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalUInt8Array!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredAcquireCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkModeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ERROR!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutAPI!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_OK!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALIDSPEC!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeEntry!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationInt32!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachPayload!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalObject!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNCOMMITTED!Smalltalk globals removeClassNamed: #AnObsoleteLGitTree!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushNegotiationCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffDelta!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECONFLICT!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommitBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFileCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRefSpec!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAPPLIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackAppendCallout!Smalltalk globals removeClassNamed: #AnObsoleteManifestLibGitCore!Smalltalk globals removeClassNamed: #AnObsoleteLGitReferenceTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitMergeOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EORPHANEDHEAD!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitReturnCodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportMessageCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteHead!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ELOCKED!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecMatchList!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitGlobal!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushTransferProgressCallback!Object removeSelector: #handleLGitReturnCode!String removeSelector: #asLGitExternalString!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfLibGit!!BaselineOfIceberg methodsFor: 'baseline' stamp: ' 7/24/2017 12:50:00'!baseline: spec	<baseline>	spec for: #common do: [ 				spec postLoadDoIt: #resetKMRepository.				spec		configuration: 'OSSubprocess' with: [ spec			versionString: #stable;			repository: 'github://marianopeck/OSSubprocess/repository' ];		configuration: 'ProcessWrapper' with: [ spec			versionString: #stable;			repository: 'http://smalltalkhub.com/mc/Pharo/MetaRepoForPharo50/main' ];		baseline: 'FileTree' with: [ spec			repository: 'github://pharo-vcs/filetree:pharo6.0_dev/repository';			loads: 'Git' ];		baseline: 'LibGit' with: [ spec			repository: 'github://pharo-vcs/libgit2-pharo-bindings:v0.25.1';  			loads: 'default' ];		project: 'LibGit-Tests'          copyFrom: 'LibGit'          with: [ spec loads: #('tests') ];		for: #MacOS do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess') ] ];		for: #Unix do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess' ) ] ];		for: #Windows do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('ProcessWrapper') ] ];		package: 'Iceberg';		package: 'Iceberg-Plugin' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Plugin-GitHub' with: [ spec requires: #('Iceberg-Plugin' 'Iceberg-UI') ];		package: 'Iceberg-Metacello-Integration' with: [ spec requires: #('Iceberg')];		package: 'Iceberg-UI' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Tests' with: [ spec requires: #('Iceberg' 'Iceberg-GitCommand') ];		package: 'Iceberg-UI-Tests' with: [ spec requires: #('Iceberg-UI' 'Iceberg-Tests')];		package: 'Iceberg-GitFileTree' with: [ spec requires: #('Iceberg' 'FileTree') ];		package: 'Iceberg-GitFileTree-Tests' with: [ spec requires: #('Iceberg-GitFileTree' 'Iceberg-Tests') ];		package: 'Iceberg-Libgit' with: [ spec requires: #('Iceberg' 'LibGit') ];		group: 'minimal' with: #('Iceberg' 'Iceberg-Libgit');		group: 'default' with: #(minimal 'Iceberg-Metacello-Integration' 'Iceberg-UI' 'Iceberg-Plugin' 'Iceberg-Plugin-GitHub');		group: 'allTests' with: #('Iceberg-Tests' 'LibGit-Tests' 'Iceberg-GitFileTree-Tests' 'Iceberg-UI-Tests' );		group: 'development' with: #(default 'Iceberg-GitFileTree' allTests)	]! !!BaselineOfIceberg methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:00'!customProjectAttributes	Smalltalk os isMacOS ifTrue: [ ^ #(#MacOS) ].	Smalltalk os isUnix ifTrue: [ ^ #(#Unix) ].	Smalltalk os isWindows ifTrue: [ ^ #(#Windows) ]! !!BaselineOfIceberg methodsFor: 'script' stamp: ' 7/24/2017 12:50:00'!resetKMRepository	KMRepository reset! !"BaselineOfIceberg"!!BaselineOfLibGit methodsFor: 'baseline' stamp: ' 7/24/2017 12:50:03'!baseline: spec  <baseline>  spec    for: #(common)    do: [       spec        package: 'LibGit-Tests' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-GT' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Patches' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Core'.      spec        group: 'default'        with: #('LibGit-Core').		spec			group: 'development'			with: #('default' 'LibGit-Tests' 'LibGit-Patches' 'LibGit-GT').		spec			group: 'tests'			with: #('LibGit-Tests').		spec postLoadDoIt: #postLoadActions ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/24/2017 12:50:03'!changeRepositoryType	| repos newRepo |	(Smalltalk hasClassNamed: #MCGitRepository) ifFalse: [ ^ self ].		repos := MCRepositoryGroup default repositories		select: [ :r | (r description includesSubstring: 'LibGit:master') or: [ 			r description includesSubstring: 'LibGit/master' ] ].	repos ifEmpty: [  ^ self ].		'github-cache/theseion' asFileReference deleteAll.	newRepo := (Smalltalk at: #MCGitRepository) new		repoUrl: 'git@github.com:theseion/LibGit';		ensureDirectory;		yourself.			MCRepositoryGroup allInstances		select: [ :group | group repositories includesAnyOf: repos ]		thenDo: [ :group | 			repos do: [ :repo | group removeRepository: repo ].			group addRepository: newRepo ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/24/2017 12:50:03'!postLoadActions	self changeRepositoryType! !"BaselineOfLibGit"!!LGitExternalArray commentStamp: 'MaxLeske 7/14/2015 09:09' prior: 0!I provide general implementations for my subclasses that represent dedicated arrays of a certain type.!!LGitExternalCommitArray commentStamp: 'MaxLeske 7/13/2015 17:10' prior: 0!I represent an external array of commits.!!LGitExternalStringArray commentStamp: 'MaxLeske 7/13/2015 17:12' prior: 0!I represent an external array of strings. Since strings are of variable size, they can not be easily represented by the general implementation.I take care of converting regular strings to external ones (which allocates and reserves the memory) and reading strings from memory.I override #free to ensure that the memory for the external strings is correctly freed.!!LGitExternalUInt8Array commentStamp: 'MaxLeske 7/15/2015 10:31' prior: 0!My elements are 8 bit unsigned integers.!!LGitExternalEnumerationUInt32 commentStamp: 'MaxLeske 3/17/2014 13:57' prior: 0!See the comment in NBExternalEnumeration. I am a copy of NBExternalEnumeration with the exception that I inherit from Object, not from SharedPool.!!LGitCheckoutStrategyEnum commentStamp: 'MaxLeske 8/13/2015 11:06' prior: 0!/** * Checkout behavior flags * * In libgit2, checkout is used to update the working directory and index * to match a target tree.  Unlike git checkout, it does not move the HEAD * commit for you - use `git_repository_set_head` or the like to do that. * * Checkout looks at (up to) four things: the "target" tree you want to * check out, the "baseline" tree of what was checked out previously, the * working directory for actual files, and the index for staged changes. * * You give checkout one of three strategies for update: * * - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts, *   etc., but doesn't make any actual changes. * * - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to *   make the working directory match the target (including potentially *   discarding modified files). * * - `GIT_CHECKOUT_SAFE` is between these two options, it will only make *   modifications that will not lose changes. * *                         |  target == baseline   |  target !!= baseline  | *    ---------------------|-----------------------|----------------------| *     workdir == baseline |       no action       |  create, update, or  | *                         |                       |     delete file      | *    ---------------------|-----------------------|----------------------| *     workdir exists and  |       no action       |   conflict (notify   | *       is !!= baseline    | notify dirty MODIFIED | and cancel checkout) | *    ---------------------|-----------------------|----------------------| *      workdir missing,   | notify dirty DELETED  |     create file      | *      baseline present   |                       |                      | *    ---------------------|-----------------------|----------------------| * * To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout * notification callback (see below) that displays information about dirty * files.  The default behavior will cancel checkout on conflicts. * * To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a * notification callback that cancels the operation if a dirty-but-existing * file is found in the working directory.  This core git command isn't * quite "force" but is sensitive about some types of changes. * * To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`. * * * There are some additional flags to modified the behavior of checkout: * * - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates *   even if there are conflicts (instead of cancelling the checkout). * * - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not *   in target, baseline, or index, and not ignored) from the working dir. * * - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also *   untracked) from the working directory as well. * * - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that *   already exist.  Files will not be created nor deleted.  This just skips *   applying adds, deletes, and typechanges. * * - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the *   updated files' information to the index. * * - Normally, checkout will reload the index and git attributes from disk *   before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload. * * - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips *   files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and *   GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the *   stage 2 ("ours") or stage 3 ("theirs") version of files in the index. * * - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being *   overwritten.  Normally, files that are ignored in the working directory *   are not considered "precious" and may be overwritten if the checkout *   target contains that file. * * - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing *   files or folders that fold to the same name on case insensitive *   filesystems.  This can cause files to retain their existing names *   and write through existing symbolic links. */!!LGitDeltaTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:32' prior: 0!/** * What type of change is described by a git_diff_delta? * * `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run * `git_diff_find_similar()` on the diff object. * * `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE` * in the option flags (otherwise type changes will be split into ADDED / * DELETED pairs). */!!LGitDiffBinaryTypeEnum commentStamp: 'MaxLeske 8/13/2015 14:28' prior: 0!/** * When producing a binary diff, the binary data returned will be * either the deflated full ("literal") contents of the file, or * the deflated binary delta between the two sides (whichever is * smaller). */!!LGitOptionsVersionsEnum commentStamp: 'MaxLeske 7/17/2015 13:37' prior: 0!I map names to versions for all the option structs.!!LGitProxyTypeEnum commentStamp: '<historical>' prior: 0!/** * The type of proxy to use. */!!LGitRevwalkSortTypeEnum commentStamp: 'MaxLeske 3/1/2015 16:39' prior: 0!/** * Sort the repository contents in no particular ordering; * this sorting is arbitrary, implementation-specific * and subject to change at any time. * This is the default sorting for new walkers. */#define GIT_SORT_NONE			(0)/** * Sort the repository contents in topological order * (parents before children); this sorting mode * can be combined with time sorting. */#define GIT_SORT_TOPOLOGICAL (1 << 0)/** * Sort the repository contents by commit time; * this sorting mode can be combined with * topological sorting. */#define GIT_SORT_TIME			(1 << 1)/** * Iterate through the repository contents in reverse * order; this sorting mode can be combined with * any of the above. */#define GIT_SORT_REVERSE		(1 << 2)!!LGitStatusTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:34' prior: 0!/** * Status flags for a single file. * * A combination of these values will be returned to indicate the status of * a file.  Status compares the working directory, the index, and the * current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags * represents the status of file in the index relative to the HEAD, and the * `GIT_STATUS_WT` set of flags represent the status of the file in the * working directory relative to the index. */!!LGitRefSpec commentStamp: 'MaxLeske 4/18/2014 11:59' prior: 0!Use:	LGitRefSpec fromString: '+refs/heads/*:refs/remotes/origin/*'.Note: The asterisk wildcard (*) matches all refs of a given path (not explicitly documented in the below).From the git-fetch man page:<refspec>           The format of a <refspec> parameter is an optional plus +, followed by the source           ref <src>, followed by a colon :, followed by the destination ref <dst>.           The remote ref that matches <src> is fetched, and if <dst> is not empty string,           the local ref that matches it is fast-forwarded using <src>. If the optional plus           + is used, the local ref is updated even if it does not result in a fast-forward           update.               Note               If the remote branch from which you want to pull is modified in non-linear               ways such as being rewound and rebased frequently, then a pull will attempt a               merge with an older version of itself, likely conflict, and fail. It is under               these conditions that you would want to use the + sign to indicate               non-fast-forward updates will be needed. There is currently no easy way to               determine or declare that a branch will be made available in a repository               with this behavior; the pulling user simply must know this is the expected               usage pattern for a branch.               Note               You never do your own development on branches that appear on the right hand               side of a <refspec> colon on Pull: lines; they are to be updated by git               fetch. If you intend to do development derived from a remote branch B, have a               Pull: line to track it (i.e.  Pull: B:remote-B), and have a separate branch               my-B to do your development on top of it. The latter is created by git branch               my-B remote-B (or its equivalent git checkout -b my-B remote-B). Run git               fetch to keep track of the progress of the remote side, and when you see               something new on the remote branch, merge it into your development branch               with git pull . remote-B, while you are on my-B branch.               Note               There is a difference between listing multiple <refspec> directly on git pull               command line and having multiple Pull: <refspec> lines for a <repository> and               running git pull command without any explicit <refspec> parameters. <refspec>               listed explicitly on the command line are always merged into the current               branch after fetching. In other words, if you list more than one remote refs,               you would be making an Octopus. While git pull run without any explicit               <refspec> parameter takes default <refspec>s from Pull: lines, it merges only               the first <refspec> found into the current branch, after fetching all the               remote refs. This is because making an Octopus from remote refs is rarely               done, while keeping track of multiple remote heads in one-go by fetching more               than one is often useful.Some short-cut notations are also supported.           o    tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests               fetching everything up to the given tag.           o   A parameter <ref> without a colon fetches that ref into FETCH_HEAD, and               updates the remote-tracking branches (if any).!!LGitExternalStructure commentStamp: 'MaxLeske 3/1/2015 20:36' prior: 0!Important: structs in libgit2 are usually freed by libgit2 itself.	We therefore disable freeing of structs during GC to prevent invalid	memory accesses. However, users of any struct need to make sure that	they free the struct (using a manual #free send) iff it is necessary.	Otherwise the structs will leak and we can't reclaim the space once the	object representing the struct has been collected!!LGitCredentialsSSH commentStamp: '<historical>' prior: 0!I'm a set of credentials who asks public/private keys from from files (in case you need something different than what is answered by ssh-agent, provided by LGitCredentialsSSHAgent)!!LGitCredentialsSSHAgent commentStamp: '<historical>' prior: 0!I'm a set of credentials who feeds from the ssh-agent client.!!LGitDiffBinary commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** Structure describing the binary contents of a diff. */!!LGitDiffBinaryFile commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** The contents of one of the files in a binary diff. */!!LGitDiffDelta commentStamp: 'MaxLeske 7/4/2015 17:03' prior: 0!I represent the difference between two entities (e.g. two files). If one of the entities is new or deleted the "nfiles" field will hold be set to 1, otherwise it will be set to 2.!!LGitId commentStamp: '<historical>' prior: 0!I'm an unique identity of any object (commit, tree, blob, tag).https://libgit2.github.com/libgit2/#HEAD/type/git_oidNOTE: This might be replaces by an FFITypeArray in the future.!!LGitRemoteHead commentStamp: 'EstebanLorenzano 1/5/2017 16:00' prior: 0!I'm a description of a reference advertised by a remote server, given out on `ls` calls.https://libgit2.github.com/libgit2/#HEAD/type/git_remote_head!!LGitSignature commentStamp: '<historical>' prior: 0!A LGitSignature represents the information of a specific person for a commit.Instance Variables	email:		ByteString	name:		ByteString	when:		DateAndTime!!LGitProxyOptions commentStamp: '<historical>' prior: 0!/** * Options for connecting through a proxy * * Note that not all types may be supported, depending on the platform * and compilation options. */!!LGitPushOptions commentStamp: 'MaxLeske 8/13/2015 23:46' prior: 0!/** * Controls the behavior of a git_push object. */!!LGitRemoteCallbacks commentStamp: 'MaxLeske 8/13/2015 13:20' prior: 0!/** * The callback settings structure * * Set the callbacks to be called by the remote when informing the user * about the progress of the network operations. */!!LGitSafeFFICalloutAPI commentStamp: 'JanVanDeSandt 5/1/2016 21:18' prior: 0!I'm a variant of FFICalloutAPI that uses a different builder to generate methods with an extra check to see if the object is 'ready' or not.!!LGitRepository commentStamp: '<historical>' prior: 0!A LGitRepository represents a git repository.Instance Variables	handle:		NBExternalObjecthandle	- reference to the external object!!LGitConfig commentStamp: 'NicoPasserini 2/8/2017 00:51' prior: 0!/** Memory representation of a set of config files */typedef struct git_config git_config;https://libgit2.github.com/libgit2/#HEAD/type/git_config!!LGitCommit commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitCommit represents a specific commit and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitTag commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitTag represents a git tag and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitReference commentStamp: '<historical>' prior: 0!A LGitReference represents the reference to a git object. References can be symbolic as for instance HEAD or a branch etc.Instance Variables	handle:			NBExternalObject	repoHandle:	NBExternalObjecthandle	- the reference to the external object representing the referencerepoHandle	- the reference to the repository in which the reference is contained!!LGitNoCredentialsProvided commentStamp: 'EstebanLorenzano 2/8/2017 16:19' prior: 0!I'm an error thrown in callbacks when no credentials has been found.Callbacks supplying credentials HAVE to throw this error and not one created by themselves (because libgit2 aborts processing with this exception and not with others). !!ManifestLibGitCore commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!LGitCredAcquireCallback commentStamp: 'MaxLeske 3/1/2015 16:57' prior: 0!/** * Signature of a function which acquires a credential object. * * - cred: The newly created credential object. * - url: The resource for which we are demanding a credential. * - username_from_url: The username that was embedded in a "user@host" *                          remote url, or NULL if not included. * - allowed_types: A bitmask stating which cred types are OK to return. * - payload: The payload provided when specifying this callback. * - returns 0 for success, < 0 to indicate an error, > 0 to indicate *       no credential was acquired */!!LGitIndexMatchedPathCallback commentStamp: '<historical>' prior: 0!I define a git_index_matched_path_cb.https://libgit2.github.com/libgit2/#HEAD/group/callback/git_index_matched_path_cb!!LGitSafeFFICalloutMethodBuilder commentStamp: 'JanVanDeSandt 5/1/2016 21:17' prior: 0!I'm a variant of FFICalloutMethodBuilder  that adds a call to  #signalIfNotReady  before the actual ffi call.!!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibrary	^LGitLibrary ! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibraryName	^self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'argument validation' stamp: ' 7/24/2017 12:50:03'!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!TLGitCalloutTrait classTrait methodsFor: 'exit code handling' stamp: ' 7/24/2017 12:50:03'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibrary	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibraryName	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiNull	^FFIExternalObject null! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isReady	^ true! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalNotReady	LGitObjectNotInitialized signalWith: self! !!TLGitCalloutTrait methodsFor: 'argument validation' stamp: ' 7/24/2017 12:50:03'!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!TLGitCalloutTrait methodsFor: 'exit code handling' stamp: ' 7/24/2017 12:50:03'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!shouldContinuePrintingOn: aStream	^ true! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!externalNew: numberOfElements	^ self 		externalNewType: self type 		size: numberOfElements! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!onAddress: handle size: numberOfElements	^ self fromHandle: handle type: self type size: numberOfElements! !!LGitExternalArray class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type 	^ self subclassResponsibility! !!LGitExternalArray methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asArray	| array |	array := Array new: self size.	1 to: self size do: [ :index |		array			at: index			put: (self at: index) ].			^ array! !!LGitExternalCommitArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :commit :index |		instance at: index put: commit ].		^ instance! !!LGitExternalCommitArray class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type 	^ LGitCommit! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: anIndex	^ LGitCommit fromHandle: (super at: anIndex)! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: anIndex put: aLGitCommit	^ super at: anIndex put: aLGitCommit getHandle! !!LGitExternalStringArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :element :index |		instance at: index put: element ].		^ instance! !!LGitExternalStringArray class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type	^ 'char*'! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: anInteger	^ (self primAt: anInteger) readString! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: index put: aString	^ super at: index put: aString asLGitExternalString getHandle! !!LGitExternalStringArray methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!free	1 to: self size do: [ :index | 		(self primAt: index) free ].		super free! !!LGitExternalStringArray methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!primAt: anInteger	^ super at: anInteger! !!LGitExternalUInt8Array class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type	^ FFIUInt32! !!LGitExternalUInt8Array methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type 	^ FFIUInt8! !!LGitBlameFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		"Normal blame the default"		GIT_BLAME_NORMAL 0		"Track lines that have moved within a file (like `git blame -M`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_FILE 1		"Track lines that have moved across files in the same commit (like `git blame -C`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES 2		"Track lines that have been copied from another file that exists in the		 * same commit (like `git blame -CC`). Implies SAME_FILE.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES 4		"Track lines that have been copied from another file that exists in *any*		 * commit (like `git blame -CCC`). Implies SAME_COMMIT_COPIES.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES 8		"Restrict the search of commits to those reachable following only the		 * first parents."		GIT_BLAME_FIRST_PARENT 16	)! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_first_parent	^ self basicNew		value: 16;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_normal	^ self basicNew		value: 0;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_any_commit_copies	^ self basicNew		value: 8;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_same_commit_copies	^ self basicNew		value: 4;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_same_commit_moves	^ self basicNew		value: 2;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_same_file	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_BRANCH_LOCAL 1	GIT_BRANCH_REMOTE 2	GIT_BRANCH_ALL 3)! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_branch_all	^ self basicNew		value: 3;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_branch_local	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_branch_remote	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_CHECKOUT_NOTIFY_NONE 0	GIT_CHECKOUT_NOTIFY_CONFLICT 1	GIT_CHECKOUT_NOTIFY_DIRTY 2	GIT_CHECKOUT_NOTIFY_UPDATED 4	GIT_CHECKOUT_NOTIFY_UNTRACKED 8	GIT_CHECKOUT_NOTIFY_IGNORED 16	GIT_CHECKOUT_NOTIFY_ALL 65535)! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_all	^ self basicNew		value: 65535;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_conflict	^ self basicNew		value: 1;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_dirty	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_ignored	^ self basicNew		value: 16;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_untracked	^ self basicNew		value: 8;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_updated	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'enum description' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		GIT_CHECKOUT_NONE  0 "< default is a dry run, no actual updates "		" Allow safe updates that cannot overwrite uncommitted data "		GIT_CHECKOUT_SAFE  "1 bitShift: 0" 1		" Allow all updates to force working directory to look like index "		GIT_CHECKOUT_FORCE  "1 bitShift: 1" 2		" Allow checkout to recreate missing files "		GIT_CHECKOUT_RECREATE_MISSING  "1 bitShift: 2" 4		" Allow checkout to make safe updates even if conflicts are found "		GIT_CHECKOUT_ALLOW_CONFLICTS  "1 bitShift: 4" 16		" Remove untracked files not in index (that are not ignored) "		GIT_CHECKOUT_REMOVE_UNTRACKED  "1 bitShift: 5" 32		" Remove ignored files not in index "		GIT_CHECKOUT_REMOVE_IGNORED  "1 bitShift: 6" 64		" Only update existing files, don't create new ones "		GIT_CHECKOUT_UPDATE_ONLY  "1 bitShift: 7" 128		"		 * Normally checkout updates index entries as it goes; this stops that.		 * Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.		 "		GIT_CHECKOUT_DONT_UPDATE_INDEX  "1 bitShift: 8" 256		" Don't refresh index/config/etc before doing checkout "		GIT_CHECKOUT_NO_REFRESH  "1 bitShift: 9" 512		" Allow checkout to skip unmerged files "		GIT_CHECKOUT_SKIP_UNMERGED  "1 bitShift: 10" 1024		" For unmerged files, checkout stage 2 from index "		GIT_CHECKOUT_USE_OURS  "1 bitShift: 11" 2048		" For unmerged files, checkout stage 3 from index "		GIT_CHECKOUT_USE_THEIRS  "1 bitShift: 12" 4096		" Treat pathspec as simple list of exact match file paths "		GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH  "1 bitShift: 13" 8192		" Ignore directories in use, they will be left empty "		GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES  "1 bitShift: 18" 262144		" Don't overwrite ignored files that exist in the checkout target "		GIT_CHECKOUT_DONT_OVERWRITE_IGNORED  "1 bitShift: 19" 524288		" Write normal merge files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_MERGE  "1 bitShift: 20" 1048576		" Include common ancestor data in diff3 format files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_DIFF3  "1 bitShift: 21" 2097152		" Don't overwrite existing files or folders "		GIT_CHECKOUT_DONT_REMOVE_EXISTING  "1 bitShift: 22" 4194304		" Normally checkout writes the index upon completion; this prevents that. "		GIT_CHECKOUT_DONT_WRITE_INDEX  "1 bitShift: 23" 8388608		"		 * THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED		 "		" Recursively checkout submodules with same options (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES  "1 bitShift: 16" 65536		" Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED  "1 bitShift: 17" 131072)! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_allow_conflicts	^ self basicNew		value: 16;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_conflict_style_diff3	^ self basicNew		value: 2097152;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_conflict_style_merge	^ self basicNew		value: 1048576;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_disable_pathspec_match	^ self basicNew		value: 8192;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_overwrite_ignored	^ self basicNew		value: 524288;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_remove_existing	^ self basicNew		value: 4194304;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_update_index	^ self basicNew		value: 256;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_write_index	^ self basicNew		value: 8388608;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_force	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_no_refresh	^ self basicNew		value: 512;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_recreate_missing	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_remove_ignored	^ self basicNew		value: 64;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_remove_untracked	^ self basicNew		value: 32;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_safe	^ self basicNew		value: 1;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_safe_create	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_skip_locked_directories	^ self basicNew		value: 262144;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_skip_unmerged	^ self basicNew		value: 1024;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_update_only	^ self basicNew		value: 128;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_update_submodules	^ self basicNew		value: 65536;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_update_submodules_if_changed	^ self basicNew		value: 131072;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_use_ours	^ self basicNew		value: 2048;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_use_theirs	^ self basicNew		value: 4096;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(			GIT_CLONE_LOCAL_AUTO 0			GIT_CLONE_LOCAL 1			GIT_CLONE_NO_LOCAL 2			GIT_CLONE_LOCAL_NO_LINKS 3		)! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_local	^ self basicNew		value: 1;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_local_auto	^ self basicNew		value: 0;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_local_no_links	^ self basicNew		value: 3;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_no_local	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_CREDTYPE_USERPASS_PLAINTEXT 1	GIT_CREDTYPE_SSH_KEY 2	GIT_CREDTYPE_SSH_CUSTOM 4	GIT_CREDTYPE_DEFAULT 8)! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_default	^ self basicNew		value: 8;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_ssh_custom	^ self basicNew		value: 4;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_ssh_key	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_userpass_plaintext	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DELTA_UNMODIFIED 0 "no changes"	GIT_DELTA_ADDED 1 "entry does not exist in old version"	GIT_DELTA_DELETED 2 "entry does not exist in new version"	GIT_DELTA_MODIFIED 3 "entry content changed between old and new"	GIT_DELTA_RENAMED 4 "entry was renamed between old and new"	GIT_DELTA_COPIED 5 "entry was copied from another old entry"	GIT_DELTA_IGNORED 6 "entry is ignored item in workdir"	GIT_DELTA_UNTRACKED 7 "entry is untracked item in workdir"	GIT_DELTA_TYPECHANGE 8 "type of entry changed between old and new"	GIT_DELTA_UNREADABLE 9 "entry is unreadable"	GIT_DELTA_CONFLICTED 10 "< entry in the index is conflicted")! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_added	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_conflicted	^ self basicNew		value: 10;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_copied	^ self basicNew		value: 5;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_deleted	^ self basicNew		value: 2;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_ignored	^ self basicNew		value: 6;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_modified	^ self basicNew		value: 3;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_renamed	^ self basicNew		value: 4;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_typechange	^ self basicNew		value: 8;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_unmodified	^ self basicNew		value: 0;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_unreadable	^ self basicNew		value: 9;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_untracked	^ self basicNew		value: 7;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(		" There is no binary delta. "		GIT_DIFF_BINARY_NONE 0		" The binary data is the literal contents of the file. "		GIT_DIFF_BINARY_LITERAL 1		" The binary data is the delta from one side to the other. "		GIT_DIFF_BINARY_DELTA 2	)! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_binary_delta	^ self basicNew		value: 2;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_binary_literal	^ self basicNew		value: 1;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_binary_none	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	<todo: 'enum defines 0 twice (one commented out). Use second enum?'>	^#(	" Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag. "	GIT_DIFF_FIND_BY_CONFIG 0	" Look for renames? (`--find-renames`) "	GIT_DIFF_FIND_RENAMES 1	" Consider old side of MODIFIED for renames? (`--break-rewrites=N`) "	GIT_DIFF_FIND_RENAMES_FROM_REWRITES 2	" Look for copies? (a la `--find-copies`). "	GIT_DIFF_FIND_COPIES 4	" Consider UNMODIFIED as copy sources? (`--find-copies-harder`).	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNMODIFIED when	 * the initial `git_diff` is being generated.	 "	GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED 8	" Mark significant rewrites for split (`--break-rewrites=/M`) "	GIT_DIFF_FIND_REWRITES 16	" Actually split large rewrites into delete/add pairs "	GIT_DIFF_BREAK_REWRITES 32	" Mark rewrites for split and break into delete/add pairs "	GIT_DIFF_FIND_AND_BREAK_REWRITES 48	" Find renames/copies for UNTRACKED items in working directory.	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNTRACKED when the	 * initial `git_diff` is being generated (and obviously the diff must	 * be against the working directory for this to make sense).	 "	GIT_DIFF_FIND_FOR_UNTRACKED 64	" Turn on all finding features. "	GIT_DIFF_FIND_ALL 255	" Measure similarity ignoring leading whitespace (default) "	"GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE 0"	" Measure similarity ignoring all whitespace "	GIT_DIFF_FIND_IGNORE_WHITESPACE 4096	" Measure similarity including all data "	GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE 8192	" Measure similarity only by comparing SHAs (fast and cheap) "	GIT_DIFF_FIND_EXACT_MATCH_ONLY 16384	" Do not break rewrites unless they contribute to a rename.	 *	 * Normally GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-	 * similarity of modified files and split the ones that have changed a	 * lot into a DELETE / ADD pair.  Then the sides of that pair will be	 * considered candidates for rename and copy detection.	 *	 * If you add this flag in and the split pair is *not* used for an	 * actual rename or copy then the modified record will be restored to	 * a regular MODIFIED record instead of being split.	 "	GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY 32768	" Remove any UNMODIFIED deltas after find_similar is done.	 *	 * Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the	 * --find-copies-harder behavior requires building a diff with the	 * GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED	 * records in the final result pass this flag to have them removed.	 "	GIT_DIFF_FIND_REMOVE_UNMODIFIED 65536	)! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_break_rewrites	^ self basicNew		value: 32;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_break_rewrites_for_renames_only	^ self basicNew		value: 32768;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_all	^ self basicNew		value: 255;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_and_break_rewrites	^ self basicNew		value: 48;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_by_config	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_copies	^ self basicNew		value: 4;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_copies_from_unmodified	^ self basicNew		value: 8;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_dont_ignore_whitespace	^ self basicNew		value: 8192;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_exact_match_only	^ self basicNew		value: 16384;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_for_untracked	^ self basicNew		value: 64;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_ignore_whitespace	^ self basicNew		value: 4096;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_remove_unmodified	^ self basicNew		value: 65536;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_renames	^ self basicNew		value: 1;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_renames_from_rewrites	^ self basicNew		value: 2;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_rewrites	^ self basicNew		value: 16;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DIFF_FLAG_BINARY 0 "file(s) treated as binary data"	GIT_DIFF_FLAG_NOT_BINARY 1 "file(s) treated as text data"	GIT_DIFF_FLAG_VALID_ID  2 "`id` value is known correct"	)! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_flag_binary	^ self basicNew		value: 0;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_flag_not_binary	^ self basicNew		value: 1;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_flag_valid_id	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DIFF_FORMAT_PATCH        1 "full git diff"	GIT_DIFF_FORMAT_PATCH_HEADER 2 "just the file headers of patch"	GIT_DIFF_FORMAT_RAW          3 "like git diff --raw"	GIT_DIFF_FORMAT_NAME_ONLY    4 "like git diff --name-only"	GIT_DIFF_FORMAT_NAME_STATUS  5 "like git diff --name-status"	)! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_name_only	^ self basicNew		value: 4;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_name_status	^ self basicNew		value: 5;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_patch	^ self basicNew		value: 1;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_patch_header	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_raw	^ self basicNew		value: 3;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^{	 "These values will be sent to `git_diff_line_cb` along with the line"	#GIT_DIFF_LINE_CONTEXT.   '$ '.	#GIT_DIFF_LINE_ADDITION.  '$+'.	#GIT_DIFF_LINE_DELETION.  '$-'.	#GIT_DIFF_LINE_CONTEXT_EOFNL. '$='."Both files have no LF at end"	#GIT_DIFF_LINE_ADD_EOFNL. '$>'.    "Old has no LF at end new does"	#GIT_DIFF_LINE_DEL_EOFNL. '$<'.    "Old has LF at end new does not"	"The following values will only be sent to a `git_diff_line_cb` when	 * the content of a diff is being formatted through `git_diff_print`.	"	#GIT_DIFF_LINE_FILE_HDR.  '$F'.	#GIT_DIFF_LINE_HUNK_HDR.  '$H'.	#GIT_DIFF_LINE_BINARY.    '$B' "For 'Binary files x and y differ'"	}! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_add_eofnl	^ self basicNew		value: $>;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_addition	^ self basicNew		value: $+;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_binary	^ self basicNew		value: $B;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_context	^ self basicNew		value: $ ;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_context_eofnl	^ self basicNew		value: $=;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_del_eofnl	^ self basicNew		value: $<;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_deletion	^ self basicNew		value: $-;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_file_hdr	^ self basicNew		value: $F;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_hunk_hdr	^ self basicNew		value: $H;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	"Normal diff, the default"	GIT_DIFF_NORMAL 0	"	 * Options controlling which files will be in the diff	"	"Reverse the sides of the diff"	GIT_DIFF_REVERSE 1	"Include ignored files in the diff"	GIT_DIFF_INCLUDE_IGNORED 2	"Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory	 *  will be marked with only a single entry in the diff; this flag	 *  adds all files under the directory as IGNORED entries, too.	"	GIT_DIFF_RECURSE_IGNORED_DIRS 4	"Include untracked files in the diff"	GIT_DIFF_INCLUDE_UNTRACKED 8	"Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked	 *  directory will be marked with only a single entry in the diff	 *  (a la what core Git does in `git status`); this flag adds *all*	 *  files under untracked directories as UNTRACKED entries, too.	"	GIT_DIFF_RECURSE_UNTRACKED_DIRS 16	"Include unmodified files in the diff"	GIT_DIFF_INCLUDE_UNMODIFIED 32	"Normally, a type change between files will be converted into a	 *  DELETED record for the old and an ADDED record for the new; this	 *  options enabled the generation of TYPECHANGE delta records.	"	GIT_DIFF_INCLUDE_TYPECHANGE 64	"Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still	 *  generally show as a DELETED blob.  This flag tries to correctly	 *  label blob->tree transitions as TYPECHANGE records with new_file's	 *  mode set to tree.  Note: the tree SHA will not be available.	"	GIT_DIFF_INCLUDE_TYPECHANGE_TREES 128	"Ignore file mode changes"	GIT_DIFF_IGNORE_FILEMODE 256	"Treat all submodules as unmodified"	GIT_DIFF_IGNORE_SUBMODULES 512	"Use case insensitive filename comparisons"	GIT_DIFF_IGNORE_CASE 1024	"If the pathspec is set in the diff options, this flags means to	 *  apply it as an exact match instead of as an fnmatch pattern.	"	GIT_DIFF_DISABLE_PATHSPEC_MATCH 4096	"Disable updating of the `binary` flag in delta records.  This is	 *  useful when iterating over a diff if you don't need hunk and data	 *  callbacks and want to avoid having to load file completely.	"	GIT_DIFF_SKIP_BINARY_CHECK 8192	"When diff finds an untracked directory, to match the behavior of	 *  core Git, it scans the contents for IGNORED and UNTRACKED files.	 *  If *all* contents are IGNORED, then the directory is IGNORED; if	 *  any contents are not IGNORED, then the directory is UNTRACKED.	 *  This is extra work that may not matter in many cases.  This flag	 *  turns off that scan and immediately labels an untracked directory	 *  as UNTRACKED (changing the behavior to not match core Git).	"	GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS 16384	"When diff finds a file in the working directory with stat	 * information different from the index, but the OID ends up being the	 * same, write the correct stat information into the index.  Note:	 * without this flag, diff will always leave the index untouched.	"	GIT_DIFF_UPDATE_INDEX 32768	"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE 65536		"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED 131072	"	 * Options controlling how output will be generated	"	"Treat all files as text, disabling binary attributes & detection"	GIT_DIFF_FORCE_TEXT 1048576	"Treat all files as binary, disabling text diffs"	GIT_DIFF_FORCE_BINARY 2097152	"Ignore all whitespace"	GIT_DIFF_IGNORE_WHITESPACE 4194304	"Ignore changes in amount of whitespace"	GIT_DIFF_IGNORE_WHITESPACE_CHANGE 8388608	"Ignore whitespace at end of line"	GIT_DIFF_IGNORE_WHITESPACE_EOL 16777216	"When generating patch text, include the content of untracked	 *  files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but	 *  it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that	 *  flag if you want the content of every single UNTRACKED file.	"	GIT_DIFF_SHOW_UNTRACKED_CONTENT 33554432	"When generating output, include the names of unmodified files if	 *  they are included in the git_diff.  Normally these are skipped in	 *  the formats that list files (e.g. name-only, name-status, raw).	 *  Even with this, these will not be included in patch format.	"	GIT_DIFF_SHOW_UNMODIFIED 67108864	"Use the 'patience diff' algorithm"	GIT_DIFF_PATIENCE 268435456	"Take extra time to find minimal diff"	GIT_DIFF_MINIMAL 536870912	"Include the necessary deflate / delta information so that `git-apply`	 *  can apply given diff information to binary files.	"	GIT_DIFF_SHOW_BINARY 1073741824	)! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_disable_pathspec_match	^ self basicNew		value: 4096;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_enable_fast_untracked_dirs	^ self basicNew		value: 16384;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_force_binary	^ self basicNew		value: 2097152;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_force_text	^ self basicNew		value: 1048576;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_case	^ self basicNew		value: 1024;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_filemode	^ self basicNew		value: 256;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_submodules	^ self basicNew		value: 512;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_whitespace	^ self basicNew		value: 4194304;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_whitespace_change	^ self basicNew		value: 8388608;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_whitespace_eol	^ self basicNew		value: 16777216;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_ignored	^ self basicNew		value: 2;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_typechange	^ self basicNew		value: 64;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_typechange_trees	^ self basicNew		value: 128;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_unmodified	^ self basicNew		value: 32;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_unreadable	^ self basicNew		value: 65536;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_unreadable_as_untracked	^ self basicNew		value: 131072;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_untracked	^ self basicNew		value: 8;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_minimal	^ self basicNew		value: 536870912;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_normal	^ self basicNew		value: 0;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_patience	^ self basicNew		value: 268435456;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_recurse_ignored_dirs	^ self basicNew		value: 4;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_recurse_untracked_dirs	^ self basicNew		value: 16;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_reverse	^ self basicNew		value: 1;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_show_binary	^ self basicNew		value: 1073741824;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_show_unmodified	^ self basicNew		value: 67108864;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_show_untracked_content	^ self basicNew		value: 33554432;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_skip_binary_check	^ self basicNew		value: 8192;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_update_index	^ self basicNew		value: 32768;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	"No stats"	GIT_DIFF_STATS_NONE 0	"Full statistics equivalent of `--stat`"	GIT_DIFF_STATS_FULL 1	"Short statistics equivalent of `--shortstat`"	GIT_DIFF_STATS_SHORT 2	"Number statistics equivalent of `--numstat`"	GIT_DIFF_STATS_NUMBER 4	"Extended header information such as creations renames and mode changes equivalent of `--summary`"	GIT_DIFF_STATS_INCLUDE_SUMMARY 8	)! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_full	^ self basicNew		value: 1;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_include_summary	^ self basicNew		value: 8;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_none	^ self basicNew		value: 0;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_number	^ self basicNew		value: 4;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_short	^ self basicNew		value: 2;		yourself! !!LGitDirectionEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DIRECTION_FETCH 0	GIT_DIRECTION_PUSH 1)! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_direction_fetch	^ self basicNew		value: 0;		yourself! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_direction_push	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		GITERR_NONE 0		GITERR_NOMEMORY		1		GITERR_OS				2		GITERR_INVALID		3			GITERR_REFERENCE		4		GITERR_ZLIB			5		GITERR_REPOSITORY	6		GITERR_CONFIG	7		GITERR_REGEX	8		GITERR_ODB	9		GITERR_INDEX			10		GITERR_OBJECT			11		GITERR_NET				12		GITERR_TAG			13		GITERR_TREE			14		GITERR_INDEXER		15		GITERR_SSL				16		GITERR_SUBMODULE	17		GITERR_THREAD		18		GITERR_STASH			19		GITERR_CHECKOUT		20		GITERR_FETCHHEAD	21		GITERR_MERGE			22		GITERR_SSH	23		GITERR_FILTER 24		GITERR_REVERT	25		GITERR_CALLBACK	26		GITERR_CHERRYPICK	27		GITERR_DESCRIBE	28		GITERR_REBASE	29		GITERR_FILESYSTEM	30)! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_callback	^ self basicNew		value: 26;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_checkout	^ self basicNew		value: 20;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_cherrypick	^ self basicNew		value: 27;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_config	^ self basicNew		value: 7;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_describe	^ self basicNew		value: 28;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_fetchhead	^ self basicNew		value: 21;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_filesystem	^ self basicNew		value: 30;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_filter	^ self basicNew		value: 24;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_index	^ self basicNew		value: 10;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_indexer	^ self basicNew		value: 15;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_invalid	^ self basicNew		value: 3;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_merge	^ self basicNew		value: 22;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_net	^ self basicNew		value: 12;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_nomemory	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_none	^ self basicNew		value: 0;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_object	^ self basicNew		value: 11;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_odb	^ self basicNew		value: 9;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_os	^ self basicNew		value: 2;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_rebase	^ self basicNew		value: 29;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_reference	^ self basicNew		value: 4;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_regex	^ self basicNew		value: 8;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_repository	^ self basicNew		value: 6;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_revert	^ self basicNew		value: 25;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_ssh	^ self basicNew		value: 23;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_ssl	^ self basicNew		value: 16;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_stash	^ self basicNew		value: 19;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_submodule	^ self basicNew		value: 17;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_tag	^ self basicNew		value: 13;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_thread	^ self basicNew		value: 18;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_tree	^ self basicNew		value: 14;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_zlib	^ self basicNew		value: 5;		yourself! !!LGitExternalEnumerationInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultRepresentationType	^ FFIInt32 new! !!LGitObjectTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_OBJ_ANY -2	GIT_OBJ_BAD -1	GIT_OBJ__EXT1 0	GIT_OBJ_COMMIT 1	GIT_OBJ_TREE 2	GIT_OBJ_BLOB 3	GIT_OBJ_TAG 4	GIT_OBJ__EXT2 5	GIT_OBJ_OFS_DELTA 6	GIT_OBJ_REF_DELTA 7)! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj__ext1	^ self basicNew		value: 0;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj__ext2	^ self basicNew		value: 5;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_any	^ self basicNew		value: -2;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_bad	^ self basicNew		value: -1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_blob	^ self basicNew		value: 3;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_commit	^ self basicNew		value: 1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_ofs_delta	^ self basicNew		value: 6;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_ref_delta	^ self basicNew		value: 7;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_tag	^ self basicNew		value: 4;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_tree	^ self basicNew		value: 2;		yourself! !!LGitReturnCodeEnum class methodsFor: 'enum description' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(			GIT_OK           0		"< No error "			GIT_ERROR       -1		"< Generic error "			GIT_ENOTFOUND   -3		"< Requested object could not be found "			GIT_EEXISTS     -4		"< Object exists preventing operation "			GIT_EAMBIGUOUS  -5		"< More than one object matches "			GIT_EBUFS       -6		"< Output buffer too short to hold data "			"GIT_EUSER is a special error that is never generated by libgit2			 * code.  You can return it from a callback (e.g to stop an iteration)			 * to know that it was generated by the callback and not by libgit2.			 "			GIT_EUSER       -7			GIT_EBAREREPO         -8	"< Operation not allowed on bare repository "			GIT_EUNBORNBRANCH     -9	"< HEAD refers to branch with no commits "			GIT_EUNMERGED        -10	"< Merge in progress prevented operation "			GIT_ENONFASTFORWARD  -11	"< Reference was not fast-forwardable "			GIT_EINVALIDSPEC     -12	"< Name/ref spec was not in a valid format "			GIT_ECONFLICT        -13	"< Checkout conflicts prevented operation "			GIT_ELOCKED          -14	"< Lock file prevented operation "			GIT_EMODIFIED        -15	"< Reference value does not match expected "			GIT_EAUTH            -16      "< Authentication error "			GIT_ECERTIFICATE     -17      "< Server certificate is invalid "			GIT_EAPPLIED         -18	"< Patch/merge has already been applied "			GIT_EPEEL            -19      "< The requested peel operation is not possible "			GIT_EEOF             -20      "< Unexpected EOF "			GIT_EINVALID         -21      "< Invalid operation or input "			GIT_EUNCOMMITTED     -22	"< Uncommitted changes in index prevented operation "			GIT_PASSTHROUGH      -30	"< Internal only "			GIT_ITEROVER         -31	"< Signals end of iteration with iterator "		)! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eambiguous	^ self basicNew		value: -5;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eapplied	^ self basicNew		value: -18;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eauth	^ self basicNew		value: -16;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ebarerepo	^ self basicNew		value: -8;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ebufs	^ self basicNew		value: -6;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ecertificate	^ self basicNew		value: -17;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_econflict	^ self basicNew		value: -13;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eeof	^ self basicNew		value: -20;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eexists	^ self basicNew		value: -4;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_einvalid	^ self basicNew		value: -21;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_einvalidspec	^ self basicNew		value: -12;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_elocked	^ self basicNew		value: -14;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_emodified	^ self basicNew		value: -15;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_enonfastforward	^ self basicNew		value: -11;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_enotfound	^ self basicNew		value: -3;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_epeel	^ self basicNew		value: -19;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_error	^ self basicNew		value: -1;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eunbornbranch	^ self basicNew		value: -9;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_euncommitted	^ self basicNew		value: -22;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eunmerged	^ self basicNew		value: -10;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_euser	^ self basicNew		value: -7;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_iterover	^ self basicNew		value: -31;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ok	^ self basicNew		value: 0;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_passthrough	^ self basicNew		value: -30;		yourself! !!LGitReturnCodeEnum class methodsFor: 'handlers' stamp: ' 7/24/2017 12:50:03'!handlers	^ handlers ifNil: [ handlers := self setUpHandlers ]! !!LGitReturnCodeEnum class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!setUpHandlers	^ (self declaration associations collect: [ :nameToValue |		nameToValue key -> (LGitCallReturnHandler for: (self perform: nameToValue key)) ]) asDictionary! !!LGitReturnCodeEnum methodsFor: 'handling' stamp: ' 7/24/2017 12:50:03'!handleLGitReturnCode	| handler |	self isOk		ifTrue: [ ^ self ].	handler := self handlers		at: self symbol		ifAbsent: [ LGitNoReturnCodeHandlerDefined signalWith: self ].	^ handler isError		ifTrue: [ handler signalWith: LGitError last ]		ifFalse: [ self ]! !!LGitReturnCodeEnum methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!handlers	^ self class handlers! !!LGitReturnCodeEnum methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!isOk	^ value = 0! !!LGitExternalEnumerationUInt32 class methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asExternalTypeOn: generator	^ FFIExternalEnumerationType 		objectClass: self 		representationType: self representationType! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!buildDeclaration	| dictionary |	self removeOldAccessors.	dictionary := self literalDeclaration.	self compileAccessorsFrom: dictionary.		^ declaration := dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!compileAccessorsFrom: aDictionary	aDictionary keysAndValuesDo: [ :symbol :value |		self class			compile: (String streamContents: [ :stream |				stream					nextPutAll: symbol asString; cr; tab;					nextPutAll: '^ self basicNew'; cr; tab; tab;					nextPutAll: 'value: ';					nextPutAll: value asString;					nextPutAll: ';'; cr; tab; tab;					nextPutAll: 'yourself' ])			classified: 'accessing-values' ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!declaration	^ declaration ifNil: [ declaration := self literalDeclaration ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultRepresentationType	^ FFIUInt32 new! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#()! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromInteger: anInteger	^self basicNew		value: anInteger;		yourself! !!LGitExternalEnumerationUInt32 class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!includes: aSymbol	^ self declaration includesKey: aSymbol! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!initialize	declaration := nil.	representationType := nil.! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!literalDeclaration	| dictionary |	dictionary := self enumDecl in: [ :decl |		decl isDictionary			ifTrue: [ decl ]			ifFalse: [ Dictionary newFromPairs: decl ] ].			self makeSelectorsLegalIn: dictionary.	^ dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!makeSelectorsLegalIn: aDictionary	aDictionary associationsDo: [ :nameToValue |		| selector |		selector := nameToValue key asLowercase asSymbol.		nameToValue key: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!new	^ self shouldNotImplement ! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!removeOldAccessors	declaration ifNil: [ ^ self ].		declaration keys do: [ :selector |		self class removeSelector: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!representationType	^ representationType ifNil: [ representationType := self defaultRepresentationType ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anEnumInst	^ self class == anEnumInst class and: [		self value = anEnumInst value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ self className hash bitXor: self value hash! !!LGitExternalEnumerationUInt32 methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isPartOfBitFlag: anInteger	"A bit flag may be composed of several values, where every bit	represents the state of one flag. Therefore, a 2 bit value can	represent 2 different flags, for instance. The #bitAnd: operation	will mask all other flags.		For some reason the libgit2 folks thought it would make sense to	use flags of value 0 in bit flags. That forces one to check for zero	(on the entire word)	explicitly. WTF."	^ self value isZero		ifTrue: [ anInteger isZero ]		ifFalse: [ (self value bitAnd: anInteger) = self value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printOn: stream	super printOn: stream.	value isInteger 		" temp: due to a uffi bug (?) sometimes value == self"		ifFalse: [ ^ self ].	stream nextPut: $(;		nextPutAll: self symbol printString;		nextPutAll: ' [';		nextPutAll: self value asString;		nextPut: $];		nextPut: $)! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!symbol	<todo: 'now we can handle enums which define the same value multiple times, but in case of this handler, we don''t know which name we need to associate with the return value. This is basically random...'>	^ self class declaration		keyAtValue: self value		ifAbsent: [ nil ]! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value	^ value! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value: anInteger	value := anInteger ! !!LGitFetchPruneTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		"		 * Use the setting from the configuration		 "		GIT_FETCH_PRUNE_UNSPECIFIED 0		"		 * Force pruning on		 "		GIT_FETCH_PRUNE 1		"		 * Force pruning off		 "		GIT_FETCH_NO_PRUNE 2	)! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_no_prune	^ self basicNew		value: 2;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_prune	^ self basicNew		value: 1;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_prune_unspecified	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_FILEMODE_NEW 0	GIT_FILEMODE_TREE 16384	GIT_FILEMODE_BLOB 33188	GIT_FILEMODE_BLOB_EXECUTABLE 33261	GIT_FILEMODE_LINK 40960	GIT_FILEMODE_COMMIT 57344)! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_blob	^ self basicNew		value: 33188;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_blob_executable	^ self basicNew		value: 33261;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_commit	^ self basicNew		value: 57344;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_link	^ self basicNew		value: 40960;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_new	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_tree	^ self basicNew		value: 16384;		yourself! !!LGitOpenFlagEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_REPOSITORY_OPEN_NO_SEARCH 1	GIT_REPOSITORY_OPEN_CROSS_FS 2	GIT_REPOSITORY_OPEN_BARE 4)! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_repository_open_bare	^ self basicNew		value: 4;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_repository_open_cross_fs	^ self basicNew		value: 2;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_repository_open_no_search	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_BLAME_OPTIONS_VERSION_1 1	GIT_CHECKOUT_OPTIONS_VERSION_1 1	GIT_CLONE_OPTIONS_VERSION_1 1	GIT_DIFF_OPTIONS_VERSION_1 1	GIT_DIFF_FIND_OPTIONS_VERSION_1 1	GIT_FETCH_OPTIONS_VERSION_1 1	GIT_PUSH_OPTIONS_VERSION_1 1	)! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_merge_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_PATHSPEC_DEFAULT 0	"forces match to ignore case; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_IGNORE_CASE 1	"forces case sensitive match; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_USE_CASE 2	"disables glob patterns and just uses simple string comparison for matching"	GIT_PATHSPEC_NO_GLOB 4	"means the match functions return error code GIT_ENOTFOUND if no matches are found; otherwise no matches is still success (return 0) but git_pathspec_match_list_entrycount will indicate 0 matches."	GIT_PATHSPEC_NO_MATCH_ERROR 8	"means that the git_pathspec_match_list should track which patterns matched which files so that at the end of the match we can identify patterns that did not match any files."	GIT_PATHSPEC_FIND_FAILURES 16	"means that the git_pathspec_match_list does not need to keep the actual matching filenames. Use this to just test if there were any matches at all or in combination with GIT_PATHSPEC_FIND_FAILURES to validate a pathspec."	GIT_PATHSPEC_FAILURES_ONLY 32)! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_default	^ self basicNew		value: 0;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_failures_only	^ self basicNew		value: 32;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_find_failures	^ self basicNew		value: 16;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_ignore_case	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_no_glob	^ self basicNew		value: 4;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_no_match_error	^ self basicNew		value: 8;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_use_case	^ self basicNew		value: 2;		yourself! !!LGitProxyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(	"/**	 * Do not attempt to connect through a proxy	 *	 * If built against libcurl, it itself may attempt to connect	 * to a proxy if the environment variables specify it.	 */"	GIT_PROXY_NONE 0	"/**	 * Try to auto-detect the proxy from the git configuration.	 */"	GIT_PROXY_AUTO 1	"/**	 * Connect via the URL given in the options	 */"	GIT_PROXY_SPECIFIED 2	)! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_proxy_auto	^ self basicNew		value: 1;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_proxy_none	^ self basicNew		value: 0;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_proxy_specified	^ self basicNew		value: 2;		yourself! !!LGitPushOptionsVersionEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(			LGIT_PUSH_OPTIONS_VERSION_1 1		)! !!LGitPushOptionsVersionEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!lgit_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_REF_INVALID 0	GIT_REF_OID 1	GIT_REF_SYMBOLIC 2	GIT_REF_LISTALL 3)! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_invalid	^ self basicNew		value: 0;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_listall	^ self basicNew		value: 3;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_oid	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_symbolic	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		"		 * Use the setting from the configuration.		 "		GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED 0		"		 * Ask the server for tags pointing to objects we're already		 * downloading.		 "		GIT_REMOTE_DOWNLOAD_TAGS_AUTO 1		"		 * Don't ask for any tags beyond the refspecs.		 "		GIT_REMOTE_DOWNLOAD_TAGS_NONE 2		"		 * Ask for the all the tags.		 "		GIT_REMOTE_DOWNLOAD_TAGS_ALL 3	)! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_all	^ self basicNew		value: 3;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_auto	^ self basicNew		value: 1;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_none	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_unspecified	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_REMOTE_COMPLETION_DOWNLOAD 0	GIT_REMOTE_COMPLETION_INDEXING 1	GIT_REMOTE_COMPLETION_ERROR 2)! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_completion_download	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_completion_error	^ self basicNew		value: 2;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_completion_indexing	^ self basicNew		value: 1;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_SORT_NONE 0	GIT_SORT_TOPOLOGICAL 1	GIT_SORT_TIME 2	GIT_SORT_REVERSE 4	)! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_none	^ self basicNew		value: 0;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_reverse	^ self basicNew		value: 4;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_time	^ self basicNew		value: 2;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_topological	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(		GIT_STATUS_CURRENT  0		GIT_STATUS_INDEX_NEW         "1 bitShift: 0" 1		GIT_STATUS_INDEX_MODIFIED    "1 bitShift: 1" 2		GIT_STATUS_INDEX_DELETED     "1 bitShift: 2" 4		GIT_STATUS_INDEX_RENAMED     "1 bitShift: 3" 8		GIT_STATUS_INDEX_TYPECHANGE  "1 bitShift: 4" 16		GIT_STATUS_WT_NEW            "1 bitShift: 7" 128		GIT_STATUS_WT_MODIFIED       "1 bitShift: 8" 256		GIT_STATUS_WT_DELETED        "1 bitShift: 9" 512		GIT_STATUS_WT_TYPECHANGE     "1 bitShift: 10" 1024		GIT_STATUS_WT_RENAMED        "1 bitShift: 11" 2048		GIT_STATUS_WT_UNREADABLE     "1 bitShift: 12" 4096		GIT_STATUS_IGNORED           "1 bitShift: 14" 16384		GIT_STATUS_CONFLICTED        "1 bitShift: 15" 32768)! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_conflicted	^ self basicNew		value: 32768;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_current	^ self basicNew		value: 0;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_ignored	^ self basicNew		value: 16384;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_deleted	^ self basicNew		value: 4;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_modified	^ self basicNew		value: 2;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_new	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_renamed	^ self basicNew		value: 8;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_typechange	^ self basicNew		value: 16;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_deleted	^ self basicNew		value: 512;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_modified	^ self basicNew		value: 256;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_new	^ self basicNew		value: 128;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_renamed	^ self basicNew		value: 2048;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_typechange	^ self basicNew		value: 1024;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_unreadable	^ self basicNew		value: 4096;		yourself! !!LGitStructVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(		GIT_REMOTE_CALLBACKS_VERSION_1 1	)! !!LGitStructVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_callbacks_version_1	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_SUBMODULE_IGNORE_RESET     -1 "reset to on-disk value"	GIT_SUBMODULE_IGNORE_NONE      1  "any change or untracked == dirty"	GIT_SUBMODULE_IGNORE_UNTRACKED 2  "dirty if tracked files change"	GIT_SUBMODULE_IGNORE_DIRTY     3  "only dirty if HEAD moved"	GIT_SUBMODULE_IGNORE_ALL       4  "never dirty"	GIT_SUBMODULE_IGNORE_DEFAULT   0)! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_all	^ self basicNew		value: 4;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_default	^ self basicNew		value: 0;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_dirty	^ self basicNew		value: 3;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_none	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_reset	^ self basicNew		value: -1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_untracked	^ self basicNew		value: 2;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_TREEWALK_PRE 0	GIT_TREEWALK_POST 1)! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_treewalk_post	^ self basicNew		value: 1;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_treewalk_pre	^ self basicNew		value: 0;		yourself! !!LGitFunctionReturn class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!methodSelector: aSymbol value: anObject	^ self new		methodSelector: aSymbol;		value: anObject;		yourself! !!LGitFunctionReturn methodsFor: 'handling' stamp: ' 7/24/2017 12:50:03'!handleLGitReturnCode	^ self value handleLGitReturnCode! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!methodSelector	^ methodSelector! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!methodSelector: aSymbol	methodSelector := aSymbol! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value	^ value! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value: anObject	value := anObject! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkInitialized	"Make sure that LigGit2 is properly initialized."	self ffiLibrary isInitialized 		ifFalse: [ self ffiLibrary uniqueInstance initializeLibGit2 ]! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!runSequence: aBlock	LGitActionSequence value ifNotNil: aBlock.		LGitActionSequence		value: thisContext sender		during: [			self checkInitialized.			aBlock value ]! !!LGitRefSpec class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromString: aString	^ self new		initializeFromString: aString;		yourself! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!beForced	forced := true! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!destination	^ destination ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!destination: aString	destination := aString! !!LGitRefSpec methodsFor: 'intialization' stamp: ' 7/24/2017 12:50:03'!initializeFromString: aString	<todo: 'use exceptions instead of assertions'>	| stream |	self assert: ('((\+[\w/]+)|([\w/]*))\:[\w/]+' asRegex matches: aString).		stream := aString readStream.	[		(stream peek = $+) ifTrue: [ 			self beForced.			stream next ].		self source: (stream upTo: $:).		self destination: stream upToEnd ] ensure: [ stream close ]! !!LGitRefSpec methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isForced	^ forced ifNil: [ false ]! !!LGitRefSpec methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printOn: aStream	self isForced ifTrue: [ aStream nextPut: $+ ].	aStream		nextPutAll: self source;		nextPut: $:;		nextPutAll: self destination! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!source	^ source ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!source: aString	source := aString! !!Object methodsFor: '*LibGit-Core-FFI-Handling' stamp: ' 7/24/2017 12:50:03'!handleLGitReturnCode	^ self! !!LGitBlameHunk class methodsFor: 'alignment' stamp: ' 7/24/2017 12:50:03'!byteAlignment	^ 1! !!LGitBlameHunk class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	<hack: 'orig_start_line_number is a uint16_t according to spec. The offset of orig_signature however is 56, not 54 (while the first fields are *not* aligned). To fix that, I changed the type of orig_start_line_number to uint32_t'>	^ #(		#FFIUInt16 lines_in_hunk "is the number of lines in this hunk"		LGitId final_commit_id "is the OID of the commit where this line was last changed."		#FFIUInt16 final_start_line_number "is the 1-based line number where this hunk begins, in the final version of the file"		LGitSignature * final_signature				LGitId orig_commit_id "is the OID of the commit where this hunk was found. This will usually be the same as final_commit_id, except when GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES has been specified."		String orig_path "is the path to the file where this hunk originated, as of the commit specified by orig_commit_id."		#FFIUInt32 orig_start_line_number "is the 1-based line number where this hunk begins in the file named by orig_path in the commit specified by orig_commit_id."		LGitSignature * orig_signature				Boolean boundary "is 1 iff the hunk has been tracked to a boundary commit (the root, or the commit specified in git_blame_options.oldest_commit)"	)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!boundary	^ self prim_boundary! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!finalCommitId	"prim version doesn't work"	"^ self prim_final_commit_id"		^ LGitId fromHandle: (handle copyFrom: 3 to: 22)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!finalSignature		^ self prim_final_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!finalStartLineNumber	^ self prim_final_start_line_number! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!numberOfLines	^ self prim_lines_in_hunk! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalCommitId	"prim version doesn't work"	"^ self prim_orig_commit_id"		^LGitId fromHandle: (handle copyFrom: 29 to: 48)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalPath	^ self prim_orig_path readString! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalSignature		^ self prim_orig_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalStartLineNumber	^ self prim_orig_start_line_number! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_boundary	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BOUNDARY! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_boundary: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BOUNDARY put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_FINAL_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FINAL_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_start_line_number	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_start_line_number: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_lines_in_hunk	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_lines_in_hunk: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ORIG_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ORIG_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_PATH) type: ExternalType char asPointerType! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_PATH put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_start_line_number	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_start_line_number: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER put: anObject! !!LGitBuf class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		char * ptr;		size_t asize;		size_t size;	)		"self rebuildFieldAccessors"! !!LGitBuf class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!signature_free: handle 	^ self		call: #(void git_buf_free(void *handle))		options: #(  )! !!LGitBuf methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!free	"Free the memory referred to by the git_buf.	Note that this does not free the git_buf itself, just the memory pointed to by buffer->ptr. This 	will not free the memory if it looks like it was not allocated internally, but it will clear the 	buffer back to the empty state."	self class signature_free: handle! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_asize	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_asize: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE put: anObject! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ptr	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PTR) type: ExternalType char asPointerType! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ptr: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PTR put: anObject getHandle.! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitCheckoutPerfData class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		size_t mkdir_calls;		size_t stat_calls;		size_t chmod_calls;	)! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_chmod_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_chmod_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mkdir_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mkdir_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitCredentials class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	LGitCredentialsTypeEnum credtype;	LGitCredentialsFreeCallout free;	)! !!LGitCredentials methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aStructure	self subclassResponsibility! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!passphrase	^ passphrase! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!passphrase: aString	passphrase := aString! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!username	^ username! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!username: aString	username := aString! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider onto: lgitCredentials	| credentials |	[		credentials := self new.		provider providePlaintextCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ :e | 		LGitError setError: 'Invalid username and/or password provided.'.						^ -1 ]! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!username: username passphrase: passphrase	^ self new		username: username;		passphrase: passphrase;		yourself! !!LGitCredentialsPlaintext methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self passphrase isEmptyOrNil not.	self withReturnHandlerDo: [ 		self 			cred_userpass_plaintext_new: aStructure			username: self username			password: self passphrase ]! !!LGitCredentialsPlaintext methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_userpass_plaintext_new: out username: usernameString password: password 	^self call: #(		LGitReturnCodeEnum git_cred_userpass_plaintext_new(			LGitCredentials * out, 			String username, 			String password)	) options: #(  )! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider onto: lgitCredentials	| credentials |	 	[		credentials := self new.		provider provideSshCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'Invalid ssh keys in provided files.'.				-1 ]! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider username: username onto: lgitCredentials	 ^ self createFrom: provider onto: lgitCredentials! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!username: username passphrase: passphrase publicKeyReference: publicKeyFileReference privateKeyReference: privateKeyFileReference	^ self new		username: username;		passphrase: passphrase;		publicKeyReference: publicKeyFileReference;		privateKeyReference: privateKeyFileReference;		yourself! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self publicKeyReference exists.	self assert: self privateKeyReference exists.	self withReturnHandlerDo: [ 		self 			cred_ssh_key_new: aStructure			username: self username			publickey: self publicKeyReference fullName			privatekey: self privateKeyReference fullName			passphrase: self passphrase ]! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_ssh_key_new: out username: usernameString publickey: publickey privatekey: privatekey passphrase: passphraseString	^self call: 		#(int git_cred_ssh_key_new(			LGitCredentials * out, 			String usernameString, 			String publickey, 			String privatekey, 			String passphraseString)) options: #(  )! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_username_new: out username: usernameString	^ self 		call: #(int git_cred_username_new (LGitCredentials * out, String usernameString)) 		options: #()			! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!privateKeyReference	^ privateKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!privateKeyReference: aFileReference	privateKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!publicKeyReference	^ publicKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!publicKeyReference: aFileReference	publicKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setGitUsernameIn: aStructure	self withReturnHandlerDo: [ 		self cred_username_new: aStructure username: 'git'	]! !!LGitCredentialsSSHAgent class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider username: username onto: lgitCredentials	| credentials |		[  		credentials := self new.		provider provideSshAgentCredentialsTo: credentials.			credentials createWith: username onto: lgitCredentials.		^ 0 ]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'No ssh-agent suitable credentials found.'.		^ -1 ]! !!LGitCredentialsSSHAgent methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aName onto: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: aName isEmptyOrNil not.	self withReturnHandlerDo: [ 		self cred_ssh_key_new: aStructure username: aName ]! !!LGitCredentialsSSHAgent methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_ssh_key_new: out username: aName	^ self call: #(int git_cred_ssh_key_from_agent(LGitCredentials *out, String aName))! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitDiffBinary class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(			uint contains_data;		LGitDiffBinaryFile old_file; "< The contents of the old file."		LGitDiffBinaryFile new_file; "< The contents of the new file."	)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_contains_data	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_contains_data: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA put: anObject! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinaryFile class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		" The type of binary data for this file. "		LGitDiffBinaryTypeEnum type;		" The binary data, deflated. is char* originally, but I do not want to get the \0"		void *data;		" The length of the binary data. "		size_t datalen;		" The length of the binary data after inflation. "		size_t inflatedlen;	)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DATA) type: ExternalType void asPointerType! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DATA put: anObject getHandle.! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_datalen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_datalen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_inflatedlen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_inflatedlen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type	"This method was automatically generated"	^LGitDiffBinaryTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitDiffDelta class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitDeltaTypeEnum status	uint32 flags	"for RENAMED and COPIED, value 0-100"	uint16 similarity	"number of files in this delta"	uint16 nfiles	LGitDiffFile old_file	LGitDiffFile new_file	)! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newFile	^ self prim_new_file! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!numberOfFiles	^ self prim_nfiles! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldFile	^ self prim_old_file! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_nfiles	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_NFILES! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_nfiles: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_NFILES put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_SIMILARITY! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_SIMILARITY put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_status	"This method was automatically generated"	^LGitDeltaTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_STATUS)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_status: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_STATUS put: anObject value! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!status	^ self prim_status! !!LGitDiffFile class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	LGitId id	String path	int64 size	uint32 flags	uint16 mode	uint16 id_abbrev	)! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!id	^ self prim_id! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!path	^ self prim_path readString! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ID length: LGitId byteSize)! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ID put: anObject getHandle length: LGitId byteSize! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mode	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MODE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mode: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MODE put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PATH) type: ExternalType char asPointerType! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PATH put: anObject getHandle.! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_SIZE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!size	^ self prim_size! !!LGitDiffHunk class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	int old_start "Starting line number in old_file"	int old_lines "Number of lines in old_file"	int new_start "Starting line number in new_file"	int new_lines "Number of lines in new_file"	size_t header_len "Number of bytes in header text"	Char128 header "Header text, NUL-byte terminated" 		)! !!LGitDiffHunk class methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initialize	Char128 := FFITypeArray ofType: #char size: 128! !!LGitDiffHunk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx	^ self		call: #(LGitReturnCodeEnum git_patch_get_hunk(LGitDiffHunk * self, LGitWriteBackValueSizeT lines_in_hunk, LGitPatch patch, size_t hunk_idx))		options: #(  )! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newNumberOfLines	^ self prim_new_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newStart	^ self prim_new_start! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldNumberOfLines	^ self prim_old_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldStart	^ self prim_old_start! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header	"This method was automatically generated"	^(FFITypeArray ofType: #FFICharacterType size: 128) fromHandle: (handle copyFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127)! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header: anObject	"This method was automatically generated"	handle replaceFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127 with: anObject getHandle startingAt: 1! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_START put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_START put: anObject! !!LGitDiffLine class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	LGitDiffLineTypeEnum	  origin       "A git_diff_line_t value"	int    old_lineno   "Line number in old file or -1 for added line"	int    new_lineno   "Line number in new file or -1 for deleted line"	int    num_lines    "Number of newline characters in content"	size_t content_len  "Number of bytes of data"	int64 content_offset "Offset in the original file to the content"	String content "Pointer to diff text, not NUL-byte terminated"	) ! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!content	^ (self prim_content getHandle copyFrom: 1 to: self prim_content_len) asString! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newLineNumber	^ self prim_new_lineno! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldLineNumber	^ self prim_old_lineno! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CONTENT) type: ExternalType char asPointerType! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CONTENT put: anObject getHandle.! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_offset	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_offset: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_num_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NUM_LINES! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_num_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NUM_LINES put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_origin	"This method was automatically generated"	^LGitDiffLineTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_ORIGIN)! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_origin: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIGIN put: anObject value! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!size	^ self prim_content_len! !!LGitDiffPerfData class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	uint version	size_t stat_calls "Number of stat() calls performed"	size_t oid_calculations "Number of ID calculations"	)! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid_calculations	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid_calculations: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_VERSION! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject! !!LGitDiffSimilarityMetric class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc"int (*file_signature)(		void **out, const git_diff_file *file,		const char *fullpath, void *payload);	int (*buffer_signature)(		void **out, const git_diff_file *file,		const char *buf, size_t buflen, void *payload);	void (*free_signature)(void *sig, void *payload);	int (*similarity)(int *score, void *siga, void *sigb, void *payload);	void *payload;"	^#(	LGitFileSignatureCallback file_signature;	LGitBufferSignatureCallback buffer_signature;	LGitFreeSignatureCallback free_signature;	LGitSimilarityCallback similarity;	void *payload;	)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_buffer_signature	"This method was automatically generated"	^LGitBufferSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_buffer_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_signature	"This method was automatically generated"	^LGitFileSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FILE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FILE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free_signature	"This method was automatically generated"	^LGitFreeSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FREE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FREE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity	"This method was automatically generated"	^LGitSimilarityCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIMILARITY) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIMILARITY		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitError class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	String message;	LGitErrorTypeEnum klass;	)! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!giterr_clear	^ self call: #(void giterr_clear()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!giterr_last	^ self call: #(void *giterr_last()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!giterr_set_str: string	"GIT_EUSER = -7"	^ self call: #(void giterr_set_str(-7, String string))! !!LGitError class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!last	| externalData |	externalData := self giterr_last.	^ self fromHandle: externalData getHandle! !!LGitError class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!lastMessage	^ self last message! !!LGitError class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setError: aString	self giterr_set_str: aString! !!LGitError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message	^ self isNull		ifFalse: [ self prim_message readString ]		ifTrue: [ 'no error message set by libgit2' ]! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_klass	"This method was automatically generated"	^LGitErrorTypeEnum fromInteger: (handle signedLongAt: OFFSET_PRIM_KLASS)! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_klass: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_KLASS put: anObject value! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_message	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_MESSAGE) type: ExternalType char asPointerType! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_message: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_MESSAGE put: anObject getHandle.! !!LGitError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type	^ self isNull		ifFalse: [ self prim_klass ]		ifTrue: [ nil ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!createAccessorsFor: fieldName 	"Define read/write accessors for the given field"	| code |	code := fieldName,'	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ].		code := fieldName,': anObject	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString , ' put: anObject'.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!fieldNamesAndProtocols	^ Dictionary new! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!fieldSpec	^ LGitExternalStructureFieldParser new  		parseFields: self fieldsDesc structure: self.! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!free: aHandle	aHandle free! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #free:! !!LGitExternalStructure class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromExternalAddress: anAddress	anAddress isNull		ifTrue: [ ^ nil ].	^ self fromHandle: anAddress getHandle! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!generatedFieldProtocolName	^ 'libgit-fields'! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!protocolForField: aString	^ self fieldNamesAndProtocols		at: aString		ifAbsent: [ 'libgit-fields' ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!removeAccessor: aSelector	self package removeMethod: (self		compiledMethodAt: aSelector		ifAbsent: [ ^ self ]).			^ super removeAccessor: aSelector! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!autoRelease	"Some LGit structures need specialised free functions. Use the same autoRelease functionality	as FFIExternalReference to achieve this.	Note, subclasses should implement #resourceData	and #finalizeResourceData: on class side"	FFIExternalResourceManager addResource: self! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalStructure methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isExternal	"answer true if data referenced by receiver located in external heap, or just in object memory "	^ handle isExternalAddress! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!resourceData	^ self getHandle! !!LGitId class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	uint8 data1;	uint8 data2;	uint8 data3;	uint8 data4;	uint8 data5;	uint8 data6;	uint8 data7;	uint8 data8;	uint8 data9;	uint8 data10;	uint8 data11;	uint8 data12;	uint8 data13;	uint8 data14;	uint8 data15;	uint8 data16;	uint8 data17;	uint8 data18;	uint8 data19;	uint8 data20;	)! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromByteArray: aByteArray	^ self new		prim_data1: (aByteArray at: 1);		prim_data2: (aByteArray at: 2);		prim_data3: (aByteArray at: 3);		prim_data4: (aByteArray at: 4);		prim_data5: (aByteArray at: 5);		prim_data6: (aByteArray at: 6);		prim_data7: (aByteArray at: 7);		prim_data8: (aByteArray at: 8);		prim_data9: (aByteArray at: 9);		prim_data10: (aByteArray at: 10);		prim_data11: (aByteArray at: 11);		prim_data12: (aByteArray at: 12);		prim_data13: (aByteArray at: 13);		prim_data14: (aByteArray at: 14);		prim_data15: (aByteArray at: 15);		prim_data16: (aByteArray at: 16);		prim_data17: (aByteArray at: 17);		prim_data18: (aByteArray at: 18);		prim_data19: (aByteArray at: 19);		prim_data20: (aByteArray at: 20);		yourself! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromHexString: aString	^ self fromByteArray: (ByteArray readHexFrom: aString)! !!LGitId methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject		or: [ self class = anObject class			and: [ self compare: anObject ] ]! !!LGitId methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asByteArray	^ (ByteArray new: 20)		at: 1 put: (self prim_data1);		at: 2 put: (self prim_data2);		at: 3 put: (self prim_data3);		at: 4 put: (self prim_data4);		at: 5 put: (self prim_data5);		at: 6 put: (self prim_data6);		at: 7 put: (self prim_data7);		at: 8 put: (self prim_data8);		at: 9 put: (self prim_data9);		at: 10 put: (self prim_data10);		at: 11 put: (self prim_data11);		at: 12 put: (self prim_data12);		at: 13 put: (self prim_data13);		at: 14 put: (self prim_data14);		at: 15 put: (self prim_data15);		at: 16 put: (self prim_data16);		at: 17 put: (self prim_data17);		at: 18 put: (self prim_data18);		at: 19 put: (self prim_data19);		at: 20 put: (self prim_data20);		yourself	! !!LGitId methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asInteger	^ self asByteArray asInteger! !!LGitId methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!asRelativePathString	| string |	string := String new: 41.	string pin.	self		oid_pathfmt: string		id: self.	string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!compare: anId	^ (self 		oid_cmp: self		b: anId) isZero! !!LGitId methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!hexString	| string |	self isExternal 		ifFalse: [ ^handle hex ].	string := String new: 40.	string pin.	self		oid_fmt: string		id: self.		string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!internalize	"Copy the data of this object over to Smalltalk memory if it is currently external.	Now we can keep on using this object after the containing object (Blob, Tree or Commit)	has been freed."	(handle isExternalAddress and: [ handle isNull not ])		ifTrue: [ 			| bytes |			bytes := handle copyFrom: 1 to: self class byteSize.			handle := bytes ]! !!LGitId methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self hexString surroundedBySingleQuotes! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!oid_cmp: a b: b 	^self call: #(int git_oid_cmp(LGitId * self, LGitId * b)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!oid_fmt: out id:  objectId	^self call: #(void git_oid_fmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!oid_pathfmt: out id: id 	^ self call: #(void git_oid_pathfmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data1	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA1! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data10	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA10! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data10: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA10 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data11	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA11! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data11: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA11 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data12	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA12! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data12: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA12 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data13	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA13! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data13: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA13 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data14	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA14! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data14: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA14 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data15	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA15! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data15: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA15 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data16	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA16! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data16: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA16 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data17	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA17! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data17: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA17 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data18	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA18! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data18: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA18 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data19	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA19! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data19: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA19 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data1: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA1 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data2	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA2! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data20	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA20! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data20: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA20 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data2: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA2 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data3	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA3! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data3: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA3 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data4	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA4! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data4: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA4 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data5	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA5! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data5: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA5 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data6	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA6! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data6: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA6 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data7	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA7! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data7: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA7 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data8	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA8! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data8: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA8 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data9	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA9! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data9: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA9 put: anObject! !!LGitOdbWritepack class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	"git_odb_backend *" void *backend; "Using void* because I didn't mapped the structure git_odb_backend"	LGitWritepackAppendCallout append;	LGitWritepackCommitCallout commit;	LGitWritepackFreeCallout free;	)! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!appendWithBuffer: anAddress length: anInteger progress: aTransferProgress	| data callout|	data := self prim_append.	callout := LGitWritepackAppendCallout fromHandle: data getHandle.	^ callout		writepack: self		buffer: anAddress		length: anInteger		progress: aTransferProgress! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!commitWithProgress: aTransferProgress	self withReturnHandlerDo: [		self prim_commit			writepack: self			progress: aTransferProgress ]! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!free	self prim_free writepack: self! !!LGitOdbWritepack methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!odb_write_pack: out db: db progress_cb: progress_cb progress_payload: progress_payload 	^ self		call: #(#LGitReturnCodeEnum git_odb_write_pack(LGitOdbWritepack * self, LGitOdb db, LGitTransferProgressCallback progress_cb, void * progress_payload))		options: #( optMayGC optCoerceNilToNull )! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_append	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_APPEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_append: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_APPEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_backend	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BACKEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_backend: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BACKEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_commit	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_COMMIT) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_commit: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_COMMIT put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitPackbuilderForeachPayload class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitTransferProgress *stats;		LGitTransferProgressCallback *progress_cb;		void *progress_payload;		LGitOdbWritepack *writepack;	)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stats	"This method was automatically generated"	^LGitTransferProgress fromHandle: (handle pointerAt: OFFSET_PRIM_STATS)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stats: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STATS put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_writepack	"This method was automatically generated"	^LGitOdbWritepack fromHandle: (handle pointerAt: OFFSET_PRIM_WRITEPACK)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_writepack: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_WRITEPACK put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!stats	^ self prim_stats! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!stats: aTransferProgress	self prim_stats: aTransferProgress! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!writepack	^ self prim_writepack! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!writepack: aWritepack	self prim_writepack: aWritepack! !!LGitPushUpdate class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		"		 * The source name of the reference		 "		String src_refname;		"		 * The name of the reference to update on the server		 "		String dst_refname;		"		 * The current target of the reference		 "		LGitId src		"		 * The new target for the reference		 "		LGitId dst	)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_DST length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_DST put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DST_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DST_REFNAME put: anObject getHandle.! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_SRC length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_SRC put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SRC_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SRC_REFNAME put: anObject getHandle.! !!LGitRemoteHead class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	"self rebuildFieldAccessors"	^#(	int local; " available locally "	LGitId oid;	LGitId loid;	String name;	"	 * If the server send a symref mapping for this ref, this will	 * point to the target.	"	String symref_target;	)! !!LGitRemoteHead methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name 	^ (self prim_name) readString! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_LOCAL! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_LOCAL put: anObject! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_loid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_LOID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_loid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_LOID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_symref_target	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SYMREF_TARGET) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_symref_target: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SYMREF_TARGET put: anObject getHandle.! !!LGitSignature class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		char * name;		char * email;		LGitTime when;	)! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!name: nameString email: emailString	^ self name: nameString email: emailString when: DateAndTime now! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!name: nameString email: emailString when: dateAndTime	"Allocate an instance on the external heap and initialize it.	Use autoRelease so the data will be freed when the instance is gc'ed."	^ self externalNew			name: nameString;			email: emailString;			dateAndTime: dateAndTime;			autoRelease;			yourself! !!LGitSignature class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!signature_free: handle 	^ self		call: #(void git_signature_free(void *handle))		options: #(  )! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self name = anObject name				and: [ self email = anObject email					and: [ self dateAndTime = anObject dateAndTime ] ] ] ]! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!dateAndTime	^ self prim_when asDateAndTime! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!dateAndTime: aDateAndTime	self prim_when: (LGitTime fromDateAndTime: aDateAndTime)! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!email	^ self prim_email readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!email: aString	self prim_email: aString asLGitExternalString! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ ((self name hash bitXor: self email hash) bitXor: self email hash) bitXor: self dateAndTime hash! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name	^ self prim_name readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name: aString	self prim_name: aString asLGitExternalString! !!LGitSignature methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream		nextPutAll: self name;		nextPutAll: ' <';		nextPutAll: self email;		nextPutAll: '> '.	self dateAndTime printOn: aStream! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_email	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_EMAIL) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_email: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_EMAIL put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_when	"This method was automatically generated"	^ LGitTime fromHandle: (handle referenceStructAt: OFFSET_PRIM_WHEN length: LGitTime byteSize)! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_when: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_WHEN put: anObject getHandle length: LGitTime byteSize! !!LGitStringArray class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitExternalStringArray * strings;		size_t count;	)! !!LGitStringArray class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!strarray_free: handle	"libgit2 will also free all the strings in this struct"	^ self		call: #(void git_strarray_free(void *handle))		options: #()! !!LGitStringArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withAll: stringCollection	"Allocate an instance on the external heap and initialize it with	<stringCollection>. Use autoRelease so the data will be freed when	the instance is gc'ed."	^ self externalNew		count: stringCollection size;		strings: stringCollection;		autoRelease;		yourself! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!count	^ self prim_count! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!count: anInteger	self prim_count: anInteger! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_count	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_count: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT put: anObject! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_strings	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_STRINGS) type: ExternalType void asPointerType! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_strings: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STRINGS put: anObject getHandle.! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!strings	| externalArray |	self count = 0		ifTrue: [ ^ #() ].	externalArray := LGitExternalStringArray 		onAddress: self prim_strings getHandle 		size: self count.	^externalArray asArray! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!strings: aCollection	| array |	array := LGitExternalStringArray fromCollection: aCollection.	self prim_strings: array! !!LGitBlameOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version		uint32 flags "is a combination of the git_blame_flag_t values above."		uint16 min_match_characters "is the lower bound on the number of alphanumeric characters that must be detected as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20. This value only takes effect if any of the GIT_BLAME_TRACK_COPIES_* flags are specified."		LGitId newest_commit "is the id of the newest commit to consider. The default is HEAD."		LGitId oldest_commit "is the id of the oldest commit to consider. The default is the first commit encountered with a NULL parent."		size_t min_line "is the first line in the file to blame. The default is 1 (line numbers start with 1)."		size_t max_line "is the last line in the file to blame. The default is the last line of the file."	)! !!LGitBlameOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_init_options: opts version: version	^ self		callUnchecked: #(int git_blame_init_options(LGitBlameOptions * self, LGitOptionsVersionsEnum version))		options: #( )! !!LGitBlameOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			blame_init_options: self			version: LGitOptionsVersionsEnum git_blame_options_version_1 ]! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_match_characters	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_match_characters: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_newest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEWEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_newest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEWEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oldest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLDEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oldest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLDEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCheckoutOptions class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		uint checkout_strategy; "< default will be a dry run "		int disable_filters;    "< don't apply filters like CRLF conversion "		uint dir_mode;  "< default is 0755 "		uint file_mode; "< default is 0644 or 0755 as dictated by blob "		int file_open_flags;    "< default is O_CREAT | O_TRUNC | O_WRONLY "		uint notify_flags; "< see `git_checkout_notify_t` above "		LGitCheckoutNotifyCallback notify_cb;		void *notify_payload;		" Optional callback to notify the consumer of checkout progress. "		LGitCheckoutProgressCallback progress_cb;		void *progress_payload;		" When not zeroed out, array of fnmatch patterns specifying which		 *  paths should be taken into account, otherwise all files.  Use		 *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.		 "		LGitStringArray paths;		" The expected content of the working directory; defaults to HEAD.		 *  If the working directory does not match this baseline information,		 *  that will produce a checkout conflict.		 "		LGitTree *baseline;		" Like `baseline` above, though expressed as an index.  This		 *  option overrides `baseline`.		 "		LGitIndex *baseline_index; "< expected content of workdir, expressed as an index. "		String target_directory; "< alternative checkout path to workdir "		String ancestor_label; "< the name of the common ancestor side of conflicts "		String our_label; "< the name of the *our* side of conflicts "		String their_label; "< the name of the *their* side of conflicts "		" Optional callback to notify the consumer of performance data. "		LGitCheckoutPerfDataCallback perfdata_cb;		void *perfdata_payload;	)! !!LGitCheckoutOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!checkoutStrategy: aCheckoutStrategyEnum	self prim_checkout_strategy: aCheckoutStrategyEnum value! !!LGitCheckoutOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_init_options: opts version: version 	^ self		callUnchecked: #(int git_checkout_init_options(LGitCheckoutOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCheckoutOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			checkout_init_options: self			version: LGitOptionsVersionsEnum git_checkout_options_version_1 ]! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ancestor_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ancestor_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline_index	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE_INDEX) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline_index: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE_INDEX put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_strategy	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_strategy: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dir_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_DIR_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dir_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DIR_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_disable_filters	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_disable_filters: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_open_flags	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_open_flags: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb	"This method was automatically generated"	^LGitCheckoutNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_our_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OUR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_our_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OUR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_paths	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHS length: LGitStringArray byteSize)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_paths: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHS put: anObject getHandle length: LGitStringArray byteSize! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_cb	"This method was automatically generated"	^LGitCheckoutPerfDataCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PERFDATA_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PERFDATA_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb	"This method was automatically generated"	^LGitCheckoutProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_directory	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_directory: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_their_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_THEIR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_their_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_THEIR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;				"		 * These options are passed to the checkout step. To disable		 * checkout, set the `checkout_strategy` to		 * `GIT_CHECKOUT_NONE`.		 "		LGitCheckoutOptions checkout_opts;		"		 * Options which control the fetch, including callbacks.		 *		 * The callbacks are used for reporting fetch progress, and for acquiring		 * credentials in the event they are needed.		 "		LGitFetchOptions fetch_opts;		"		 * Set to zero (false) to create a standard repo, or non-zero		 * for a bare repo		 "		Boolean bare;		"		 * Whether to use a fetch or copy the object database.		 "		LGitCloneLocalTypeEnum local;		"		 * The name of the branch to checkout. NULL means use the		 * remote's default branch.		 "		String checkout_branch;		"		 * A callback used to create the new repository into which to		 * clone. If NULL, the 'bare' field will be used to determine		 * whether to create a bare repository.		 "		LGitRepositoryCreateCallback repository_cb;		"		 * An opaque payload to pass to the git_repository creation callback.		 * This parameter is ignored unless repository_cb is non-NULL.		 "		void *repository_cb_payload;		"		 * A callback used to create the git_remote, prior to its being		 * used to perform the clone operation. See the documentation for		 * git_remote_create_cb for details. This parameter may be NULL,		 * indicating that git_clone should provide default behavior.		 "		LGitRemoteCreateCallback remote_cb;		"		 * An opaque payload to pass to the git_remote creation callback.		 * This parameter is ignored unless remote_cb is non-NULL.		 "		void *remote_cb_payload;	)! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withCredentialsCallback: aBlock	| credentialsCallback callbacks fetchOptions  |	credentialsCallback := LGitCredAcquireCallback on: aBlock.	callbacks := LGitRemoteCallbacks defaults		credentials: credentialsCallback;		yourself.	fetchOptions := LGitFetchOptions defaults		callbacks: callbacks;		yourself.	^ self defaults		fetchOptions: fetchOptions;		yourself.	! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withCredentialsProvider: provider	| fetchOptions |	fetchOptions := LGitFetchOptions defaults		callbacks: (LGitRemoteCallbacks withProvider: provider);		yourself.	^ self defaults		fetchOptions: fetchOptions		yourself.	! !!LGitCloneOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone_init_options: opts version: version 	^ self		callUnchecked: #(LGitReturnCodeEnum git_clone_init_options(LGitCloneOptions *self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchOptions	^ self prim_fetch_opts! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchOptions: _fetchOptions	fetchOptions := _fetchOptions.	self prim_fetch_opts: fetchOptions! !!LGitCloneOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			clone_init_options: self			version: LGitOptionsVersionsEnum  git_clone_options_version_1 ]! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_bare	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BARE! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_bare: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BARE put: anObject! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_branch	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH) type: ExternalType char asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_branch: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_opts	"This method was automatically generated"	^ LGitCheckoutOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_CHECKOUT_OPTS length: LGitCheckoutOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CHECKOUT_OPTS put: anObject getHandle length: LGitCheckoutOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_fetch_opts	"This method was automatically generated"	^ LGitFetchOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_FETCH_OPTS length: LGitFetchOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_fetch_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FETCH_OPTS put: anObject getHandle length: LGitFetchOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local	"This method was automatically generated"	^LGitCloneLocalTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_LOCAL)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL put: anObject value! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb	"This method was automatically generated"	^LGitRemoteCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REMOTE_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REMOTE_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb	"This method was automatically generated"	^LGitRepositoryCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REPOSITORY_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REPOSITORY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteCallback	^ self prim_remote_cb! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteCallback: aRemoteCallback	self prim_remote_cb: aRemoteCallback! !!LGitDiffFindOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		"Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).		 NOTE: if you don't explicitly set this, `diff.renames` could be set		 to false, resulting in `git_diff_find_similar` doing nothing."		uint32 flags;		" Similarity to consider a file renamed (default 50) "		uint16 rename_threshold;		" Similarity of modified to be eligible rename source (default 50) "		uint16 rename_from_rewrite_threshold;		" Similarity to consider a file a copy (default 50) "		uint16 copy_threshold;		" Similarity to split modify into delete/add pair (default 60) "		uint16 break_rewrite_threshold;		"Maximum similarity sources to examine for a file (somewhat like		 git-diff's `-l` option or `diff.renameLimit` config) (default 200)"		size_t rename_limit;		" Pluggable similarity metric; pass NULL to use internal metric "		LGitDiffSimilarityMetric metric;	)! !!LGitDiffFindOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_find_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_find_init_options(LGitDiffFindOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffFindOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_find_init_options: self			version: LGitOptionsVersionsEnum git_diff_find_options_version_1 ]! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_break_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_break_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_copy_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_copy_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric	"This method was automatically generated"	^ LGitDiffSimilarityMetric fromHandle: (handle referenceStructAt: OFFSET_PRIM_METRIC length: LGitDiffSimilarityMetric byteSize)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_METRIC put: anObject getHandle length: LGitDiffSimilarityMetric byteSize! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_from_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_from_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_limit	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_limit: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitDiffOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version      "version for the struct"		uint32 flags            "defaults to GIT_DIFF_NORMAL"		"options controlling which files are in the diff"		LGitSubmoduleIgnoreTypeEnum ignore_submodules "submodule ignore rule"		LGitStringArray       pathspec     "defaults to include all paths"		LGitDiffNotifyCallback notify_cb		void *notify_payload		"options controlling how to diff text is generated"		uint32    context_lines    "defaults to 3"		uint32    interhunk_lines  "defaults to 0"		uint16    id_abbrev       "default 'core.abbrev' or 7 if unset"		int64   max_size         "defaults to 512MB"		String old_prefix       "defaults to 'a'"		String new_prefix       "defaults to 'b'"	)! !!LGitDiffOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_init_options(LGitDiffOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_init_options: self			version: LGitOptionsVersionsEnum git_diff_options_version_1 ]! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_context_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_context_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ignore_submodules	"This method was automatically generated"	^LGitSubmoduleIgnoreTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ignore_submodules: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES put: anObject value! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_interhunk_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_interhunk_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NEW_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NEW_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb	"This method was automatically generated"	^LGitDiffNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OLD_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OLD_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pathspec	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHSPEC length: LGitStringArray byteSize)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pathspec: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHSPEC put: anObject getHandle length: LGitStringArray byteSize! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitFetchOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version;		"		 * Callbacks to use for this fetch operation		 "		LGitRemoteCallbacks callbacks;		"		 * Whether to perform a prune after the fetch		 "		LGitFetchPruneTypeEnum prune;		"		 * Whether to write the results to FETCH_HEAD. Defaults to		 * on. Leave this default in order to behave like git.		 "		Boolean update_fetchhead;		"		 * Determines how to behave regarding tags on the remote, such		 * as auto-downloading tags for objects we're downloading or		 * downloading all of them.		 *		 * The default is to auto-follow tags.		 "		LGitRemoteAutotagOptionTypeEnum download_tags;		"	    * Proxy options to use, by default no proxy is used.	   "		LGitProxyOptions proxy_opts;		"	  	 * Extra headers for this fetch operation	 	"		LGitStringArray custom_headers;	)! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks	^ self prim_callbacks! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks: _callbacks	callbacks := _callbacks.	self prim_callbacks: callbacks! !!LGitFetchOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!fetch_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_fetch_init_options(LGitFetchOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitFetchOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			fetch_init_options: self			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_download_tags	"This method was automatically generated"	^LGitRemoteAutotagOptionTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_download_tags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_prune	"This method was automatically generated"	^LGitFetchPruneTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_PRUNE)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_prune: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PRUNE put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_fetchhead	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_fetchhead: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD put: anObject! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitMergeOptions class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	"https://libgit2.github.com/libgit2/#HEAD/type/git_merge_options"	^#(		LGitOptionsVersionsEnum version;		uint32 flags; "Should be: git_merge_flag_t"		uint rename_threshold;		uint target_limit;		void* metric; "Should be: git_diff_similarity_metric *"		uint recursion_limit;		String default_driver;		uint32 file_favor; "Should be: git_merge_favor_flag_t"		uint32 file_flags; "Should be: git_merge_file_flag_t"	)! !!LGitMergeOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			merge_init_options: self			version: LGitOptionsVersionsEnum git_merge_options_version_1 ]! !!LGitMergeOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_init_options: opts version: version 	^ self		callUnchecked: #(int git_merge_init_options(			LGitMergeOptions * self, 			LGitOptionsVersionsEnum version))		options: #()! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_default_driver	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER) type: ExternalType char asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_default_driver: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_favor	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_favor: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_METRIC) type: ExternalType void asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_METRIC put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_recursion_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_recursion_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"/**	 * The type of proxy to use, by URL, auto-detect.	 */"	LGitProxyTypeEnum type;	"/**	 * The URL of the proxy.	 */"	String url;	"/**	 * This will be called if the remote host requires	 * authentication in order to connect to it.	 *	 * Returning GIT_PASSTHROUGH will make libgit2 behave as	 * though this field isn't set.	 */"	LGitCredAcquireCallback credentials;	"/**	 * If cert verification fails, this will be called to let the	 * user make the final decision of whether to allow the	 * connection to proceed. Returns 1 to allow the connection, 0	 * to disallow it or a negative value to indicate an error.	 */"   LGitTransportCertificateCheckCallback certificate_check;	"/**	 * Payload to be provided to the credentials and certificate	 * check callbacks.	 */"	void *payload;	)! !!LGitProxyOptions methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			proxy_init_options: self getHandle getHandle			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type	"This method was automatically generated"	^LGitProxyTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_url	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_URL) type: ExternalType char asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_url: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_URL put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!proxy_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_proxy_init_options(void *handle, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitPushOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"	 * If the transport being used to push to the remote requires the creation	 * of a pack file, this controls the number of worker threads used by	 * the packbuilder when creating that pack file to be sent to the remote.	 *	 * If set to 0, the packbuilder will auto-detect the number of threads	 * to create. The default value is 1.	 "	uint pb_parallelism;	"	 * Callbacks to use for this push operation	 "	LGitRemoteCallbacks callbacks;			"	* Proxy options to use, by default no proxy is used.	"	LGitProxyOptions proxy_opts;	"	 * Extra headers for this push operation	"	LGitStringArray custom_headers;)! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks	^ self prim_callbacks! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks: _callbacks	callbacks := _callbacks.	^ self prim_callbacks: callbacks! !!LGitPushOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			push_init_options: self			version: LGitOptionsVersionsEnum git_push_options_version_1 ]! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pb_parallelism	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pb_parallelism: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM put: anObject! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitPushOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!push_init_options: options version: version	self		callUnchecked: #(LGitReturnCodeEnum git_push_init_options(LGitPushOptions * self, LGitOptionsVersionsEnum version))		options: #()! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!defaults	^ super defaults 		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitStructVersionsEnum version;		"		 * Textual progress from the remote. Text send over the		 * progress side-band will be passed to this function (this is		 * the 'counting objects' output.		 "		LGitTransportMessageCallback sideband_progress;		"		 * Completion is called when different parts of the download		 * process are done (currently unused).		 "		LGitCompletionCallback completion;		"		 * This will be called if the remote host requires		 * authentication in order to connect to it.		 *		 * Returning GIT_PASSTHROUGH will make libgit2 behave as		 * though this field isn't set.		 "		LGitCredAcquireCallback credentials;		"		 * If cert verification fails, this will be called to let the		 * user make the final decision of whether to allow the		 * connection to proceed. Returns 1 to allow the connection, 0		 * to disallow it or a negative value to indicate an error.		 "	   LGitTransportCertificateCheckCallback certificate_check;		"		 * During the download of new data, this will be regularly		 * called with the current count of progress done by the		 * indexer.		 "		LGitTransferProgressCallback transfer_progress;		"		 * Each time a reference is updated locally, this function		 * will be called with information about it.		 "		LGitUpdateTipsCallback update_tips;		"		 * Function to call with progress information during pack		 * building. Be aware that this is called inline with pack		 * building operations, so performance may be affected.		 "		LGitPackbuilderProgressCallback pack_progress;		"		 * Function to call with progress information during the		 * upload portion of a push. Be aware that this is called		 * inline with pack building operations, so performance may be		 * affected.		 "		LGitPushTransferProgressCallback push_transfer_progress;		"		 * Called for each updated reference on push. If `status` is		 * not `NULL`, the update was rejected by the remote server		 * and `status` contains the reason given.		 "		LGitPushUpdateReferenceCallback push_update_reference;		"		 * Called once between the negotiation step and the upload. It		 * provides information about what updates will be performed.		 "		LGitPushNegotiationCallback push_negotiation;		"		 * Create the transport to use for this operation. Leave NULL		 * to auto-detect.		 "		LGitTransport transport;		"		 * This will be passed to each of the callbacks in this struct		 * as the last parameter.		 "		void *payload;	)! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!newCertificateCheckCallback	self flag: #fixMe. "I need to skip the verification of certificate because on macOS, 	libgit2 has problems to be compiled with Secure framework, and if compiled with 	openssl instead, openssl for macOS does not checks agains the certificates installed 	at S.O., so it will fail almost always. This is, of course, a workaround... eventually 	libgit2 will work :P"	^ LGitTransportCertificateCheckCallback on: [ :cert :value :host :payload  |		1 ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!newCredentialsCallbackFor: provider	^ LGitCredAcquireCallback		on: [ :output :url :username_from_url :allowed_types :data | 			"Allowed types are defined in git_credtype_t 		https://github.com/libgit2/libgit2/blob/HEAD/include/git2/transport.h#L81-111"			self				putCredentialsType: allowed_types				username: username_from_url				provider: provider				onto: output ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!putCredentialsType: types username: username provider: provider onto: output  	(types anyMask: 1 << 0) ifTrue: [ 		^ LGitCredentialsPlaintext createFrom: provider onto: output ].	(types anyMask: 1 << 1) ifTrue: [ 		^ provider sshCredentialsClass 			createFrom: provider 			username: username			onto: output ].	Transcript logCr: ('I can''t create credentials for type: {1}' format: {types}).	^ -1! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withProvider: provider	^ LGitRemoteCallbacks defaults		credentials: (self newCredentialsCallbackFor: provider);		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!certificateCheck: aCallback	certificateCheckCallback := aCallback.	self prim_certificate_check: aCallback! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!credentials	^ self prim_credentials! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!credentials: aCredentialsCallback	credentialsCallback := aCredentialsCallback.	self prim_credentials: credentialsCallback! !!LGitRemoteCallbacks methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			remote_init_callbacks: self			version: LGitStructVersionsEnum git_remote_callbacks_version_1 ]! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_completion	"This method was automatically generated"	^LGitCompletionCallback forAddress: ((handle pointerAt: OFFSET_PRIM_COMPLETION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_completion: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_COMPLETION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pack_progress	"This method was automatically generated"	^LGitPackbuilderProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PACK_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pack_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PACK_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_negotiation	"This method was automatically generated"	^LGitPushNegotiationCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_negotiation: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_transfer_progress	"This method was automatically generated"	^LGitPushTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_update_reference	"This method was automatically generated"	^LGitPushUpdateReferenceCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_update_reference: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_sideband_progress	"This method was automatically generated"	^LGitTransportMessageCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_sideband_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transfer_progress	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transport	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TRANSPORT) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transport: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TRANSPORT put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_tips	"This method was automatically generated"	^LGitUpdateTipsCallback forAddress: ((handle pointerAt: OFFSET_PRIM_UPDATE_TIPS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_tips: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_UPDATE_TIPS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitStructVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitRemoteCallbacks methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_init_callbacks: opts version: version 	^ self		call: #(LGitReturnCodeEnum git_remote_init_callbacks(LGitRemoteCallbacks * self, LGitStructVersionsEnum version))		options: #(  )! !!LGitStructWithDefaults class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!defaults	^ self externalNew		initializeWithDefaults;		yourself! !!LGitStructWithDefaults methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initialize	super initialize.		"Options are only ever used during a single setup function call.	The contents of the struct are then copied to a libgit2 internal	struct."	self autoRelease! !!LGitStructWithDefaults methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self subclassResponsibility! !!LGitTime class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	int64 time;	int offset;	)! !!LGitTime class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromDateAndTime: aDateAndTime	^ self new 		time: aDateAndTime asUnixTime;		offset: aDateAndTime offset asMinutes asInteger;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self time = anObject time				and: [  self offset = anObject offset ] ] ]! !!LGitTime methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asDateAndTime	^ (DateAndTime fromUnixTime: self time) 		offset: self offset;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ (super hash bitXor: self time) bitXor: self offset! !!LGitTime methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self asDateAndTime printOn: aStream! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!offset	^ self prim_offset! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!offset: anInteger	self prim_offset: anInteger! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_offset	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OFFSET! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_offset: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OFFSET put: anObject! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_time	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_TIME! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_time: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_TIME put: anObject! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!time	^ self prim_time! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!time: anInteger	^ self prim_time: anInteger! !!LGitTransferProgress class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	uint total_objects;	uint indexed_objects;	uint received_objects;	uint local_objects;	uint total_deltas;	uint indexed_deltas;	size_t received_bytes;	)! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_bytes	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_bytes: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS put: anObject! !!LGitSafeFFICalloutAPI methodsFor: 'action' stamp: ' 7/24/2017 12:50:03'!newBuilder	^ LGitSafeFFICalloutMethodBuilder calloutAPI: self! !!String methodsFor: '*libgit-core' stamp: ' 7/24/2017 12:50:03'!asLGitExternalString	| data |	data := ExternalData		fromHandle: (ExternalAddress allocate: self size + 1)		type: ExternalType char asPointerType.	LibC memCopy: self to: data size: self size.	data getHandle byteAt: self size + 1 put: 0.	^ data! !!LGitCredentialsFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!credentials: credentials	^ self		call: #(void #(LGitCredentials * credentials))		options: #(optMayGC)! !!LGitWritepackAppendCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!writepack: writepack buffer: buffer length: length progress: progress		^ self		call:			#(int #(LGitOdbWritepack * writepack , void * buffer , int length , LGitTransferProgress * progress))		options: #(optMayGC)! !!LGitWritepackCommitCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!writepack: writepack progress: progress	^ self		call: #(int #(LGitOdbWritepack *writepack , LGitTransferProgress *progress))		options: #(optMayGC)! !!LGitWritepackFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!writepack: writepack	^ self call: #(void #(LGitOdbWritepack *writepack)) options: #()! !!LGitExternalObject class methodsFor: 'finalization' stamp: ' 7/24/2017 12:50:03'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalObject class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #object_free:! !!LGitExternalObject class methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!fromHandle: aHandle	^self basicNew setHandle: aHandle! !!LGitExternalObject class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_free: handle 	"We pass a handle in here instead of the object. We can't pass the object since that	has already been gc'ed."	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitExternalObject methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isReady	^ self isNull not! !!LGitExternalObject methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!shouldContinuePrintingOn: aStream	self ifNotReady: [ aStream nextPutAll: ' (<not initialized>)' ].		^ self isReady! !!LGitOdb class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #odb_free:! !!LGitOdb class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!odb_free: handle		^ self call: #(void git_odb_free #(void *handle)) options: #()! !!LGitPackBuilder class methodsFor: 'native-boost' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #packbuilder_free:! !!LGitPackBuilder class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_free: handle		^ self		call: #(void git_packbuilder_free #(void *handle))		options: #()! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_foreach: pb cb: cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_foreach #(self , LGitPackbuilderForeachCallback cb ,  void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_insert_commit: pb id: id		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_insert_commit #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_insert_tree: pb id: id		^ self		call: #(LGitReturnCodeEnum git_packbuilder_insert_tree #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_packbuilder_new #(LGitPackBuilder * self , LGitRepository repo))		options: #()! !!LGitRepository class methodsFor: 'native-boost' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #repository_free:! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!new	self error: 'This class should be instantiated with a give path.'! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!on: aFileReference	LGitGlobal checkInitialized.	^ self basicNew		initialize;		initializeOn: aFileReference! !!LGitRepository class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_free: handle		^ self call: #(void git_repository_free #(void *handle)) options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!addRemote: aName url: anUrl	(LGitRemote of: self named: aName url: anUrl) createWithoutSpec! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!allBranches	^ OrderedCollection new: 10 streamContents: [ :stream |		self allBranchesDo: [ :reference | 			stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!allBranchesDo: aBlock	LGitBranchIterator allBranchesOf: self do: aBlock! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!allRemotes	| out |		out := LGitStringArray externalNew autoRelease.	self remote_list: out.	^ out strings collect: [ :each | (LGitRemote of: self named: each) lookup ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!beOpen	isOpen := true! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!branchNames	^ self branches collect: #name! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_lookup: out branch_name: branch_name branch_type: branch_type		^ self		call:			#(LGitReturnCodeEnum git_branch_lookup #(LGitReference * out , self , String branch_name , LGitBranchTypeEnum branch_type))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!branches	^ OrderedCollection new: 10 streamContents: [ :stream |		self branchesDo: [ :reference | stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!branchesDo: aBlock	LGitBranchIterator localBranchesOf: self do: aBlock.! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkout: aString	<todo: 'use proper exceptions'>	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	[ 		| branch |		branch := self lookupLocalBranch: aString ifAbsent: [ self createBranchFromOrigin: aString ].		self checkout_treeish: branch object.		self setHead: branch.	] 	on: LGit_GIT_EINVALIDSPEC, LGit_GIT_ENOTFOUND do: [		"aString is not a valid branch name, so try to find a corresponding treeish using revparse, 		this will handle stuff like 'master~1'"		| commitish | 		commitish := self revparse: aString.		self checkout_treeish: commitish.		self setHeadDetached: commitish.	].! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkoutHead	self withReturnHandlerDo: [ 		self checkout_head_opts: (			LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;				yourself) ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_head_opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_head #(self , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_treeish: treeish	"treeish can be a commit, tag or tree (or NULL to use HEAD)"	self withReturnHandlerDo: [ 		self			checkout_treeish: treeish			opts:				(LGitCheckoutOptions defaults					checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;					yourself) ].! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_treeish: treeish opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_tree #(self , LGitObject treeish , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!clone: aString	| cloneOptions |	cloneOptions := LGitCloneOptions defaults.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone: aString options: cloneOptions	self		clone: aString		options: cloneOptions		to: self repositoryReference! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone: aString options: cloneOptions to: aFileReference	<todo: 'use exceptions instead of assertion'>	self assert: aString isEmptyOrNil not.	self assert: aFileReference notNil.	self assert: cloneOptions notNil.		aFileReference ensureCreateDirectory.		self withReturnHandlerDo: [ 		self 			clone: self			url: aString			local_path: aFileReference pathString			options: cloneOptions ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone: out url: url local_path: local_path options: options		^ self		callUnchecked:			#(LGitReturnCodeEnum git_clone (LGitRepository *out, String url, String local_path, LGitCloneOptions *options))		options: #(optCoerceNilToNull)! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!clone: aString withCredentials: aCredentialsProvider 	| cloneOptions |	cloneOptions := LGitCloneOptions withCredentialsProvider: aCredentialsProvider.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneHttps: aString	<todo: 'use exceptions instead of assertion'>	self assert: (aString beginsWith: 'https://').		self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneLocal: aString	self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneRemote: aRemote signature: aSignature	self		cloneRemote: aRemote		signature: aSignature		branch: 'master'! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneRemote: aRemote signature: aSignature branch: aString	self		cloneRemote: aRemote		signature: aSignature		branch: aString		checkoutOptions: LGitCheckoutOptions defaults! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneRemote: aRemote  signature: aSignature branch: aString checkoutOptions: options	<todo: 'use exceptions instead of assertions'>	self assert: aRemote hasFetchSpec.		self withReturnHandlerDo: [		self 			clone_into: self			remote: aRemote			co_opts: options			branch: aString			signature: aSignature ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneSsh: aString	| credentials cloneOptions |	credentials := LGitRemote credentialsSsh.	cloneOptions := LGitCloneOptions withCredentialsCallback: 		[ :cred :url :username_from_url :allowed_types :data | 			allowed_types = 32 				ifTrue: [ credentials setGitUsernameIn: cred ]				ifFalse: [ credentials createWith: cred ].			0 		].		self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!config	| config |	config := (LGitConfig of: self) autoRelease.	self withReturnHandlerDo: [ self repository_config: config ].	^ config! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!create	self exists ifTrue: [ ^ self ].		self repositoryReference ensureCreateDirectory! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString force: aBoolean	<todo: 'this method belongs somewhere else and should allow to specify the target'>	| reference |	reference := LGitReference of: self.	reference createSymbolic: 'refs/heads/' , aString target: 'refs/dummy' force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString target: aGitReference	<todo: 'this method belongs somewhere else'>	^ self createBranch: aString target: aGitReference force: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString target: aGitReference force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference 		createDirect: 'refs/heads/' , aString 		target: aGitReference object id 		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString targetId: aGitId force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference createDirect: 'refs/heads/' , aString target: aGitId force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranchFromOrigin: branchName	| remoteBranchName remoteBranch localBranch |	remoteBranchName := 'origin/', branchName.	remoteBranch := self lookupRemoteBranch: remoteBranchName.	localBranch := self createBranch: branchName target: remoteBranch.	localBranch setUpstream: remoteBranchName.	^ localBranch! !!LGitRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createPackForReference: aReference	| odb walk packbuilder writepack stats packbuilderPayload progresscb packbuilderCallback |	odb := self database.	walk := (LGitRevwalk of: self)		beSortedByCommitTime;		pushReference: aReference;		yourself.	packbuilder := LGitPackBuilder new.	packbuilder packbuilder_new: packbuilder repo: self.	"hideCallback := LG2RevwalkHideCb on: [ :oid :payload |  ].	LG2RevwalkH uniqueInstance		revwalk_add_hide_cb: walk		hide_cb: hideCallback		payload: nil."	[ walk hasNext ] whileTrue: [ 		| commit tree |		commit := walk next.		tree := commit tree.		packbuilder			packbuilder_insert_commit: packbuilder id: commit id;			packbuilder_insert_tree: packbuilder id: tree id.		commit free.		tree free ].	progresscb := LGitTransferProgressCallback on: [ :progress :data | 0 ].	writepack := LGitOdbWritepack externalNew.	writepack		odb_write_pack: writepack		db: odb		progress_cb: progresscb		progress_payload: ExternalAddress null.	writepack := LGitOdbWritepack fromHandle: writepack getHandle pointer.	stats := LGitTransferProgress externalNew.	packbuilderPayload := LGitPackbuilderForeachPayload externalNew.	packbuilderCallback := LGitPackbuilderForeachCallback		on: [ :buffer :length :payload | payload writepack appendWithBuffer: buffer length: length progress: payload stats ].	packbuilderPayload		writepack: writepack;		stats: stats.	packbuilder packbuilder_foreach: packbuilder cb: packbuilderCallback payload: packbuilderPayload.	writepack commitWithProgress: stats! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createTag: aString targetId: aGitId force: aBoolean	"Create a tag. Based on #createBranch:targetId:force:"	| reference |	reference := LGitReference of: self.	reference		createDirect: 'refs/tags/', aString		target: aGitId		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!database	| database |	database := LGitOdb new.	self withReturnHandlerDo: [		self			repository_odb: database			repo: self ].			^ database! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!defaultSignature	| signaturePointer |	signaturePointer := ExternalAddress new.	self withReturnHandlerDo: [ self signature_default: signaturePointer repo: self ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!deleteAllLooseObjectsForReference: aReference	(self repositoryReference / '.git' / 'objects') children		select: [ :entry | entry basename ~= 'pack' ]		thenDo: [ :entry | entry deleteAll ].		"raise an exception if not resolvable"	self head	"	| walker oid baseReference |	walker := LGitRevwalkType new.	LG2RevwalkH uniqueInstance		revwalk_new: walker		repo: self.	LG2RevwalkH uniqueInstance		revwalk_sorting: walker		sort_mode: 2.	LG2RevwalkH uniqueInstance		revwalk_push_ref: walker		refname: aReference name.	baseReference := aReference repository repositoryReference / '.git' / 'objects'.	oid := LGitId new.	[ (LG2RevwalkH uniqueInstance		revwalk_next: oid		walk: walker) isZero ] whileTrue: [			| fileReference |			fileReference := baseReference resolve: oid asRelativePathString.			fileReference delete.			fileReference parent hasChildren ifFalse: [ fileReference parent delete ] ]"! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!exists	^ self repositoryReference exists! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fastForward	<todo: 'check for conflicts'>	"currently forces fastForward in every case"	self head resolve setTarget: (self lookup: 'FETCH_HEAD')! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchFrom: remoteName 	(LGitRemote of: self named: remoteName) 		lookup; 		fetch! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!head	| head |	head := LGitReference of: self.	self withReturnHandlerDo: [ self repository_head: head of: self ].	^ head! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!index	| index |	index := LGitIndex of: self.	self withReturnHandlerDo: [ self repository_index: index repo: self ].	^ index! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!init	self initBare: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initBare: aBoolean	self withReturnHandlerDo: [		self			repository_init: self			path: self repositoryReference pathString			is_bare: aBoolean ].	self autoRelease ! !!LGitRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeOn: aFileReference	repositoryPath := aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBare	^ self repository_is_bare: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isDirty: aFileReference	^ self index isDirty: aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isEmpty	self exists ifFalse: [ ^ true ].		^ self repository_is_empty: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isInitialized	^ self isReady! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isOpen	^ isOpen ifNil: [ false ]! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isProperRepository	| return |	return := self		repository_open_ext: self		path: self repositoryReference pathString		flags: LGitOpenFlagEnum git_repository_open_no_search		ceiling_dirs: nil.			^ return isOk! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isUnborn	^ self repository_is_unborn: self! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookup: name	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [		self			reference_lookup: reference			repo: self			shorthand: name ].			^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupBranch: name	^ (name includes: $/)		ifTrue: [ self lookupRemoteBranch: (name withoutPrefix: 'refs/remotes/') ]		ifFalse: [ self lookupLocalBranch: name ] ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupBranch: branchName inRemote: remoteName	^ self lookupRemoteBranch: remoteName, '/', branchName! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupBranch: name type: branchType	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [ 		self			branch_lookup: reference			branch_name: name			branch_type: branchType	].	^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupLocalBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_local ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupLocalBranch: name ifAbsent: aBlock	^ [ self lookupLocalBranch: name ]		on: LGit_GIT_ENOTFOUND 		do: aBlock ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupRemoteBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_remote! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!merge: aLGitAnnotatedCommit 	| heads |	heads := (FFIExternalArray externalNewType: LGitAnnotatedCommit size: 1) autoRelease;		at: 1 put: aLGitAnnotatedCommit handle;		yourself.	self withReturnHandlerDo: [		self merge_heads: heads 			length: 1 			merge_options: LGitMergeOptions defaults			checkout_options: LGitCheckoutOptions defaults 	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!mergeBaseBetween: aLGitId and: aLGitId2 	| base |	base := LGitId new.	self withReturnHandlerDo: [ self merge_base: base between: aLGitId and: aLGitId2 ].	^ base! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_base: out between: one and: two	^ self call: #(	LGitReturnCodeEnum git_merge_base #(			LGitId * out, 			self, 			LGitId * one, 			LGitId * two))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_heads: heads length: length merge_options: mergeOptions checkout_options: checkoutOptions		^ self		callUnchecked:			#(LGitReturnCodeEnum git_merge #(				self , 				FFIExternalArray heads ,				int length , 				LGitMergeOptions * mergeOptions ,				LGitCheckoutOptions * checkoutOptions))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!new_signature: out name:name email:email time:time		^ self		call:			#(LGitReturnCodeEnum git_signature_new #(void **out , String name, String email, LGitTime time, 0))		options: #()! !!LGitRepository methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self repositoryReference fullName.	self isBare 		ifTrue: [ aStream nextPutAll: ' [bare]' ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!open	self withReturnHandlerDo: [ 		self			repository_open: self			bare_path: self repositoryReference pathString ].	self beOpen! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!origin	^ (LGitRemote of: self named: 'origin') lookup; yourself! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!packHead	<todo: 'This method is distructive. It will delete *all* objects, including those not in the pack (not reachable from head'>	"USE VERY CAREFULLY"		LGitGlobal runSequence: [ self createPackForReference: self head ].	self deleteAllLooseObjectsForReference: self head! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_lookup: out repo: repo shorthand: shorthand		^ self		call:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * out , self , String shorthand))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!references	self notYetImplemented! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_list: out	^ self 		call: #( int git_remote_list ( LGitStringArray *out, self ) ) 		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!repositoryReference	^ repositoryPath! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_config: config	^ self		call:			#(LGitReturnCodeEnum git_repository_config(LGitConfig *config, self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_head: reference of: repository		^ self		call:			#(LGitReturnCodeEnum git_repository_head #(LGitReference * reference , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_index: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_index #(LGitIndex * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_init: out path: path is_bare: is_bare		^ self		callUnchecked:			#(int git_repository_init #(LGitRepository * out , String path , Boolean is_bare))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_is_bare: repo		^ self call: #(Boolean git_repository_is_bare #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_is_empty: repo		^ self call: #(Boolean git_repository_is_empty #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_is_unborn: repo	^ self call: #( Boolean git_repository_head_unborn (self) ) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_odb: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_odb #(LGitOdb * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_open: out bare_path: bare_path		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open #(LGitRepository * out , String bare_path))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_open_ext: out path: path flags: flags ceiling_dirs: ceiling_dirs		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open_ext #(LGitRepository * out , String path , LGitOpenFlagEnum flags , String ceiling_dirs))		options: #(optCoerceNilToNull optStringOrNull)! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_set_head: refname log_message: log_message		^ self		call:			#(int git_repository_set_head #(self , String refname , String log_message))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_set_head_detached: commitish		^ self		call:			#(int git_repository_set_head_detached #(self, LGitId * commitish))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_workdir: repo		^ self call: #(String git_repository_workdir #(self)) options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!revparse: aString	"See git-rev-parse documentation.	Examples:		repository revparse: 'HEAD' 	# last commit		repository revparse: 'HEAD~5'	# 5 commits back from last commit		repository revparse: 'develop'	# last commit from develop branch	"	| object |	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	object := LGitObject of: self.	self withReturnHandlerDo: [ 		self			revparse_single: object			repo: self			spec: aString ].	^ object concreteObject	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revparse_single: out repo: repo spec: spec		^ self		call:			#(LGitReturnCodeEnum git_revparse_single #(LGitObject * out , self , String spec))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setHead: aLGitReference	self withReturnHandlerDo: [ 		self			repository_set_head: aLGitReference name			log_message: 'set head to refs/heads/' , aLGitReference name ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setHeadDetached: commitish	self withReturnHandlerDo: [ 		self repository_set_head_detached: commitish id	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!signatureWithName: name email: email dateTime: dateTime	| signaturePointer time |	signaturePointer := ExternalAddress new.	time := LGitTime fromDateAndTime: dateTime.	self		withReturnHandlerDo: [ self				new_signature: signaturePointer				name: name				email: email				time: time ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!signature_default: out repo: repo		^ self		call:			#(LGitReturnCodeEnum git_signature_default #(void **out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_list: tag_names repo: repo		^ self		call:			#(LGitReturnCodeEnum git_tag_list #(LGitStringArray * tag_names , LGitRepository repo))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tags	| array strings |	array := LGitStringArray externalNew.	self withReturnHandlerDo: [		self			tag_list: array			repo: self ].	strings := array strings.	array free.	^ strings	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!workingDirectory	^ workingDirectory ifNil: [			workingDirectory := self withReturnHandlerDo: [				(self repository_workdir: self) asFileReference ] ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!workingDirectoryName	^ self isBare			ifTrue: [ nil ]			ifFalse: [ self workingDirectory basename ]! !!LGitAnnotatedCommit class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!annotated_commit_free: handle	^ self		call: #(void git_annotated_commit_free #(void *handle))		options: #()! !!LGitAnnotatedCommit class methodsFor: 'ligbit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #annotated_commit_free:! !!LGitAnnotatedCommit class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromRef: anLGitReference	^ (self of: anLGitReference repository) initializeFromRef: anLGitReference ! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/24/2017 12:50:03'!annotated_commit_from_ref: ref	^ self callUnchecked: #(		int git_annotated_commit_from_ref #(			LGitAnnotatedCommit * self , 			LGitRepository repository ,			LGitReference ref)) 		options: #()! !!LGitAnnotatedCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!annotated_commit_id	 ^ self call: #(LGitId * git_annotated_commit_id #(self)) options: #()! !!LGitAnnotatedCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!id	^ self annotated_commit_id! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/24/2017 12:50:03'!initializeFromRef: anLGitReference	self withReturnHandlerDo: [ 		self annotated_commit_from_ref: anLGitReference	].	self autoRelease! !!LGitBlame class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_free: handle	^ self call: #(void git_blame_free #(void *handle)) options: #()! !!LGitBlame class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #blame_free:! !!LGitBlame class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository on: aFileReference	^ (self of: aRepository)		getForReference: aFileReference;		yourself! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_buffer: out reference: reference buffer: buffer buffer_len: buffer_len		^ self		callUnchecked:			#(FFIInt32 git_blame_buffer #(LGitBlame *self , LGitBlame reference , String buffer , size_t buffer_len))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_file: out repo: repo path: path options: options		^ self		callUnchecked:			#(int git_blame_file #(LGitBlame * self , LGitRepository repo , String path , LGitBlameOptions * options))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_get_hunk_byindex: blame index: index	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byindex #(self , uint32 index))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_get_hunk_byline: blame lineno: lineno	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byline #(self , size_t lineno))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_get_hunk_count: blame		^ self		call: #(uint32 git_blame_get_hunk_count #(self))		options: #()! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!getForReference: aFileReference	^ self withReturnHandlerDo: [		self			blame_file: self			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/)			options: LGitBlameOptions defaults ]! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hunkAt: anInteger	"use 1 based offset"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byindex: self			index: anInteger - 1)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hunkAtLineNumber: anInteger	"first line has index 1"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byline: self			lineno: anInteger)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!numberOfHunks	^ self blame_get_hunk_count: self! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!allBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_all		do: aBlock! !!LGitBranchIterator class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_iterator_free: handle		^ self		call: #(void git_branch_iterator_free #(void *handle))		options: #()! !!LGitBranchIterator class methodsFor: 'native-boost' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #branch_iterator_free:! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!localBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_local		do: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository branchType: aLGitBranchTypeEnum do: aBlock	^ (self of: aRepository)		iterate: aLGitBranchTypeEnum;		branchesDo: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!remoteBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_remote		do: aBlock! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_iterator_new: out repo: repo list_flags: list_flags		^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_iterator_new #(LGitBranchIterator * self , LGitRepository repo , LGitBranchTypeEnum list_flags))		options: #()! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_next: out out_type: out_type	^ self		call:			#(LGitReturnCodeEnum git_branch_next #(				LGitReference * out ,				LGitWriteBackValueUInt * out_type,				LGitBranchIterator self))		options: #()! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!branchesDo: aBlock	| returnCode branchType reference finishedCode isLocal |		returnCode := LGitReturnCodeEnum git_ok.	finishedCode := LGitReturnCodeEnum git_iterover.	branchType := LGitWriteBackValueUInt new.		[ 		reference := LGitReference of: self repository.		returnCode := self branch_next: reference out_type: branchType.		isLocal := branchType value = LGitBranchTypeEnum git_branch_local value.		returnCode = finishedCode 	] 	whileFalse: [ aBlock cull: reference cull: isLocal ]! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!iterate: aLGitBranchTypeEnum	self repository signalIfNotReady.	self withReturnHandlerDo: [		self			branch_iterator_new: self			repo: self repository			list_flags: aLGitBranchTypeEnum ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!author	^ author ifNil: [		author := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!author: anLGitSignature	author := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!commitId	^ commitId ifNil: [ commitId := LGitId new ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!commitId: anLGitId	commitId := anLGitId! !!LGitCommitBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_create: theCommitId repo: repo update_ref: update_ref author: theAuthor committer: theCommitter message_encoding: message_encoding message: theMessage tree: theTree parent_count: parent_count parents: parentsPointer		<todo:		'try to use original function signature instead of passing ExternalAddress as last arg'>	^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_create #(LGitId * theCommitId , LGitRepository repo , String update_ref , LGitSignature * theAuthor , LGitSignature * theCommitter , String message_encoding , String theMessage , LGitTree theTree , int parent_count , void *parentsPointer))		options: #(optCoerceNilToNull)! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committer	^ committer ifNil: [ 		committer := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committer: anLGitSignature	committer := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message	^ message ifNil: [ message := 'empty message' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message: aString	message := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!messageEncoding	^ messageEncoding ifNil: [ 'UTF-8' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!messageEncoding: aString	messageEncoding := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!parents	^ parents ifNil: [ parents := #() ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!parents: aCollection	parents := aCollection! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tree	<todo: 'use proper exceptions'>	^ tree ifNil: [ self error: 'need an existing tree here' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tree: anLGitTree	tree := anLGitTree! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!updateReference	^ updateReference! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!updateReference: aReference	updateReference := aReference! !!LGitCommitBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!writeCommit	| parentsPointer |	self withReturnHandlerDo: [ 		self assert: (self parents allSatisfy: #isReady).		parentsPointer := self parents			ifEmpty: [ ExternalAddress null ]			ifNotEmpty: [ (LGitExternalCommitArray fromCollection: self parents) getHandle ].	self withReturnHandlerDo: [ 		self			commit_create: self commitId			"libgit2 asserts the identity of this repository and the one it retrieves for the tree, so they need to be the same here"			repo: self tree owner 			update_ref: self updateReference			author: self author			committer: self committer			message_encoding: self messageEncoding			message: self message withUnixLineEndings			tree: self tree			parent_count: self parents size			parents: parentsPointer] ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!writtenCommit	<todo: 'use proper exceptions'>	commitId ifNil: [ self error: 'haven''t written the commit yet!!' ].	^ LGitCommit of: self repository fromId: self commitId! !!LGitConfig class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_free: handle	^ self		call: #(void git_config_free #(void *handle))		options: #()! !!LGitConfig class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #config_free:! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_get_string: name output: output	^ self call:			#(LGitReturnCodeEnum git_config_get_string_buf(				LGitBuf* output, 				self, 				String name))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_open_global: out	^ self call: #(int git_config_open_global("LGitConfig **"void **out, self))! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_set_bool: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_bool(				self, 				String name, 				Boolean value))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_set_string: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_string(				self, 				String name, 				String value))		options: #()! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!getString: name ifAbsent: aBlock	^ self getString: name ifPresent: #yourself ifAbsent: aBlock! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!getString: name ifPresent: presentBlock ifAbsent: absentBlock	| buf |	buf := LGitBuf new.	^ [		self config_get_string: name output: buf.		buf prim_ptr readString 			ifNotEmpty: presentBlock			ifEmpty: absentBlock	]	ensure: [ buf free ]! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!openGlobal	| outHandle |	outHandle := ExternalAddress null.	self config_open_global: outHandle.	^ (self class fromHandle: outHandle) autoRelease	! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!setBoolean: aBoolean to: varName! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!setString: name to: value	self config_set_string: name to: value! !!LGitDiff class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_free: handle		^ self call: #(void git_diff_free #(void *handle)) options: #()! !!LGitDiff class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #diff_free:! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!deltaAt: anInteger	"use 1 based offset as in Smalltalk"	^ LGitDiffDelta fromHandle: (		self			diff_get_delta: self			idx: anInteger - 1) getHandle! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffIndexToWorkDir	self diffIndexToWorkDirOptions: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffIndexToWorkDirOptions: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_index_to_workdir: self			repo: self repository			index: self repository index			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffTree: oldTree toTree: newTree	self		diffTree: oldTree		toTree: newTree		options: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffTree: oldTree toTree: newTree options: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_tree_to_tree: self			repo: self repository			old_tree: oldTree			new_tree: newTree			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_blob_to_buffer: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blob_to_buffer #(LGitBlob old_blob , String old_as_path , String buffer , size_t buffer_len , String buffer_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_blobs: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blobs (LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions *options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_buffers: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_buffers #(FFIVoid * old_buffer , size_t old_len , String old_as_path , void *new_buffer , size_t new_len , String new_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_foreach: diff file_cb: file_cb binary_cb: binary_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_foreach #(self , LGitDiffFileCallback file_cb , LGitDiffBinaryCallback binary_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_get_delta: diff idx: idx	<todo: 'use LGitDiffDelta* as return type'>		^ self		call: #(void *git_diff_get_delta #(self , size_t idx))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_get_perfdata: out diff: diff		^ self		call:			#(LGitReturnCodeEnum git_diff_get_perfdata #(LGitDiffPerfData * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_get_stats: out diff: diff		^ self		call: #(LGitReturnCodeEnum git_diff_get_stats #(LGitDiffStats * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_index_to_workdir: diff repo: repo index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_index_to_workdir #(LGitDiff * self , LGitRepository repo , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_is_sorted_icase: diff		^ self call: #(Boolean git_diff_is_sorted_icase #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_num_deltas: diff		^ self call: #(size_t git_diff_num_deltas #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_num_deltas_of_type: diff type: type		^ self		call: #(size_t git_diff_num_deltas_of_type #(self , LGitDeltaTypeEnum type))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_print: diff format: format print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_print #(self , LGitDiffFormatTypeEnum format , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_status_char: status		^ self		call: #(Character git_diff_status_char #(LGitDeltaTypeEnum status))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_index: diff repo: repo old_tree: old_tree index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_tree: diff repo: repo old_tree: old_tree new_tree: new_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_tree #(LGitDiff * diff , LGitRepository repo , LGitTree old_tree , LGitTree new_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_workdir: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_workdir_with_index: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir_with_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!filesDo: filesBlockOrNil binaryFilesDo: binaryBlockOrNil hunksDo: hunksBlockOrNil linesDo: linesBlockOrNil	^ self		diff_foreach: self		file_cb: (filesBlockOrNil 			ifNotNil: [ LGitDiffFileCallback on: filesBlockOrNil ]			ifNil: [ LGitCallback null ])		binary_cb: (binaryBlockOrNil 			ifNotNil: [ 	LGitDiffBinaryCallback on: binaryBlockOrNil ]			ifNil: [ LGitCallback null ])		hunk_cb: (hunksBlockOrNil 			ifNotNil: [ 	LGitDiffHunkCallback on: hunksBlockOrNil ]			ifNil: [ LGitCallback null ])		line_cb: (linesBlockOrNil 			ifNotNil: [ 	LGitDiffLineCallback on: linesBlockOrNil ]			ifNil: [ LGitCallback null ])		payload: ExternalAddress null! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!numberOfDeltas	^ self diff_num_deltas: self! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!patchAt: anInteger	^ LGitPatch		fromDiff: self		at: anInteger! !!LGitDiffStats class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_free: handle		^ self call: #(void git_diff_stats_free #(void *handle)) options: #()! !!LGitDiffStats class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #diff_stats_free:! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_deletions: stats		^ self		call: #(size_t git_diff_stats_deletions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_files_changed: stats		^ self		call: #(size_t git_diff_stats_files_changed #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_insertions: stats		^ self		call: #(size_t git_diff_stats_insertions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_to_buf: out stats: stats format: format width: width		^ self		call:			#(LGitReturnCodeEnum git_diff_stats_to_buf #(LGitBuffer out , self , LGitDiffStatsFormatTypeEnum format , size_t width))		options: #()! !!LGitIndex class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #index_free:! !!LGitIndex class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_free: handle		^ self call: #(void git_index_free #(void *handle)) options: #()! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addAll: pathSpecs	| pathspec |	pathspec := LGitStringArray withAll: pathSpecs.	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!allFilesStatusDo: aBlock	"The callback is passed the path of the file, the status (a combination of the git_status_t values above) and the payload data pointer passed into this function.If the callback returns a non-zero value, this function will stop looping and return that value to caller."	self withReturnHandlerDo: [ 		self			status_foreach: self repository			callback: (LGitStatusCallback on: aBlock)			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkout	self withReturnHandlerDo: [ 		self checkout_index_withOptions: 			(LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;				yourself) ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_index_withOptions: opts	^ self		call: #(LGitReturnCodeEnum 			git_checkout_index(				LGitRepository repository, 				self, 				LGitCheckoutOptions *opts))		options: #()! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!entriesSelect: aBlock	| entries |	entries := OrderedCollection new.	self allFilesStatusDo: [ :path :status :payload |		(aBlock value: path value: status) ifTrue: [ entries add: {path. status. payload} ].		0 ].		^ entries! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!entryCount	^ self index_entrycount: self! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!forceRefresh	self withReturnHandlerDo: [ 		self			index_read: self			force: true ]! !!LGitIndex methodsFor: 'hack' stamp: ' 7/24/2017 12:50:03'!hackOwner: aRepository	"There is a bug in version 0.23 of libgit2, the returned index does not have an 	 owner (a pointer to a repository), as you would expect from the documentation. 	This breaks libgit encapsulation, and will probably fail if updating to a newer 	version, but anyway if we migrate this bug should be fixed."	self flag: #fixMe. "When possible :)"	"	NOTE: is Smalltalk wordSize + 1 because the structure is something like: 	struct git_index {		git_refcount rc; 		...	}		then:		struct git_refcount { 		git_atomic refcount;		void *owner;	}		and finally: 	git_atomic = int -> 32bits	git_atomic = int64_t -> 64bits		So we need to ensure the owner is set properly.	"	self handle 		pointerAt: Smalltalk wordSize + 1		put: repository handle! !!LGitIndex methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasConflicts	^ self index_has_conflicts asBoolean! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hasEntry: aString	^ self withReturnHandlerDo: [ 		self			index_find: nil			index: self			path: aString ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_add_all: index pathspec: pathspec flags: flags callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_add_all #(				self, 				LGitStringArray *pathspec, 				uint flags, 				LGitIndexMatchedPathCallback callback, 				void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_entrycount: index		^ self call: #(size_t git_index_entrycount #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_find: at_pos index: index path: path		^ self		call:			#(LGitReturnCodeEnum git_index_find #(LGitWriteBackValueSizeT *at_pos , self, String path))		options: #(optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_has_conflicts 	^ self call: #(LGitReturnCodeEnum git_index_has_conflicts #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_owner	^ self call: #(LGitRepository * git_index_owner (LGitIndex self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_path	^ self		call: #(String git_index_path #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_read: index force: force		^ self		call: #(LGitReturnCodeEnum git_index_read #(self , Boolean force))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_remove_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_remove_all #(self, LGitStringArray * pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_update_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_update_all #(self, LGitStringArray *pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_write	^ self		call: #(LGitReturnCodeEnum git_index_write #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_write_tree: out index: index		^ self		call: #(LGitReturnCodeEnum git_index_write_tree #(LGitId * out , self))		options: #()! !!LGitIndex methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBeingTracked: aString	| intValue |	(self repository repositoryReference resolve: aString) isDirectory ifTrue: [ ^ true ].		intValue := LGitWriteBackValueUInt new.	self withReturnHandlerDo: [ 		self			status_file: intValue			repo: self repository			path: aString ].	^ (LGitStatusTypeEnum  git_status_wt_new isPartOfBitFlag: intValue value) not! !!LGitIndex methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isDirty: aFileReference	| intValue |	intValue := LGitWriteBackValueInt new.	self withReturnHandlerDo: [		self			status_file: intValue			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/) ].			^ intValue value isZero not! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self index_owner! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!path	^ self index_path! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!removeAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_remove_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_file: status_flags repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_status_file #(LGitWriteBackValueUInt status_flags, LGitRepository repo, String path))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_foreach: repo callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_status_foreach #(LGitRepository repo, LGitStatusCallback callback, void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!updateAll	| pathspec |	pathspec := LGitStringArray withAll: { '*' }.	self withReturnHandlerDo: [ 		self			index_update_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!writeToDisk	self withReturnHandlerDo: [ self index_write ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!writeTreeAndReturnOid	| oid |	oid := LGitId externalNew.	self withReturnHandlerDo: [ 		self			index_write_tree: oid			index: self ].			^ oid! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_create_frombuffer: objectId repo: repo buffer: buffer len: len		^ self		call:			#(LGitReturnCodeEnum git_blob_create_frombuffer #(LGitId * objectId , LGitRepository repo , void  *buffer , size_t len))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_create_fromdisk: objectId repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_blob_create_fromdisk #(LGitId * objectId , LGitRepository repo , FFIExternalString path))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_free: handle		^ self		call: 	#(void git_blob_free(void *handle))		options: #()! !!LGitBlob class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultFilemode	^ LGitFilemodeEnum git_filemode_blob! !!LGitBlob class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #blob_free:! !!LGitBlob class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_blob! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromExternalCollection: aCollection	| id |	self assert: (aCollection class = ByteArray or: [ aCollection class theMetaClass canUnderstand: #asExternalTypeOn: ]).	id := LGitId new.	self		blob_create_frombuffer: id		repo: aRepository		buffer: aCollection		len: aCollection size.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromFile: aFileReference	| id |	id := LGitId new.	self blob_create_fromdisk: id repo: aRepository path: aFileReference fullName.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromString: aString	^ self of: aRepository fromExternalCollection: aString! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/24/2017 12:50:03'!binaryContents	| bytes |	"freeing not required. See #rawBuffer"	bytes := ByteArray new: self rawSize.	LibC memCopy: self rawBuffer to: bytes size: bytes size.	^bytes! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_id: blob		^ self call: #(void * git_blob_id #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_is_binary: blob		^ self call: #(Boolean git_blob_is_binary #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_lookup: blob repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_blob_lookup #(LGitBlob * blob , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_rawcontent: blob		^ self call: #(void * git_blob_rawcontent #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_rawsize: blob		^ self call: #(int64 git_blob_rawsize #(self)) options: #()! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!contents	^ self isBinary		ifTrue:  [ self binaryContents ]		ifFalse: [ self rawBuffer readStringUTF8 ]		! !!LGitBlob methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self blob_id: self! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ self contents hash! !!LGitBlob methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBinary	^ self blob_is_binary: self! !!LGitBlob methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBlob	^ true! !!LGitBlob methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ self		blob_lookup: self 		repo: self repository		id: self id ].	self autoRelease! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!names	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :rootPath :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: entry filename ].		0 ].		^ names! !!LGitBlob methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self id objectPrintOn: aStream! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/24/2017 12:50:03'!rawBuffer	"freeing not required (see http://libgit2.github.com/libgit2/#HEAD/group/blob/git_blob_rawcontent)"	^ self blob_rawcontent: self! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/24/2017 12:50:03'!rawSize	^ self blob_rawsize: self! !!LGitCommit class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_free: handle		^ self call: #(void git_commit_free #(void *handle)) options: #()! !!LGitCommit class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #commit_free:! !!LGitCommit class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_commit! !!LGitCommit class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromHexString: aCommitId	^ self of: aRepository fromId: (LGitId fromHexString: aCommitId)! !!LGitCommit methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!author	^ self commit_author: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!authorStruct	^ self commit_author: self! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_author: commit		^ self		call: #(LGitSignature * git_commit_author #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_committer: commit		^ self		call: #(LGitSignature * git_commit_committer #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_id: commit		^ self call: #(void * git_commit_id #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_lookup: commit repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_lookup #(LGitCommit * commit , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_message: commit		^ self call: #(String git_commit_message #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_message_encoding: commit		^ self		call: #(String git_commit_message_encoding #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_parent_id: commit n: n	<todo: 'using LGitId * as return type causes a crash'>		^ self		call: #(void *git_commit_parent_id #(self , uint n))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_parentcount: commit		^ self call: #(uint git_commit_parentcount #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_raw_header: aCommit	^ self call: #(const char * git_commit_raw_header(self))! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_time: commit		^ self call: #(int64 git_commit_time #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_time_offset: commit		^ self call: #(int git_commit_time_offset #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_tree: tree_out commit: commit		^ self		call: #(LGitReturnCodeEnum git_commit_tree #(LGitTree *tree_out , self))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committer	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committerStruct	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString 	^ self tree entryByPath: aString! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString ifAbsent: aBlock	^ self tree entryByPath: aString ifAbsent: aBlock! !!LGitCommit methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self commit_id: self! !!LGitCommit methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasParents	^ self parents notEmpty! !!LGitCommit methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isCommit	^ true! !!LGitCommit methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isMerge	^ self parents size > 1! !!LGitCommit methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ 		self			commit_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitCommit methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!merge: anotherCommit	"Merge two commits, producing a git_index that reflects the result of the merge."	| index | 	index := LGitIndex of: self repository.	self withReturnHandlerDo: [ 		self merge_result: index commit: anotherCommit options: LGitMergeOptions defaults.	].	"There is a bug on libgit2 and we need to set the owner of the index (because it is not	setting it)"	index hackOwner: self repository.		^ index! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_result: out commit: anotherCommit options: options	^ self call: #(		LGitReturnCodeEnum git_merge_commits(			LGitIndex *out, 			LGitRepository repository, 			LGitCommit self, 			LGitCommit anotherCommit, 			LGitMergeOptions *options))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message	<todo: 'use encoding to properly read the message'>	|  encoding |	encoding := self commit_message_encoding: self.	^ self commit_message: self! !!LGitCommit methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self id hexString in: [ :hexId |		aStream			nextPutAll: (hexId first: 7);			nextPutAll: '...';			nextPutAll: (hexId last: 7);			nextPutAll: ', ';			nextPutAll: self message surroundedBySingleQuotes ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self 		call: #(void *git_commit_owner(self)) 		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!parents	| parentCount |	parentCount := self commit_parentcount: self.	^ Array		new: parentCount		streamContents: [ :stream | 			0 to: parentCount - 1 do: [ :i | 				| parentOid parent |				parentOid := LGitId fromHandle: (self commit_parent_id: self n: i) getHandle.				parent := self class of: self repository fromId: parentOid.				stream nextPut: parent ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!rawHeader 	^ self commit_raw_header: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!time	| time offset |	time := self commit_time: self.	offset := self commit_time_offset: self.	^ LGitTime new		time: time;		offset: offset;		yourself! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tree	| tree |	tree := LGitTree of: self repository.	self commit_tree: tree commit: self.	^ tree! !!LGitObject class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!classFor: aType	^ self subclasses detect: [ :class | class isType: aType ]! !!LGitObject class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #object_free:! !!LGitObject class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ self subclassResponsibility! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!newFromReference: aReference	^self of: aReference repository from: aReference targetId! !!LGitObject class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_free: handle 	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromId: id	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitObject methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!concreteObject	^ (self class classFor: self type) of: self repository fromId: self id! !!LGitObject methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self object_id: self! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!id	| data |	(id notNil or: [ self isNull ]) ifTrue: [ ^ id ].	data := self get_id_data.	id := LGitId fromHandle: data getHandle.	id internalize.	^ id	! !!LGitObject methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeWithId: gitOid	id := gitOid.	self lookup! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBlob	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isCommit	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTag	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTree	^ false! !!LGitObject methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ self		object_lookup: self 		repo: self repository		id: self id 		type: LGitObjectTypeEnum git_obj_any ]! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self id ifNil: [ ^ self ].		aStream nextPutAll: self id hexString! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_dup: dest from: source		^ self		callUnchecked: #(LGitObjectTypeEnum git_object_dup(LGitObject *dest, LGitObject source))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_id: obj		^ self		call: #(void * git_object_id #(self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_lookup: object repo: repo id: oid type: type		^ self		callUnchecked:			#(LGitReturnCodeEnum git_object_lookup #(LGitObject * object , LGitRepository repo , LGitId * oid , LGitObjectTypeEnum type))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_short_id: out		^ self		call: #(LGitObjectTypeEnum git_object_short_id(LGitBuf *out, self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_type: obj		^ self		call: #(LGitObjectTypeEnum git_object_type #(self))		options: #()! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!shortId	| buf shortId |	buf := LGitBuf new.	self object_short_id: buf.	shortId := buf prim_ptr readString.	buf free.	^shortId ! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type	^ self object_type: self! !!LGitTag class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #tag_free:! !!LGitTag class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tag! !!LGitTag class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_free: handle	^ self call: #(void git_tag_free #(void *handle)) options: #()! !!LGitTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name	^ self tag_name! !!LGitTag methodsFor: 'accesing' stamp: ' 7/24/2017 12:50:03'!object	| peeled |	peeled := LGitObject of: self repository.	self tag_peel: peeled.	^ peeled concreteObject! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_name	^ self call: #(String git_tag_name #(self)) options: #()! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_peel: result	^ self		call: #(LGitReturnCodeEnum git_tag_peel #(LGitObject * result, self))		options: #()! !!LGitTree class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultFilemode	^ LGitFilemodeEnum git_filemode_tree! !!LGitTree class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #tree_free:! !!LGitTree class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tree! !!LGitTree class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_free: handle		^ self call: #(void git_tree_free #(void *handle)) options: #()! !!LGitTree methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [ 			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitTree methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!allEntriesDo: aBlock	"The entries will be traversed in the specified order, children subtrees will be automatically loaded as required, and the callback will be called once per entry with the current (relative) root for the entry and the entry data itself.If the callback returns a positive value, the passed entry will be skipped on the traversal (in pre mode). A negative value stops the walk."	self withReturnHandlerDo: [ 		self			tree_walk: self			mode: LGitTreewalkModeEnum git_treewalk_pre			callback: (LGitTreewalkCallback on: aBlock)			payload: ExternalAddress null ]! !!LGitTree methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!entries	| entryCount |	entryCount := self tree_entrycount: self.		^ Array new: entryCount streamContents: [ :stream |		0 to: entryCount - 1 do: [ :i || entry |			entry := self tree_entry_byindex: self idx: i.			entry repository: self repository.			stream nextPut: entry ] ]! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByName: aString 	^ self entryByName: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByName: aString ifAbsent: aBlock	| entry |	entry := self tree_entry_byname: self name: aString.	(entry isNil or: [ entry isNull ])		ifTrue: [ ^aBlock value ].	entry repository: self repository.	^entry! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString 	^ self entryByPath: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString ifAbsent: aBlock	| entry |	entry := LGitTreeEntry of: self repository.	self tree_entry_bypath: entry path: aString.	^ entry isNull		ifTrue: [ aBlock value ]		ifFalse: [ 			entry repository: self repository.			entry ]! !!LGitTree methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self tree_id: self! !!LGitTree methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ super hash bitXor: self id asInteger! !!LGitTree methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isEmpty	^ self entries isEmpty! !!LGitTree methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isLeaf	^ self entries noneSatisfy: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree  ]! !!LGitTree methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTree	^ true! !!LGitTree methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [		self			tree_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!names	<todo: 'decide what to do with this:	- will not work for trees not referenced from head (e.g. in an older commit)	- very slow for large repositories because every entry is visited'>	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :name :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: name ].		0 ].		^ names! !!LGitTree methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream		nextPutAll: 'number of entries: ';		nextPutAll: self size asString! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self tree_owner: self! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!size	^ self tree_entrycount: self! !!LGitTree methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!subTreeEntries	^ self entries select: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree ]! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_byindex: tree idx: idx		^ self		call: #(LGitTreeEntry git_tree_entry_byindex #(self , size_t idx))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_byname: tree name: name		^ self		call: #(LGitTreeEntry git_tree_entry_byname #(self , String name))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_bypath: out path: path		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_bypath #(LGitTreeEntry * out, self, String path))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entrycount: tree		^ self call: #(int git_tree_entrycount #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_id: tree		^ self call: #(void * git_tree_id #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_lookup: out repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_tree_lookup #(LGitTree * out , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_owner: tree		^ self call: #(LGitRepository git_tree_owner #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_walk: tree mode: mode callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_tree_walk #(LGitTree tree , LGitTreewalkModeEnum mode , LGitTreewalkCallback callback , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_patch_free: handle		^ self call: #(void git_patch_free #(void *handle)) options: #()! !!LGitPatch class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #diff_patch_free:! !!LGitPatch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromDiff: aDiff at: anInteger	^ (self of: aDiff repository)		fromDiff: aDiff at: anInteger;		yourself! !!LGitPatch methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fromDiff: aDiff at: anInteger	"use 1 based offset as in Smalltalk"	self withReturnHandlerDo: [		self			patch_from_diff: self			diff: aDiff			idx: anInteger - 1 ].	self autoRelease! !!LGitPatch methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hunkAt: anInteger	| hunk lines |	hunk := LGitDiffHunk externalNew.	lines := LGitWriteBackValueSizeT new.	self withReturnHandlerDo: [		self			patch_get_hunk: hunk			lines_in_hunk: lines patch: self			hunk_idx: anInteger ].			^ hunk! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_blob_and_buffer: out old_blob: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blob_and_buffer #(LGitPatch * self , LGitBlob old_blob , String old_as_path , String buffer , FFIUInt32 buffer_len , String buffer_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_blobs: out old_blob: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobs #(LGitPatch * self , LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_buffers: out old_buffer: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path opts: opts	self flag: #todo. "This one doesnt seems to exist anymore. Instead I think it is git_patch_from_blob_and_buffer"	^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobuffers #(LGitPatch * self , FFIVoid * old_buffer , FFIUInt32 old_len , String old_as_path , String new_buffer , FFIUInt32 new_len , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_diff: out diff: diff idx: idx		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_diff #(LGitPatch * self , LGitDiff diff , size_t idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_get_delta: patch		^ self		call: #(LGitDiffDelta * git_patch_get_delta #(self))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx		^ self		call:			#(LGitReturnCodeEnum git_patch_get_hunk #(				LGitDiffHunk **out , 				LGitWriteBackValueSizeT *lines_in_hunk, 				LGitPatch *patch, 				size_t hunk_idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_get_line_in_hunk: out patch: patch hunk_idx: hunk_idx line_of_hunk: line_of_hunk		^ self		call:			#(LGitReturnCodeEnum git_patch_get_line_in_hunk #(LGitDiffLine * out , self , size_t hunk_idx , size_t line_of_hunk))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_print: patch print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_patch_print #(self , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printDiff	^ String new: 500 streamContents: [ :stream |		self printDiffOn: stream ]! !!LGitPatch methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!printDiffOn: aStream	| callback |	callback := LGitDiffLineCallback on: [ :delta :hunk :line :payload |		aStream nextPutAll: line content. 0 ].		self withReturnHandlerDo: [		self			patch_print: self			print_cb: callback			payload: nil ]! !!LGitPathSpecMatchList class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #pathspec_match_list_free:! !!LGitPathSpecMatchList class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!pathspec_match_list_free: handle		^ self		call: #(void git_pathspec_match_list_free #(void *handle))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!pathspec_match_diff: out diff: diff flags: flags ps: ps		^ self		callUnchecked:			#(int git_pathspec_match_diff #(LGitPathSpecMatchList * self , LGitDiff diff , LGitPathSpecFlagTypeEnum flags , LGitPathSpec ps))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!pathspec_match_list_diff_entry: m pos: pos		^ self		call:			#(LGitDiffDelta git_pathspec_match_list_diff_entry #(LGitPathSpecMatchList m , size_t pos))		options: #()! !!LGitReference class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #reference_free:! !!LGitReference class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_free: handle	^ self		call: #(void git_reference_free #(void *handle))		options: #()! !!LGitReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	self class == anObject class ifFalse: [ ^ false ].		^ self == anObject or: [		(self 			reference_cmp: self 			ref2: anObject) = LGitReturnCodeEnum git_ok  ]	! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!annotatedCommit	^ LGitAnnotatedCommit fromRef: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!basename	^ self name copyAfterLast: $/! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_is_head: branch		^ self call: #(int git_branch_is_head #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_set_upstream: upstream	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_set_upstream #(self , String upstream))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_upstream: out local: local	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_upstream #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createDirect: nameString target: aGitId force: aBoolean	self withReturnHandlerDo: [ 		self			reference_create: self			repo: self repository			name: nameString			id: aGitId			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createSymbolic: nameString target: targetString force: aBoolean	self withReturnHandlerDo: [ 		self			reference_symbolic_create: self			repo: self repository			name: nameString			target: targetString			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!initializeOn: aHandle in: aRepo	handle := aHandle.	self repository: aRepo.! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBranch	^ (self reference_is_branch: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isDirect	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_oid! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isHead	^ (self branch_is_head: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isLocal	^ self reference_is_remote not! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isSymbolic	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_symbolic! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTag	^ self reference_is_tag = 1! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name	^ self reference_name: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object	self isDirect 		ifFalse: [ ^ self resolve object ].	^(LGitObject of: self repository fromId: self targetId) concreteObject! !!LGitReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self name surroundedBySingleQuotes! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self call: #(void * git_reference_owner #(self)) options: #()! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!pushUpstream	| pushRemote | 	^ self repository config 		getString: 'remote.pushDefault'		ifPresent: [ :pushRemoteName |			self repository 				lookupBranch: self upstream basename				inRemote: pushRemoteName ]		ifAbsent: [ self upstream ]! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_cmp: ref1 ref2: ref2		^ self		call: #(LGitReturnCodeEnum git_reference_cmp #(self , LGitReference ref2))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_create: out repo: repo name: name id: id force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_create #(LGitReference * self , LGitRepository repo , String name , LGitId * id , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_is_branch: ref		^ self call: #(int git_reference_is_branch #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_is_remote	^ self call: #(Boolean git_reference_is_remote #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_is_tag		^ self call: #(int git_reference_is_tag #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * self , LGitRepository repo , String name))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_name: ref		^ self call: #(String git_reference_name #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_resolve: out ref: ref		^ self		callUnchecked: #(LGitReturnCodeEnum git_reference_resolve #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_set_target: out ref: ref id: id log_message: log_message		^ self		call:			#(LGitReturnCodeEnum git_reference_set_target #(LGitReference * out , self , LGitId * id , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_symbolic_create: out repo: repo name: name target: target force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_create #(LGitReference * self , LGitRepository repo , String name , String target , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_symbolic_set_target: out ref: ref target: target log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_set_target #(LGitReference * self , LGitReference ref , String target , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_target: ref	<todo: 'using LGitId* as return value causes random crashes'>		^ self call: #(void * git_reference_target #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_type: ref		^ self		call: #(LGitReferenceTypeEnum git_reference_type #(self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!resolve	| resolved |	self isDirect 		ifTrue: [ ^ self ].	resolved := self class of: self repository.	self withReturnHandlerDo: [ self reference_resolve: resolved ref: self ].	^ resolved! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setTarget: aReference	self setTargetId: aReference object id! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setTargetId: aGitId	| newRef |	newRef := LGitReference of: self repository.	self		withReturnHandlerDo: [ 			self				reference_set_target: newRef				ref: self				id: aGitId				log_message: 'set ' , self name , ' to ' , aGitId hexString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setUpstream: upstreamName	self withReturnHandlerDo: [		self branch_set_upstream: upstreamName	]! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!shortName	^ self isLocal 		ifTrue: [ self basename ]		ifFalse: [ self name withoutPrefix: 'refs/remotes/']! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!targetId	| data oId |	data := self reference_target: self.	data getHandle isNull		ifTrue: [ ^ nil ].	oId := LGitId fromExternalAddress: data.	oId internalize.	^ oId! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!upstream	| upstream | 	upstream  := self class of: self repository.	[ self withReturnHandlerDo: [		self branch_upstream: upstream local: self	]] 	on: LGit_GIT_ENOTFOUND do: [ ^ nil ].	^ upstream! !!LGitRemote class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!credentials	^ Credentials ifNil: [ Credentials := SmallDictionary new ]! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/24/2017 12:50:03'!credentialsPlaintext	^ LGitCredentialsPlaintext		username: self username		passphrase: self password! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/24/2017 12:50:03'!credentialsSsh	^ LGitCredentialsSSH		username: self usernameSsh		passphrase: self keyPassPhrase		publicKeyReference: self keyFilePublicPath asFileReference		privateKeyReference: self keyFilePrivatePath asFileReference! !!LGitRemote class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #remote_free:! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePrivatePath	^ self credentials		at: #keyFilePrivatePath		ifAbsentPut: [ UIManager default request: 'Path to your private key file (/home/foo/.ssh/key)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePrivatePath: aString	self credentials		at: #keyFilePrivatePath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePublicPath	^ self credentials		at: #keyFilePublicPath		ifAbsentPut: [ UIManager default request: 'Path to your public key file (/home/foo/.ssh/key.pub)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePublicPath: aString	self credentials		at: #keyFilePublicPath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyPassPhrase	^ self credentials		at: #keyPassPhrase		ifAbsentPut: [ UIManager default request: 'Passphrase of your private key file?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyPassPhrase: aString	self credentials		at: #keyPassPhrase		put: aString! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository named: aString	^ self of: aRepository named: aString url: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository named: nameString url: urlString	^ self		of: aRepository		named: nameString		url: urlString		fetchSpec: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository named: nameString url: urlString fetchSpec: aRefSpec	^ (self of: aRepository)		remoteName: nameString;		url: urlString;		fetchSpec: aRefSpec;		yourself! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!password	^ self credentials		at: #password		ifAbsentPut: [ UIManager default request: 'What''s the password for your account?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!password: aString	self credentials		at: #password		put: aString! !!LGitRemote class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_free: handle		^ self call: #(void git_remote_free #(void *handle)) options: #()! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!resetCredentials	Credentials := nil! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!username	^ self credentials		at: #username		ifAbsentPut: [ UIManager default request: 'What''s your account name?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!username: aString	self credentials		at: #username		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!usernameSsh	^ self credentials		at: #usernameSsh		ifAbsentPut: [ 			UIManager default 				request: 'What''s your username for SSH (probably "git")?'				initialAnswer: 'git' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!usernameSsh: aString	self credentials		at: #usernameSsh		put: aString! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addFetch	self withReturnHandlerDo: [ 		self			remote_add_fetch: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addPush	self withReturnHandlerDo: [ 		self			remote_add_push: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!connectFetch	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: LGitRemoteCallbacks defaults ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!connectFetchWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!connectPushWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_push			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!create	<todo: 'use exceptions instead of assertions'>	self assert: url notNil.	self assert: self repository isReady.		[ self hasFetchSpec		ifFalse: [ self createWithoutSpec ]		ifTrue: [ self createWithFetchSpec ] ]			on: LGit_GIT_EEXISTS			do: [ "all good then" ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createWithFetchSpec	self withReturnHandlerDo: [ 		self			remote_create_with_fetchspec: self			repo: self repository			name: self remoteName			url: self url			fetch: self fetchSpec ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createWithoutSpec	self withReturnHandlerDo: [ 		self			remote_create: self			repo: self repository			name: self remoteName			url: self url ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!delete	self withReturnHandlerDo: [		self			remote_delete: self repository			name: self remoteName ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetch	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks: LGitRemoteCallbacks defaults;				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchSpec	^ fetchSpec! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchSpec: aRefSpec	fetchSpec := aRefSpec! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchWithCredentials: aCredentialsProvider	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks:(LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchWithMessage: aString	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: LGitFetchOptions defaults			reflog_message: aString ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchWithMessage: aString credentials: aCredentialsProvider 	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: (LGitFetchOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: aString ]! !!LGitRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasFetchSpec	^ self fetchSpec notNil ! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ 		self			remote_lookup: self			repo: self repository			name: self remoteName.		self url: self remote_url ].	self flag: #todo. "shouldn't be autoreleased?"! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!ls	"I list all HEADS in connected remotes (you will need to #connectFetch or 	#connectPushWithCredentials: first)"	| out sizeBuf heads size |		sizeBuf := ByteArray new: FFISizeT externalTypeSize.	out := ExternalAddress new.		self withReturnHandlerDo: [ 		self remote_ls: out size: sizeBuf ].		size := sizeBuf signedLongAt: 1.	heads := Array new: size. 	1 to: size do: [ :index | 		heads at: index put: (LGitRemoteHead fromHandle: (out pointerAt: 1)).		out := out + FFIExternalType pointerSize ].		^ heads! !!LGitRemote methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self remoteName! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pullWithFetchOptions: fetchOptions	<todo: 'check for conflicts'>	self repository isReady ifFalse: [  ^ self ].	self lookup.		self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: fetchOptions			reflog_message: 'automatic pull from libgit2' ].		"assume that there are no conflicts and fast-forwad to FETCH_HEAD"	self repository fastForward! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushWithRefSpec: aRefSpec pushOptions: pushOptions	| refspecs return |	refspecs := LGitStringArray withAll: { aRefSpec asString }.	return := self withReturnHandlerDo: [		self			remote_push: self			refspecs: refspecs			opts: pushOptions ].			^ return! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!refSpecs 	| specs |	specs := LGitStringArray externalNew autoRelease.	self withReturnHandlerDo: [ 		self remote_get_fetch_refspecs: specs ].	^ specs strings! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteName	^ remoteName! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteName: aString	remoteName := aString! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_add_fetch: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_fetch #(LGitRepository repo , String remote String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_add_push: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_push #(LGitRepository repo , String remote , String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_connect: remote direction: direction callbacks: remoteCallbacks		^ self		call:			#(LGitReturnCodeEnum git_remote_connect #(self , LGitDirectionEnum direction , LGitRemoteCallbacks * remoteCallbacks))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_create: out repo: repo name: name url: urlString		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create #(LGitRemote * self , LGitRepository repo , String name , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_create_with_fetchspec: out repo: repo name: name url: urlString fetch: fetch		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create_with_fetchspec #(LGitRemote * self , LGitRepository repo , String name , String urlString , String fetch))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_delete: repo name: name		^ self		call:			#(LGitReturnCodeEnum git_remote_delete #(LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_fetch: remote refspecs: refspecs opts: opts reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_fetch #(self , void * refspecs , LGitFetchOptions * opts , String reflog_message))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_get_fetch_refspecs: array	^ self call: #(int git_remote_get_fetch_refspecs(LGitStringArray *array, self))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_lookup #(LGitRemote * self , LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_ls: out size: size	"	Since I will take a lost of addresses, I'm interested on 2nd level of 'out', that's why 	I transform `const git_remote_head ***out` into `void **out`	This is the original function: 		int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)"	^ self call: #( LGitReturnCodeEnum git_remote_ls ( void **out, size_t *size, self ))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_push: remote refspecs: refspecs opts: opts		^ self		call:			#(LGitReturnCodeEnum git_remote_push #(self , LGitStringArray * refspecs , LGitPushOptions * opts))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_set_url: repo remote: remote url: urlString		^ self		call:			#(LGitReturnCodeEnum git_remote_set_url #(LGitRepository repo , String remote , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_update_tips: remote callbacks: remoteCallbacks update_fetchhead: update_fetchhead download_tags: download_tags reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_update_tips #(self , LGitRemoteCallbacks * remoteCallbacks , Boolean update_fetchhead , LGitRemoteAutotagOptionTypeEnum download_tags , String reflog_message))		options: #(optStringOrNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_url	^ self		call: #(String git_remote_url #(self))		options: #()! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setUrl: aString	self withReturnHandlerDo: [ 		self			remote_set_url: self repository			remote: self remoteName			url: aString]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!url	^ url! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!url: aString	url := aString! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!new	self error: 'Use #of: to create an instance of ', self name! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository	^ self basicNew		initialize;		repository: aRepository;		yourself! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!repository	^ repository! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!repository: aRepository	repository := aRepository! !!LGitRevwalk class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #revwalk_free:! !!LGitRevwalk class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository	^ (super of: aRepository)		createNew;		yourself! !!LGitRevwalk class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_free: handle		^ self call: #(void git_revwalk_free #(void *handle)) options: #()! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!basicNext	"Note: in the C code you would check the return code to see when the loop is over.	This method uses instances variables to enable more Smalltalk like looping:	[ walk hasNext ] whileTrue: [ walk next ]."	| previousCommit nextId |	previousCommit := currentCommit.	nextId := self basicNextObjectId.	currentCommit := self hasNext		ifTrue: [			LGitCommit				of: self repository				fromId: nextId ]		ifFalse: [ nil ].		^ previousCommit! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!basicNextObjectId	| nextId returnCode |	nextId := LGitId new.	returnCode := self		revwalk_next: nextId		walk: self.	(returnCode ~= LGitReturnCodeEnum git_iterover and: [ 		returnCode ~= LGitReturnCodeEnum git_ok ]) ifTrue: [ returnCode handleLGitReturnCode ].	hasNext := returnCode ~= LGitReturnCodeEnum git_iterover.		^ nextId! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!basicSort: sortingEnum	sorting := sorting		ifNil: [ sortingEnum value ]		ifNotNil: [ sorting bitOr: sortingEnum value ].			self withReturnHandlerDo: [		self			revwalk_sorting: self			sort_mode: sorting ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!beSortedByCommitTime	self basicSort: LGitRevwalkSortTypeEnum git_sort_time! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!beSortedParentsBeforeChildren	self basicSort: LGitRevwalkSortTypeEnum git_sort_topological! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!beSortedReverse	self basicSort: LGitRevwalkSortTypeEnum git_sort_reverse! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createNew	self withReturnHandlerDo: [		self			revwalk_new: self			repo: self repository ]! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:03'!do: aBlock	[ self hasNext ] whileTrue: [ 		aBlock value: self next	]! !!LGitRevwalk methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasNext	^ hasNext ifNil: [		self basicNext.		hasNext ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hideCommit: aLGitId	self withReturnHandlerDo: [ self revwalk_hide: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hideReference: aReference	self withReturnHandlerDo: [		self			revwalk_hide_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!next	self hasNext ifFalse: [ ^ LGit_GIT_ITEROVER signal ].		^ self basicNext! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushCommit: aLGitId 	self withReturnHandlerDo: [ self revwalk_push: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushHead	self withReturnHandlerDo: [ self revwalk_push_head: self ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushReference: aReference	self withReturnHandlerDo: [		self			revwalk_push_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!reset	self withReturnHandlerDo: [ self revwalk_reset: self ]! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_hide: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_hide #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_hide_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_hide_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_revwalk_new #(LGitRevwalk * self , LGitRepository repo))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_next: out walk: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_next #(LGitId * out , self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_push: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_push #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_push_head: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_push_head #(self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_push_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_push_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_reset: revwalk		^ self call: #(void git_revwalk_reset #(self)) options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_sorting: walk sort_mode: sort_mode		^ self		call: #(void git_revwalk_sorting #(self , uint sort_mode))		options: #()! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:03'!select: selectionBlock thenDo: actionBlock	self do: [ :result | 		(selectionBlock value: result) 			ifTrue: [ actionBlock value: result ] ]! !!LGitStatusList class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #status_list_free:! !!LGitStatusList class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_list_free: handle		^ self		call: #(void git_status_list_free #(void *handle))		options: #()! !!LGitStatusList methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_list_get_perfdata: out status: status		^ self		call:			#(LGitReturnCodeEnum git_status_list_get_perfdata #(LGitPerfData * out , self))		options: #()! !!LGitTreeBuilder class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #treebuilder_free:! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromTree: aTree	self validate: aTree shouldBe: LGitTree.	^ self of: aTree repository fromTree: aTree! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: repository fromTree: aTree	^ (self of: repository)		initializeWithTree: aTree;		yourself! !!LGitTreeBuilder class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_free: handle		^ self		call: #(void git_treebuilder_free #(void *handle))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addEntry: aLGitObject filename: aString	self 		addEntryWithId: aLGitObject id 		filename: aString 		filemode: aLGitObject class defaultFilemode! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addEntryWithId: oidStruct filename: aString filemode: anInteger	self withReturnHandlerDo: [ 			self				treebuilder_insert: (LGitTreeEntry of: self repository)				bld: self				filename: aString				id: oidStruct				filemode: anInteger ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!clear	self treebuilder_clear: self! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createNew	self withReturnHandlerDo: [ 		self 			treebuilder_new: self			repo: self repository			source: self ffiNull handle ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!getEntryNamed: aString	| entry |	entry := self		treebuilder_get: self		filename: aString.	entry repository: self repository.		^ entry! !!LGitTreeBuilder methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeWithTree: aTree	self withReturnHandlerDo: [		self			treebuilder_new: self			repo: self repository			source: (aTree ifNotNil: #handle) ]! !!LGitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newTree	^ LGitTree of: self repository fromId: self write! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_clear: bld		^ self call: #(void git_treebuilder_clear #(self)) options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_get: bld filename: filename		^ self		call: #(LGitTreeEntry git_treebuilder_get #(self , String filename))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_insert: out bld: bld filename: filename id: id filemode: filemode		^ self		call:			#(LGitReturnCodeEnum git_treebuilder_insert #(LGitTreeEntry * out , self , String filename , LGitId * id , LGitFilemodeEnum filemode))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_new: out repo: repo source: source	^ self		callUnchecked:			#(LGitReturnCodeEnum git_treebuilder_new #(LGitTreeBuilder * out , LGitRepository repo , void * source))		options: #(+ optCoerceNilToNull)! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_write: id bld: bld		^ self		call: #(LGitReturnCodeEnum git_treebuilder_write #(LGitId * id , self))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!write	| id errorCode |	id := LGitId new.	errorCode := self		treebuilder_write: id		bld: self.			errorCode ~= 0 ifTrue: [ LGitWritingTreeFailed ].		^ id! !!LGitTreeEntry class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #tree_entry_free:! !!LGitTreeEntry class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_free: handle		^ self		call: #(void git_tree_entry_free #(void *handle))		options: #()! !!LGitTreeEntry methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [		self class == anObject class and: [ 			self isReady and: [ 				anObject isReady and: [ 					self compare: anObject ] ] ] ]! !!LGitTreeEntry methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!compare: aTreeEntry	^ (self		tree_entry_cmp: self		e2: aTreeEntry) isZero! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!entries	^ self object entries! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString 	^ self object entryByPath: aString! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString ifAbsent: aBlock	^ self object entryByPath: aString ifAbsent: aBlock! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fileMode	^ self tree_entry_filemode: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!filename	^ self tree_entry_name: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object	| object |	object := (LGitObject classFor: self type) of: self repository.	self withReturnHandlerDo: [		self			tree_entry_to_object: object			repo: self repository			entry: self ].			^ object! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!objectId	^ LGitId fromExternalAddress: (self tree_entry_id: self)! !!LGitTreeEntry methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream 	aStream nextPutAll: self filename surroundedBySingleQuotes! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!subTreeEntries	^ self object subTreeEntries! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_cmp: e1 e2: e2		^ self		call: #(int git_tree_entry_cmp #(self , LGitTreeEntry e2))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_filemode: entry		^ self		call: #(LGitFilemodeEnum git_tree_entry_filemode #(self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_id: entry		^ self call: #(void * git_tree_entry_id #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_name: entry		^ self call: #(String git_tree_entry_name #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_to_object: object_out repo: repo entry: entry		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_to_object #(LGitObject * object_out , LGitRepository repo , self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_type: entry		^ self		call: #(LGitObjectTypeEnum git_tree_entry_type #(self))		options: #()! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type	^ self tree_entry_type: handle! !!LGitWriteBackValue class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isAbstract	^ self == LGitWriteBackValue! !!LGitWriteBackValueInt class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!typeDecl	^ 'int'! !!LGitWriteBackValueSizeT class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!typeDecl	^ 'size_t'! !!LGitWriteBackValueUInt class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!typeDecl	^ 'uint'! !!LGitAbstractError class methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalWith: anObject	^ self new		object: anObject;		signal;		yourself! !!LGitAbstractError methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initialize	super initialize.	self messageText: LGitError lastMessage! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object	^ object! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object: anObject	object := anObject! !!LGitCallError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isAbstract	^ self == LGitCallError! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!canHandle: aReturnCode	^ self handledReturnCodes anySatisfy: [ :symbol | 		aReturnCode symbol = symbol ]! !!LGitCallReturnHandler class methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!for: aReturnCode	^ (self allSubclasses reject: #isAbstract)		detect: [ :class | class canHandle: aReturnCode ]		ifNone: [ LGitNoReturnCodeHandlerDefined signal ]! !!LGitCallReturnHandler class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!handledReturnCodes	^ { (self name allButFirst: 5) asLowercase asSymbol }! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isAbstract	^ self == LGitCallReturnHandler! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isError	^ true! !!LGitCallReturnHandler class methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalWith: anError	^ self new		messageText: anError message;		object: anError type;		signal;		yourself! !!LGit_GIT_ITEROVER methodsFor: 'signaling' stamp: ' 7/24/2017 12:50:03'!signal	"don't signal, everything is fine"	^ self! !!LGit_GIT_OK class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isError	^ false! !!LGit_GIT_OK methodsFor: 'signaling' stamp: ' 7/24/2017 12:50:03'!signal	"don't signal, everything is fine"	^ self! !!LGitIllegalArgument class methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalWith: anObject shouldBe: aClass	^ self new		object: anObject;		expectedClass: aClass;		signal;		yourself! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!expectedClass	^ expectedClass! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!expectedClass: anObject	expectedClass := anObject! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!messageText	^ 'libgit2 ffi call expects a(n) {1} but instead received {2}'			format: {self expectedClass. self object}! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!rejectClasses^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!rejectRules^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!ruleIfTrueBlocksRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitExternalObject #ifNotReady: #false)) #'2014-11-14T16:52:32.831129+01:00') )! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!ruleIfTrueReturnsRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.91457+01:00') #(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.915066+01:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:03'!ruleRBAbstractClassRuleV1FalsePositive^ #(#(#(#RGMetaclassDefinition #(#'LGitExternalEnumerationUInt32 class' #LGitExternalEnumerationUInt32)) #'2015-07-18T14:21:49.402159+02:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:03'!ruleRBNoClassCommentRuleV1FalsePositive^ #(#(#(#RGClassDefinition #(#LGitPushOptions)) #'2015-07-17T12:59:06.388548+02:00') )! !!LGitBufferSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void **out, LGitDiffFile *file, char *buf, size_t buflen, void *payload))! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!null	^ self new initializeNull! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!on: aBlock	^ self 		signature: self fnSpec 		block: aBlock ! !!LGitCallback methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!initializeNull	thunk := ExternalAddress null! !!LGitCheckoutNotifyCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitCheckoutNotifyTypeEnum why, String path, LGitDiffFile *baseline, LGitDiffFile *target, LGitDiffFile *workdir, void *payload))! !!LGitCheckoutPerfDataCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(void (LGitCheckoutPerfData *perfdata, void *payload))! !!LGitCheckoutProgressCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(void (String path, size_t completed_steps, size_t total_steps, void *payload))! !!LGitCompletionCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitRemoteCompletionTypeEnum type, void *argument))! !!LGitCredAcquireCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitCredentials **cred, String url, String username_from_url, uint allowed_types, void *data))! !!LGitCredAcquireCallback methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitCredAcquireCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aBlock	^[ :credAddress :url :username_from_url :allowed_types :data |		aBlock valueWithArguments: (Array			with: (LGitCredentials fromHandle: credAddress) 			with: url			with: username_from_url			with: allowed_types 			with: data) ]! !!LGitDiffBinaryCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffBinary *binary, void *payload))! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :binary :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffBinary fromHandle: binary) 			value: payload ]! !!LGitDiffFileCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta * delta, float progress, void *payload))! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :progress :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: progress			value: payload ]! !!LGitDiffHunkCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, void *payload))! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aBlock	^[ :deltaAddress :hunkAddress :payload |		aBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: payload ]! !!LGitDiffLineCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, LGitDiffLine *line, void *payload))! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aFourArgBlock	^[ :deltaAddress :hunkAddress :lineAddress :payload |		aFourArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: (LGitDiffLine fromHandle: lineAddress)			value: payload ]! !!LGitDiffNotifyCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiff *diff_so_far, LGitDiffDelta *delta_to_add, String matched_pathspec, void *payload))! !!LGitFileSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void **out, LGitDiffFile *file, String fullpath, void *payload))! !!LGitFreeSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(void (void *sig, void *payload))! !!LGitIndexMatchedPathCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (String path, String matched_pathspec, void *payload))! !!LGitPackbuilderForeachCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (void *buffer, int length, void *payload))! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aBlock	^[ :buffer :length :payload |		aBlock 			value: buffer 			value: length			value: payload ]! !!LGitPackbuilderProgressCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (int stage, uint32 current, uint32 total, void *payload))! !!LGitPushNegotiationCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (LGitPushUpdate **updates, size_t len, void *payload))! !!LGitPushStatusForeachCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (char *arg1, char *arg2, void *arg3))! !!LGitPushTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (uint current, uint total, size_t bytes, void *payload))! !!LGitPushUpdateReferenceCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (String refname, String status, void *data))! !!LGitRemoteCreateCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void **out, LGitRepository repo, String name, String url, void *payload))! !!LGitRepositoryCreateCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (LGitRepository **out, String path, Boolean bare, void *payload))! !!LGitSimilarityCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (int *score, void *siga, void *sigb, void *payload))! !!LGitStatusCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (String path, uint status_flags, void *payload))! !!LGitTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitTransferProgress *stats, void *payload))! !!LGitTransportCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int git_transport_cb(LGitTransport *out, LGitRemote owner, void *param))! !!LGitTransportCertificateCheckCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void *cert, int valid, String host, void *payload))! !!LGitTransportMessageCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (String str, int len, void *payload))! !!LGitTreewalkCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (String name, LGitTreeEntry entry, void *payload))! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aThreeArgBlock	^[ :rootPath :entryAddress :payload |		aThreeArgBlock 			value: rootPath 			value: (LGitTreeEntry fromHandle: entryAddress)			value: payload ]		! !!LGitUpdateTipsCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (String refname, LGitId *a, LGitId *b, void * data))! !!LGitLibrary class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!initialize	"Required to reset the Initialized flag on image startup"	Smalltalk addToStartUpList: self! !!LGitLibrary class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isInitialized	"Answer true when git_libgit2_init has been called in the current session."	^ Initialized ifNil: [ false ]! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/24/2017 12:50:03'!shutDown: quitting	quitting ifFalse: [ ^ self ].	self isInitialized ifFalse: [ ^self ].	self uniqueInstance shutdownLibGit2.! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/24/2017 12:50:03'!startUp: isImageStarting	isImageStarting		ifTrue: [ Initialized := false ]! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeLibGit2	self libgit2_init.	Initialized := true! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_features	"Query compile time options for libgit2."		^self ffiCall: #(int git_libgit2_features())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_featuresAlt	"Query compile time options for libgit2."		| fnc |		fnc := ExternalLibraryFunction		name: 'git_libgit2_features'		module: 'libgit2.0.dylib'		callType: 0		returnType: FFIInt32 new externalTypeWithArity		argumentTypes: {}.			^fnc invokeWithArguments: { }! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_init	^self ffiCall: #(int git_libgit2_init())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_shutdown	^self ffiCall: #(int git_libgit2_shutdown())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_version: major minor: minor rev: rev	"Return the version of the libgit2 library being currently used."	^self ffiCall: #(void git_libgit2_version(LGitWriteBackValueInt major, LGitWriteBackValueInt minor, LGitWriteBackValueInt rev))! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/24/2017 12:50:03'!macModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent / 'Plugins'.	#('libgit2.dylib' 'libgit2.0.dylib')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!shutdownLibGit2	| initsRemaining |		initsRemaining := self libgit2_shutdown.	initsRemaining <= 0		ifTrue: [ Initialized := false ].	^ initsRemaining! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/24/2017 12:50:03'!unixModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent.	#('libgit2.so' 'libgit2.so.0')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!version	"self uniqueInstance version"	| major minor rev |		major := LGitWriteBackValueInt new.	minor := LGitWriteBackValueInt new.	rev := LGitWriteBackValueInt new.		self libgit2_version: major minor: minor rev: rev.	^Array with: major value with: minor value with: rev value! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/24/2017 12:50:03'!win32ModuleName	^ 'libgit2.dll'! !!LGitExternalStructureFieldParser methodsFor: 'parsing' stamp: ' 7/24/2017 12:50:03'!parseFields: fields structure: structClass	| stream type fieldName generator |		stream := fields readStream.	generator := FFICallout new requestor: structClass.	fieldSpec := FFIExternalStructureFieldSpec new.	[ stream atEnd ] whileFalse: [ | arity |		type := generator resolveType: stream next. 		arity := 0.		[stream peek = #* ] whileTrue: [			arity := arity + 1.			stream next ].		type pointerArity: arity.				fieldName := ('prim_', stream next) asSymbol.		fieldName isSymbol ifFalse: [ self error: 'invalid field name'].		(fieldSpec fieldNames includes: fieldName) ifTrue: [ self error: 'duplicate field name' ].		"align := type typeSize min: byteAlign." "if byte align == 1, struct is packed"		"add padding between fields, if needed"		"self sizeAlignedTo: align with: type." 		fieldSpec addField: fieldName type: type. 			stream peek == #';' ifTrue: [ stream next ]].		^ self fieldSpec! !!LGitSafeFFICalloutMethodBuilder methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!generateFFICallout: builder spec: functionSpec	"Before the actual ffi call generate a check to see if the object is ready."	builder 		pushReceiver;		send: #signalIfNotReady.	^ super generateFFICallout: builder spec: functionSpec! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!objectPrintOn: aStream! !!Trait method!objectPrintOn: aStream! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !"LibGit-Core"!!TIceRepositoryBackend commentStamp: 'NicoPasserini 7/4/2016 17:39' prior: 0!Common functionality for Ice repository backends.!!IceMCVersionInfo commentStamp: 'NicoPasserini 9/7/2016 15:19' prior: 0!Adapter to produce an MCVersionInfo that knows how to (lazily) load ancestors from an Iceberg repository.!!ManifestIceberg commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!IceError commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!Base class for all errors in Iceberg.!!CannotIdentifyVersionForCommit commentStamp: 'NicoPasserini 7/26/2016 14:05' prior: 0!This error is signaled when looking for a version in a commit (and its ancestry) has found two versions and can not decide which of them is the desired one. This should not happen if the repository is consistent.!!IceDuplicatedRepository commentStamp: 'NicoPasserini 8/3/2016 14:50' prior: 0!When trying to create a repository I found another one with a conflicting location (i.e. the same director on disk).!!IceGitUsernameOrEmailNotFound commentStamp: '<historical>' prior: 0!I'm an error to be sent when the error that comes from external library can be guessed to be the absense of user.name and user.mail properties.!!IceLocalRepositoryMissing commentStamp: 'NicoPasserini 10/4/2016 17:44' prior: 0!The repository code directory does not exist, maybe because the image was moved. Default action is to clone the repository again, but signal an error and allow for other components to react accordingly.!!IceMergeAborted commentStamp: 'NicoPasserini 8/9/2016 16:35' prior: 0!Attempting to merge arised a conflict so merge was aborted.!!IceMissingRepositoryEntry commentStamp: 'NicoPasserini 11/28/2016 14:05' prior: 0!Directory does not exist in the specified version in the repository.!!IceNoRemoteBranch commentStamp: 'NicoPasserini 8/3/2016 14:51' prior: 0!The operation you tried (for example push) requires that your branch has a configured upstream (something like origin/branchName), but is has none.!!IceVersionDoesNotExist commentStamp: 'NicoPasserini 11/28/2016 14:39' prior: 0!Version does not exist, probably the package was created in a later commit or it was deleted.!!IceWrongUrl commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!We can not parse the origin URL you have introduced. Maybe you made a typo, or maybe we do not support that kind of URLs.!!IceRepositoryAnnouncement commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Groupes different announcements that can happen in a repository.!!IceCommited commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has commited.!!IcePushed commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has been pushed.!!IceRepositoryModified commentStamp: 'NicoPasserini 10/5/2016 15:56' prior: 0!Announces an unspecified change to a repository.!!IceAbstractCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:25' prior: 0!Base class for shared code between different commit walk implementations.!!IceAbstractDiff commentStamp: 'NicoPasserini 5/12/2016 17:23' prior: 0!Parent class for any comparison between two versions of the code (working copy, commit or other) and comprising any level of granularity (a whole repository, a package, a class, etc.).!!IceChangeSet commentStamp: 'NicoPasserini 5/9/2016 18:11' prior: 0!I represent a (maybe unitary) set of changes to be handled by the Iceberg framework. I am the top class of a composite pattern.A change should be defined as1. the difference between two versions of the code (currently two MCSnapthots for an IcePackageChangeSet)2. a filter from a bigger change set (for example we can create a class change set which is a subset of a package change set, all other subclasses from IceStructuralChangeSet).3. an explicit set of changes (see IceSimpleChangeSet).Public API and Key Messages- elements: returns a set of change sets which are my children, for example the change set related to a package contains the change sets for each class in the package.- (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	elements:		<Object>    Implementation Points!!IcePackageChangeSet commentStamp: 'NicoPasserini 5/12/2016 17:32' prior: 0!Provides a filtered version of a diff, restricted to a package.!!IceDiff commentStamp: 'NicoPasserini 5/12/2016 17:10' prior: 0!I model (and track) the diff between the working copy and the last commit in a given repository.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!IceAbstractVersion commentStamp: 'NicoPasserini 10/20/2016 15:48' prior: 0!Base class for different types of versions, namely: IceVersion (normal versions) and IceForeignVersion (versions not managed by Ice).!!IceForeignVersion commentStamp: 'NicoPasserini 9/14/2016 18:01' prior: 0!Place holder for an Iceberg version. When you get an instance of me instead of a real ice package version, this means that we can not correlate the current version of the code loaded into the image with a version in the corresponding Iceberg repository.!!IceSavedPackageVersion commentStamp: 'NicoPasserini 9/26/2016 11:11' prior: 0!A version of a package as saved in a repository. We have one of this for each commit in a repository which modifies the specified package.Internal representation- commit is the commit from which I loaded this version. - originatingCommit is the commit in which this version was first introduced, it is useful for comparing this version to another one.!!IceTemporaryVersion commentStamp: 'NicoPasserini 11/28/2016 14:49' prior: 0!Temporary versions are created in two situations:1) As  a temporary place holder for a version. Someone asked for a version but the package is still being loaded, at some point a real version will replace me. In the meanwhile I can respond to some messages as a version would do.2) For packages that are added to the repository but not yet saved. In this case the version will be replaced with a real version on next commit.!!IceBackendWriterAdapter commentStamp: 'NicoPasserini 9/26/2016 15:01' prior: 0!Adapter for having MCFileTreeWriters being able to write into Iceberg backend repositories without introducing unpleasant modifications in them.!!IceClassReference commentStamp: 'NicoPasserini 5/18/2016 12:20' prior: 0!This class is just for organizing class references together in a hierarchy, see subclases for more info.!!IceRemovedClassReference commentStamp: 'NicoPasserini 5/18/2016 12:19' prior: 0!A reference to a class that has been removed, but can be handled polymorphically with references to existing classes (see IceSimpleClassReference)!!IceSimpleClassReference commentStamp: 'NicoPasserini 5/18/2016 12:18' prior: 0!Wraps a Pharo class, to allow to handle it polymorphicaly with other references to classes (see IceRemovedClassReference)!!IceCommitish commentStamp: 'NicoPasserini 9/16/2016 14:08' prior: 0!A commit-ish is some object that ultimately points to a commit in a repository: could be a real commit, a branch, a tag.!!IceBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!This can be a local o remote branch, see subclasses. When I am used as a commitish, you must understand that the commit I point to can change over time.!!IceLocalBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!Models a local branch in the repository.!!IceRemoteBranch commentStamp: 'NicoPasserini 12/6/2016 11:42' prior: 0!Models a remote tracking branch.Please note that a "remote tracking" branch is in fact in the local repository, but it is not intended to work on it, but just to mirror a branch in a remote repository. You can not really checkout this branch, neither commit on it, it is read only.When cheking out a branch, if it is a remote tracking branch, a local branch will be created.!!IceCommitInfo commentStamp: 'NicoPasserini 6/6/2016 17:30' prior: 0!Holds the information about a commit in a git repository.!!IceLoadedCode commentStamp: 'NicoPasserini 9/16/2016 14:14' prior: 0!The loaded code of a repository can have three different shapes:- Nothing is loaded yet (represented by an instance of me).- All loaded packages using versions from the same commit (should be the most common situation).- You cherry-picked versions comming from differents commits (not recomended but supported).As commitish, I point to the code as it was loaded from the repository. Notice that after that moment both the code in the image as well as the origin of the code could have changed (in case that I load a branch, the branch can have new commits after I loaded it).!!IceTag commentStamp: 'NicoPasserini 11/3/2016 17:20' prior: 0!Representation of a tag!!IceUnbornBranch commentStamp: 'NicoPasserini 12/5/2016 16:47' prior: 0!I represent the "HEAD commit" of a new repository, i.e. one without any branches or commits. Once you commit on me, your repository will have just one commit and one branch named 'master'.!!IceUnknownBranch commentStamp: 'EstebanLorenzano 7/19/2017 14:20' prior: 0!I'm an unknown branch. I implement an "null pattern" to provide correct output for non-existing local repositories.!!IceWorkingCopy commentStamp: 'NicoPasserini 9/16/2016 14:13' prior: 0!A commitish pointing to the current version of the code.!!IceCredentialsProvider commentStamp: 'NicoPasserini 11/7/2016 15:01' prior: 0!I am in charge of remembering credentials information, configuration and providing it as required by the different backend implementations.I have a counter to avoid for trying for ever with the same credentials.!!IceMetacelloRepositoryAdapter commentStamp: 'NicoPasserini 9/30/2016 15:01' prior: 0!Adapter for allowing metacello to use Iceberg to download packages and versions.!!IcePackageReference commentStamp: 'NicoPasserini 5/25/2016 12:00' prior: 0!I represent a package, that could be in an IceRepository or in the image.Public API and Key Messages- isLoaded tells if the package is currently loaded in the image.In the future we should add load/unload here.We could also add commit, but in general is better to commit at the project level and not at the package level.!!IcePlaintextCredentials commentStamp: 'NicoPasserini 11/22/2016 14:35' prior: 0!I keep a username and a password for connecting to a repository.!!IceRemote commentStamp: 'NicoPasserini 11/17/2016 12:30' prior: 0!I represent a reference to an upstream repository, i.e. the repository to which you want to push/pull. Usually I am called a  'remote' but I could also be local. Most frequently each repository has at least one remote named 'origin'.I am abstract, my subclasses provide access to different kinds of remotes.Right now I just provide information about the different parts of the url, I could get smarter in the future.Internal Representation and Key Implementation Points.    Instance Variables	url:		<String>!!IceFileRemote commentStamp: 'NicoPasserini 7/1/2016 11:41' prior: 0!I am a 'remote' repository which is stored locally in your machine and accessed through a 'file://' url.!!IceNetworkRemote commentStamp: 'NicoPasserini 11/18/2016 13:39' prior: 0!Base abstract class for SCP and HTTPS remotes.!!IceHttpRemote commentStamp: 'TorstenBergmann 2/23/2017 10:33' prior: 0!A remote repository created out of a HTTP  url, such as 'http://localhost/owner/repository.git'.!!IceHttpsRemote commentStamp: 'NicoPasserini 11/18/2016 12:39' prior: 0!A remote repository created out of a HTTPS  url, such as 'https://github.com/npasserini/iceberg.git'.!!IceScpRemote commentStamp: 'NicoPasserini 7/1/2016 11:40' prior: 0!A remote repository created out of a SCP url, such as 'git@github.com:npasserini/iceberg.git'.!!IceUndefinedRemote commentStamp: 'EstebanLorenzano 3/29/2017 17:32' prior: 0!I'm an undefined remote. I exist when a repository is created from scratch and then there is no remote assigned to it yet.!!IceRepository commentStamp: 'NicoPasserini 10/25/2016 15:10' prior: 0!I represent an interface to a git repository. My main responsibilities are:- Load/update both baselines and individual packages from the repository.- Commit changes to the local repository and publish them to a remote repository.- Browse other versions of the loaded packages.- Handle branchesFor the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- loadPackage: packageName- createBranch: newBranchNameSample usage:    Git new origin: 'git@github.com:npasserini/pharo-git-test.git'.    git loadPackage: 'Pharo-Git-Test'. Instance Variables- origin: A string representing the url of a remote git repository (used as origin)- repository:	An IceGitTreeGitRemoteRepository, which provides underlying git operations.- location: <FileReference> The directory of the local repository.- commitDictionary: <Dictionary of IceCommitInfo> Cached dictonary from commitId (hex string) to  all commits in the current branch (in the local repo).- subdirectory: <String> The subdirectory of the local repository which is handled by the underlying GitFileTree- versionDescriptors: <List of GitFileTreePackageEntry> cached list of all package versions saved in the (currently selected branch) of the (local) repository.- announcer: <Announcer>- branch: <IceBranch> currently selected branch. - loadedCode:  <IceLoadedCode> Contains information about the loaded code for each package in this repository. (TODO: maybe handle special cases about loading different versions loaded for different packages, see: https://github.com/npasserini/iceberg/issues/139).Implementation Points!!IceRepositoryCreator commentStamp: 'EstebanLorenzano 12/7/2016 18:46' prior: 0!I create repositories. I do this (trying in this order):- with a location and url defined, I check if it can be a repository and in positive case, I answer the repository, or I can do a clone+checkout (into location) and answer the resulting repository.- with a remote defined , I can take url and location and perform the correct actions.You can also define  branchName to checkout a specific branch.!!IceSavedPackage commentStamp: 'NicoPasserini 6/13/2016 15:57' prior: 0!Can give information about a package that is saved in a repository, for example: - isLoaded if the package has been loaded into the image.- isModified if the package has local changes to be commited- incommingCommigs information about commits in the repository that are newer than the version loaded into the image.!!IceSshCredentials commentStamp: 'NicoPasserini 11/22/2016 14:34' prior: 0!I am a container for the credentials needed for connecting to a git repository via ssh/scp.!!Iceberg commentStamp: 'NicoPasserini 4/28/2016 14:10' prior: 0!I am a cache providing access to several Ice objects, such as packages, repositories, working copies, etc.Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!TIceRepositoryBackend classTrait methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:04'!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/24/2017 12:50:04'!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/24/2017 12:50:04'!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!TIceRepositoryBackend methodsFor: 'descriptions' stamp: ' 7/24/2017 12:50:04'!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!TIceRepositoryBackend methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!TIceRepositoryBackend methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!LGitCredentialsSSH methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!readFrom: credentials	self username: credentials username.	self passphrase: credentials keyPassphrase.  	self publicKeyReference: credentials publicKey asFileReference.	self privateKeyReference: credentials privateKey asFileReference! !!MCWorkingCopy methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!loadedVersion	self ancestors do: [ :ancestor |		(self repositoryGroup 			versionWithInfo: ancestor			ifNone: [ MCRepositoryGroup default versionWithInfo: ancestor ifNone: [] ])			ifNotNil: [ :version | ^ version ]	].! !!IceMCVersionInfo class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!package: package message: commitMessage	^ self new fromPackage: package message: commitMessage! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/24/2017 12:50:04'!uuidFromCommit: aCommit package: aPackage.	^ self uuidFromSHA: (SHA1 new hashStream: (ReadStream on: aCommit id, aPackage name))! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/24/2017 12:50:04'!uuidFromSHA: cid	"Return an adequate uuid from a git commit ID. Copied from GitFileTree."	^ UUID nilUUID		in: [ :uuid |			1 to: 16 do: [ :i | uuid at: i put: (cid at: i) ].			uuid at: 9 put: (16r80 bitOr: ((uuid at: 9) bitAnd: 16r3F)).	"Type"			uuid at: 7 put: (16r50 bitOr: ((uuid at: 7) bitAnd: 16r0F)).	"Version 5 : SHA-1 Namespace (git)."			uuid ]! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ commit! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!fromCommit: aCommit package: aPackage	"This method can be used for first initializing a version info or to update a partially initialized version info."	"See #fromPackage:message:"	commit := aCommit.	package := aPackage.	   	date := commit datetime asDate.   	time := commit datetime asTime.		name := ('{1}-{2}.{3}' format: {		package name. 		commit compatibleUsername. 		commit datetime asUnixTime 	}).		id := self class uuidFromCommit: aCommit package: aPackage.   	message := commit comment.   	author := commit compatibleUsername! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!fromPackage: package message: commitMessage	"This creates a partial version info. Full version info can not be created until we commit into a repository, 	but current fileout tools require it, so we first create an incomplete info and after committing it will be completed	by sending #fromCommit:package:		To improve this implementation we should review the fileout process."	name := ('{1}-{2}.{3}' format: {package name. Author fullName. 'unknown'}).	message := commitMessage.! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iceVersion	^ commit versionFor: package! !!IceMCVersionInfo methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!loadAncestorsAndStepChildren	self shouldBeImplemented ! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!MCClassDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!classCategory	"Avoid direct use of #category, because MCClassDefinitions and 	MCMethodDefinition use the same message for different things. "	^ self category! !!MCVersion methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!directoryName	^ (MCFileTreeRepository parseName: self info name) first , '.package'! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:04'!ruleRBReturnsBooleanAndOtherRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepositoryModel #canPush #false)) #'2016-10-25T18:44:14.262953+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:04'!ruleRBTempsReadBeforeWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepository #outgoingCommits #false)) #'2016-06-16T17:24:18.524965+02:00') #(#(#RGMethodDefinition #(#IceMCGitRepository #outgoingCommits #false)) #'2016-07-06T15:14:46.350843+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:04'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#IceGitFileTreeCommitWalk)) #'2016-09-21T17:13:36.812598+02:00') )! !!IceMetadatalessStCypressWriter class methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!on: aStream	^ self new stream: aStream! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeClassDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeClassDefinition: definition ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeDefinitions: aCollection	| classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |	self writeBasicDefinitions: aCollection.	extensionClasses := OrderedCollection new.	extensionMethodDefinitions := OrderedCollection new.	methodHolders := self classDefinitions , self traitDefinitions.	self methodDefinitions		keysAndValuesDo:			[ :className :extensionMethods | 			methodHolders				at: className				ifAbsent:					[ extensionClasses add: className.					extensionMethodDefinitions addAll: extensionMethods ] ].	extensionClasses		do: [ :className | self methodDefinitions removeKey: className ].	self		writeMethodHolderDefinitions: self traitDefinitions		extension: '.trait'		to: ''		do:			[ :definition :classPath | self writeTraitDefinition: definition to: classPath ].	self		writeMethodHolderDefinitions: self classDefinitions		extension: '.class'		to: ''		do:			[ :definition :classPath | self writeClassDefinition: definition to: classPath ].	classDirExtension := '.extension'.	extensionMethodMap := Dictionary new.	extensionMethodDefinitions		do:			[ :methodDefinition | 			| classPath |			(extensionMethodMap				at: methodDefinition className				ifAbsent:					[ extensionMethodMap						at: methodDefinition className						put: OrderedCollection new ]) add: methodDefinition.			classPath := methodDefinition className , classDirExtension				, self fileUtils pathNameDelimiter asString.			self writeExtensionClassDefinition: methodDefinition to: classPath ].	extensionMethodMap		keysAndValuesDo:			[ :className :classMethodDefinitions | 			| classPath filenameMetaMap |			filenameMetaMap := self fileNameMapFor: classMethodDefinitions.			classMethodDefinitions				do:					[ :methodDefinition | 					| filename methodPath |					filename := (filenameMetaMap at: methodDefinition classIsMeta)						at: methodDefinition selector.					classPath := methodDefinition className , classDirExtension						, self fileUtils pathNameDelimiter asString.					methodPath := classPath						,							(methodDefinition classIsMeta								ifTrue: [ 'class' ]								ifFalse: [ 'instance' ])						, self fileUtils pathNameDelimiter asString.					self						writeMethodDefinition: methodDefinition						to: methodPath						filename: filename ] ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeMethodProperties: classMethodDefinitions	"We don't want to write that."	self shouldNotImplement! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeTraitDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeTraitDefinition: definition ]! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addChange: aChange! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addToPackageChangeSet: anIcePackageChangeSet 	anIcePackageChangeSet addChangedClass: self iceClass! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceClass	^ IceClassReference forDefinition: self! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	^ self iceClass ifNotNil: #package! !!MCPostscriptDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addToPackageChangeSet: anIcePackageChangeSet 	"By doing nothing, this definition will not be shown in the changes tree."! !!MCMethodDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!classCategory	^ self actualClass ifNotNil: #category ifNil: [ RPackage defaultPackageName ]! !!MCMethodDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	^ self isExtensionMethod 		ifTrue: [ Iceberg packageForCategoryNamed: (self protocol withoutPrefix: '*') ]		ifFalse: [ self iceClass package ] ! !!MCMethodDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!method	^ self actualClass >> self selector! !!IceMetadatalessFileTreeWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!snapshotWriterClass	^ IceMetadatalessStCypressWriter! !!IceMetadatalessFileTreeWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!writeVersion: aVersion	"We have to do that to avoid writing the version info."	| members |	directory := (members := MCFileTreeRepository		parseName: aVersion info name) last.	self deleteExistingPackageStructureFor: members.	self fileUtils ensureDirectoryExists: self packageFileDirectory.	self initializePackageFileDirectoryCache.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!MCGitHubRepository class methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aWorkingCopy	^ aWorkingCopy repositoryGroup repositories 		detect: [ :repo | repo isKindOf: self ] 		ifFound: #commitId		ifNone: nil! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitId	"This kind of repo is associated to a specific commit that was downloaded, 	sadly the only way to know it is to parse the directory name."	| repoRoot |	repoRoot := self repoPath isEmpty ifTrue: [ self directory ] ifFalse: [ self directory parent ].	^ repoRoot basename copyAfterLast: $-.! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	(aMCWorkingCopy repositoryGroup includes: self)		ifTrue: [ aBlockClosure value: self commitId ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!getOrCreateIcebergRepository	| remoteUrl remote |	remoteUrl := self perform: Iceberg remoteTypeSelector.	remote := IceRemote url: remoteUrl.	^ IceRepository registry 		detect: [ :repo | repo origin referencesSameRemoteLocationAs: remote ]		ifNone: [			(IceRepositoryCreator new 				url: remoteUrl;				subdirectory: repoPath;				branchName: self projectVersion;				createRepository)				register ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!httpsUrl	^ 'https://github.com/', projectPath, '.git'! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!scpUrl	^ 'git@github.com:', projectPath, '.git'! !!MCRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	"Do nothing. By default MCRepositories can not provide a commitId for you."! !!RPackage methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceRepository	^ Iceberg repositoryForPackage: self! !!MCClassTraitDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!classCategory	^ self category! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!asIcebergObjectInRepository: backend	^ backend iceCommitFrom: self! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!changesFileNamed: fileName	| lookup myVersion parentVersions |	lookup := [:commit | [ commit entryByPath: fileName ] on: Error do: [ nil ]].	myVersion := lookup value: self.	parentVersions := self parents collect: lookup.		^ (myVersion 		ifNil: [ parentVersions includes: nil ]		ifNotNil: [ parentVersions anySatisfy: [ :version | 				version notNil and: [ version objectId = myVersion objectId ]]]) not! !!FileSystemDirectoryEntry methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!packageName 	^ self asFileReference basenameWithoutExtension! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!files	| deltaFiles |		deltaFiles := Set new.	self filesDo: [ :delta :ignored1 :ignored2 | 		deltaFiles add: delta newFile path.		0 "Continue" ].	^ deltaFiles! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!filesDo: aBlockClosure 	^ self filesDo: aBlockClosure binaryFilesDo: aBlockClosure hunksDo: nil linesDo: nil		! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!includesFileNamed: path	^ (self filesDo: [ :delta :second :third | 		| modifiedFileName |		modifiedFileName := delta newFile path.		(modifiedFileName beginsWith: path) asAlien	]) asBoolean.! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!name	^ self filename! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!readStreamDo: aBlock	aBlock value: (ReadStream on: self object contents asString)! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!tree	^ self object! !!LGitTag methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!asIcebergObjectInRepository: backend	^ IceTag named: self name inRepository: backend frontend! !!IceGitUsernameOrEmailNotFound class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!guessKind: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' 		or: [ anError messageText = 'Failed to parse signature - Signature cannot have an empty name or email' ] ])		ifTrue: [ self signal ].	notBlock value! !!IceLocalRepositoryMissing class methodsFor: 'exceptioninstantiator' stamp: ' 7/24/2017 12:50:04'!signalFor: repository	^ self new 		repository: repository;		signal! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageText	^ self name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: anObject	name := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner	^ owner! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner: anObject	owner := anObject! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageText	^ 'There is no version for package: {1} in  commit {2}' 		format: { 			self version packageName.			self version commit shortId		}! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!version	^ version! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!version: anObject	version := anObject! !!LGitReturnCodeEnum methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!asBoolean	^ self value = 0 ifTrue: false ifFalse: 		[ self value = 1 ifTrue: true ifFalse: 		[ self error: self printString, ' can''t be converted to a boolean' ]]! !!IcePackageLoaded class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!version: version 	^ self new loadedVersion: version! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedVersion	^ loadedVersion! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedVersion: anObject	loadedVersion := anObject! !!IceRepositoryAnnouncement class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: repository	^ self new repository: repository; yourself! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceRepositoryRegistryModified class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository	^ self new repository: aRepository; yourself! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!LGitCredentialsPlaintext methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!readFrom: credentials	self username: credentials username.	self passphrase: credentials password.  ! !!MCOrganizationDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addOrganisationChange: aChange! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceClass	^ nil! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	"TODO: Refactor this, see https://github.com/npasserini/iceberg/issues/42"	self categories 		ifNotEmpty: [ ^ Iceberg packageForCategoryNamed: (self categories anyOne) ]	 	ifEmpty: nil! !!MCPatchOperation methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addToPackageChangeSet: anIcePackageChangeSet 	self definition addToPackageChangeSet: anIcePackageChangeSet ! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!asIceChangeSet	^ IceMethodChange new 		operation: self; 		yourself.! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceClass	^ self definition iceClass! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	^ self definition icePackage! !!IceAbstractCommitWalk class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forRepository: repository	^ self new repository: repository; yourself! !!IceAbstractCommitWalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitFrom: result	^ self repository iceCommitFrom: result! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!commits	| commits |	commits := OrderedCollection new.	self commitsDo: [ :commit | commits add: commit ].	^ commits! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!commitsDo: aBlock 	self rawResultsDo: [ :result | aBlock value: (self commitFrom: result) ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!includesCommit: aCommit	self commitsDo: [ :commit | 		commit id = aCommit id ifTrue: [ ^ true ]].	^ false! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!maxNumber	^ maxNumber! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!maxNumber: anObject	maxNumber := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!modifyingPackage	^ modifyingPackage! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!modifyingPackage: anObject	modifyingPackage := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!upto: aCommitish	aCommitish hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoBranch: anIceBranch 	self uptoCommit: anIceBranch lastCommit! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoBranches: branches	^ branches do: [ :branch | self uptoBranch: branch ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoCommits: commits	commits do: [ :commit | self uptoCommit: commit  ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoVersion: version	version hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!versionsFor: package	self modifyingPackage: package.	^ self commits collect: [ :commit | commit versionFor: package ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock	self modifyingPackage: package.	self commitsDo: [ :commit | 		| version | 		version := commit versionFor: package.		(selectBlock value: version) ifTrue: [ ^ version ]	].	^ ifNoneBlock value  ! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ announcer! !!IceAbstractDiff methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!description	^ self name! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!elements	^ elements ifNil: [ 		elements := self initialElements sorted: [ :a :b | a description < b description ] ]! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	^ self subclassResponsibility ! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	announcer := Announcer new.! !!IceAbstractDiff methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	elements ifNotNil: [ elements do: #refresh ].	elements := nil.	announcer announce: IceChangeSetChanged new.! !!IceAbstractDiff methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!whenChangedDo: aBlock	announcer when: IceChangeSetChanged do: aBlock! !!IceChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel 	aDiffModel		contextClass: nil;		leftText: '';		rightText: ''.! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ self organizationDescription: self newOrganization! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!newOrganization	^ newOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!newOrganization: anObject	newOrganization := anObject! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!oldOrganization	^ oldOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!oldOrganization: anObject	oldOrganization := anObject! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!organizationDescription: tags 	^ String streamContents: [ :stream |		stream nextPutAll:	'Package tags: '.		tags do: [ :elem | 			stream nextPutAll: String crlf;				nextPutAll: String tab;				nextPutAll: elem.	]]! !!IcePackageOrganizationChange methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!removedCategories	^ self oldOrganization difference: self newOrganization ! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ self organizationDescription: self oldOrganization! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	aDiffModel		contextClass: nil;		leftText: (self organizationDescription: self newOrganization);		rightText: (self organizationDescription: self oldOrganization).! !!IceClassChangeSet class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!class: aClass parent: anIcePackageChangeSet 	^ self new 		targetClass: aClass; 		parent: anIcePackageChangeSet; 		yourself.! !!IceClassChangeSet methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!analyseChanges	| newChanges |	newChanges := self parent changes select: [ :operation | 		operation iceClass = self targetClass ].		newChanges		detect: [ :operation | operation definition isClassDefinition ]		ifFound: [ :classDef | 			classDefinition := classDef. 			changes := newChanges copyWithout: classDef.		]		ifNone: [ changes := newChanges ].! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self targetClass browse! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browseReferences	self targetClass browseReferences! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ self targetClass canBeBrowsed! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ self targetClass canBrowseReferences! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changes	^ changes ifNil: [ self analyseChanges. changes ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!classDefinition	^ classDefinition ifNil: [ self analyseChanges. classDefinition ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self targetClass description! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ self classDefinition 		ifNotNil: #icon		ifNil: [	self isExtension			ifTrue: [ Smalltalk ui icons iconNamed: #protocolExtension ] 			ifFalse: [ self targetClass icon ]]! !!IceClassChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	^ self changes collect: #asIceChangeSet! !!IceClassChangeSet methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!isExtension	^ parent package name ~= self packageName! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ self classDefinition ifNotNil: #diffToSource! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	^ self classDefinition! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ self targetClass package! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self targetClass packageName! !!IceClassChangeSet methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		nextPutAll: targetClass description;		nextPut: $)		! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass	^ targetClass! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass: anObject	targetClass := anObject! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ self classDefinition ifNotNil: #diffFromSource! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	self classDefinition		ifNil: [ super updateDiff: aDiffModel ]		ifNotNil: [ :cd |			aDiffModel				contextClass: nil;				leftText: cd diffToSource;				rightText: cd diffFromSource		]! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self method browse! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ self operation canBeBrowsed! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ false! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!description	^ operation definition selector! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ self operation icon! !!IceMethodChange methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	^ {}! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!method	^ self operation definition method! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ self operation diffToSource! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	^ operation! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation: anObject	operation := anObject! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ self operation definition actualClass package! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package name! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: operation definition summary;		nextPut: $)! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ self operation diffFromSource! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	aDiffModel		contextClass: self operation targetClass;		leftText: self operation diffToSource;		rightText: self operation diffFromSource.! !!IcePackageChangeSet class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!package: aPackage parent: anIceDiff 	^ self new 		package: aPackage;		parent: anIceDiff;		yourself! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/24/2017 12:50:04'!addChange: change	changes add: change! !!IcePackageChangeSet methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!addChangedClass: anIceClassReference 	changedClasses add: anIceClassReference ! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/24/2017 12:50:04'!addOrganisationChange: change	change isAddition ifTrue: [ ^ self newOrganization: change definition categories ].	change isRemoval ifTrue: [ ^ self oldOrganization: change definition categories ].	self error: 'Can not handle definition'.! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!analyseChanges	| newChanges |	newChanges := self basicChanges.	newChanges ifEmpty: [ 		(self package isLoaded 			and: [ self package isModified			and: [(self parent myVersion isKindOf: IceWorkingCopy) 			and: [ self parent theirVersion isKindOf: IceLoadedCode ]]])			ifTrue: [ self package workingCopy modified: false ]].		changes := OrderedCollection new.	newChanges do: [ :change | 		change definition 			addAnalysisToPackageChangeSet: self			change: change ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!basicChanges	| mine theirs |	self package isLoaded ifFalse: [ ^ #() ].	mine := self parent mySnapshot: self package.	theirs := (self package isExported 		ifTrue: [ self parent theirSnapshot: self package ]		ifFalse: [ MCSnapshot empty ]).	^ (mine notNil and: [ theirs notNil ]) 		ifTrue: [ (MCPatch fromBase: theirs target: mine) operations ]		ifFalse: [ #() ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!basicOrganizationChange	^ organizationChange ifNil: [ organizationChange := IcePackageOrganizationChange new. ]! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self package browse! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ true! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ false! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!changedClasses	^ (self changes collect: #iceClass as: Set) 		sorted: [ :a :b | a description > b description ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!changes	^ changes ifNil: [ 		self analyseChanges. 		changes ]! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!description	^ self package packageName! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasChanged	^ self changes notEmpty or: [ self organizationChange notNil ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasChanges	^ self elements notEmpty! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: 		(self hasChanges 			ifTrue: [ #dirtyMonticelloPackage ]			ifFalse: [ #emptyPackage  ])! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	changedClasses := Set new.	self changes do: [ :change | change addToPackageChangeSet: self ].	^ changedClasses collect: [:class | IceClassChangeSet class: class parent: self ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isExtension: changeSet	^  changeSet package ~= self package correspondingRPackage! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ organizationChange ifNotNil: #myVersion! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newOrganization: aCollectionOfTags	self basicOrganizationChange newOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!oldOrganization: aCollectionOfTags	self basicOrganizationChange oldOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	"This operation is not modeled in MC"	^ nil! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!organizationChange	^ organizationChange ifNil: [ self analyseChanges. organizationChange ]! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package: anObject	package := anObject! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package name! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self package packageName;		nextPut: $)! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	changes := nil.	organizationChange := nil.	super refresh.! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ organizationChange ifNotNil: #theirVersion! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	organizationChange 		ifNotNil: [ :change | change updateDiff: aDiffModel ]		ifNil: [ super updateDiff: aDiffModel ]! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self asString! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parent	^ parent! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parent: anObject	parent := anObject! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forRepository: aRepository 	^ self new 		repository: aRepository;		myVersion: IceCommitish image;		theirVersion: aRepository loadedCode;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forRepository: aRepository commit: anIceCommitInfo	^ self new 		repository: aRepository;		theirVersion: anIceCommitInfo;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!from: myCommitish to: theirsCommitish	^ self new 		repository: myCommitish repository;		myVersion: myCommitish;		theirVersion: theirsCommitish;		yourself.! !!IceDiff methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canRevertChanges	^ self myVersion canRevertChanges ! !!IceDiff methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!changedPackages	^ self elements select: #hasChanged thenCollect: #package! !!IceDiff methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createChangeSetFor: package	^ IcePackageChangeSet package: package parent: self! !!IceDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	| changedPackages |	changedPackages := self myVersion changedPackagesTo: self theirVersion.	^ changedPackages collect: [ :package | self createChangeSetFor: package ]! !!IceDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	myVersion := IceCommitish image.! !!IceDiff methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mySnapshot: package	^ self myVersion snapshotFor: package	! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!myVersion	^ myVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!myVersion: anObject	myVersion := anObject! !!IceDiff methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self repository location pathString;		nextPut: $)! !!IceDiff methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	self repository refresh.	elements ifNotNil: [ elements do: #refresh ].	announcer announce: IceChangeSetChanged new.! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject.	repository announcer weak		subscribe: IceCommited send: #refresh to: self! !!IceDiff methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!revertChange: anIceMethodChange 	self myVersion revertChange: anIceMethodChange.	self refresh.! !!IceDiff methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!theirSnapshot: package 	^ theirVersion ifNotNil: [ 		theirVersion snapshotFor: package ]! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ theirVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!theirVersion: anObject	theirVersion := anObject! !!IceAbstractVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forPackage: package	^ self new package: package; yourself! !!IceAbstractVersion methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!beCurrent	"By default do not to anything, version should have a package manager that makes them current without Iceberg intervention."! !!IceAbstractVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ #()! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package: anObject	package := anObject! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self package repository! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!snapshot	^ [ self mcVersion snapshot ] on: IceVersionDoesNotExist do: [ MCSnapshot empty ]! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!updated	^ self! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ nil! !!IceForeignVersion methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ self package workingCopy gtDisplayString ! !!IceForeignVersion methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk	"Do nothing. I can't filter a commit walk because I do not know my commit."! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcVersion	^ mcVersion ifNil: [ mcVersion := self package workingCopy loadedVersion ]! !!IceForeignVersion methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: 			(mcVersion 				ifNotNil: [ mcVersion printString ] 				ifNil: [ self package name ]);		nextPut: $).! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forPackage: package	"Use fromCommit:package: instead"	self shouldNotImplement ! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!fromCommit: commit package: package	^ self new		commit: commit;		package: package;		yourself! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	self species = another species ifFalse: [ ^ false ].		"If I both load commits are equal, we are the same version."	self commit = another commit ifTrue: [ ^ true ]. 	"If not, look for actual origination commits and compare them."	^ self originatingCommit = another originatingCommit.! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!author	^ self info author! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!beCurrent 	"Ensure that the working copy points to the right info."	self package workingCopy versionInfo: self info.	! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ commit! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit: anIceCommit	commit := anIceCommit ! !!IceSavedPackageVersion methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ self commit description ! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entry	^ entry! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entry: anObject	entry := anObject.	entry repository: self repository! !!IceSavedPackageVersion methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self commit! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	"Returns only the commits modifying this package."	^ self repository newCommitWalk 		fromHead;		uptoVersion: self; 		versionsFor: self package! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!info	^ info ifNil: [ info := IceMCVersionInfo new fromCommit: self commit package: package ]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!info: anObject	info := anObject! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isAncestorOf: anotherVersion	^ self commit isAncestorOf: anotherVersion commit! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isAncestorOfCommitId: anotherCommitId	^ self commit isAncestorOf: (self repository commitAt: anotherCommitId)! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isNewerThan: another	^ self info timeStamp > another info timeStamp! !!IceSavedPackageVersion methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!load	self mcVersion load.	self repository versionLoaded: self.! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!mcVersion	^ self repository backend mcVersionFor: self! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!nextVersionName	^ ('{1}-{2}.{3}' format: {		self package packageName. 		self author. 		self info versionNumber + 1	})! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!originatingCommit	^ originatingCommit ifNil: [ originatingCommit := 		self repository newCommitWalk 			fromCommit: self commit;			modifyingPackage: self package;			firstCommit 		]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package packageName! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!parent	^ (self repository newCommitWalk 		fromCommit: self commit; 		modifyingPackage: self package;		maxNumber: 2;		commits)		second "First commit will be my own commit, the second is my parent"		versionFor: self package.! !!IceSavedPackageVersion methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: self package name.	commit ifNotNil: [ 		aStream 		nextPutAll: ', loaded from: ';		nextPutAll: commit shortId ].			originatingCommit ifNotNil: [ 		aStream 			nextPutAll: ', committed in: ';			nextPutAll: originatingCommit shortId ].			aStream nextPut: $).! !!IceTemporaryVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!commit	"I am a temporary version, I am not related to any commit or it is unknown. 	When computing a reference commit I must be ignored."	^ nil! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!snapshot	"I am only a temporary version, I can't provide a meaningful snapshot"	^ MCSnapshot empty! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!updated	| newVersion |	newVersion := self package computeLoadedVersion.	self package repository loadedCode versionLoaded: newVersion.	^ newVersion! !!IceBackendWriterAdapter class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: anIceBackend	^ self new backend: anIceBackend; yourself.! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend	^ backend! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend: anObject	backend := anObject! !!IceBackendWriterAdapter methodsFor: 'accesing' stamp: ' 7/24/2017 12:50:04'!directory	^ self backend codeDirectory ! !!IceBackendWriterAdapter methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!propertyFileExtension	^ MCFileTreeRepository defaultPropertyFileExtension! !!IceClassReference class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forDefinition: anMCDefinition	^ anMCDefinition actualClass 		ifNil: [ IceRemovedClassReference for: anMCDefinition ]		ifNotNil: [:class | IceSimpleClassReference new targetClass: class ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= other	^ other class = self class and: [ other description = self description ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!hash	^ self description hash! !!IceRemovedClassReference class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aMCClassDefinition 	^ self new		targetClassName: aMCClassDefinition className;		packageName: aMCClassDefinition classCategory		yourself! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	IceTool uiManager 		abort: ('Class {1} was removed from the system' format: { self targetClassName })		title: 'Unable to browse class'! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ false! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ false! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self targetClassName ! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeRemove ! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ packageName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName: anObject	packageName := anObject! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClassName	^ targetClassName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClassName: anObject	targetClassName := anObject! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self targetClass browse! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browseReferences	self systemNavigation browseAllCallsOnClass: self targetClass! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ true! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ true! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self targetClass name! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #class! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self targetClass package name! !!IceSimpleClassReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		print: self targetClass;		nextPut: $)! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass	^ targetClass! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass: anObject	targetClass := anObject! !!IceBranch class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isRemoteBranchName: branchName	^ ((branchName beginsWith: 'refs/remotes/') 		or: [ branchName beginsWith: 'remotes/' ])! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName inRepository: repo	^ self 		named: branchName		local: (self isRemoteBranchName: branchName) not		inRepository: repo! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName local: isLocal inRepository: repo	^ (isLocal ifTrue: IceLocalBranch ifFalse: IceRemoteBranch)		named: branchName inRepository: repo.! !!IceBranch methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= anotherBranch	self species = anotherBranch species ifFalse: [ ^ false ].	self repository = anotherBranch repository ifFalse: [ ^ false ].	^ self name = anotherBranch name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend	^ self repository backend! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesToCommitInfo: aCommitish	^ aCommitish changedPackagesToCommitInfo: self lastCommit! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commits	^ self repository newCommitWalk fromBranch: self; commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitsNotIn: anotherBranch	^ self repository newCommitWalk		fromBranch: self;		uptoBranch: anotherBranch;		commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!includesCommit: commit	^ self lastCommit isDescendantOf: commit! !!IceBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLocal	^ false! !!IceBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isRemote	^ false! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!lastCommit	"The first commit in the list was the last in time."	^ self repository newCommitWalk fromBranch: self; firstCommit! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: anObject	name := anObject! !!IceBranch methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $).! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package	^ self lastCommit snapshotFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock 	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package detect: selectBlock ifNone: ifNoneBlock ! !!IceLocalBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName inRepository: repo	^ self new 		name: (branchName withoutPrefix: 'refs/heads/'); 		repository: repo; 		yourself! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!basename	^ self name! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!committish	^ (self name includesSubstring: 'detached')		ifTrue: [ ('\(detached from ([0-9a-f]+)\)' asRegex) matches: self name; subexpression: 2 ]		ifFalse: [ self name ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ self upstream		ifNotNil: [ self upstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommitsFrom: aRemote 	^ (self upstreamFor: aRemote) 		ifNotNil: [ :remoteUpstream | remoteUpstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLocal	^ true! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommits: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	self upstream 		ifNotNil: [ walk uptoBranch: self upstream ]		ifNil: [ walk uptoBranches: (			self repository localBranches copyWithout: self) ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote do: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	(self upstreamFor: aRemote)		ifNotNil: [ :aRemoteBranch | walk uptoBranch: aRemoteBranch ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!upstream	^ upstream ifNil: [ 		self backend upstream 			ifNotNil: [ :upstreamName |				upstream := (IceRemoteBranch named: upstreamName inRepository: self repository) ] ]! !!IceLocalBranch methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!upstreamFor: aRemote	^ aRemote 		upstreamForBranch: self		backend: self backend! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName inRepository: repo	^ self new 		name: ((branchName withoutPrefix: 'refs/') withoutPrefix: 'remotes/'); 		repository: repo; 		yourself! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!remoteName: remoteName branchName: branchName inRepository: aRepository 	^ self new 		name: remoteName, '/', branchName; 		repository: aRepository; 		yourself! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!basename	^ self name copyAfterLast: $/! !!IceRemoteBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isRemote	^ true! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteName	^ self name copyUpToLast: $/! !!IceCommitInfo class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!createFrom: aGitLogLine	^ self new 		initializeFrom: aGitLogLine;		yourself.! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	^ another species = self species and: [ self commitId = another commitId ]! !!IceCommitInfo methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!backend	^ self repository backend! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesTo: aCommitish	"If is first commit, it will have no parents. Answer all packages because 	 all are 'changed'"	aCommitish ifNil: [ ^ self repository savedPackages ].	^ aCommitish changedPackagesToCommitInfo: self ! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesToCommitInfo: aCommitInfo	| files packageNames |	files := self backend changedFilesBetween: self and: aCommitInfo.	packageNames := (files 		select: [ :each | each includesSubstring: '.package' ] 		thenCollect: [ :each | | packageName |			packageName := each copyFrom: 1 to: (each findString: '.package') - 1.			(packageName includesSubstring: '/') 				ifTrue: [ packageName copyAfterLast: $/ ]				ifFalse: [ packageName ] ])		asSet.	^ packageNames sorted		select: [ :each | self repository includesPackageNamed: each  ] 		thenCollect: [ :each | self repository packageNamed: each ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!comment	^ comment! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!comment: anObject	comment := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitId	^ commitId! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitId: anObject	commitId := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!compatibleTimestamp	"I'm a timestamp as system: likes authorname MM/DD/YYYY HH:MM"	^ String streamContents: [ :stream |		stream 			<< self compatibleUsername 			<< ' '		 	<< self datetime asStringYMDHM  ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!compatibleUsername	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ self username reject: [ :each | each = Character space ]	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datetime	^ datetime! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datetime: anObject	datetime := anObject! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ String streamContents: [ :stream | 		stream 			nextPutAll: self shortId; 			nextPutAll: ' (';			nextPutAll: self printShortTime;			nextPut: $) ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffFromHead	^ IceDiff from: self repository headCommit to: self! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffTo: aCommitInfo	^ IceDiff from: self to: aCommitInfo! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffToParent	^ self diffTo: (self parents 			ifNotEmpty: #first			ifEmpty: [ nil ])! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!hash	^ self id hash! !!IceCommitInfo methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!id	^ commitId! !!IceCommitInfo methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeFrom: aGitLogLine	"Reads commit info out of a git commit log line, such as: '|f659e2851cb84eb6812b19e5a820c06fb509b0d5|Nicolás Passerini|2016-05-27 09:20:49 +0200|ea6c151|Updated test method with version 2'. 	This lines are obtained with git log options: '--format=|%H|%an|%ai|%p|%s' as in IceRepository>>incomingCommits. "	| elements |	elements := $| split: aGitLogLine.	self		commitId: (elements at: 2);		username: (elements at: 3);		datetime: (DateAndTime readFrom: (elements at: 4) readStream );		parentIds: ((Character space split: (elements at: 5) trim) select: #notEmpty);		comment: (elements at: 6)! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isAncestorOf: anotherCommit	"Warning: this method considers that a commit is ancestor of itself."	^ self = anotherCommit 		or: [ anotherCommit isDescendantOf: self]! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!isCurrent	^ repository loadedCode referenceCommit = self ! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isDescendantOf: aCommit	^ self repository newCommitWalk		fromCommit: self;		includesCommit: aCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self isAncestorOf: repository loadedCode referenceCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!isMerged	^ repository branch includesCommit: self! !!IceCommitInfo methodsFor: 'detached head' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!load	(self changedPackagesTo: self repository loadedCode referenceCommit)		collect: [ :package | self versionFor: package ]		thenDo: [:version | version load ]! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge	self repository merge: self! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseWith: anotherCommit	^ self repository commitAt: 		(self repository backend mergeBaseBetween: self id and: anotherCommit id)! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergeInto: aBranch	self repository 		merge: self		into: aBranch! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ self shortId! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!ownVersions	^ self repository savedPackages collect: [ :package | 		self versionFor: package ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!packageNames	^ self repository backend packagesPresentOn: self! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentIds	^ parentIds! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentIds: anObject	parentIds := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parents	^ parents ifNil: [ 		parents := parentIds 			collect: [ :parentId | self repository commitAt: parentId ] ]! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self commitId first: 7);		nextPutAll: ', ';		print: self datetime;		nextPutAll: ', ';		nextPutAll: comment;		nextPut: $)		 ! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printShortTime	^ self datetime asDate = Date today	ifTrue: [ self datetime asTime asString ]	ifFalse: [ self datetime asDate asString ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!shortId	^ commitId first: 7! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package 	^ (self versionFor: package) ifNotNil: #snapshot! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!status	self isCurrent ifTrue: [ ^ 'Current' ].	self isLoaded ifTrue: [ ^ 'Loaded' ].	self isMerged ifTrue: [ ^ 'Not loaded' ].	^ 'Not merged'! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ username! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: anObject	username := anObject! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: package	^ IceSavedPackageVersion fromCommit: self package: package! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsChangedSince: anotherCommit	| changes | 		changes := OrderedCollection new.	self repository loadedPackages do: [ :package | 		| myVersion theirVersion |		myVersion := self versionFor: package.		theirVersion := anotherCommit versionFor: package.		(myVersion = theirVersion)			ifFalse: (changes add: myVersion)	].		^ changes! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromCommit: self;		versionsFor: package! !!IceCommitish class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!image	^ IceWorkingCopy instance! !!IceCommitish methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canRevertChanges	^ false! !!IceCommitish methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesTo: aCommitish	"This method will implement a double dispatch, since the strategies to resolve deltas 	 change if you are comparing: 		- loaded code -> working copy		- a commit -> a branch 		- a commit -> a commit	 and they need to be treated differently"	^ self subclassResponsibility! !!IceCommitish methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffWith: aCommitish	^ IceDiff from: self to: aCommitish ! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommitsFrom: aRemote	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ self outgoingCommits: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommits: aBlockClosure 	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote 	^ self outgoingCommitsTo: aRemote do: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote do: aBlock	^ #()! !!IceCommitish methodsFor: 'detached head' stamp: ' 7/24/2017 12:50:04'!refresh	"Do nothing. This provides polymorphism with IceBranches, in a repo with a detached head."! !!IceLoadedCode class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: repository	^ self basicNew 		repository: repository; 		initialize; 		yourself! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesToWorkingCopy: aWorkingCopy	| lastCommit commitPackageNames loadedPackageNames added removed |		lastCommit := self repository branch lastCommit.	commitPackageNames := lastCommit packageNames.	loadedPackageNames := self repository loadedPackages collect: #name.	added := (loadedPackageNames \ commitPackageNames) 		collect: [ :each | self repository packageNamed: each ]. 	"this will give me the removals, but I'm still don't know what to do with them	 (because if I just add it it will show them as added not as removed)"	"removed := (commitPackageNames \ loadedPackageNames)		reject: [ :each | self repository includesPackageNamed: each ]		thenCollect: [ :each | IceSavedPackage named: each repository: self repository ]."	^ added, (self loadedVersions keys select: #isModified)! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!commited: newCommit changingPackages: packages	self repository addCommit: newCommit.	packages do: [ :package | self versionLoaded: (newCommit versionFor: package) ].	referenceCommit := newCommit.	repository announcer announce: IceCommited new.! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!commitsNotLoaded	^ self repository newCommitWalk		fromHead;		upto: self referenceCommit;		commits ! !!IceLoadedCode methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!computeReferenceCommit	| candidates |		"1. If no code has been loaded, take HEAD commit as reference."	self loadedVersions isEmpty ifTrue: [ ^ self repository headCommit ].			"2. Happy path: see if all loaded code has the same updation commit. 	If we can't compute an updation commit for some loaded code, it means that it has been 	probably loaded from another kind of repository, we just ignore it."	candidates := (self loadedVersions collect: [:version | version commit] as: Set) reject: #isNil.	candidates size = 1 ifTrue: [ ^ candidates anyOne ].	"3. None of the loaded versions produced a non nil candidate, just use the HEAD commit"		candidates isEmpty ifTrue: [ ^ self repository headCommit ].	"4. We could try other strategies... but this should be good for now."		^ candidates detectMax: #datetime! !!IceLoadedCode methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ self loadedVersions 		ifEmpty: ['No package loaded']		ifNotEmpty: [ self referenceCommit description ] ! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedVersions	^ loadedVersions ifNil: [ 		loadedVersions := Dictionary new.		repository loadedPackages do: [ :pkg | self versionLoaded: pkg computeLoadedVersion ].			loadedVersions 	]! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseWith: aCommit	^ self referenceCommit mergeBaseWith: aCommit! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!referenceCommit	^ referenceCommit ifNil: [ referenceCommit := self computeReferenceCommit ]! !!IceLoadedCode methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!refresh	loadedVersions := nil.	referenceCommit := nil.! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package	^ (self versionFor: package) snapshot! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: package 	^ self loadedVersions 		at: package 		ifPresent: #updated		ifAbsent: [ self loadedVersions at: package put: package computeLoadedVersion ]		! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!versionLoaded: version	self loadedVersions at: version package put: version.	version beCurrent.	"Reset reference commit so that it gets recomputed the next time it is needed"	referenceCommit := nil.! !!IceTag class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: aTagName inRepository: anIceRepository 	^ self new name: aTagName; repository: anIceRepository; yourself! !!IceTag methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!commit	^ commit ifNil: [ commit := self repository newCommitWalk fromTag: self; firstCommit ]! !!IceTag methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self repository backend revparseCommit: self name! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: anObject	name := anObject! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceTag methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: package	^ self commit versionFor: package! !!IceTag methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!versionsFor: package 	^ self commit versionsFor: package! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self name! !!IceUnbornBranch methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self ! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ '<New branch>'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNames	^ #()! !!IceUnbornBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: aPackage 	^ #()! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self name! !!IceUnknownBranch methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self ! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ '<Unknown>'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNames	^ #()! !!IceUnknownBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: aPackage 	^ #()! !!IceWorkingCopy class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!instance	^ Instance ifNil: [ Instance := self new ]! !!IceWorkingCopy methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canRevertChanges	^ true! !!IceWorkingCopy methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesTo: aCommitish	^ aCommitish changedPackagesToWorkingCopy: self! !!IceWorkingCopy methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!revertChange: anIceMethodChange	| loader |	loader := MCPackageLoader new.	anIceMethodChange operation inverse applyTo: loader.	loader load.! !!IceWorkingCopy methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package	^ package workingCopy snapshot! !!IceCredentialsProvider class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!default	^ self providerType new! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plaintextCredentials	^ PlaintextCredentials ifNil: [ PlaintextCredentials := IcePlaintextCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plaintextCredentials: anObject	PlaintextCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!providerType	^ ProviderType ifNil: [ ProviderType := IceCredentialsProvider ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!providerType: anObject	ProviderType := anObject! !!IceCredentialsProvider class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!settingsOn: aBuilder 	<systemsettings>	(aBuilder setting: #useCustomSsh)		parent: #Iceberg;		noOrdering;		target: self;		label: 'Use custom SSH keys';		description: 'Check if you want to have your own pair of keys (id_rsa and id_rsa.pub), without using the ssh-agent';		with: [			(aBuilder setting: #username)				target: self;				targetSelector: #sshCredentials;				label: 'SSH Username';				description: 'If you are trying to connect to github through ssh (something like git@github.com:owner/projectName), the username should be `git`'.			(aBuilder setting: #publicKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Public SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa.pub'.			(aBuilder setting: #privateKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Private SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa'.			(aBuilder setting: #keyPassphrase)				target: self;				targetSelector: #sshCredentials;				label: 'Passphrase of your SSH key'.		].		(aBuilder group: #'Plaintext Credentials')		parent: #Iceberg;		noOrdering;		with: [ 			(aBuilder setting: #username)				target: self;				targetSelector: #plaintextCredentials;				label: 'Github username';				description: 'Your github username'.			(aBuilder setting: #password)				target: self;				targetSelector: #plaintextCredentials;				type: #Password;				label: 'Your github password, if you want Iceberg to remember it, but be aware that this does not pretend to be safe.'.		]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentials	^ SshCredentials ifNil: [ SshCredentials := IceSshCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentials: anObject	SshCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentialsClass	self useCustomSsh ifTrue: [ ^ LGitCredentialsSSH ].	^ LGitCredentialsSSHAgent	! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!useCustomSsh	^ UseCustomSsh ifNil: [ UseCustomSsh := false ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!useCustomSsh: aBoolean	UseCustomSsh := aBoolean! !!IceCredentialsProvider methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	tries := 0.! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plaintextCredentials	^ self class plaintextCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentials	^ self class sshCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentialsClass	^ self class sshCredentialsClass! !!IceMetacelloRepositoryAdapter class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: anIceRepository 	^ self new repository: anIceRepository; yourself! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addTo: aMCRepositoryGroup 	^ aMCRepositoryGroup addBasicRepository: self! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canUpgradeTo: anMCGitBasedRepository 	"Copied from MCGitBasedNetworkRepository"  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath 	and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aWorkingCopy ifFound: aBlock	self flag: #todo. "Do nothing?"! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self repository backend description! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!getOrCreateIcebergRepository	^ self repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!goferPriority	^ 8! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!goferReferences	^ self repository savedPackages collect: [ :package | 		GoferResolvedReference name: package latestVersion info name repository: self ]! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasNoLoadConflicts: anMCGitBasedRepository	"Copied from MCGitBasedNetworkRepository"  	(anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].	^ self projectPath = anMCGitBasedRepository projectPath and: [		self repoPath = anMCGitBasedRepository repoPath and: [ 			self projectVersion = anMCGitBasedRepository projectVersion ] ]! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/24/2017 12:50:04'!isCache	"User for Kommiter and Versionner"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/24/2017 12:50:04'!isRemote	"User for Komitter"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isValid	^ true! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectPath	^ self repository origin projectPath! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectVersion	^ self repository branchName! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repoPath	^ self repository subdirectory ! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryDescription	^ self repository description! !!IceMetacelloRepositoryAdapter methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!repositoryVersionString	^ self repository headCommit id! !!IceMetacelloRepositoryAdapter methodsFor: 'versions' stamp: ' 7/24/2017 12:50:04'!versionFrom: aVersionName 	| packageName package version |	packageName := (MCFileTreeRepository parseName: aVersionName) first.	package := self repository packageNamed: packageName.		version := package latestVersion.	version info name = aVersionName ifFalse: [		version := package versions detect: [ :ver | ver info name = aVersionName ]].		^ version mcVersion				! !!IcePackageReference class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: aPackageName	^ self new 		packageName: aPackageName;		yourself! !!IcePackageReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= anotherPackage	^ anotherPackage species = self species 	and: [ self packageName = anotherPackage packageName ]! !!IcePackageReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	(RPackageOrganizer default packageNamed: self name) browse! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!changesIn: commitish comparedToBase: baseCommitish	^ (MCPatch 		fromBase: (baseCommitish snapshotFor: self)		target: (commitish snapshotFor: self))		operations! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ RPackageOrganizer default includesPackageNamed: packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName: anObject	packageName := anObject! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printDescriptionOn: aStream	aStream nextPut: $(;		nextPutAll: packageName;		nextPutAll: ', ';		nextPutAll: (self isLoaded ifTrue: 'loaded' ifFalse: 'not loaded');		nextPut: $)		! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name.	self printDescriptionOn: aStream! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!workingCopy	^ self isLoaded ifTrue: [		MCWorkingCopy forPackage: (MCPackage named: self packageName)]! !!IcePlaintextCredentials methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPresent	^ self username isEmpty not and: [ self password isEmpty not ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password	^ password ifNil: [ password := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password: anObject	password := anObject! !!IcePlaintextCredentials methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!readFrom: credentials	self username: credentials username.	self password: credentials password! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ username ifNil: [ username := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: anObject	username := anObject! !!IceFileRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ aRepositoryUrl beginsWith: 'file:'! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ { 'Origin' -> path pathString }! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ 'local filesystem'! !!IceFileRemote methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!organizer	^ 'local'! !!IceFileRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	| matcher |	matcher := 'file\://(.*)' asRegex.	(matcher matches: url) 		ifTrue: [ 			path := (matcher subexpression: 2) asFileReference.			projectName := path basename.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse  "file:" url: ', url ]! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ path basename! !!IceHttpRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ (aRepositoryUrl beginsWith: self protocolID, '://') ! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	"Returns the HTTP default port"		^80! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!protocolID	"Return the protocol identifier"		^'http'! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	| matcher |	matcher := '((http|https)\://)(([\w]+)@)*([\w.]+)(\:([\d]+))*(/[\w]+)*/([\w\-]+)/([\w\-.]+(.git)?)' asRegex.	(matcher matches: url) 		ifTrue: [					user := matcher subexpression: 5.			host := matcher subexpression: 6.			port := (matcher subexpression: 8)				ifNotNil: [: x | x asInteger ] 				ifNil: [ self class defaultPort ].				 			path := (matcher subexpressions: 9)				inject: OrderedCollection new 				into: [:coll :each  | coll add: each allButFirst. coll ]. 			owner := matcher subexpression: 10.			projectName := self stripPossibleExtension: (matcher subexpression: 11) ]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!stripPossibleExtension: aString	^ (aString endsWith: '.git')		ifTrue: [ aString allButLast: 4 ]		ifFalse: [ aString ]! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	"Returns the HTTPS default port"		^443! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!protocolID	"Return the protocol identifier"		^'https'! !!IceHttpsRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: aRemote	^ (super referencesSameRemoteLocationAs: aRemote)		or: [ self url = aRemote httpsUrl ] ! !!IceNetworkRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aString 	"I am abstract I can't handle any url."	^ false! !!IceNetworkRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	^self subclassResponsibility! !!IceNetworkRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicUrl: aString	url := (aString endsWith: '.git') 		ifTrue: [ aString ]		ifFalse: [ aString, '.git' ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ { 		'Origin' -> self url.		'Remote User' -> self userName.		'Remote host' -> (self port = self class defaultPort ifTrue: [ self host ] ifFalse: [self host, ':', self portName]).		'Repo Owner' -> self owner.	} ! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ host! !!IceNetworkRemote methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!organizer	^ self owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner	 ^ owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!path	^path ifNil: [ path := OrderedCollection new ].! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!port	^port ifNil: [ self class defaultPort ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!portName	^self port asString! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectPath	^ self owner, '/', self projectName! !!IceNetworkRemote methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: another	^ (self url withoutSuffix: '.git') = (another url withoutSuffix: '.git')! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!user	^user! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!userName	^user ifNil: [ '' ]	! !!IceScpRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	"Very simplistic implementation that does not cover all cases"	^ (aRepositoryUrl beginsWith: 'git@' )		or: [aRepositoryUrl beginsWith: 'ssh://']! !!IceScpRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	^ 22! !!IceScpRemote methodsFor: 'private - patches' stamp: ' 7/24/2017 12:50:04'!httpsUrl	^ 'https://{1}/{2}.git' format: { self host . self projectPath }! !!IceScpRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	| matcher |	matcher := '(ssh\://)?(git@)?([\w.]+)(\:|/)/?([\w\-]+)/([\w\-]+)(\.git)?' asRegex.	(matcher matches: url) 		ifTrue: [			host := matcher subexpression: 4.			owner := matcher subexpression: 6.			projectName := matcher subexpression: 7.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceScpRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: aRemote	^ ((super referencesSameRemoteLocationAs: aRemote)		or: [ self httpsUrl = aRemote httpsUrl ])			! !!IceRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ self subclassResponsibility ! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!name: aName url: anUrl	^ (self url: anUrl)		remoteName: aName;		yourself! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!url: aRepositoryUrl	self allSubclasses  		detect: [ :subclass | subclass canHandleUrl: aRepositoryUrl ]		ifFound: [ :subclass | ^ subclass new url: aRepositoryUrl ]		ifNone: [ IceWrongUrl signal: 'Remote repository scheme not supported: ', aRepositoryUrl ]! !!IceRemote methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	^ self species = another species and: [ self referencesSameRemoteLocationAs: another ]	! !!IceRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicUrl: aString	url := aString! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ #()! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ self subclassResponsibility! !!IceRemote methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!httpsUrl	"This method is used to compare exchangeable addresses (https:// and git@). 	 So it has sense in my children, and is notably used on #isSameUrl: 	 implementations"	^ self url! !!IceRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isOrigin	^ self remoteName = 'origin'! !!IceRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSame: aRemote	^ (self referencesSameRemoteLocationAs: aRemote)		and: [ self remoteName = aRemote remoteName ]! !!IceRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	^ self subclassResponsibility ! !!IceRemote methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: stream	stream 		<< (self remoteName ifNil: [ 'noname' ]) 		<< ' (' << self url << ')'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectBasename	^ self projectName withoutSuffix: '.git'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ projectName! !!IceRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: another	"Base/trivial implementation is that two urls are the same if they are equal, 	but some subclasses have more complicated logic to detect two urls pointing to the same remote"	^ self url = another url	! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteName	^ remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteName: anObject	remoteName := anObject! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!upstreamForBranch: aBranch backend: backend	^ backend 		lookupBranchNamed: aBranch name 		inRemote: self remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url	^ url! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url: aString	self basicUrl: aString.	self parseUrl! !!IceUndefinedRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ false! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ nil! !!IceUndefinedRemote methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	url := 'No remote url'.	projectName := 'No name'.	remoteName := 'No remote'! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!upstreamForBranch: aBranch backend: backend	^ nil! !!IceRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!backend: aBackend	"This should be the only way to create a repository. Usually, this creator is called on 	 IceRepositoryCreator>>#createRepository."	^ self new 		backend: aBackend;		yourself! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultBackend	^ self defaultBackendType		ifNotNil: [ :className | 			Smalltalk				at: className				ifAbsent: [ IceError signal: 'Selected Iceberg backend is missing: ', className ] ]				ifNil: [ 			| backend | 			backend := self detectDefaultBackend.			self defaultBackend: backend.			backend ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultBackend: class	self defaultBackendType: class name! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!defaultBackendType	^ DefaultBackendType ifNil: [ DefaultBackendType := #IceLibgitLocalRepository ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!defaultBackendType: anObject	DefaultBackendType := anObject! !!IceRepository class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!detectDefaultBackend	"Error if not backend"	TIceRepositoryBackend traitUsers 		ifEmpty: [ ^ IceError signal: 'There are no configured backend type' ].		"Detect default backend"	Smalltalk globals 		at: #IceLibgitLocalRepository		ifPresent: [ :class | ^ class ].		^ TIceRepositoryBackend traitUsers anyOne! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!localRepositoriesLocation	^ ((FileLocator respondsTo: #localDirectory) 		ifTrue: [ FileLocator localDirectory / #iceberg ]		ifFalse: [ FileLocator imageDirectory / #'iceberg-cache' ]) asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!registerRepository: aRepository	^ self registry add: aRepository! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!registry	^ Registry ifNil: [ Registry := OrderedCollection new ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoriesLocation 	^ self shareRepositoriesBetweenImages 		ifTrue: [ self sharedRepositoriesLocation ]		ifFalse: [ self localRepositoriesLocation ] ! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!reset	Registry := nil.	Iceberg announcer announce: IceRepositoryForgotten new.! !!IceRepository class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!settingsOn: aBuilder 	<systemsettings>	(aBuilder pickOne: #'defaultBackendType')		parent: #Iceberg;		target: self;		label: 'Backend type';		description: 'Select your preferred way to access git repositories from Iceberg: the git command line (OSSubprocess) or the libgit2 library';		domainValues: 			((TIceRepositoryBackend traitUsers collect: [:class | class description -> class name ]) 				ifEmpty: { 'No backend' -> nil }).		(aBuilder setting: #shareRepositoriesBetweenImages)		parent: #Iceberg;		target: self;		label: 'Share repositories between images';		description: 'Check if you want to have your git repositories cloned by default in a single location that is shared between all your Pharo images';		with: [			(aBuilder setting: #sharedRepositoriesLocationString)				target: self;				type: #Directory;				label: 'Location for shared repositories';				description: 'A directory where you have your git repositories'.		].		! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!shareRepositoriesBetweenImages	^ ShareRepositoriesBetweenImages ifNil: [ ShareRepositoriesBetweenImages := false ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!shareRepositoriesBetweenImages: anObject	ShareRepositoriesBetweenImages := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocation	^ SharedRepositoriesLocation ifNil: [ 		SharedRepositoriesLocation := (FileLocator home / #iceberg) asFileReference ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocation: anObject	SharedRepositoriesLocation := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocationString	^ self sharedRepositoriesLocation fullName! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocationString: aString	SharedRepositoriesLocation := aString asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!unregisterRepository: aRepository ifAbsent: aBlock	^ self registry 		remove: aRepository 		ifAbsent: aBlock ! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!addCommit: newCommit	newCommit repository: self.	self commitDictionary 		at: newCommit id 		put: newCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addFilesToIndex: aListOfPaths	^ self backend 		addFilesToIndex: aListOfPaths! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addPackage: aWorkingCopy	^ self savedPackagesDictionary		at: aWorkingCopy packageName		ifAbsentPut: [			IceSavedPackage 				named: aWorkingCopy packageName 				repository: self ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addPackageNamed: packageName	^ self savedPackagesDictionary		at: packageName		ifAbsentPut: [ IceSavedPackage named: packageName repository: self ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!addRemote: aRemote  	^ self backend addRemote: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!allBranches	^ self backend allBranches	! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ announcer! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer: anObject	announcer := anObject! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend	^ backend! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend: aBackend	aBackend validate.	aBackend frontend: self.	backend := aBackend! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!basicMerge: aCommitish	"Try automatic merge handled by the (git?) repository itself. 	Will raise an IceMergeAborted in case that automatic merge 	detects conflicts that have to be solved manually."	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend merge: aCommitish id.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicOrigin	self isValid ifFalse: [ ^ nil ].	^ [ self backend origin ]		on: LGit_GIT_ENOTFOUND 		do: [ :e | nil ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!beSystemRepository	system := true! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	self isValid ifFalse: [ ^ IceUnknownBranch new ].	^ self backend branch! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self branch name! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!branchesForCheckout	"Returns a list of the most useful branches for being checked out"	| branches |	branches := self backend allBranches.	^ branches select: [ :br |		br isLocal or: [ branches noneSatisfy: [:b | b isLocal and: [ b basename = br basename ]]]	].! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!branchesForMerge: aCommit	"Returns a list of local branches to which we could merge the received commit"	^ self allBranches		select: [:each | (each includesCommit: aCommit) not ].! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/24/2017 12:50:04'!checkForRegistryConflicts	self class registry 		detect: [ :repo | repo location = self location ]		ifFound: [ :repo | self origin = repo origin			ifTrue: [ 				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} and with the same origin URL. If you really whant create another one, please locate it in a different directory.'					 format: {self location pathString}) ]			ifFalse: [				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} but with a different origin URL.You provided {2} and the original repository''s url is {3}.'					 format: {self location. self origin. repo origin}) ]].! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!checkoutBranch: branchName	self backend checkoutBranch: branchName! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitAt: commitId	commitId size = 40 		ifTrue: [ 			^ self commitDictionary 				at: commitId				ifAbsent: [ self lookupCommit: commitId ]].	"Commit id is an abbreviation, sequential search"		(self commitDictionary keys 		select: [ :key | key beginsWith: commitId ]) 		in: [ :possibleKeys | 			possibleKeys size = 1 				ifTrue: [ ^ self commitDictionary at: possibleKeys anyOne ] 				ifFalse: [ possibleKeys isEmpty 					ifTrue: [ ^ self lookupCommit: commitId ] 					ifFalse: [ self error: 'Ambiguous commit hexString: ', commitId  ]]		]! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitAt: commitId ifAbsentPut: aBlock	^ self commitDictionary at: commitId ifAbsentPut: [ 		| newCommit |		newCommit := aBlock value.		newCommit repository: self; yourself 	]! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitCherryPick: pickedCollection withMessage: message	^ self 		commitCherryPick: pickedCollection		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitCherryPick: pickedCollection withMessage: message andParents: parentCommitishList	"Commits a snapshot of definitions (can be a cherry-pick). 	 I need to group definitions in packages and create new versions for those packages, 	 which is annoying but is the price of using MC definitions :)"	| changesByPackage versions |		versions := OrderedCollection new.	changesByPackage := SmallDictionary new.	"Collect changes by package"	pickedCollection 		do: [ :each | (changesByPackage at: each packageName ifAbsentPut: [ Set new ]) add: each ].		"Create patched versions for each package"	changesByPackage 		keysAndValuesDo: [ :packageName :changes | | workingCopy snapshot patcher |			workingCopy := (RPackageOrganizer default packageNamed: packageName) mcWorkingCopy.			snapshot := (self packageNamed: packageName) loadedVersion snapshot.			patcher := MCPatcher snapshot: snapshot.			pickedCollection 				select: [ :each | each operation notNil ]				thenDo: [ :each | each operation applyTo: patcher ].			versions add: (MCVersion new				setPackage: workingCopy package				info: (IceMCVersionInfo package: workingCopy package message: message)				snapshot: patcher patchedSnapshot				dependencies: #()) ].		"save versions"	versions do: [ :each | self backend internalStoreVersion: each ].	"now perform commit"	self doCommitMcVersions: versions withMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitDictionary	^ commitDictionary! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!commitIndexWithMessage: message andParents: parentCommitishList	| packages newCommit |	packages := self stagedPackages.	newCommit := self backend		commitIndexWithMessage: message andParents: parentCommitishList.	self loadedCode 		commited: newCommit changingPackages: packages.	^ newCommit! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitPackages: packagesToCommit withMessage: message	^ self 		commitPackages: packagesToCommit		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitPackages: packagesToCommit withMessage: message andParents: parentCommitishList	| savedVersions |		savedVersions := packagesToCommit collect: [ :package | 		self internalSavePackage: package withMessage: message ].		self		doCommitMcVersions: savedVersions 		withMessage: message 		andParents: parentCommitishList! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitPackagesAndMarkAsMerged: aCommitish	^ self 		commitPackages: self modifiedPackages		withMessage: 'Merging with ', aCommitish id		andParents: { self headCommit . aCommitish }! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitPackagesWithMessage: message	self modifiedPackages 		ifEmpty: [ NothingToCommitException signal ]		ifNotEmpty: [ :packages |			self 				commitPackages: packages				withMessage: message ]! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitsNotLoaded	self backend isUnborn ifTrue: [ ^ #() ].	^ self loadedCode commitsNotLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!contentOfFileNamed: aPathString commit: aCommitId	^ self backend 		contentOfFileNamed: aPathString		commit: aCommitId! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createBranch: branchName	self backend createBranch: branchName.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self origin url, '[', self branchName, ']'! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!detachRemote: aRemote	(self pushRemote isSame: aRemote) ifTrue: [ self pushRemote: nil ].	(self pullRemote isSame: aRemote) ifTrue: [ self pullRemote: nil ]! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!directoryForPackage: mcPackage	| package |	package := self packageNamed: mcPackage name.	^ self subdirectory isEmptyOrNil		ifTrue: [ package directoryName ]		ifFalse: [ self subdirectory, '/', package directoryName ]! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!doCommitMcVersions: versions withMessage: message andParents: parentCommitishList	self addFilesToIndex: (versions collect: [ :version | self directoryForPackage: version package ]).	^ self commitIndexWithMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!ensureBranch: branchName	(self hasLocalBranchNamed: branchName)		ifFalse: [ self createBranch: branchName ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	self fetchFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetchFrom: aRemote		self backend fetchFrom: aRemote.	self refresh.! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/24/2017 12:50:04'!forget	(self class unregisterRepository: self ifAbsent: [ nil ])		ifNotNil: [ Iceberg announcer announce: (IceRepositoryForgotten repository: self) ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasLocalBraches	^ self localBranches isNotEmpty! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasLocalBranchNamed: aString	^ self backend localBranchNames includes: aString! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headCommit	^ self branch lastCommit! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!includesCommit: anIceCommit	^ [ self commitAt: anIceCommit id. true ] 		on: LGit_GIT_ENOTFOUND do: [ false ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!includesPackageNamed: aString	^ self savedPackagesDictionary includesKey: aString! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	self pullRemote ifNil: [ ^ #() ].	^ self incomingCommitsFrom: self pullRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommitsFrom: aRemote	^ (SortedCollection sortBlock: [ :a :b | a datetime > b datetime ])		addAll: self commitsNotLoaded;		addAll: (self branch incomingCommitsFrom: aRemote);		yourself! !!IceRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	system := false. "by default, this is not a system repository"	commitDictionary := Dictionary new.	self initializeAnnouncer.	loadedCode := IceLoadedCode repository: self.! !!IceRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeAnnouncer	announcer 		ifNil: [ announcer := Announcer new ]		ifNotNil: [	announcer subscriptions reset ].	announcer weak		when: IceCommited, IcePackageLoaded 		send: #refresh 		to: self! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!internalSavePackage: package withMessage: commitMessage	"Save a package to the underlying store but do not commit"	| workingCopy newVersion |	workingCopy := 	package workingCopy.	"This hack is copied from MCWorkingCopy code, I do not know why it is necessary."	workingCopy modified: true; modified: false.		(workingCopy repositoryGroup includes: self backend) 		ifFalse: [ workingCopy repositoryGroup addRepository: self backend ].	newVersion := MCVersion new		setPackage: workingCopy package		info: (IceMCVersionInfo package: package message: commitMessage)		snapshot: workingCopy package snapshot		dependencies: #(). "Note we do not track Monticello dependencies."	self backend internalStoreVersion: newVersion.	SystemAnnouncer uniqueInstance		announce: (MCVersionSaved version: newVersion repository: self backend).		^ newVersion ! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isCodeMissing	^ self backend isCodeMissing! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!isFilePartOfAPackage: aFileReferenceRelativeToRepositoryDirectory	| packageSuffix segments |	packageSuffix := '.package'.	segments := aFileReferenceRelativeToRepositoryDirectory path segments.	^ self subdirectory isEmptyOrNil		ifTrue: [ segments first endsWith: packageSuffix ]		ifFalse: [  (segments first = self subdirectory) and: [ segments second endsWith: packageSuffix ] ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isMissing	^ self backend isMissing ! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!isModified	^ self loadedPackages anySatisfy: #isModified! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPullRemote: aRemote	^ self pullRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPushRemote: aRemote	^ self pushRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSystemRepository	"Indicated if this repository is a system repository (for example, 'pharo' itself).	 This is useful because we do not want to treat all repositories the same. System 	 repositories, although present, shouldn't be visible by default (unless desired), 	 for example"	^ system! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isValid	self flag: #todo. "Make this tests more solid"	^ self isMissing not		and: [ self isCodeMissing not ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedCode	^ loadedCode! !!IceRepository methodsFor: 'working copies' stamp: ' 7/24/2017 12:50:04'!loadedPackages	^ self savedPackages select: #isLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!localBranches	^ self backend localBranchNames collect: [ :branchName | 		IceLocalBranch named: branchName inRepository: self ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ self backend location! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: aFileReference	self backend location: aFileReference.	aFileReference ifNil: [ ^ self ].	name := nil. "New location may mean new repository with new name"	self refresh.	! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!lookupCommit: commitId	^ self backend newCommitWalk 		fromCommitId: commitId; 		firstCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: aCommitish	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other types of commitish."	[ self basicMerge: aCommitish ]		on: IceMergeAborted		do: [ :error | self mergeConflictsWith: aCommitish ] ! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: aCommitish into: aBranch	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other 	 types of commitish."	self backend 		merge: aCommitish id 		into: aBranch basename! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeBaseBetween: anId and: otherId	^ self backend 		mergeBaseBetween: anId 		and: otherId! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseWith: aCommitInfo	^ self loadedCode mergeBaseWith: aCommitInfo! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergeConflictsWith: aCommitish	"Use version merger to create a new version. 	If all conflicts are resolved, commit it to the repository, 	marking it as parent to the received commitish."	| versionsChangedInCommit |	versionsChangedInCommit := aCommitish versionsChangedSince: (self mergeBaseWith: aCommitish).	(MCVersionMerger new		addVersions: (versionsChangedInCommit collect: #mcVersion);		merge)		ifTrue: [ self commitPackagesAndMarkAsMerged: aCommitish ]! !!IceRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!metacelloAdapter	^ IceMetacelloRepositoryAdapter for: self! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!modifiedPackages	^ self loadedPackages 		select: [ :package | package workingCopy needsSaving ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name ifNil: [ name := self origin projectBasename ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: aString	"Change the name of the repository as is seen inside image (real project name resides 	 externally, in repository). This can be confusing, but some times you need it to create new 	 repositories from image (before creating repository externally... which means no remote)"	name := aString! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!newCommitWalk	^ self backend newCommitWalk! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!origin	^ self basicOrigin 		ifNil: [ IceUndefinedRemote new ]! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ self branch outgoingCommits ! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote	^ self branch outgoingCommitsTo: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!packageNamed: packageName	^ self savedPackagesDictionary at: packageName! !!IceRepository methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self origin url;		nextPut: $)! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pull	self pullFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pullFrom: aRemote	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend pullFrom: aRemote.	self refresh.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pullRemote	^ pullRemote ifNil: [ pullRemote := self pushRemote ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pullRemote: aRemote	pullRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!push	self pushTo: self pushRemote! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pushRemote	^ pushRemote ifNil: [ pushRemote := self basicOrigin ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pushRemote: aRemote	pushRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushTo: aRemote		self backend pushTo: aRemote.	self refresh.	self announcer announce: IcePushed new! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!refresh	self branch refresh.	self loadedCode refresh.	commitDictionary := Dictionary new.	savedPackages := nil.	self announcer announce: (IceRepositoryModified for: self)! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/24/2017 12:50:04'!register	self checkForRegistryConflicts.	self class registerRepository: self.	Iceberg announcer announce: (IceRepositoryCreated repository: self).	^ self ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!remotes	self isValid ifFalse: [ ^ #() ].	^ self backend remotes ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!removeRemote: aRemote	self backend removeRemote: aRemote.	self detachRemote: aRemote! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!revparse: aString 	"Right now this is necessary because Metacello provides a tag objectId instead of a commitId"	^ self backend revparse: aString! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!saveContent: aString inWorkingCopyFile: aRelativePathString	| outputFile |	outputFile := (self backend repositoryDirectory fullName , '/' , aRelativePathString) asFileReference.	outputFile writeStreamDo: 		[ :stream |		stream nextPutAll: aString ].	self addFilesToIndex: { aRelativePathString }.	^ outputFile! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!savedPackages	^ self savedPackagesDictionary values! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!savedPackagesDictionary	^ savedPackages ifNil: [ savedPackages := self backend lookupPackages ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!stagedFiles	^ self backend stagedFiles! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!stagedPackageNames	^ self stagedFiles 		select: [ :fileRef | self isFilePartOfAPackage: fileRef ]		thenCollect: [ :fileRef | 			self subdirectory isEmptyOrNil 				ifTrue: [ fileRef path segments first asFileReference basenameWithoutExtension ] 				ifFalse: [ fileRef path segments second asFileReference basenameWithoutExtension ] ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!stagedPackages	^ self stagedPackageNames		select: [ :each | self includesPackageNamed: each ]		thenCollect: [ :packageName | self packageNamed: packageName ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ self backend subdirectory! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory: aString	self backend subdirectory: aString.	self refresh! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!updatePackage: packageName 	self backend pull.	(self packageNamed: packageName) loadLatest.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: aName email: anEmail global: globalBoolean	^ self backend 		username: aName 		email: anEmail 		global: globalBoolean! !!IceRepository methodsFor: 'versions handling' stamp: ' 7/24/2017 12:50:04'!versionLoaded: version 	loadedCode versionLoaded: version.	self announcer announce: (IcePackageLoaded version: version).	self refresh! !!IceRepository methodsFor: 'working copies' stamp: ' 7/24/2017 12:50:04'!workingCopies	^ self loadedPackages collect: #workingCopy! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!workingCopyDiff	^ IceDiff forRepository: self! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!workingCopyDiffToCommit: anIceCommitInfo	^ IceDiff forRepository: self commit: anIceCommitInfo! !!IceRepositoryCreator class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultSubdirectory	^ ''! !!IceRepositoryCreator class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isGitRoot: aReference	self flag: #todo. "This does not understand submodules"	^ aReference isDirectory 		and: [ (aReference directoriesMatching: '.git') notEmpty		and: [ (aReference / '.git' / 'config') exists ] ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ branchName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName: anObject	branchName := anObject! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createNewRepositoryNamed: aString	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	(locationToUse exists 		and: [ locationToUse hasChildren ])		ifTrue: [ IceError signal: ('{1} is not empty.' format: {locationToUse fullName}) ].			locationToUse ensureCreateDirectory.	self subdirectory  		ifNotEmpty: [ (locationToUse / self subdirectory) ensureCreateDirectory ].	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	backend init.	^ (IceRepository backend: backend)		name: aString;		yourself! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	(locationToUse exists not or: [ locationToUse hasChildren not ])		ifTrue: [ 			backend 				cloneRepositoryFrom: self remoteToUse 				branch: self branchName ].	^ IceRepository backend: backend! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!defaultLocation	| remoteToUse |	remoteToUse := self remoteToUse.	^ IceRepository repositoriesLocation 		/ remoteToUse organizer 		/ remoteToUse projectName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ location! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: anObject	location := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!locationToUse	^ self location ifNil: [ self defaultLocation ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!remoteToUse	self remote ifNotNil: [ ^ self remote ].	self url ifNotNil: [ ^ IceRemote url: self url ]. 	^ nil! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storageClass	^ storageClass ifNil: [ storageClass := IceRepository defaultBackend ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storageClass: aClass	storageClass := aClass! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ subdirectory ifNil: [ self class defaultSubdirectory ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory: anObject	subdirectory := anObject! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url	^ url! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url: anObject	url := anObject! !!IceRepositoryCreator methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validate	"Validate something is provided to create the repo (I need url OR location OR remote), 	 but the 3 cannot be nil"	(self location isNil 		and: [ self remoteToUse isNil ])		ifTrue: [ IceError signal: 'No location/url or remote defined.' ].			"Validate if I will add a local repository (url isNil and location isNotNil)... testing the 	 local directory actually exists"	(self remoteToUse isNil 		and: [ self location notNil 		and: [ self location exists 		and: [ (self class isGitRoot: self location) not ] ] ])		ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: { self location fullName }) ]! !!IceSavedPackage class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: packageName repository: repository	^ self new 		package: (IcePackageReference named: packageName); 		repository: repository; 		yourself! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	^ self species = another species 		and: [ self repository = another repository 		and: [ self name = another name ]]! !!IceSavedPackage methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	^ self package browse! !!IceSavedPackage methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!computeLoadedVersion	| workingCopyAncestors |	workingCopyAncestors := self package workingCopy ancestors.	workingCopyAncestors ifEmpty: [ ^ IceTemporaryVersion forPackage: self ].	self workingCopy ancestors		detect: [ :ancestor | 			(ancestor respondsTo: #iceVersion) and: [ 			(ancestor commit notNil) and: [			self repository includesCommit: ancestor commit ]]]		ifFound: [ :ancestor | ^ ancestor iceVersion ].	self workingCopy repositoryGroup repositories do: [ :mcRepo |		mcRepo 			commitIdFor: self workingCopy 			ifFound: [ :commitish | 				[ 					| commit |					commit := (self repository revparse: commitish).					^ commit versionFor: self 				] 				on: LGit_GIT_ENOTFOUND 				do: [					"If we cannot parse commitish, we asume that it is a commit ID which is unknown for this repo, 					so we just ignore it. Maybe we should consider other cases and handle them adecquately."				]]	].			^ IceForeignVersion forPackage: self.! !!IceSavedPackage methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!directoryName	^ package packageName, '.package'! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!directoryPathString	^ self repository subdirectory isEmptyOrNil 		ifTrue: [ self directoryName ]		ifFalse: [ self repository subdirectory, '/',  self directoryName ].! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!hash	^ self name hash! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ self loadedVersion incomingCommits ! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isExported	| location |	location := self location.	^ location exists and: [ location hasChildren ]! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self package isLoaded! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isModified	^ self package workingCopy modified! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!latestVersion	^ self repository headCommit versionFor: self! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!loadLatest	self latestVersion load.	! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!loadedVersion	^ self repository loadedCode versionFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	| location |	 	location := self repository location.	(self directoryPathString substrings: '/')		do: [ :each | location := location / each ].	^ location! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ self package packageName! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ self repository branch outgoingCommits: [ :walk | walk modifyingPackage: self ]! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package: anObject	package := anObject! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package packageName! !!IceSavedPackage methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name.	self package printDescriptionOn: aStream! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!reload	self latestVersion load.	! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDisk	self isLoaded ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDisk: force	(self isLoaded and: [ force not ]) ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!unload	self workingCopy unload.	self repository announcer 		announce: IcePackageUnloaded new.	self repository refresh! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: aCommitId	^ (self repository commitAt: aCommitId) versionFor: self! !!IceSavedPackage methodsFor: 'versions' stamp: ' 7/24/2017 12:50:04'!versionLike: selectBlock ifNone: ifNoneBlock	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch 		versionsFor: self 		detect: selectBlock 		ifNone: ifNoneBlock ! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versions	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch versionsFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!workingCopy	^ self package workingCopy! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultPrivateKey 		self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultPublicKey	self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa.pub') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultUsername	^ 'git'! !!IceSshCredentials methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPresent	^ self username notEmpty 		and: [ self publicKey notEmpty 		and: [ self privateKey notEmpty ] ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!keyPassphrase	^ keyPassphrase ifNil: [ keyPassphrase := '' ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!keyPassphrase: anObject	keyPassphrase := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!privateKey	^ privateKey ifNil: [ privateKey := self class defaultPrivateKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!privateKey: anObject	privateKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!publicKey	^ publicKey ifNil: [ publicKey := self class defaultPublicKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!publicKey: anObject	publicKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ username ifNil: [ username := self class defaultUsername ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: anObject	username := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ icebergAnnouncer ifNil: [ icebergAnnouncer := Announcer new ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!enableMetacelloIntegration	^ EnableMetacelloIntegration ifNil: [ EnableMetacelloIntegration := true ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!enableMetacelloIntegration: anObject	EnableMetacelloIntegration := anObject! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!icebergRepositoriesURLs	^ {		'git@github.com:pharo-vcs/iceberg.git'. 		'git@github.com:pharo-vcs/filetree.git'.		'git@github.com:pharo-vcs/libgit2-pharo-bindings.git'	}! !!Iceberg class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:04'!initialize	| tree nodes |	tree := SystemSettingsPersistence default settingTree.	nodes := tree deeplySelect: [ :node | node receiverPackage name beginsWith: 'Iceberg' ].	SystemSettingsPersistence updateSettingNodes: nodes.! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!mcRepositoryFor: aLocationString	^ (IceMetacelloRepositoryType for: aLocationString) mcRepository ! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageForCategoryNamed: categoryName	| systemPackage |	systemPackage := RPackageOrganizer default packageMatchingExtensionName: categoryName.	^ self packageNamed: systemPackage name! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNamed: packageName	^ IcePackageReference named: packageName! !!Iceberg class methodsFor: 'maintenance' stamp: ' 7/24/2017 12:50:04'!rebuildRepositories	IceRepository registry do: [ :repo | 		repo initialize.		"repo branch: nil."		repo commitDictionary.		repo loadedPackages do: [ :pkg | repo versionLoaded: pkg computeLoadedVersion ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteTypeSelector	"Should be #scpURL or #httpsURL"	^ RemoteTypeSelector ifNil: [ RemoteTypeSelector := #scpUrl ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteTypeSelector: anObject	RemoteTypeSelector := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryForPackage: anRPackage 	| existingRepositories possibleRepositoryTypes |		existingRepositories := (MCWorkingCopy forPackage: anRPackage mcPackage) repositoryGroup repositories.	possibleRepositoryTypes := TIceRepositoryBackend traitUsers, 		{ IceMetacelloRepositoryAdapter. 		  MCGitHubRepository }.		possibleRepositoryTypes do: [ :class |		existingRepositories 			detect: [ :repo | repo isKindOf: class ]			ifFound: [ : repo |  ^ repo getOrCreateIcebergRepository ] ].	self error: ('Could not find a git repository for {1}' format: {anRPackage name})	! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!settingsOn: aBuilder 	<systemsettings>	(aBuilder group: #Iceberg)		parent: #SCM;		with: [ 			(aBuilder setting: #enableMetacelloIntegration)				target: self;				order: 0.1;				label: 'Enable Metacello integration';				description: 'If selected, Metacello github// repositories will be loaded using iceberg';"				icon: (Smalltalk ui icons iconNamed: #smallConfigurationIcon);"				with: [ 					(aBuilder pickOne: #remoteTypeSelector)						label: 'Remote type';						description: 'When creating an Iceberg repository out of a github:// URL choose whether you want to user an SCP URL (i.e. with the form ''git@github.com:<username>/<project>.git'') or an HTTPS URL (i.e. with the form ''https://github.com/<username>/<project>.git''';						domainValues: {							'SCP (git@github.com:<username>/<project>.git)' -> #scpUrl.							'HTTPS (https://github.com/<username>/<project>.git)' -> #httpsUrl						}.				].			(aBuilder setting: #showSystemRepositories) 				order: 0.2;				label: 'Include system repositories by default';				description: 'If checked then system repositories (like ''pharo'') will be shown in repositories list by default';				target: self.		]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!showSystemRepositories	^ ShowSystemRepositories ifNil: [ ShowSystemRepositories := false ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!showSystemRepositories: aBoolean	ShowSystemRepositories := aBoolean! !!Iceberg class methodsFor: 'updating' stamp: ' 7/24/2017 12:50:04'!update	#(Iceberg LGitRepository MCFileTreeGitRepository) do: [:className | 		Smalltalk 			at: className 			ifPresent: [ :class | class package iceRepository pull ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!workingCopyForPackageNamed: packageName	^ (self packageNamed: packageName) workingCopy! !"Iceberg"!!IcePlugin commentStamp: '<historical>' prior: 0!I'm a base for all kind of plugins. I can define - repositoryActions (actions that will be added to IceRepositoriesBrowser, repositories section)- ... (TBD)!!IceBaselineInstallerPlugin commentStamp: 'EstebanLorenzano 4/7/2017 12:36' prior: 0!I'm a plugin who allows Baselines to be installed from Iceberg (just right-click and install).It adds two options to packages tab of repositories browser: - Install baseline (default)- Install baseline...2nd one allows to pick groups to install!!IcePharoFogbugzPlugin commentStamp: 'EstebanLorenzano 2/13/2017 16:59' prior: 0!I'm a pluging to handle fogbugz issues integration. It just add options to easily handle the creation of branchs with the "convention" issue naming format (number-plus-normalised-title): 12345-a-sample-of-issue-branchNOTE: In the future we can add other fogbugz elements (like list issues, etc.), but since API is very slow we will consider it very carefully. !!IcePluginManager commentStamp: '<historical>' prior: 0!I keep plugins configured for a repository. WARNING: Managers are kept in a week dictionary with Repository as a key, reason why plugins can't have any kind of reference that could cause a memory leak. Consider using stateless plugins or instance copies of relevant information instead.!!IcePharoFogbugzModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for issue number to create correct branchs for Pharo Development.!!IceRepository methodsFor: '*Iceberg-Plugin' stamp: ' 7/24/2017 12:50:04'!pluginManager	^ IcePluginManager managerFor: self! !!IceBaselineInstallerPlugin class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baselinePrefix	^ 'BaselineOf'! !!IceBaselineInstallerPlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	^ true! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!installBaseline: icePackage groups: anArray	| packageDir baselineName |		packageDir := icePackage location parent fullName.	baselineName := icePackage name allButFirst: self class baselinePrefix size.	Metacello new		repository: 'gitlocal://', packageDir;		baseline: baselineName;		load: anArray! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!installBaselineGroups: icePackage	| groupsString groups |		groupsString := self pickGroupsOnCancel: [ ^ self ].	groups := groupsString 		ifNotNil: [ (groupsString substrings: ',') collect: #trimBoth as: Array ]		ifNil: [ #() ].	self installBaseline: icePackage groups: groups! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!installDefaultBaseline: icePackage	self installBaseline: icePackage groups: #()! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!installDefaultBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installDefaultBaseline: presentation selection entity ];		showTitle: 'Install baseline (default)'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!installGroupsBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installBaselineGroups: presentation selection entity ];		showTitle: 'Install baseline...'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageActionsFor: icePackage	^ (icePackage packageName beginsWith: self class baselinePrefix) 		ifTrue: [ { self installDefaultBaselineAction. self installGroupsBaselineAction } ]		ifFalse: [ #() ]! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pickGroupsOnCancel: aBlock	| result |	result := UIManager default 		request: 'Groups to install (a comma separated string)' 		initialAnswer: '' 		title: 'Enter groups to install'.	result ifNil: [ ^ aBlock value ].	^ result! !!IcePharoFogbugzPlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	"ATTENTION: Bad practice!!		We cannot resolve remotes during repository creation so we unfortunately need this	pluggin enabled for all repositories. Please do not create own pluggins enabled for all	repositories unless you have a very, very, very good reason."		^ true! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasPharoInOrigin: aRepository	| origin |	origin := aRepository origin.	^ (origin host = 'github.com')		and: [ origin owner = 'pharo-project'		and: [ origin projectName = 'pharo' ] ]! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasPharoInRemotes: aRepository	^ aRepository remotes anySatisfy: [ :aRemote |		self pharoURLs includes: aRemote url ].! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	^ (self hasPharoInOrigin: aRepository) or: [ self hasPharoInRemotes: aRepository ]! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newFogbugzIssue: aRepository then: aBlock	IcePharoFogbugzModel new 		onAccept: [ :branchName | 			aRepository createBranch: branchName.			aBlock value ];		openWithSpec.! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newIssueFixAction	^ GLMGenericAction new		action: [ :presentation | 			self 				newFogbugzIssue: presentation selection repository				then: [ presentation pane browser update ] ];		category: 'Pharo';		showTitle: 'Create new branch from FogBugz issue...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself	! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newPullRequest: aRepository	"(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRepository pushRemote;		execute"! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newPullRequestAction	"This actions are copied from GitHub plugin, but presented here to make it easier"	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'Pharo';		showTitle: 'Create pull request...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pharoURLs	"list of repository URLs for official Pharo upstream"	^ #(		'git@github.com:pharo-project/pharo.git' 		'https://github.com/pharo-project/pharo.git'	)! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryActions	^ { 	self newIssueFixAction.	}! !!IcePlugin class methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!allAvailableFor: aRepository	^ self allSubclasses select: [ :each | each isAvailableFor: aRepository ]! !!IcePlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	^ self subclassResponsibility! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageActionsFor: aPackage	"answer a list of glamour actions (GLMAction) that defines operations in the packages panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteActionsFor: aRemote	"answer a list of glamour actions (GLMAction) that defines operations in the remotes tab panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryActions	"answer a list of glamour actions (GLMAction) that defines operations in the repository panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!managerFor: aRepository	^ self managers 		at: aRepository 		ifAbsentPut: [ self basicNew initializeRepository: aRepository ].! !!IcePluginManager class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!managers 	^ Managers ifNil: [ Managers := WeakKeyDictionary new ]! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #managerFor:'! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addPlugin: aPlugin 	plugins := plugins copyWith: aPlugin! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!availablePluginsFor: aRepository	^ (IcePlugin allAvailableFor: aRepository) 		collect: #new		as: Array! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeRepository: aRepository.	self initialize.	plugins := self availablePluginsFor: aRepository! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!packageActionsFor: aPackage	^ self plugins		inject: #() 		into: [ :all :each | all, (each packageActionsFor: aPackage) ]! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plugins 	^ plugins! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!remoteActionsFor: aRemote	^ self plugins 		inject: #() 		into: [ :all :each | all, (each remoteActionsFor: aRemote) ]! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!repositoryActions	^ self plugins 		inject: #() 		into: [ :all :each | all, (each repositoryActions) ]			! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 660@35! !!IcePharoFogbugzModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec>		^ SpecLayout composed		newRow: [ :row |			row 				add: #issueNumberText width: 50;				add: #issueText;				add: #createButton width: 80 ] height: self inputTextHeight! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'New branch from FogBugz issue'! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!unknownTitle	^ 'INVALID-ISSUE'! !!IcePharoFogbugzModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createBranch	| branchName |		branchName := '{1}-{2}' format: { 		issueNumberText text trim. 		issueText text trim }.	acceptBlock ifNotNil: [ acceptBlock value: branchName ].	self window delete! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton	^ createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton: anObject	createButton := anObject! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IcePharoFogbugzModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	issueNumberText := self newTextInput autoAccept: true.	issueText := self newTextInput autoAccept: true.	createButton := self newButton enabled: false.			issueNumberText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueNumberText textHolder 		whenChangedDo: [ :text | self validateIssue: text ].		createButton 		label: 'Create';		icon: #add asIcon;		action: [ self createBranch ].			self focusOrder 		add: issueNumberText;		add: issueText;		add: createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueNumberText	^ issueNumberText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueNumberText: anObject	issueNumberText := anObject! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueText	^ issueText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueText: anObject	issueText := anObject! !!IcePharoFogbugzModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock 	acceptBlock := aBlock! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!sanitizeTitle: aString	| separators safeSeparator |		aString isEmptyOrNil ifTrue: [ ^ self class unknownTitle ].		safeSeparator := $-.	separators := { Character space. Character tab. $_. safeSeparator }.	^ String streamContents: [ :str | 		aString do: [ :c |			(separators includes: c) ifTrue: [ str nextPut: safeSeparator ].			c isAlphaNumeric ifTrue: [ str nextPut: c ] ] ]! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ self class title! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!updateText: aString 	issueText text: aString! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validateIssue: aString	| number |	aString size = 5 ifFalse: [ ^ self ].	aString isAllDigits ifFalse: [ ^ self ].	number := aString asNumber.		(issue isNil or: [ issue number ~= number ])		ifTrue: [ 			issue := PharoIssue number: number.			[ 	"Fork to allow UI to continue"				issue downloadTitle.				UIManager default defer: [ 					self updateText: (self sanitizeTitle: issue title).					self createButton enabled: true ] ] fork ]	! !"Iceberg-Plugin"!!IceMetacelloRepositoryType commentStamp: '<historical>' prior: 0!I'm a base class to provide different type of MCRepositories from iceberg, so metacello can do his work of installing packages.My children define specific types, visit them to have more details of what you can do.!!IceGitLocalRepositoryType commentStamp: 'EstebanLorenzano 12/12/2016 10:43' prior: 0!I resolve git local repositories (repositories already existing on your disk).A gitlocal repositoy is composed of: gitlocal://full/path/to/repositorygitlocal  		- The git local identifierfull/path/...	- This is a path to the place where the sources are. 	For example, if you have a  repository in '/dev/voyage', which also has sources in subdirectory 'mc', your full path will be: '/dev/voyage/mc'. A part of my responsibilities is to find the git root  in the path provided.Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'gitlocal://Users/esteban/Dev/Repository/voyage/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceProviderRepositoryType commentStamp: '<historical>' prior: 0!I 'm a base class to resolve provider-based repositories.A provider repositoy is composed of: provider://username/repository[:commitish][/subdir]provider  	- The provider identifier (e.g. github, bitbucket, etc.)username 	- The provider userrepository	- The provider repositorycommitish	- an optional commitish (a branch, a tag, a commit id)subdir		- an optional subdirectory where the packages exist.		Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'github//pharo-nosql/voyage:master/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceBitbucketRepositoryType commentStamp: 'EstebanLorenzano 7/23/2017 13:18' prior: 0!I resolve Bitbucket repositories!!IceGithubRepositoryType commentStamp: 'EstebanLorenzano 7/23/2017 13:18' prior: 0!I resolve Github repositories!!IceGitlabRepositoryType commentStamp: 'EstebanLorenzano 7/23/2017 13:18' prior: 0!I resolve Gilab repositories!!IceMetacelloPharoPlatform commentStamp: '<historical>' prior: 0!I'm a class to add support for iceberg to metacello.!!IceGitLocalRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'gitlocal'! !!IceGitLocalRepositoryType methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isGitRoot: aReference	^ IceRepositoryCreator isGitRoot: aReference! !!IceGitLocalRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	| repository tuple extractedLocation |		tuple := self splitRootAndSubdirectoryFromLocation.	extractedLocation := tuple first asFileReference asAbsolute.	repository := IceRepository registry 		detect: [ :each | each location asAbsolute = extractedLocation ]		ifNone: [ 			(IceRepositoryCreator new 				location: tuple first;				subdirectory: tuple second;				createRepository)				register ].				^ repository metacelloAdapter! !!IceGitLocalRepositoryType methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!splitRootAndSubdirectoryFromLocation	| root subDir |		(self location beginsWith: (self class type, '://'))			ifFalse: [ self error: 'Invalid URL (It should be ', self class type, '://...)' ].	root := (self location allButFirst: self class type size + 3) asFileReference.	subDir := #().	[ root isNil or: [ self isGitRoot: root ] ] 		whileFalse: [ 			subDir := subDir copyWithFirst: root basename.			root := root parent ].	root ifNil: [ self error: 'I can''t find a .git/config file.' ].		^ { 		root. "a FileReference"		String streamContents: [ :stream | subDir asStringOn: stream delimiter: '/' ] "a String" }! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!allTypes	^ self allSubclasses select: [ :each | each isAbstract not ]! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleType: aType 	^ self allTypes		anySatisfy: [ :each | each isSuitableForType: aType ]  	! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!extractTypeOf: aString 	^ aString copyUpTo: $:! !!IceMetacelloRepositoryType class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aLocationString	^ (self allTypes		detect: [ :each | each isSuitableForLocation: aLocationString ])		location: aLocationString! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAbstract	^ self = IceMetacelloRepositoryType! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSuitableForLocation: aLocationString	^ self isSuitableForType: (self extractTypeOf: aLocationString) ! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSuitableForType: aType	^ self type = aType! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!location: aLocationString	self = IceMetacelloRepositoryType 		ifTrue: [ self error: 'I''m an abstract class, use one of my children instead.' ].		^ self basicNew		initializeLocation: aLocationString;		yourself! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ self subclassResponsibility! !!IceMetacelloRepositoryType methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeLocation: aString	location := aString.	self initialize! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ location! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	self subclassResponsibility! !!IceBitbucketRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'bitbucket'! !!IceGithubRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'github'! !!IceGithubRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	| baseRepo |		baseRepo := MCGitHubRepository location: self location.	^ (Iceberg icebergRepositoriesURLs includes: baseRepo scpUrl)		ifTrue: [ 			"Do not use Iceberg to load iceberg code, 			see https://github.com/pharo-vcs/iceberg/issues/168"			baseRepo ]		ifFalse: [  			baseRepo getOrCreateIcebergRepository metacelloAdapter ]		! !!IceGitlabRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'gitlab'! !!IceProviderRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAbstract	^ super isAbstract		or: [ self = IceProviderRepositoryType ]! !!IceProviderRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	| baseRepo |		baseRepo := MCGitHubRepository location: self location.	^ baseRepo getOrCreateIcebergRepository metacelloAdapter! !!IceMetacelloPharoPlatform class methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	 self select! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/24/2017 12:50:04'!createRepository: aRepositorySpec	| type |	type := aRepositorySpec type.	type = 'ftp' ifTrue: [ | description headerSize index host directory |		description := aRepositorySpec description.		headerSize := 'ftp://' size.		index := description indexOf: $/ startingAt: headerSize + 1.		host := description copyFrom: headerSize + 1 to: index - 1.		directory := description copyFrom: index + 1 to: description size.		^ MCFtpRepository			host: host 			directory: directory 			user: aRepositorySpec username			password: aRepositorySpec password ].				(Iceberg enableMetacelloIntegration 		and: [ IceMetacelloRepositoryType canHandleType: type ])		ifTrue: [ ^ Iceberg mcRepositoryFor: aRepositorySpec description ].				^ super createRepository: aRepositorySpec! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/24/2017 12:50:04'!extractTypeFromDescription: description	(description beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].	IceMetacelloRepositoryType allTypes 		detect:  [ :each | each isSuitableForLocation: description  ] 		ifFound: [ :class | ^ class type ].	^ super extractTypeFromDescription: description! !"Iceberg-Metacello-Integration"!!TIceTool commentStamp: 'NicoPasserini 9/2/2016 15:27' prior: 0!Utilities for Iceberg GUI tools.!!IceAskForPlaintextCredentialsModel commentStamp: 'NicoPasserini 11/15/2016 15:25' prior: 0!A dialog for asking plaintext credentials (username and password) to the user.!!IceAskForSshCredentialsModel commentStamp: 'EstebanLorenzano 2/8/2017 17:52' prior: 0!A dialog for asking ssh credentials to the user.!!IceAskForUsernameAndEmailModel commentStamp: '<historical>' prior: 0!I'm a dialog for asking "user.name" and "user.email" .!!IceCommitInfoModel commentStamp: '<historical>' prior: 0!I'm a simple spec model to show IceCommitInfo details. (self for: aCommitInfo) openWithSpec.!!IceCommitModel commentStamp: 'NicoPasserini 8/25/2016 14:47' prior: 0!Spec model for commit (and related) operations.!!IceCherryPickCommitModel commentStamp: '<historical>' prior: 0!Spec model for commit (and related) operations using cherry-pick.!!IceCreateRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 17:51' prior: 0!Base class for avoiding code duplications between dialogs that create repositories. !!IceCloneRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:44' prior: 0!Dialog for cloning a repository from a remote URL!!IceEditRepositoryModel commentStamp: '<historical>' prior: 0!I'm an edition dialog. I allow users to edit what is editable on an IceRepository. !!IceImportLocalRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:45' prior: 0!Dialog for creating an Iceberg repository out of an existing local git repository.!!IceNewRepositoryModel commentStamp: '<historical>' prior: 0!I'm a repository creation dialog. I allow users to create a repository from scratch. !!IceLocationModel commentStamp: '<historical>' prior: 0!I'm an abstract model to provide locations (directories or files). I need to be included in other components (search references to my children for examples)!!IceDirectoryModel commentStamp: '<historical>' prior: 0!I'm a model to choose directories.!!IceFileModel commentStamp: '<historical>' prior: 0!I'm a model to choose files.!!IceRemoteModel commentStamp: '<historical>' prior: 0!I'm a dialog for adding remotes to repositories.!!IceGlamourSynchronizer commentStamp: 'EstebanLorenzano 2/2/2017 16:22' prior: 0!I am the syncronizer window. I am called to perform any of the basic operations of iceberg: - commit (save changes)- update (load new changes from incomming commit versions)- publish (send to central repository local commits)usually I'm called from the repositories browser, when selecting the "syncronize" option from contextual menu.!!IceTool commentStamp: 'NicoPasserini 9/2/2016 15:26' prior: 0!Utility base class for building Iceberg GUI tools.It might be better to use TIceTool instead.!!IceGlamourCommitBrowser commentStamp: '<historical>' prior: 0!I allow userts to commit current changes.!!IceGlamourPublishBrowser commentStamp: '<historical>' prior: 0!I allow users to see and publish existing local commits.!!IceGlamourUpdateBrowser commentStamp: 'NicoPasserini 10/13/2016 17:28' prior: 0!This browser allows you to see the new commits  in your [upstream](../../../wiki/Some-keys-to-understand-Git-nomenclature#upstream), browse the changes and merge them into your current branch (or load them without merging).!!IceHistoryBrowser commentStamp: 'NicoPasserini 8/23/2016 14:34' prior: 0!Shows information about branches, history of commits and the changes in each commit.!!IceBranchBrowser commentStamp: '<historical>' prior: 0!I'm a browser to compare a branch with current installed sources.!!IceRepositoriesBrowser commentStamp: 'NicoPasserini 7/24/2016 20:12' prior: 0!Main entry point to the Iceberg UI tools, shows the list of the known repositories, allows to see a resume of the status of each of them and to open the repository synchronizer.Shows- all known repositorires- resume of the status of each package in each repositoryActions - create and forget repositories- refresh repository status- synchronize a repository- load / unload packages in a repository!!IceInteractiveCredentialsProvider commentStamp: 'NicoPasserini 11/15/2016 12:15' prior: 0!A credentials provider that asks the user for credentials.!!IceRemoteAdded commentStamp: 'EstebanLorenzano 1/6/2017 09:12' prior: 0!I'm an announce that happens  when a remote has been added.!!SwappedColorDiffMorph commentStamp: 'YuriyTymchuk 4/7/2017 11:32' prior: 0!I swap colors for the original giff morph, so the additions are green and removals are red!!GLMSwappedColorDiffPresentation commentStamp: 'EstebanLorenzano 5/8/2017 13:57' prior: 0!A glamour presentation  for the swapped diff morph!!IceAbstractBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:25' prior: 0!Description--------------------I am an abstract class to define a common API for my subclasses that will manage some actions for some branch view of Iceberg. My subclasses will encapsulate a branch or a remote.I am use in the branch view of the main browser of Iceberg.Public API and Key Messages--------------------- #children				It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches.- #nameToDisplay		String to show to the user.- #status 				Status to show to the user about incomming/unpublished commits.!!IceBranchGroupModel commentStamp: 'CyrilFerlicot 7/9/2017 03:35' prior: 0!Description--------------------I represent a group of branches. I am used in two principal cases. 1) We want to group the branches of a remote2) We want to group the local branchesExamples--------------------	"For a remote"	IceBranchGroupModel repository: anIceRepository remote: anIceRemote.		"For local branches"	IceBranchGroupModel localFromRepository: anIceRepository Internal Representation and Key Implementation Points.--------------------    Instance Variables	branches:		<aBlockOrSymbol>	This block takes the repository as parameter and should return the branches of the group	groupName:		<aString>			Name of the group. In case I represent a remote it will be the remote name, else it will probably be "Local"	repository:		<anIceRepository>	The repository where to get the branches!!IceBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:36' prior: 0!Description--------------------I represent an unique branch. I should be contained in an IceBranchGroupModel.Examples--------------------	IceBranchModel parent: anIceBranchGroupModel branch: anIceBranch Internal Representation and Key Implementation Points.--------------------    Instance Variables	branch:				<anIceBranch>				The branch I should display info for.	parentGroup:		<anIceBranchGroupModel>	The branch group inside of which I am.!!IceChangesTreeResetSelectionHelper commentStamp: '<historical>' prior: 0!I am a helper to reset selections on changes tree browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					do: [ presentation selection: nil ] ] ]... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ]removing the outer context problems .!!IceDiffChangeTreeBuilder commentStamp: '<historical>' prior: 0!I'm a builder to help users to build reusable diff-changes-tree elements.I'm used in several parts, notable in the syncronize window and in th e history browser.!!IceMergeTool commentStamp: 'NicoPasserini 12/13/2016 11:44' prior: 0!This is a very basic merge tool, just for keeping some state and coordinating interation between the 'real' merge tools. Internal Representation- source: <IceCommit> indicating the source of the changes to be merged (TODO: should be a commitish).- targetBranch: <IceBranch> where we want to merge the commits. If not provided the tool will raise a dialog to ask for it.- onMerge: <block or symbol> will be executed after a successfull merge.!!IceRepositoryUpdateHelper commentStamp: 'EstebanLorenzano 12/23/2016 15:50' prior: 0!I am a helper to create update cycles on repositories browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		do: [ :ann | 			table 				updateOn: IceRepositoryAnnouncement 				from: ann repository announcer ].... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).removing the outer context problems :)!!GLMMorphicSwappedColorDiffRenderer commentStamp: 'EstebanLorenzano 5/5/2017 12:19' prior: 0!A glamour renderer for the swapped diff morph!!TIceTool classTrait methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!uiManager	^ UIManager default! !!TIceTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!uiManager	^ self class uiManager! !!MCModification methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeUpdate! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!selectionAction: actionSelector	"action selector will be sent to the presentation selection. 	If it accepts one argument, the presentation will be sent."	^ self		action: [ :presentation | 			presentation selection				ifNotNil: [ :sel | (MessageSend receiver: sel selector: actionSelector) cull: presentation ] ];		enabledCondition:				[ :presentation | "This is a minimal condition, that can be overriden (refined) later" presentation selection notNil ]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!selectionCondition: selectionCondition	"selectionCondition can be anything that can respond #cull: such as a block or unary symbol.	It will only be evaluated if the presentation has a (not nil) selected element."		^ self enabledCondition: [ :presentation | 		presentation selection notNil and: [ 			selectionCondition cull: presentation selection ]]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!showTitle: aTitle	^ self title: aTitle; showTitle! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'callbacks' stamp: ' 7/24/2017 12:50:04'!actOnPresentationRefreshRequest: anAnnouncement	tableMorph window ifNil: [ ^ self ].	tableMorph window isActive ifFalse: [ ^ self ].	(tableMorph window boundsInWorld containsRect: tableMorph boundsInWorld) ifFalse: [ ^ self ].  " tableModel resetElements."	tableModel resetDataCache.	tableMorph refresh! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!createDataSourceFrom: aPresentation	^ GLMCherryPickTreeDataSource new! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!specificTableMorphInitializiation	super specificTableMorphInitializiation.	tableModel glamourPresentation isAllSelected		ifTrue: [ tableModel selectAll ]! !!IceAskForPlaintextCredentialsModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col newRow: [:row | row add: #usernameLabel width: 80; add: #usernameInput ] height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 80; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight	]! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ IcePlaintextCredentials new 		username: self username;		password: self password;		yourself.! !!IceAskForPlaintextCredentialsModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (350@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForPlaintextCredentialsModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	usernameLabel := self newLabel label: 'Username: '.	usernameInput := self newTextInput autoAccept: true.		passwordLabel := self newLabel label: 'Password: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		help: 'Please note that storing your credentials is handy but unsafe';		state: true.		self focusOrder		add: usernameInput;		add: passwordInput;		add: storeCheckbox! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password 	^ passwordInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!passwordInput	^ passwordInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!passwordLabel	^ passwordLabel! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storeCheckbox	^ storeCheckbox ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storeCredentials	^ storeCheckbox state ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Please log in to git'! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ usernameInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!usernameInput	^ usernameInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!usernameLabel	^ usernameLabel! !!IceAskForSshCredentialsModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #usernameLabel width: 100; add: #usernameInput ] height: self inputTextHeight;			newRow: #publicKeyLocation height: self inputTextHeight;			newRow: #privateKeyLocation  height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 100; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight ]! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ IceSshCredentials new 		username: self username;		publicKey: self publicKey;		privateKey: self privateKey;		keyPassphrase: self password;		yourself.! !!IceAskForSshCredentialsModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 5		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForSshCredentialsModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	usernameLabel := self newLabel label: 'SSH Username: '.	usernameInput := self newTextInput autoAccept: true.		publicKeyLocation := self instantiate: IceFileModel.	publicKeyLocation 		label: 'Public SSH Key: ';		chooseTitle: 'Public SSH Key (id_rsa.pub)'.	privateKeyLocation := self instantiate: IceFileModel.	privateKeyLocation 		label: 'Private SSH Key: ';		chooseTitle: 'Private SSH Key (id_rsa)'.	passwordLabel := self newLabel label: 'SSH Passphrase: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		state: true.		self focusOrder		add: usernameInput;		add: publicKeyLocation;		add: privateKeyLocation;		add: passwordInput;		add: storeCheckbox! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password 	^ passwordInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordInput	^ passwordInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordInput: anObject	passwordInput := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordLabel	^ passwordLabel! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordLabel: anObject	passwordLabel := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!privateKey	^ privateKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!privateKeyLocation	^ privateKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!privateKeyLocation: anObject	privateKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!publicKey	^ publicKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!publicKeyLocation	^ publicKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!publicKeyLocation: anObject	publicKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!storeCheckbox	^ storeCheckbox ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storeCredentials	^ storeCheckbox state ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Please provide SSH keys'! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ usernameInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!usernameInput	^ usernameInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!usernameLabel	^ usernameLabel! !!IceAskForUsernameAndEmailModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #nameLabel width: 100; add: #nameInput ] height: self inputTextHeight;			newRow: [:row | row add: #emailLabel width: 100; add: #emailInput ] height: self inputTextHeight;			add: #globalCheckbox height: self inputTextHeight;			add: #acceptButton height: self buttonHeight  ]! !!IceAskForUsernameAndEmailModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	self username isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.name is required.' ].	self email isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.email is required.' ].			acceptBlock 		value: self username 		value: self email		value: self isGlobal.		self window delete.! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!email	^ self emailInput text trimBoth! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailInput	^ emailInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailInput: anObject	emailInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailLabel	^ emailLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailLabel: anObject	emailLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!globalCheckbox	^ globalCheckbox! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!globalCheckbox: anObject	globalCheckbox := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (400@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForUsernameAndEmailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	nameLabel := self newLabel label: 'user.name'.	nameInput := self newTextInput 		ghostText: 'John Doe';		autoAccept: true.	emailLabel := self newLabel label: 'user.email'.	emailInput := self newTextInput 		ghostText: 'johndoe@mail.net';				autoAccept: true.	globalCheckbox := self newCheckBox		label: 'Save properties as global?';		state: false.	acceptButton := self newButton		label: 'Set properties';		action: [ self accept ];		yourself.					self focusOrder		add: nameInput;		add: emailInput;		add: globalCheckbox;		add: acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isGlobal	^ self globalCheckbox state! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameInput	^ nameInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameInput: anObject	nameInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameLabel	^ nameLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameLabel: anObject	nameLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	"aBlock will receive 3 arguments: name, email, global flag"	acceptBlock := aBlock! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Please provide required properties'! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ self nameInput text trimBoth! !!IceCommitInfoModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #dateLabel width: 80; add: #datePanel ] height: 25;				newRow: [:row | row add: #idLabel width: 80; add: #idPanel ] height: 25;				newRow: [:row | row add: #parentsLabel width: 80; add: #parentsPanel ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorPanel ] height: 25;				newRow: [:row | row add: #commentLabel width: 80; add: #commentPanel ] ];		yourself! !!IceCommitInfoModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aCommit	^ self basicNew 		initializeCommit: aCommit;		yourself! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorLabel	^ authorLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorLabel: anObject	authorLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorPanel	^ authorPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorPanel: anObject	authorPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentLabel	^ commentLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentLabel: anObject	commentLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentPanel	^ commentPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentPanel: anObject	commentPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ commit! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!dateLabel	^ dateLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!dateLabel: anObject	dateLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datePanel	^ datePanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datePanel: anObject	datePanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idLabel	^ idLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idLabel: anObject	idLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idPanel	^ idPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idPanel: anObject	idPanel := anObject! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeCommit: aCommit	commit := aCommit.	self initialize! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	idLabel := self newLabel.	idPanel := self newTextInput enabled: false.	dateLabel := self newLabel.	datePanel := self newTextInput enabled: false.	authorLabel := self newLabel.	authorPanel := self newTextInput enabled: false.	commentLabel := self newLabel.	commentPanel := self newText enabled: false.	parentsLabel := self newLabel.	parentsPanel := self newTextInput enabled: false.		idLabel label: 'Commit Id'.	idPanel text: self commit id asString, ' [', self commit shortId, ']'.	dateLabel label: 'Date & time'.	datePanel text: self commit datetime asLocalStringYMDHM.	authorLabel label: 'Author'.	authorPanel text: self commit username.	commentLabel label: 'Comment'.	commentPanel text: self commit comment.	parentsLabel label: 'Parent(s)'.	parentsPanel text: (self commit parents collect: #shortId) asCommaString	! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsLabel	^ parentsLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsLabel: anObject	parentsLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsPanel	^ parentsPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsPanel: anObject	parentsPanel := anObject! !!IceCherryPickCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicCommitWithMessage: aString	| picked |	self flag: #todo. "I need to check if picked = all changes (in that case, is not 	needed the pick and I can just go 'business as usual')"	cherryPickBlock ifNotNil: [ picked := cherryPickBlock value ].	"Nothing was picked, continue as usual"	picked ifNil: [ ^ super basicCommitWithMessage: aString ].	self repository 		commitCherryPick: picked  		withMessage: aString! !!IceCherryPickCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!withSelectedCherryPick: aBlock	cherryPickBlock := aBlock! !!IceCommitModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | col			add: #message;			newRow: [ :row | row				add: #commitButton;				add: #commitPushButton			] height: self toolbarHeight		]! !!IceCommitModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageGhostText	^ 'Please enter commit message.'! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicCommitWithMessage: aString	self repository 		commitPackages: self model changedPackages		withMessage: aString! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicCommitWithMessage: text ifCancel: cancelBlock	[		[ self basicCommitWithMessage: text asString ]		on: IceGitUsernameOrEmailNotFound 		do: [ :e |			self configGitUsernameAndEmailOnCancel: cancelBlock.			e retry ].		self resetText ]	on: NothingToCommitException 	do: [ :e | UIManager default inform: 'There is nothing to commit.' ]! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self model repository branchName! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitButton	^ commitButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitPushButton	^ commitPushButton! !!IceCommitModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!commitPushing: pushBoolean	| text |		(text := self messageText) ifEmpty: [ ^ self ].	UIManager default		informUserDuring: [ :bar | 			bar label: ('Commiting changes to {1}' format: {self repository}).			self basicCommitWithMessage: text ifCancel: [ ^ self ].			pushBoolean ifTrue: [ | remote |				remote := self repository pushRemote.				bar label: ('Pushing changes to {1}' format: {remote}).				self pushRepository: self repository andThen: [ ]. 				UIManager default inform: ('Uploaded changes to {1}' format: {remote}) ] ]! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!configGitUsernameAndEmailOnCancel: cancelBlock	| passed |	passed := false.	(IceAskForUsernameAndEmailModel new 		onAccept: [ :username :email :global |			self repository 				username: username				email: email				global: global.			passed := true ];			openWithSpec)		modalRelativeTo: World.			passed ifFalse: cancelBlock! !!IceCommitModel methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!contractedNameFor: diff	"If the name of a branch is too long it is better to contract it in order to limit the UI glitches."	^ diff repository branchName contractTo: 20! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	model := nil asValueHolder.	model whenChangedDo: [ :diff | commitButton label: 'Commit onto ' , (self contractedNameFor: diff) ].	model whenChangedDo: [ :diff | commitPushButton label: 'Commit and Push onto ' , (self contractedNameFor: diff) ].	super initialize! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	commitButton action: [ self commitPushing: false ].	commitPushButton action: [ self commitPushing: true ]! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	message := self newText		autoAccept: true;		whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ];		whenTextChanged: [ | enable |			enable := self messageText notEmpty.			commitButton enabled: enable.			commitPushButton enabled: enable ];		yourself.	commitButton := self newButton		label: 'Commit';		enabled: false;		yourself.	commitPushButton := self newButton		label: 'Commit and push';		enabled: false;		yourself.			self focusOrder 		add: message;		add: commitButton;		add: commitPushButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!message	^ message! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!messageText	^ self message text! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!model	^ model value! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!model: aDiff	model value: aDiff ! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self model repository! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!resetText	self message text: ''! !!IceCloneRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buildDefaultSpec: col	col		newRow: [:row | row			add: #remoteUrlLabel width: 100;			add: #remoteUrl ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceCloneRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	[		| repository |				repository := IceRepositoryCreator new 			remote: (IceRemote url: remoteUrl text trim);			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceCloneRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	remoteUrlLabel := self newLabel label: 'Remote URL'.	remoteUrl := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	self focusOrder add: remoteUrl.	super initializeWidgets.	! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!remoteUrl	^ remoteUrl! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!remoteUrlLabel	^ remoteUrlLabel! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'Clone repository by URL'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buildDefaultSpec: col	col		newRow: #localDirectoryLocation		height: self inputTextHeight;				newRow: [:row | row 			add: #subdirectoryLabel width: 100;			add: #subdirectory ]		height: self inputTextHeight;					add: #createButton height: self buttonHeight ! !!IceCreateRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Create repository'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | self buildDefaultSpec: col ]! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton	^ createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton: anObject	createButton := anObject! !!IceCreateRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	self subclassResponsibility! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultLocation	^ IceRepository repositoriesLocation pathString! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	createButton action: [ self createRepository ]! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	localDirectoryLocation := self instantiate: IceDirectoryModel.	localDirectoryLocation 		label: 'Local directory';		chooseTitle: 'Choose local repository';		location: self defaultLocation.		subdirectoryLabel := self newLabel label: 'Code subdirectory'.	subdirectory := self newTextInput autoAccept: true.		createButton := self newButton		label: self class buttonLabel;		yourself.		self focusOrder 		add: localDirectoryLocation;		add: subdirectory;		add: createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!localDirectoryLocation	^ localDirectoryLocation! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!localDirectoryLocation: anObject	localDirectoryLocation := anObject! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	| location |	location := localDirectoryLocation location.	^ (location notNil and: [ location pathString ~= self defaultLocation ])		ifTrue: [ ^ location ]		ifFalse: [ nil ]! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: anObject	localDirectoryLocation location: anObject! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ subdirectory! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!subdirectoryLabel	^ subdirectoryLabel! !!IceEditRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Edit repository'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new 	self error: 'Use #repository:'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository	^ self basicNew		initializeRepository: aRepository;		yourself! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!codeDirectory	^ self subdirectory text	! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!codeDirectory: aString	self subdirectory text: aString	! !!IceEditRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	self repository location = self location 		ifFalse: [ self repository location: self location ].	self repository subdirectory = self codeDirectory		ifFalse: [ self repository subdirectory: self codeDirectory ].	self window delete. 	acceptBlock ifNotNil: [ acceptBlock cull: self ]! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	super initializePresenter.	self location: (self repository location ifNil: [ IceRepository repositoriesLocation ]).	self codeDirectory: self repository subdirectory.! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeRepository: aRepository	repository := aRepository.	self initialize! !!IceEditRepositoryModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock 	acceptBlock := aBlock! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'Edit repository'! !!IceImportLocalRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	self location ifNil: [ 		UIManager default 			abort: 'Please select a repository location'			title: 'Could not create repository'. 		^ self ].	[		| repository |				repository := IceRepositoryCreator new 			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'Import local repository into Iceberg'! !!IceNewRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buildDefaultSpec: col	col		newRow: [:row | row			add: #projectNameLabel width: 100;			add: #projectNameInput ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceNewRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Create repository'! !!IceNewRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	[		| repository |			self projectName isEmptyOrNil 		ifTrue: [ Error signal: 'Project name is required' ].		repository := IceRepositoryCreator new 			location: self location / self projectName;			subdirectory: subdirectory text;			createNewRepositoryNamed: self projectName.		repository register.		self window delete.		acceptBlock ifNotNil: [ acceptBlock cull: self ] ]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ].! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceNewRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	projectNameLabel := self newLabel label: 'Project name'.	projectNameInput := self newTextInput 		ghostText: 'project'; 		autoAccept: true.	self focusOrder add: projectNameInput.	super initializeWidgets! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ localDirectoryLocation location! !!IceNewRepositoryModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ self projectNameInput text! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameInput	^ projectNameInput! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameInput: anObject	projectNameInput := anObject! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameLabel	^ projectNameLabel! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameLabel: anObject	projectNameLabel := anObject! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'New repository'! !!IceDirectoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!chooseReference	^ UIManager default 		chooseDirectory: self chooseTitle 		path: self location! !!IceFileModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!chooseReference	^ (UIManager default 		chooseFileName: self chooseTitle 		extensions: nil 		path: self location 		preview: nil)		ifNotNil: [ :file | file asFileReference  ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultChooseDialogTitle	^ 'Choose directory'! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultLabel	^ 'Directory'! !!IceLocationModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newRow: [ :row | 			row 				add: #locationLabel width: 100; 			 	add: #locationInput; 				add: #chooseButton width: self iconWidth ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iconWidth	^ 24! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!choose	self chooseReference ifNotNil: [ :reference | 		self location: reference.		self locationInput text: reference pathString ]! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!chooseButton	^ chooseButton! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!chooseButton: anObject	chooseButton := anObject! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!chooseReference 	self subclassResponsibility! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!chooseTitle	^ chooseTitle ifNil: [ self class defaultChooseDialogTitle ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!chooseTitle: aString	chooseTitle := aString! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!icon	^ #open asIcon! !!IceLocationModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	locationLabel := self newLabel label: self label.	locationInput := self newTextInput autoAccept: true.	chooseButton := self newButton icon: self icon.		locationInput whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	chooseButton action: [ self choose ].		self focusOrder add: locationInput	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!label	^ label ifNil: [ self class defaultLabel ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!label: aString	label := aString.	self locationLabel label: aString	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ locationInput text trim 		ifNotEmpty: [ :value | value asFileReference ]		ifEmpty: [ nil ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: aReferenceOrString	locationInput text: aReferenceOrString asFileReference pathString! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationInput	^ locationInput! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationInput: anObject	locationInput := anObject! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationLabel	^ locationLabel! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationLabel: anObject	locationLabel := anObject! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #nameLabel width: 80; add: #namePanel ] height: 25;				newRow: [:row | row add: #urlLabel width: 80; add: #urlPanel ] height: 25;				add: #addButton height: self buttonHeight ];		yourself! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Add remote'! !!IceRemoteModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	| remoteName remoteUrl |		remoteName := self namePanel text trim.	remoteName ifEmpty: [ 		UIManager default alert: 'You need to specify a remote name.' title: 'Error'. ^ self ].	remoteUrl := self urlPanel text trim.	remoteUrl ifEmpty: [		UIManager default alert: 'You need to specify a remote url.' title: 'Error'. ^ self ].		self window delete.	acceptBlock ifNotNil: [ 		acceptBlock cull: (IceRemote name: remoteName url: remoteUrl) ]! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addButton	^ addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addButton: anObject	addButton := anObject! !!IceRemoteModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceRemoteModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	nameLabel := self newLabel. 	namePanel := self newTextInput ghostText: 'user-remote'; autoAccept: true.	urlLabel := self newLabel.	urlPanel := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	addButton := self newButton.		nameLabel label: 'Remote name'.	urlLabel label: 'Remote URL'.	addButton label: 'Add remote'.	addButton action: [ self accept ].		self focusOrder 		add: namePanel;		add: urlPanel;		add: addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameLabel	^ nameLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameLabel: anObject	nameLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!namePanel	^ namePanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!namePanel: anObject	namePanel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock 	acceptBlock := aBlock! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlLabel	^ urlLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlLabel: anObject	urlLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlPanel	^ urlPanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlPanel: anObject	urlPanel := anObject! !!ToolShortcutsCategory methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!openIceberg	<shortcut>	^ KMKeymap shortcut: PharoShortcuts current openIcebergShortcut action: [ IceRepositoriesBrowser  open ]! !!IceRemote methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!branchesFrom: aRepository	"I return all the branches of my remote from a repository"	^ aRepository branches		select: [ :branch | branch isRemote and: [ branch remoteName = self remoteName ] ]! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!asLocalStringYMDHM	^ self asLocal asStringYMDHM! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!asStringYMDHM	^ String streamContents: [ :aStream |		self printYMDOn: aStream.		aStream nextPut: Character space.		self hour printOn: aStream base: 10 length: 2 padded: true.		aStream nextPut: $:.		self minute printOn: aStream base: 10 length: 2 padded: true ]! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!renderCherryPickTreePresentation: aPresentation 	^ GLMMorphicCherryPickTreeRenderer render: aPresentation from: self! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!renderSwappedColorDiffPresentation: aPresentation	^ GLMMorphicSwappedColorDiffRenderer render: aPresentation from: self! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!allSelected	allSelected := true! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cherryPick	^ (self pane port: #cherryPick) value! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cherryPick: aValuable	^ (self pane port: #cherryPick) value: aValuable! !!GLMCherryPickTreePresentation methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	allSelected := false! !!GLMCherryPickTreePresentation methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAllSelected	^ allSelected! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onChangeOfCherryPick: aBlock	self onChangeOfPort: #cherryPick act: aBlock! !!GLMCherryPickTreePresentation methodsFor: 'rendering' stamp: ' 7/24/2017 12:50:04'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderCherryPickTreePresentation: self! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!cherryPickTree	^ self custom: GLMCherryPickTreePresentation new! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!swappedColorDiff	^ self custom: GLMSwappedColorDiffPresentation new	! !!IceGlamourSynchronizer class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 850@600! !!IceGlamourSynchronizer class methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!synchronize: anIceRepository	self new openOn: anIceRepository.! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	^ self repository branch! !!IceGlamourSynchronizer methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose	(self custom: GLMStacker new) with: [ :browser |		browser initialExtent: self initialExtent.		browser updateOn: Announcement from: [ :repo | repo announcer weak ].		browser aPane: #commit.		browser transmit 			transformed: #workingCopyDiff; 			to: #commit;			andShow: [ :a | a 				title: 'Commit your changes'; 				custom: IceGlamourCommitBrowser new ].		browser aPane: #update.		browser transmit 			to: #update;			andShow: [ :a | a 				title: 'Update'; 				custom: IceGlamourUpdateBrowser new ].		browser aPane: #publish.		browser transmit 			to: #publish;			andShow: [ :a | a 				title: 'Push'; 				custom: IceGlamourPublishBrowser new ].	]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ self repository location! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote ifNil: [ self repository pushRemote ]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: aRemote	remote := aRemote! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ (self pane port: #entity) value! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Synchronizing {1} -- branch: {2} -- remote: {3}' 		format: {			self location gtDisplayString.			self branch.			self remote }		! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!titleIcon	^ IceTool icon! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addCommitInfoTo: browser	browser transmit 		from: #commits; 		to: #diff; 		andShow: [ :a |			a morph				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ].! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser withTitle: diffTitle	browser transmit 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff				title: diffTitle;				display: [:change | self buildDiffInput: change ]]! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildDiffInput: change	^ { 		change myVersion ifNil: ''. 		change theirVersion ifNil: ''	}! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!configureBrowser: browser	"Do nothing, since the purpose of this browsers is to be embedded"! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!titleIcon	"Do nothing, since the purpose of this browsers is to be embedded"	^ nil! !!IceGlamourCommitBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser		row: [ :row | 			row				column: #changes; 				column: #commit ];		row: #diff.	browser transmit 		to: #changes;  		andShow: [ :a :diff |			self selectedElements: nil.			(IceDiffCherryPickChangeTreeBuilder new 				diff: diff;				onSelectCherryPick: [ :aSet | self selectedElements: aSet ];				buildOn: a)				title: 'Local changes' ].	browser transmit 		to: #commit;		andShow: [ :a :diff | 			a morph				title: 'Commit changes';				morph: [					IceCherryPickCommitModel new 						model: diff;						withSelectedCherryPick: [ self selectedElements ];						buildWithSpec ] ].	self addDiffTo: browser withTitle: 'Left: working copy / Right: local repository'! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectedElements	^ selectedElements! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectedElements: anObject	selectedElements := anObject! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo | 			(IceDiffChangeTreeBuilder new				entity: commitInfo; 				diff: (commitInfo ifNotNil: [ commitInfo diffWith: repo branch upstream ]);				buildOn: a)				title: 'Outgoing changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser 	! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeCommitsListIn: composite	composite fastTable		title: 'New local commits to be published';		display: #outgoingCommits;		column: 'User' evaluated: #username width: 120;		column: 'Date & time' evaluated: [:commit | commit datetime asLocal asStringYMDHM ] width: 120;		column: 'Comment' evaluated: #comment;		updateOn: IceCommited, IcePushed from: #announcer;		addAction: self pushAction;		addSelectionAction: self mergeIntoAction! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!pushAction	 ^ GLMGenericAction new			action: [ :presentation :repository | 				self 					pushRepository: repository					andThen: [ presentation selection: nil ]];			icon: GLMUIThemeExtraIcons glamorousRightSide;			shortcut: $p;			showTitle: 'Publish all'				! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildDiffInput: change	"The diff from an incoming change comes with the versions switched, 	so I have to switch them again."	^ { 		change theirVersion ifNil: ''.		change myVersion ifNil: ''. 	}! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo |.			(IceDiffChangeTreeBuilder new				entity: commitInfo;				diff: (commitInfo ifNotNil: [ commitInfo diffWith: (repo mergeBaseWith: commitInfo) ]); 				buildOn: a)				title: 'Incoming changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser ! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeCommitsListIn: composite	composite fastTable		title: 'New commits to be imported';		display: #incomingCommits;		column: 'User' evaluated: #username width: 120;		column: 'SHA' evaluated: #shortId width: 60;		column: 'Date & time' evaluated: [:commit | commit datetime asLocalStringYMDHM ] width: 100;		column: 'Status' evaluated: #status width: 80;		column: 'Comment' evaluated: #comment;		updateOn: IcePackageLoaded from: #announcer;		addAction: self fetchAction;		addAction: self pullAction;		addSelectionAction: self loadAction;		addSelectionAction: self mergeAction! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!fetchAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository fetch.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $f;		title: 'Fetch new versions'; 		showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!loadAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection load. 			presentation selection: nil ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged ]];		icon: #changeBlock asIcon;		shortcut: $l;		title: 'Load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!mergeAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection merge.			presentation selection: nil.			presentation pane browser update. ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged not ] ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge and load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!pullAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository pull.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $p;		title: 'Pull'; 		showTitle! !!IceBranchBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceBranchBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Branch browser'! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 850@600! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'History browser'! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new 		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffFromHead ]); 		buildOn: a)		title: 'Changes since selection'.	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffToParent ]);		buildOn: a)		title: 'Changes vs. parent' ! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addChangesTreesTo: browser	browser transmit 		from: #commits;		to: #changes; 		andShow: [ :a :commitInfo |			self addChangesTreeTo: a with: commitInfo ].! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBranchesIn: composite	composite fastTable		title: 'Branches';		display: #branchesForCheckout;		column: 'Name' evaluated: [ :branch :repo | 			self 				descriptionTextForBranch: branch				repository: repo ]		! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #branches span: 2; 				column: #commits span: 3; 				column: #changes span: 3]; 		row: #diff.		browser transmit to: #branches; andShow: [ :a | self composeBranchesIn: a ].	browser transmit from: #branches; to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeCommitsIn: composite	composite fastTable		title: 'Commits';		display: #commits;		column: 'Date & time' 			evaluated: [:commit | 				commit datetime asLocalStringYMDHM asText 					in: [ :text | 						commit isLoaded 							ifTrue: [ text ] 							ifFalse: [ text allBold ] ] ] 			width: 120;		column: 'Id' evaluated: #shortId width: 50;		column: 'User' evaluated: #username width: 120;		column: 'Parents' evaluated: [ :commit | ', ' join: (commit parents collect: #shortId) ] width: 100;		column: 'Comment' evaluated: #comment width: 300;				addSelectionAction: self inspectAction;		addSelectionAction: self mergeIntoCurrentBranchAction;		addSelectionAction: self mergeIntoAction.! !!IceHistoryBrowser methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!descriptionTextForBranch: aBranch repository: repo	| text |		self flag: #todo. "This is a duplication of IceRepositoryModel>>descriptionTextForBranch:. 	This can be solved by using an IceBranchModel instead the branch directly"	text := aBranch name asText.	(repo branch = aBranch)		ifTrue: [ text allBold ].			^ text! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/24/2017 12:50:04'!inspectAction	^ GLMGenericAction new		action: [ :presentation | presentation selection inspect ]; 		shortcut: $i; 		title: 'Inspect'; 		yourself! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/24/2017 12:50:04'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/24/2017 12:50:04'!mergeIntoCurrentBranchAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				targetBranch: presentation selection repository branch;				onMerge: [					presentation selection: nil.					presentation pane browser update ];				run ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $M;		title: 'Merge into current branch'; 		showTitle! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/24/2017 12:50:04'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/24/2017 12:50:04'!menuCommandOn: aBuilder 	"Add a custom menu item to the world menu"		<worldMenu> 		(aBuilder item: #'Iceberg')		order: 0.18; 		icon: self icon;  		parent: #'Tools';		keyText: 'o, i';		action: [ self open ].! !!IceRepositoriesBrowser class methodsFor: 'opening' stamp: ' 7/24/2017 12:50:04'!open	"self open"	^ self new open! !!IceRepositoriesBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Iceberg repositories'! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/24/2017 12:50:04'!abort: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addGlobalMenu	self		act: [ 			SettingBrowser new 				changePackageSet: { (RPackageOrganizer default packageNamed: 'Iceberg') }; 				open; 				expandAll ] 		icon: #configuration asIcon		entitled: 'Global Settings'! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addLocalRepository	IceImportLocalRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!addLocalRepositoryAction	^ GLMGenericAction new		action: [ self addLocalRepository ];		icon: #packageAdd asIcon;		shortcut: $a;		title: 'Add local repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!addPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			self addPackageToRepository: repo repository.			presentation update ];		icon: #add asIcon;		shortcut: $a;		title: 'Add package'; showTitle! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addPackageToRepository: repo	| options descriptionBlock |		descriptionBlock := [ :wc | 		wc modified 			ifTrue: ['* ', wc packageName]			ifFalse: [ wc packageName ]].	options := MCWorkingCopy allManagers difference: repo workingCopies.	(self class chooseFrom: options displaying: descriptionBlock) 		ifNotNil: [ :workingCopy | repo addPackage: workingCopy ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!addRemoteAction	^ GLMGenericAction new		action: [ :presenter | 			presenter selection addRemoteThen: [ :remote | 				self announce: (IceRemoteAdded remote: remote) ] ];		selectionCondition: #isOperative;		showTitle: 'Add remote...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addRepositoryBranchesTo: composite	| branches |	(branches := composite fastTreeTable)		title: 'Branches';		display: [ :repository | 			| localisations |			localisations := repository remotes collect: [ :remote | IceBranchGroupModel repository: repository remote: remote ] as: OrderedCollection.			repository hasLocalBraches				ifTrue: [ localisations addFirst: (IceBranchGroupModel localFromRepository: repository) ].			localisations ];		children: #children;		column: 'Name' evaluated: #nameToDisplay;		column: 'Status' evaluated: #status;		allExpanded.	"actions"	branches addAction: self branchCreateNewAction.		"selection actions"	branches		addSelectionAction: self branchSwitchAction;		addSelectionAction: self branchCompareWithCurrentAction! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addRepositoryInfoTo: composite	composite fastTable		title: 'General';		display: #detailedInfo;		column: 'Name' evaluated: #key width: 80;		column: 'Value' evaluated: #value! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addRepositoryRemotesTo: composite	| remotes |		(remotes := composite fastTable)		title: 'Remotes';		display: #remotes;		column: 'Name' evaluated: [ :remote :model | model descriptionTextForRemote: remote] width: 80;		column: 'URL' evaluated: #url width: 380;		column: 'Status' evaluated: [ :remote :model | model statusForRemote: remote ];		updateOn: IceRemoteAdded from: #announcer.			"actions"	remotes addAction: self remoteAddAction.	"selection actions"	remotes 		addSelectionAction: self remoteMakePullingAction;		addSelectionAction: self remoteMakePushingAction;		addSelectionAction: self remoteFetchAction;		addSelectionAction: self remotePullAction;		addSelectionAction: self remotePushAction;		addSelectionAction: self remoteRemoveAction.	"Plugin actions"	remotes dynamicActionsOnSelection: [ :presentation | 		presentation entity pluginRemoteActionsFor: presentation selection ]! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/24/2017 12:50:04'!alert: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/24/2017 12:50:04'!branchCompareWithCurrentAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection compareCurrentToMe.			presentation pane browser update ];		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil: #isBranchModel ];		showTitle: 'Compare with current branch';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/24/2017 12:50:04'!branchCreateNewAction	^ GLMGenericAction new		action: [ :presentation :model | 			model createNewBranchThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Create branch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/24/2017 12:50:04'!branchSwitchAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection switchToMe.			presentation pane browser update ];		showTitle: 'Switch to this branch';		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil:  #isBranchModel ];		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!browsePackageAction	^ GLMGenericAction new		selectionAction: #browse;		selectionCondition: #isLoaded;		showTitle: 'Browse package';		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepository	IceCloneRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryAction	^ GLMGenericAction new		action: [ self cloneRepository ];		icon: #add asIcon;		shortcut: $c;		title: 'Clone repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryAgainAction	^ GLMGenericAction new		selectionAction: #restore;		selectionCondition: #isMissing;		showTitle: 'Clone repository again';		shortcut: $R;		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose	self addGlobalMenu.	super compose! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: #repositories; 		row: #info.	browser transmit 		to: #repositories; 		andShow: [ :presentation | 			self composeRepositoriesIn: presentation ].	browser transmit 		from: #repositories; 		to: #info; 		andShow: [ :a |			(a custom: GLMWrapper new)				show: [ :wrapper | self composeRepositoryInfoIn: wrapper ];				when: [ :model | model isValid ].			(a custom: GLMWrapper new) 				show: [ :wrapper | self composeNotValidIn: wrapper ];				when: [ :model | model isValid not ] ].		! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeNotValidIn: composite	composite actionList		title: [ :repo | 'Repository {1} is invalid.' format: { repo descriptionText } ];		beVertical;		act: [ :presentation :model | 			model editRepositoryThen: [ 				"scale to top browser"				presentation pane browser pane browser update ] ] entitled: 'Edit...';		act: [ :presentation :model | 				model restore. 				presentation pane browser pane browser update ] entitled: 'Clone';		act: [ :presentation :model | 			model forgetThen: [ 				presentation pane browser pane browser update ] ] entitled: 'Forget'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composePackagesListIn: composite	composite fastTable		title: 'Packages';		display: #savedPackages;		column: 'Name' evaluated: #nameText width: 200;		column: 'Status' evaluated: #status;		addAction: self reloadAllPackagesAction;		addAction: self addPackageAction;		addSelectionAction: self browsePackageAction;		addSelectionAction: self loadPackageAction;		addSelectionAction: self unloadPackageAction;		addSelectionAction: self reloadPackageAction;		addSelectionAction: self unloadAndRemovePackageAction;		addSelectionAction: self removePackageAction;		addSelectionAction: self removePackageFromDiskAction;		enableFilter: [ :packageModel :pattern | packageModel packageName includesSubstring: pattern caseSensitive: false ];		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection ifNotNil: [ 				presentation entity pluginPackageActionsFor: presentation selection entity ]];		updateOn: IceCommited from: #announcer! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeRepositories: repositories in: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	repositories do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeRepositoriesIn: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	self repositoryRegistry do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeRepositoryInfoIn: composite	self addRepositoryInfoTo: composite.	self composePackagesListIn: composite.	self addRepositoryRemotesTo: composite.	self addRepositoryBranchesTo: composite.	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!createNewBranchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection createNewBranchThen: [] ];		selectionCondition: #isOperative;		showTitle: 'Create new branch...';		shortcut: $B.! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!editRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection editRepositoryThen: [				presentation pane browser pane update ] ];		showTitle: 'Edit repository...';		shortcut: $e;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!fetchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection fetch.			presentation update ];		selectionCondition: #isOperative;		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch incoming comits';		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetchAllRepositories	UIManager default informUserDuring: [ :bar |		| repositoriesCount |		repositoriesCount := IceRepository registry size.		bar max: repositoriesCount + 1.				IceRepository registry doWithIndex: [ :repository :index|			bar label: 				('Looking for incoming commigs in all repositories ({1} of {2})'					format: {index. repositoriesCount}).			bar current: index.						repository fetch.		]]	 ! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!fetchAllRepositoriesAction	^ GLMGenericAction new 		action: [ self fetchAllRepositories ];		icon: #glamorousLeftSide asIcon;		shortcut: $F;		showTitle: 'Fetch all'		! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!forgetRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection forgetThen: [ 				presentation pane browser pane update ] ];		showTitle: 'Forget repository...'; 		shortcut: $x; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!inspectRepositoryAction	^ GLMGenericAction new		selectionAction: #inspectRepository;		showTitle: 'Inspect';		shortcut: $i;		yourself! !!IceRepositoriesBrowser methodsFor: 'private testing' stamp: ' 7/24/2017 12:50:04'!isRepositoryVisible: aRepository	^ aRepository isSystemRepository not 		or: [ Iceberg showSystemRepositories ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!loadPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			presentation selection loadLatest.			presentation update ]; 		icon: #add asIcon;		shortcut: $l; 		title: 'Load package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded not ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newRepository	IceNewRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!newRepositoryAction	^ GLMGenericAction new		action: [ :presentation | self newRepository ];		icon: #smallNew asIcon;		shortcut: $n;		title: 'New repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'scripting opening' stamp: ' 7/24/2017 12:50:04'!open	IceRepository defaultBackend 		verifyBackendAvailabilityIfNot: [ :requiredVersion :currentVersion | 			^ UIManager default 				alert: ('This version of Iceberg requires libgit2 {1} to run (you have {2}).Please update your PharoVM before continue.' format: { requiredVersion. currentVersion }) ].	self openOn: Object new! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pullAction	^ GLMGenericAction new		selectionAction: #pull;		selectionCondition: #isOperative;		icon: GLMUIThemeExtraIcons glamorousLeftSide;		showTitle: 'Pull incoming commits'; 		shortcut: $p; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pullFromAction	^ GLMGenericAction new		selectionAction: #pullFrom;		selectionCondition: #isOperative;		showTitle: 'Pull from...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pushAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushThen: [ presentation pane browser update ]];		selectionCondition: #canPush;		icon: #glamorousRightSide asIcon;		showTitle: 'Push outgoing commits'; 		shortcut: $P; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pushToAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushToThen: [ presentation pane browser update ]];		selectionCondition: #isOperative;		"icon: GLMUIThemeExtraIcons glamorousRightSide;"		showTitle: 'Push to...';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!refreshRepositoryAction	^ GLMGenericAction new		selectionAction: #refresh;		showTitle: 'Refresh repository';		shortcut: $r! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!reloadAllPackagesAction	^ GLMGenericAction new		action: [ :presentation :model | 			model reloadAllLoadedPackages. 			presentation update ];		condition: [ :presentation :repo | (repo entity savedPackages select: #isLoaded) notEmpty ];		icon: #refresh asIcon;		shortcut: $e;		title: 'Reload all'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!reloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection reload.			presentation update ]; 		icon: #refresh asIcon;		shortcut: $r; 		title: 'Reload package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteAddAction	^ GLMGenericAction new		action: [ :presentation :model | 			model addRemoteThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Add remote'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteFetchAction	^ GLMGenericAction new		action: [ :presentation :model | 			model fetchRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteMakePullingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePullRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default pull remote'; 		enabledCondition: [ :presentation :model | 			(model isPullRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteMakePushingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePushRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default push remote'; 		enabledCondition: [ :presentation :model | 			(model isPushRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remotePullAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pullRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Pull'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remotePushAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pushRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousRightSide asIcon;		showTitle: 'Push'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteRemoveAction	^ GLMGenericAction new		action: [ :presentation :model | 			model 				removeRemote: presentation selection				then: [ presentation pane browser update ] ];		icon: #remove asIcon;		showTitle: 'Remove'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!removePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from repository (do not unload)'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!removePackageFromDiskAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded not ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!repositoryRegistry 	^ IceRepository registry! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!showHistoryAction	^ GLMGenericAction new		selectionAction: #browseHistory;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		showTitle: 'Show history...';		shortcut: $h! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!switchBranchAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection ifNotNil: [:repo | repo switchBranch ].			presentation pane browser pane update ];		enabledCondition: [ :presentation | 			presentation selection notNil ];			selectionCondition: #isOperative;		showTitle: 'Switch branch...';		shortcut: $b.! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/24/2017 12:50:04'!synchronize: repository	"This hack is a workaround because port #strongSelection of glamour generates multiple events for a single double-click."	(lastSynchronization isNil 		or: [ (DateAndTime current - lastSynchronization first) seconds > 1		or: [ lastSynchronization second  ~= repository ]])		ifTrue: [ 			lastSynchronization := { DateAndTime current. repository }.			IceGlamourSynchronizer synchronize: repository ]	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!synchronizeRepositoryAction	^ GLMGenericAction new		selectionAction: #synchronize;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		shortcut: $s;		title: 'Synchronize repository...'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!unloadAndRemovePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				unloadAndRemoveFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Unload & remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!unloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection unload.			presentation update ]; 		icon: #delete asIcon;		shortcut: $u; 		title: 'Unload package'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!visibleRepositoryModels	^ self repositoryRegistry 		select: [ :each | self isRepositoryVisible: each  ]		thenCollect: [ :repo | IceRepositoryModel modelFor: repo ]! !!IceTool class methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!chooseFrom: options displaying: descriptionBlock 	"Description block is used both for sorting and for displaying"		| sortedOptions index  |	sortedOptions := options asSortedCollection: [:wc1 :wc2 | (descriptionBlock value: wc1) < (descriptionBlock value: wc2) ].	index := self uiManager chooseFrom: (sortedOptions collect: descriptionBlock).	^ index > 0 		ifTrue: [ sortedOptions at: index ]		ifFalse: [ nil ]! !!IceTool class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ RealEstateAgent standardWindowExtent! !!IceTool class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceTool class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ nil! !!IceTool methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose 	self tabulator with: [ :browser |		self configureBrowser: browser.		self composeBrowserOn: browser  ]! !!IceTool methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser 	self subclassResponsibility! !!IceTool methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!configureBrowser: browser	"hack to add initial properties (as initialExtent) to browsers"		browser initialExtent: self initialExtent! !!IceTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceTool methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				onMerge: [					presentation selection: nil.					presentation pane browser update 				];				run		];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ self class title! !!IceTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!titleIcon	^ self class icon! !!IceInteractiveCredentialsProvider class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:04'!initialize	"self initialize"	IceCredentialsProvider providerType: self.! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!askForPlaintextCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForPlaintextCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class plaintextCredentials: credentials ].			response readFrom: credentials.		];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!askForSshCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForSshCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class sshCredentials: credentials ].			response readFrom: credentials ];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	tries := 0! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!providePlaintextCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self plaintextCredentials isPresent		ifTrue: [ credentials readFrom: self plaintextCredentials ]		ifFalse: [ self askForPlaintextCredentials: credentials ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!provideSshAgentCredentialsTo: credentials	"Just check for tries to ensure we do not enter an infinite cycle in libgit2"	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'No ssh-agent credentials found.' ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!provideSshCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self sshCredentials isPresent		ifTrue: [ credentials readFrom: self sshCredentials ]		ifFalse: [ self askForSshCredentials: credentials ].! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cellColumn: column row: rowIndex	| item cell |	item := self elementAt: rowIndex.	cell := FTIndentedCellMorph new.	cell indentBy: item depth * 16.	cell 		addMorphBack: (self buttonFor: item);		addMorphBack: (CheckboxButtonMorph new			selected: (self isSelected: item data);			target: [ self toggleSelectionOf: item ];			actionSelector: #value;			yourself);		addMorphBack: (self createCellMorphFor: item).	^ cell! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createCellMorphFor: item	| morph rowElements |	rowElements := OrderedCollection new.	(self iconFor: item data) ifNotNil: [ :icon | rowElements add: icon asMorph ].	rowElements		add: (self formatedDisplayValueOf: item data) asMorph asReadOnlyMorph;		addAll: (self tagMorphsFrom: self glamourPresentation for: item data).	morph := self createInnerCellMorph.	rowElements do: [ :each | morph addMorphBack: each ].	^ morph				! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createInnerCellMorph	^ Morph new 		layoutPolicy: TableLayout new;		color: Color transparent;		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		cellPositioning: #leftCenter;		cellInset: 5;		listCentering: #leftCenter;		wrapCentering: #leftCenter;		yourself! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!deselectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection remove: each data ifAbsent: [] ].	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	selection := Set new! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!isSelected: anObject	^ selection includes: anObject! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/24/2017 12:50:04'!selectAll	self rootsItems do: [ :each | 		self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!selectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection add: each data ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectAllWithChildren: aCollection	selection := Set new.	aCollection do: [ :each | self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selected: aCollection	selection := aCollection asSet! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selection	^ selection! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!tableRefresh	self table ifNil: [ ^ self ].	super tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!toggleSelectionOf: item	(self isSelected: item data) 		ifTrue: [ self deselectAllChildrenOf: item ]		ifFalse: [ self selectAllChildrenOf: item ].	self glamourPresentation cherryPick: selection.	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/24/2017 12:50:04'!updateSelectionWithCollectBlock: aBlock	self table ifNil: [ ^ self ].	super updateSelectionWithCollectBlock: aBlock! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!withAllChildrenOf: item	^ item children		inject: { item }		into: [ :all :each | all, (self withAllChildrenOf: each) ]! !!IceRemoteAdded class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!remote: aRemote	^ self new remote: aRemote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/24/2017 12:50:04'!additionColor	^ super removalColor! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/24/2017 12:50:04'!removalColor	^ super additionColor ! !!GLMSwappedColorDiffPresentation methodsFor: 'rendering' stamp: ' 7/24/2017 12:50:04'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderSwappedColorDiffPresentation: self! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ false! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeRemove! !!MCAddition methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeAdd! !!MCPatchOperation methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ true! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	"It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches."	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isBranchModel	^ false! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameToDisplay	^ self subclassResponsibility ! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	^ self subclassResponsibility! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!localFromRepository: aRepository	^ self		repository: aRepository		branches: #localBranches		groupName:			('Local' asText				allBold;				yourself)! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository branches: aCollection groupName: aString	^ self new		repository: aRepository;		branches: aCollection;		groupName: aString;		yourself! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository remote: aRemote	^ self repository: aRepository branches: [ :repository | aRemote branchesFrom: repository ] groupName: aRemote asString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branches	^ branches cull: self repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branches: aBlockOrSymbol	branches := aBlockOrSymbol! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	^ self branches collect: [ :branch | IceBranchModel parent: self branch: branch ]! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!groupName	^ groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!groupName: aString	groupName := aString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameToDisplay	^ self groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anIceRepository	repository := anIceRepository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	^ self branches size asString , ' branches'! !!IceBranchModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!parent: anIceBranchGroupModel branch: anIceBranch	^ self new		parentGroup: anIceBranchGroupModel;		branch: anIceBranch;		yourself! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	^ branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch: anIceBranch	branch := anIceBranch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	^ #()! !!IceBranchModel methodsFor: 'action' stamp: ' 7/24/2017 12:50:04'!compareCurrentToMe	self repository compareCurrentBranchWithBranch: self branch! !!IceBranchModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isBranchModel	^ true! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameToDisplay	^ self repository descriptionTextForBranch: self branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentGroup	^ parentGroup! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentGroup: anIceBranchGroupModel	parentGroup := anIceBranchGroupModel! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self parentGroup repository! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	| incoming outgoing allStatus |		incoming := self branch incomingCommits size.	outgoing := self branch outgoingCommits size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ allStatus asCommaString! !!IceBranchModel methodsFor: 'action' stamp: ' 7/24/2017 12:50:04'!switchToMe	self repository switchBranchTo: self branch! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!clearModels	"Clear the model cache, this is needed for correct testing"	modelCache := nil.! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!compactIfNeeded	| newModelCache |	self models size > 250 ifFalse: [ ^ self ].	newModelCache := self models select: [ :each | each notNil ].	modelCache := newModelCache	! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!modelFor: entity	| model |	"We are using WeakValueDictionary to keep this sinchronized (in case you have more than 	 one window open, you want always same model). Now, it has to be cleaned when windows are 	 no longer around, but associations will be nil... so we cannot use a simple ifAbsentPut:. 	 Yep, ugly... but effective."		model := self models at: entity name ifAbsent: [ nil ].	^ model ifNil: [ 		self compactIfNeeded.		self models 			at: entity name			put: (self basicNew 				entity: entity; 				initialize; 				yourself) ]! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!models	"since a repository can have same name as a package (and we keep models by name), 	 I need to keep this as an instance of class and not a variable (who would be 	 shared by all hierarchy and because of that prone to errors)"	^ modelCache ifNil: [ modelCache := WeakValueDictionary new ]! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #modelFor:'! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ self entity announcer! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorError	^ Color red! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorIncoming	^ Color brown! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorModified	^ Color r: 0 g: 0.5 b: 0! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorNotLoaded	^ Color darkGray! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorOutgoing	^ Color blue! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity	^ entity! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity: anObject	entity := anObject! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!highlight: aString	[ 		| text modified incoming outgoing |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		incoming := self incomingCommits notEmpty.		outgoing := self outgoingCommits notEmpty.		modified ifTrue: [ text prepend: '* ' ].		modified | incoming | outgoing ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		incoming ifTrue: [ ^ text makeAllColor: self colorIncoming ].		outgoing ifTrue: [ ^ text makeAllColor: self colorOutgoing ].		^ text	]	on: Error do: [ ^ aString ]! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ incomingCommits value! !!IceAbstractModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	"NOTE: this was before [ self entity incomingCommits ], but this is not happy 	 with weak announcements (they will remain forever)... so we change them for 	 WeakMessageSend instances to avoid problems"	incomingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #incomingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak.		outgoingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #outgoingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLoaded	self subclassResponsibility ! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isMissing	^ self repository isMissing! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isOperative	^ self repository isMissing not! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!makeError: aString	^ aString asText allBold makeAllColor: self colorError	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ outgoingCommits value	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	self subclassResponsibility! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	"entity could be a repository or a package"	[		| status incoming outgoing | 		self verifyDirectoryStructureIfMissing: [ :message | ^ message ].				self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				incoming := self incomingCommits size.		incoming > 0 ifTrue: [ status add: ('{1} incoming' format: { incoming })].				outgoing := self outgoingCommits size.		outgoing > 0 ifTrue: [ status add: ('{1} not published' format: { outgoing })].		^ status ifEmpty: 'Up to date' ifNotEmpty: [ ', ' join: status ]	] 	on: Error do: [ :error | ^ self makeError: error description ]! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!verifyDirectoryStructureIfMissing: aBlock	self repository isMissing 		ifTrue: [ ^ aBlock value: (self makeError: 'Local repository missing') ].	self repository isCodeMissing		ifTrue: [ ^ aBlock value: (self makeError: 'Code directory missing') ].! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browse	^ self package browse! !!IcePackageModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!highlight: aString	[ 		| text modified |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		modified ifTrue: [ text prepend: '* ' ].		modified ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		^ text	]	on: Error do: [ ^ aString ]! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self package isLoaded! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!loadLatest	self package loadLatest! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!nameText	^ self highlight: self packageName! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!package	^ entity! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package name! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!reload	self package reload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDisk	self entity removeFromDisk! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDiskThen: aBlock	(UIManager default confirm: ('You are going to remove package {1} from disk. Are you sure?' format: { self entity name }))		ifFalse: [ ^ self ].	self entity removeFromDisk: true.	aBlock value! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self entity repository! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!status	"entity could be a repository or a package"	[		| status | 		self repository isMissing ifTrue: [ ^ 'Local repository missing' asText allBold makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				^ status 			ifNotEmpty: [ status asCommaString ]			ifEmpty: [ 'Up to date' ] ] 	on: Error do: [ :error | ^ error description asText makeAllColor: self colorError ]! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!unload	self package unload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!unloadAndRemoveFromDiskThen: aBlock	self unload.	self removeFromDiskThen: [].	aBlock value! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!registry	^ IceRepository registry collect: [ :repository | self modelFor: repository ]! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!tagDefaultPull	^ 'Pull'! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!tagDefaultPush	^ 'Push'! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!addRemoteThen: aBlock	IceRemoteModel new 		setModal: true;		repository: self repository;		onAccept: [ :remote |			self repository addRemote: remote. 			aBlock cull: remote ];		openWithSpec! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self repository branch name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branches	^ self repository allBranches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browseHistory	IceHistoryBrowser openOn: self repository! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canPush	[ 		^ self isOperative 			and: [ self outgoingCommits notEmpty 			and: [ self incomingCommits isEmpty ] ]	]	on: Error do: [ ^ false ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!compareCurrentBranchWithBranch: aBranch	IceBranchBrowser openOn: aBranch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createNewBranchThen: aBlock	| selection |	selection := UIManager default		request: 'Please provide the name of the new branch to be created'		initialAnswer: ''		title: 'Create new branch'.	selection ifNotNil: [ 		selection 			ifEmpty: [ 				UIManager default 					abort: 'Branch name can not be empty.' 					title: 'Create new branch'. ]			ifNotEmpty: [ 				self repository createBranch: selection.				aBlock cull: self repository branch ] ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!descriptionText	^ self highlight: self repository name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!descriptionTextForBranch: aBranch	^ aBranch isRemote		ifTrue: [ aBranch basename ]		ifFalse: [ | text |			text := aBranch name asText.			(self isCurrentBranch: aBranch)				ifTrue: [ text allBold ].			text ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!descriptionTextForRemote: aRemote	^ aRemote remoteName! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ 	self repository origin detailedInfo, { 		'Location' -> self repository location pathString. 		'Pulling from' -> (self repository pullRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]). 		'Pushing to' -> (self repository pushRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]).		'On branch' -> self repository branchName.	} ! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!editRepositoryThen: aBlock	(IceEditRepositoryModel repository: self repository) 		onAccept: aBlock;		openWithSpec! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	^ self repository fetch! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!fetchRemote: aRemote 	self repository fetchFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!forgetThen: aBlock	(UIManager default confirm:			('Are you sure to remove repository: {1}?(Packages will not be deleted, nor the repository from the file system)'				format: { self repository origin url })		label: 'Removing Iceberg Repository')	ifTrue: [ 		self repository forget.		aBlock cull: self ]! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasLocalBraches	^ self repository hasLocalBraches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!inspectRepository	self repository inspect! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isCurrentBranch: aBranch	^ self repository branch = aBranch! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self repository loadedPackages isNotEmpty ! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPullRemote: aRemote	^ self repository isPullRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPushRemote: aRemote	^ self repository isPushRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isValid	^ self repository isValid! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedCodeDescription	self verifyDirectoryStructureIfMissing: [ :message | ^ message ].	^ self repository loadedCode description! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!localBranches	^ self repository localBranches! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!makePullRemote: aRemote	self repository pullRemote: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!makePushRemote: aRemote	self repository pushRemote: aRemote! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pickBranch 	| branches |	 	branches := self repository branchesForCheckout.	^ UIManager default		chooseFrom: (branches collect: #name)		values: branches		message: 'Select the new branch you want to switch to:' 		title: 'Checkout branch'! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pickRemote: aTitle	| remotes |	 	remotes := self repository remotes.	^ UIManager default		chooseFrom: (remotes collect: #remoteName)		values: remotes		message: 'Select the remote you want to use:' 		title: aTitle! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/24/2017 12:50:04'!pluginActions	^ self repository pluginManager repositoryActions! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/24/2017 12:50:04'!pluginPackageActionsFor: icePackage	^ self repository pluginManager packageActionsFor: icePackage! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/24/2017 12:50:04'!pluginRemoteActionsFor: aRemote	^ self repository pluginManager remoteActionsFor: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pull	self validateCanPull ifFalse: [ ^ self ].	self repository pull! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pullFrom	| remote |	self validateCanPull ifFalse: [ ^ self ].	remote := self pickRemote: 'Pull from'.	remote ifNil: [ ^ self ].	self repository pullFrom: remote.! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!pullRemote: aRemote	self repository pullFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!pushRemote: aRemote	self repository pushTo: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushThen: aBlock	self 		pushTo: self repository pushRemote 		then: aBlock! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pushTo: aRemote then: aBlock	"We need an existing remote as premise to do the push (new repositories can have this 	 situation)"	aRemote ifNil: [ 		^ UIManager default			abort: 'There is no remote to publish, please add one (in "remotes" tab).'			title: 'Publishing aborted' ].	[ 		UIManager default informUserDuring: [ :bar | 			bar label: ('Publishing local commits to {1}' format: { aRemote url }).			self repository pushTo: aRemote. 			aBlock value ] ] 	on: YouShouldPullBeforePush	do: [ 		UIManager default			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushToThen: aBlock	| remote |	remote := self pickRemote: 'Push to'.	remote ifNil: [ ^ self ].	self pushTo: remote then: aBlock! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	self repository refresh! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!reloadAllLoadedPackages	self repository savedPackages 		select: #isLoaded 		thenDo: [ :each | each reload ].! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remotes	^ self repository remotes! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!removeRemote: aRemote then: aBlock	(self confirm: (('You are going to remove remote {1}. Are you sure?') format: {aRemote}))		ifFalse: [ ^ self ].	self repository removeRemote: aRemote.	aBlock cull: aRemote! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self entity! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!restore	self repository backend cloneRepository.	self repository refresh.! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!savedPackages	^ [self repository savedPackages collect: [ :package | IcePackageModel modelFor: package ]]		on: Error do: [ :error | 			self inform: ('Error computing saved packages for repository: {1}. {2}'				format: { self repository name. error }).			#()		]! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!shouldCreateLocalBranchFromRemote 	^ UIManager default		confirm: 'You are trying to switch to a remote branch.' , String cr , 			'Do you want to create a local branch for it?' , String cr ,			'Note: if you do not create a local branch, you will be in a detached head and you won''t be abe to commit code!!'		label: 'Checkout remote branch'! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!statusForRemote: aRemote	| incoming outgoing allStatus |		incoming := (self repository incomingCommitsFrom: aRemote) size.	outgoing := (self repository outgoingCommitsTo: aRemote) size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ ((self tagsForRemote: aRemote), allStatus) asCommaString! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!switchBranch	| branch |	branch := self pickBranch.	branch ifNil: [ ^ self ].	self switchBranchTo: branch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!switchBranchTo: branch	branch isRemote		ifTrue: [ self repository localBranches 				detect: [:aBranch | aBranch name = branch basename ]				ifFound: [ UIManager default inform: 'Cannot switch to this branch. A local branch with the same name already exists!!'.								self flag: 'We should probably go into detached head state.' ]				ifNone: [ self shouldCreateLocalBranchFromRemote 					ifTrue: [ self repository backend withRepoDo: [ :repo | repo createBranchFromOrigin: branch basename ].								self repository checkoutBranch: branch basename ]					ifFalse: [ self shouldBeImplemented ] ] ]		ifFalse: [ self repository checkoutBranch: branch basename ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!synchronize	IceGlamourSynchronizer synchronize: self repository! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!tagsForRemote: aRemote	| tags |		tags := OrderedCollection new.	(self isPushRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPush ]. 	(self isPullRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPull ]. 		^ tags asArray! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validateCanPull	self repository isModified		ifTrue: [ 			^ IceTool uiManager				confirm:					'Your repository has uncommited changes. Merging incoming commits will changeyour current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'				label: 'You might loose your current changes!!'				trueChoice: 'Proceed anyway'				falseChoice: 'Cancel'				cancelChoice: nil				default: false ].	^ true! !!IceCachedValue class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aBlock	^ self new updateAction: aBlock! !!IceCachedValue class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!timeout	^ 30 seconds! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	updating := false! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!invalidateOn: announcementType from: announcer	announcer subscribe: announcementType send: #reset to: self! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!isValid	^ lastUpdated isNotNil and: [ (DateAndTime current - lastUpdated) < self class timeout ]! !!IceCachedValue methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!reset	lastUpdated := nil! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!updateAction: anObject	updateAction := anObject! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!value	self isValid ifTrue: [ ^ value ].	updating ifTrue: [ ^ 'Loading...' asText allItalic ].	[ 		updating := true.		value := updateAction value.		lastUpdated := DateAndTime current.		^ value	]	ensure: [ updating := false ]! !!IceChangesTreeResetSelectionHelper class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceChangesTreeResetSelectionHelper methodsFor: 'executing' stamp: ' 7/24/2017 12:50:04'!execute: ann	self presentation selection: nil! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation	^ presentation! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation: anObject	presentation := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browseAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browse ];		condition: [ :presentation :entity | 			presentation selection notNil 				and: [ presentation selection canBeBrowsed ]];		icon: #nautilus asIcon;		shortcut: $b;		title: 'Browse'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browseReferencesAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browseReferences ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection canBrowseReferences ]];		shortcut: $n;		title: 'Browse references'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildOn: aPresenter	^ aPresenter fastTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [  				self diff announcer 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!diff	^ diff! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!diff: anObject	diff := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!elements 	^ self diff elements select: #hasChanges! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity	^ entity ifNil: [ self diff ]! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity: anObject	entity := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refreshTreeAction	^ GLMGenericAction new		action: [ self entity refresh ];		icon: #glamorousRefresh asIcon;		shortcut: $r;		title: 'Refresh tree'; showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!revertChangeAction	^ GLMGenericAction new		action: [ :presentation | self entity revertChange: presentation selection ];		condition: [ self entity canRevertChanges ];		icon: #glamorousUndo asIcon;		title: 'Revert change'; 		showTitle! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildOn: aPresenter	^ aPresenter cherryPickTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		allSelected;		onChangeOfCherryPick: [ :presentation | self selectedCherryPick: presentation cherryPick ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [				self diff announcer 					subscribe: IceChangeSetChanged					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onSelectCherryPick: aBlock	cherryPickBlock := aBlock! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectedCherryPick: aSet	cherryPickBlock ifNil: [ ^ self ].	cherryPickBlock value: aSet! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!chooseTargetBranch	| branches |		self targetBranch ifNotNil: [ ^ self targetBranch ].		branches := self repository branchesForMerge: self source.	^ targetBranch := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { source shortId })		title: 'Merge your changes into another branch'.! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!confirmContinueWithDirtyRepository	^ self uiManager		confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'		label: 'You might loose your current changes!!'		trueChoice: 'Proceed anyway'		falseChoice: 'Cancel'		cancelChoice: nil		default: false! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!informAutomaticMergeImpossible	self uiManager		abort: 'Automatic merge is not possible, to merge manually please first checkout branch ', self targetBranch name, ' and then retry.' 		title: 'Automatic merge impossible'! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onMerge	^ onMerge! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onMerge: anObject	onMerge := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository ifNil: [ repository := self source repository ]! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	^ repository := anObject! !!IceMergeTool methodsFor: 'merging' stamp: ' 7/24/2017 12:50:04'!run	"Merge selected commit into another branch"	self repository isModified ifTrue: [ 		self confirmContinueWithDirtyRepository ifFalse: [ ^ self ]].	self chooseTargetBranch ifNil: [ ^ self ].	[ source mergeInto: self targetBranch ]		on: IceMergeAborted		do: [ 			self targetBranch name = repository branchName 				ifTrue: [ repository mergeConflictsWith: source ]				ifFalse: [ self informAutomaticMergeImpossible. ^ self ]].	self onMerge value ! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!source	^ source! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!source: anObject	source := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetBranch	^ targetBranch! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetBranch: anObject	targetBranch := anObject! !!IceRepositoryUpdateHelper class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceRepositoryUpdateHelper methodsFor: 'executing' stamp: ' 7/24/2017 12:50:04'!execute: ann	self presentation		updateOn: IceRepositoryAnnouncement 		from: [ ann repository announcer weak ]! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation	^ presentation! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation: anObject	presentation := anObject! !!PharoShortcuts methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!openIcebergShortcut	^ $o meta, $i meta! !!Text methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!allItalic	"Force this whole text to be italic."	string isEmpty ifTrue: [ ^ self ].	^ self addAttribute: TextEmphasis italic from: 1 to: string size.! !!GLMMorphicSwappedColorDiffRenderer methodsFor: 'rendering' stamp: ' 7/24/2017 12:50:04'!render: aPresentation	| textMorph |	textMorph := (SwappedColorDiffMorph		from: aPresentation displayValue first		to: aPresentation displayValue last		contextClass: aPresentation contextClassValue)			layoutFrame: (LayoutFrame identity);			vResizing: #spaceFill;			hResizing: #spaceFill;			yourself.	^textMorph! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !"Iceberg-UI"!!IceGitHubPullRequestBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show a pull request in detailt. Since a PR is not much more than a branch, I extend the branch browser :)!!IceGitHubPullRequestListBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show all open pull requests in a repository.!!IceGitHubError commentStamp: 'EstebanLorenzano 2/1/2017 17:15' prior: 0!I'm an error that happens when something fails when performing a GitHub action.!!IceGitHubBadCredentialsError commentStamp: '<historical>' prior: 0!I'm an error that happens when credentials are bad.!!IceGitHubGenericError commentStamp: '<historical>' prior: 0!I'm an error that happens when something went wrong on GitHub API operations.!!IceGitHubJSONDataSource commentStamp: '<historical>' prior: 0!I'm a generic datasource to show in a table results of a JSON. I'm intended to be used to show information from GitHub API, but I'm generic enough to be used which any kind of JSON structure.!!IceGitHubPullRequestDataSource commentStamp: '<historical>' prior: 0!I'm a datasource for pull request status, to be used when showing pull requests details. See IceGitHubPullRequestDetailModel!!IceGitHubAcceptPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog for collecting data to accept a pull request.!!IceGitHubCreatePullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for data relevant to create a pull request.!!IceGitHubPullRequestActionsModel commentStamp: '<historical>' prior: 0!I'm an actions toolbar, to be used with IceGitHubPullRequestBrowser.!!IceGitHubPullRequestDetailModel commentStamp: '<historical>' prior: 0!I'm a spec model to present a detailed view of a Pull Request.!!IceGitHubRejectPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to collect data about a pull request rejection.!!IceGitHubSelectListModel commentStamp: '<historical>' prior: 0!I'm a dialog to select a list of anything (used by branches now).!!IceGitHubAPI commentStamp: '<historical>' prior: 0!I represent an access point to the GitHub API. I provide different high level abstractions to interact with GitHub, following the speciphications you can find here: https://developer.github.com/v3/!!IceGitHubAPIPaginatedResult commentStamp: '<historical>' prior: 0!I'm a paginated answer from github (he sends results in pages and includes information in headers)!!IceGitHubCommand commentStamp: '<historical>' prior: 0!I'm a generic command to perform plugin actions for GitHub.My children define the real behavior, and they need to implement #execute.!!IceGitHubNewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to create a Pull Request!!IceGitHubRemoveBranchesCommand commentStamp: '<historical>' prior: 0!I'm a command to remove branches from remotes.!!IceGitHubViewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to show the pull request review browser.!!IceGitHubPullRequest commentStamp: '<historical>' prior: 0!I'm a pull request from github API. I represent (more or less), what is described here: https://developer.github.com/v3/pulls/#list-pull-requests!!IceGitHubPullRequestDefinition commentStamp: '<historical>' prior: 0!I am a pull request. I can be sent using ==#sendWithCredentials:== protocol.!!IceGitHubSelectItem commentStamp: '<historical>' prior: 0!I'm a helper to keep selected items in a list.!!IceGitHubPullRequestPlugin commentStamp: '<historical>' prior: 0!I define the plugin GitHub - Pull Request!!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!acceptPullRequest	IceGitHubAcceptPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				acceptMessage: model message 				type: model type ];		openWithSpec	! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ 			commitInfo diffTo: (self mergeBaseCommitFor: commitInfo) ]);		buildOn: a)		title: 'Changes vs. destination' .	super addChangesTreeTo: a with: commitInfo! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseSHA	^ self pullRequest baseSHA! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff;		row: #actions size: 35.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser.		browser transmit to: #actions; andShow: [ :a | 		a morph			morph: [ 				IceGitHubPullRequestActionsModel new 					onMerge: [ self mergePullRequestIntoImage ];					onAccept: [ self acceptPullRequest ];					onReject: [ self rejectPullRequest ];					buildWithSpec ] ]! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeBaseCommitFor: commitInfo	^ commitInfo repository commitAt: (self mergeBaseFor: commitInfo)! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeBaseFor: commitInfo	^ commitInfo repository		mergeBaseBetween: commitInfo commitId 		and: self baseSHA! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergePullRequestIntoImage	(UIManager default confirm: ('I will create a new local branch named {1}. Should I continue?' format: { self pullRequest branchName }))	ifFalse: [ ^ self ].	self pullRequest mergeIntoImage! !!IceGitHubPullRequestBrowser methodsFor: 'scripting opening' stamp: ' 7/24/2017 12:50:04'!open	self openOn: self pullRequest branch! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequest	^ pullRequest! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequest: anObject	pullRequest := anObject! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!rejectPullRequest	IceGitHubRejectPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				rejectMessage: model message  ];		openWithSpec! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Browsing pull request: #{1} {2}' format: { self pullRequest number. self pullRequest title  }! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 700@700! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildOn: browser	browser 		row: #pullRequests;		row: #detail span: 2.			browser transmit to: #pullRequests; andShow: [ :a |		a fastTable 			title: 'Open pull requests';			addAction: self refreshAction;			selectionAct: [ :presentation | 				self viewPullRequest: presentation selection ] 				entitled: 'Review pull request...';			onChangeOfPort: #strongSelection act: [ :presentation | 				self viewPullRequest: presentation selection ];			column: '#' evaluated: #number width: 50;			column: 'State' evaluated: #state width: 50;			column: 'Author' evaluated: #author width: 120;			column: 'Title' evaluated: #title ].			browser transmit from: #pullRequests; to: #detail; andShow: [ :a |		a morph 			title: [ :pr | '#{1} {2}' format: {pr number. pr title} ];			morph: [ :presentation :pr | (IceGitHubPullRequestDetailModel for: pr) buildWithSpec ] ]! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose	self tabulator with: [ :browser |		browser initialExtent: self initialExtent.		self buildOn: browser ]! !!IceGitHubPullRequestListBrowser methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!fetchPullRequests	^ (IceGitHubAPI new		getPullRequests: self remote owner project: self remote projectName) all		collect: [ :each | 			(IceGitHubPullRequest fromJSON: each)				repository: self repository;				yourself ]! !!IceGitHubPullRequestListBrowser methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceGitHubPullRequestListBrowser methodsFor: 'scripting opening' stamp: ' 7/24/2017 12:50:04'!open	^ self openOn: self pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequests	^ pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequests: anObject	pullRequests := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!refreshAction	^ GLMGenericAction new		action: [ :presentation |			UIManager default				informUser: 'Refreshing pull request list' 				during: [ self refreshPullRequests ].			presentation update ];		icon: #refresh asIcon;		title: 'Refresh'; 		showTitle! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!refreshPullRequests	self pullRequests: self fetchPullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Pull requests on {1} ({2})' format: { self remote remoteName. self remote url }! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!titleIcon	^ self class icon! !!IceGitHubPullRequestListBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequest: aPullRequest	UIManager default 		informUser: ('Opening pull request {1} {2}' format: { aPullRequest number. aPullRequest title })		during: [  			IceGitHubPullRequestBrowser new 			pullRequest: aPullRequest;			open ]! !!IceGitHubBadCredentialsError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAppropriateFor: aResponse 	^ aResponse status = 401! !!IceGitHubBadCredentialsError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageBody	^ 'Credentials provided are wrong'! !!IceGitHubError class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!errorClassFor: aResponse	^ self allSubclasses 		detect: [ :each | each isAppropriateFor: aResponse  ]		ifNone: [ self ]! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aResponse	^ (self errorClassFor: aResponse) new 		response: aResponse;		yourself	! !!IceGitHubError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAppropriateFor: aResponse	^ false! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!signalFor: aResponse	^ (self for: aResponse) signal! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!code	^ self response status! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!contents	^ self response contents! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!customError: aDictionary	^ aDictionary at: #message		! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!errorToString: aDictionary 	(aDictionary at: #code) = 'custom' ifTrue: [ ^ self customError: aDictionary ].	(aDictionary at: #code) = 'invalid' ifTrue: [ ^ self invalidError: aDictionary ].		^ self unknownError: aDictionary	! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!invalidError: aDictionary	^ 'Invalid field: ', (aDictionary at: #field)			! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!jsonContents	^ jsonContents ifNil: [ jsonContents := STON fromString: self contents ]		! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageBody	| errors |	errors := self jsonContents at: #errors ifAbsent: [ ^ '' ].	^ String streamContents: [ :stream | 		errors			do: [ :each | stream << (self errorToString: each) ] 			separatedBy: [ stream cr ] ].! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageText	^ self jsonContents at: #message! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!response	^ response! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!response: anObject	response := anObject! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!unknownError: aDictionary	^ String streamContents: [ :stream | 		(aDictionary associations sorted: [ :a :b | a key < b key  ])			do: [ :each | stream << each key << ': ' << each value ]			separatedBy: [ stream << ', ' ] ]! !!IceGitHubGenericError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAppropriateFor: aResponse	^ aResponse status = 422! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!actionColumn: column	elements := elements sorted: [ :a :b |		(a at: column id) < (b at: column id) ]		! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cellColumn: column row: rowIndex 	^ FTCellMorph new  		addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;		yourself	! !!IceGitHubJSONDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!columnTitleFor: column	^ column id capitalized! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headerColumn: column	column id ifNil: [ ^ nil ].	^ SimpleButtonMorph new		layoutPolicy: RowLayout new; 		listDirection: #leftToRight; 		wrapCentering: #center;		cellInset: 5@0;		layoutInset: 5@0;		label: (self columnTitleFor: column);		target: self;		actionSelector: #actionColumn:;		arguments: {column};		yourself! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!actionColumn: column	column id = #target_url ifTrue: [ ^ self ].	^ super actionColumn: column	! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cellColumn: column row: rowIndex 	column id = #target_url ifTrue: [ ^ self targetUrlCellColumn: column rowIndex: rowIndex ].	column id = #state ifTrue: [ ^ self statusCellColumn: column rowIndex: rowIndex ].	column id = #context ifTrue: [ ^ self contextCellColumn: column rowIndex: rowIndex ].	^ super cellColumn: column row: rowIndex ! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!columnTitleFor: column	column id = #target_url ifTrue: [ ^ '' ].	^ super columnTitleFor: column! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!contextCellColumn: column rowIndex: rowIndex	| context |	context := (self elementAt: rowIndex) at: column id.	(context includesSubstring: 'travis-ci')		ifTrue: [ context := 'travis-ci' ].	^ FTCellMorph new  		addMorphBack: context asMorph;		yourself		! !!IceGitHubPullRequestDataSource methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!copyToClipboard: url	Clipboard clipboardText: url.	UIManager default inform: ('Url {1} copied to clipboard' format: { url })! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!statusCellColumn: column rowIndex: rowIndex	| status |	status := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		cellInset: 5;		addMorphBack: (self iconForStatus: status) asMorph;		addMorphBack: status asStringMorph;		yourself	! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!targetUrlCellColumn: column rowIndex: rowIndex	| url |	url := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		addMorphBack: (			IconicButton new				target: self;				actionSelector: #copyToClipboard:;				arguments: { url };				labelGraphic: (#smallCopy asIcon scaledToSize: 12@12);				color: Color transparent;				helpText: ('Copy url {1} to clipboard' format: { url });				borderWidth: 0;				yourself);		yourself	! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				newRow: [:row | row add: #typeLabel width: 80; add: #typeList ] height: 25;				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultType	^ 'merge'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Accept pull request'! !!IceGitHubAcceptPullRequestModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ 500@250! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	super initializePresenter.	self typeList 		items: self class availableTypes;		displayBlock: [ :each | each  ];		setSelectedItem: self class defaultType! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	typeLabel := self newLabel.	typeList := self newDropList.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	typeLabel label: 'Merge type'.	acceptButton label: 'Accept pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: typeList;		add: acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!message	^ self messageText text asString! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel	^ messageLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText	^ messageText! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText: anObject	messageText := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ self typeList selectedItem! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeLabel	^ typeLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeLabel: anObject	typeLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeList	^ typeList! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeList: anObject	typeList := anObject! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #titleLabel width: 80; add: #titlePanel ] height: 25;				newRow: [:row | 					row 						newColumn: #headLabel width: 80;						newColumn: [ :col2 | 							col2 newRow: [ :row2 | 								row2									add: #headForkList;									add: #headBranchList ] ] ] height: 25;				newRow: [:row | 					row 						newColumn: #baseLabel width: 80;						newColumn: [ :col2 |							col2 newRow: [ :row2 |								row2 									add: #baseForkList;									add: #baseBranchList ] ] ] height: 25;				newRow: [:row | row add: #bodyLabel width: 80; add: #bodyPanel ];				add: #addButton height: self buttonHeight  ];		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #repository:credentials:'! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository credentials: aCredentials headRemote: aRemote	^ self basicNew 		initializeRepository: aRepository 			credentials: aCredentials			headRemote: aRemote;		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'New pull request'! !!IceGitHubCreatePullRequestModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	| title |		title := self titlePanel text trim.	title ifEmpty: [ 		UIManager default alert: 'You need to specify a title for the pull request.' title: 'Error'. 		^ self ].		acceptBlock ifNotNil: [ 		acceptBlock cull: self createPullRequest ].		self window delete! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!addButton	^ addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!addButton: anObject	addButton := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableBranchNames	^ availableBranchNames ifNil: [ availableBranchNames := self obtainAvailableBranchNames ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableRemotes	"retrieves available remotes to perform the PR"	^ availableRemotes ifNil: [ availableRemotes := self obtainAvailableRemotes ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseBranchList	^ baseBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseBranchList: anObject	baseBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!baseBranchNames	^ self baseBranches collect: [ :each | each at: #name ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!baseBranches	^ baseBranches ifNil: [ 		baseBranches := self requestBaseBranches ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseDefaultBranchName	^ self gitBase at: #'default_branch' ! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseForkList	^ baseForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseForkList: anObject	baseForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseLabel	^ baseLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseLabel: anObject	baseLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseRemote	"This is the 'base' remote (the place where the repository is forked). This is used to 	 suggest fork PR destination (base)"	^ baseRemote ifNil: [ baseRemote := self obtainBaseRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyLabel	^ bodyLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyLabel: anObject	bodyLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyPanel	^ bodyPanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyPanel: anObject	bodyPanel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	^ self repository branch! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!createPullRequest	^ IceGitHubPullRequestDefinition new 		credentials: self credentials;		title: self titlePanel text trim;		headRemote: self headForkList selectedItem;		headBranchName: self headBranchList selectedItem;		baseRemote: self baseForkList selectedItem;		baseBranchName: self baseBranchList selectedItem;		body: self bodyPanel text asString trim;		yourself! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ credentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials: aCredentials	credentials := aCredentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultBaseBranchName	self hasParent ifFalse: [ ^ self baseDefaultBranchName ].	^ self baseBranchNames 		detect: [ :each | each = self branch basename ] 		ifNone: [ self baseDefaultBranchName ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultHeadBranchName	^ self branch basename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!gitBase	| info |	^ (info := self gitRepositoryInfo) 		at: #parent		ifAbsent: [ info ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!gitRepositoryInfo	^ gitRepositoryInfo ifNil: [ 		gitRepositoryInfo := self requestGitRepositoryInfo ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!hasParent	^ self gitRepositoryInfo includesKey: #parent! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headBranchList	^ headBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headBranchList: anObject	headBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headForkList	^ headForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headForkList: anObject	headForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headLabel	^ headLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headLabel: anObject	headLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headRemote 	^ headRemote  ifNil: [ self repository pushRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ 500@300! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	super initializePresenter.	self titlePanel text: self branch basename.	self headForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self headRemote.	self headBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultHeadBranchName.	self baseForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self baseRemote.	self baseBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultBaseBranchName! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeRepository: aRepository credentials: aCredentials headRemote: aRemote	repository := aRepository.	credentials := aCredentials.	headRemote := aRemote.	self initialize! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	titleLabel := self newLabel.	titlePanel := self newTextInput autoAccept: true.	headLabel := self newLabel.	headForkList := self newDropList.	headBranchList := self newDropList.	baseLabel := self newLabel.	baseForkList := self newDropList.	baseBranchList := self newDropList.	bodyLabel := self newLabel.	bodyPanel := self newText autoAccept: true.	addButton := self newButton.			titleLabel label: 'Title'.	headLabel label: 'From (Head)'.	baseLabel label: 'To (Base)'.	bodyLabel label: 'Comment'.	addButton label: 'Create pull request'.	addButton action: [ self accept ].		self focusOrder 		add: titlePanel;		add: headForkList;		add: headBranchList;		add: baseForkList;		add: baseBranchList;		add: bodyPanel;		add: addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainAvailableBranchNames	^ ((self repository allBranches 		collect: #basename as: Set)		addAll: self baseBranchNames;		asArray)		sort.	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainAvailableRemotes	| remotes |		remotes := self repository remotes.	(remotes includes: self baseRemote)		ifFalse: [ remotes := remotes copyWith: self baseRemote ].	^ remotes	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainBaseRemote	| base |	base := self gitBase.	^ IceRemote url: ((base at: #'git_url') copyReplaceAll: 'git://' with: 'https://')! !!IceGitHubCreatePullRequestModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/24/2017 12:50:04'!requestBaseBranches	^ IceGitHubAPI new 		credentials: self credentials;		getBranches: self baseRemote owner project: self baseRemote projectBasename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/24/2017 12:50:04'!requestGitRepositoryInfo	| remote |	remote := self headRemote.	^ IceGitHubAPI new 		credentials: self credentials;		getRepository: remote owner 			project: remote projectBasename! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titleLabel	^ titleLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titleLabel: anObject	titleLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titlePanel	^ titlePanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titlePanel: anObject	titlePanel := anObject! !!IceGitHubPullRequestActionsModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec>	^ SpecLayout composed		newRow: [ :row | 			row				add: #mergeButton;				add: #acceptButton;				add: #rejectButton ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	mergeButton := self newButton.	acceptButton := self newButton.	rejectButton := self newButton.			mergeButton 		label: 'Merge into image';		action: [ mergeBlock value ].	acceptButton 		label: 'Accept pull request';		action: [ acceptBlock value ].	rejectButton 		label: 'Reject pull request';		action: [ rejectBlock value ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeButton	^ mergeButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeButton: anObject	mergeButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onMerge: aBlock	mergeBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onReject: aBlock	rejectBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!rejectButton	^ rejectButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!rejectButton: anObject	rejectButton := anObject! !!IceGitHubPullRequestDetailModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #urlLabel width: 80; add: #urlText ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorText ] height: 25;				newRow: [:row | row add: #fromLabel width: 80; add: #fromText ] height: 25;				newRow: [:row | row add: #toLabel width: 80; add: #toText ] height: 25;				newRow: [:row | row add: #mergeableLabel width: 80; add: #mergeablePanel ] height: 25;				newRow: [:row | row add: #statusLabel width: 80; add: #statusPanel ] height: 25;				newRow: [:row | row add: #checksTable ];				newRow: [:row | row add: #bodyText ] ];		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aPullRequest	^ self basicNew 		initializePullRequest: aPullRequest;		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #for:'! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorLabel	^ authorLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorLabel: anObject	authorLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorText	^ authorText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorText: anObject	authorText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyText	^ bodyText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyText: anObject	bodyText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!checksTable	^ checksTable! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!checksTable: anObject	checksTable := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromLabel	^ fromLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromLabel: anObject	fromLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromText	^ fromText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromText: anObject	fromText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iconForMergeable: mergeable	mergeable = true ifTrue: [ ^ #smallOk asIcon ].	^ #smallCancel asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	self retrieveStatuses.	self retrieveDetail.! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePullRequest: aPullRequest	pullRequest := aPullRequest.	self initialize	! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	urlLabel := self newLabel label: 'Url'.	authorLabel := self newLabel label: 'Author'.	fromLabel := self newLabel label: 'From'.	toLabel := self newLabel label: 'Into'.	mergeableLabel := self newLabel label: 'Mergeable'.	statusLabel := self newLabel label: 'Status'.	urlText := self newTextInput 		enabled: false;		text: self pullRequest url.	authorText  := self newTextInput 		enabled: false;		text: self pullRequest author.	fromText  := self newTextInput 		enabled: false;		text: self pullRequest headLabel.	toText  := self newTextInput 		enabled: false;		text: self pullRequest baseLabel.	mergeablePanel := self newMergeablePanel.	statusPanel := self newStatusPanel.	checksTable := self newChecksTable.	bodyText := self newText 		enabled: false;		text: self pullRequest body.! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!mergeableLabel	^ mergeableLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!mergeableLabel: anObject	mergeableLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeablePanel	^ mergeablePanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeablePanel: anObject	mergeablePanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newChecksTable	^ FTTableMorph new 		addColumn: ((FTColumn id: #target_url) width: 18);		addColumn: ((FTColumn id: #state) width: 65);		addColumn: ((FTColumn id: #context) width: 100);		addColumn: (FTColumn id: #description);		cellInset: 5;		beResizable;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter		! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newMergeablePanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newStatusPanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequest	^ pullRequest! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!retrieveDetail		self mergeablePanel widget addMorphBack: 'Loading...' asMorph.	[ | detail mergeable |  		[  			detail := self pullRequest detail.			mergeable := detail at: #mergeable ]		on: Error do: [ :e | mergeable := nil ].		UIManager default defer: [ 			self mergeablePanel widget				removeAllMorphs;				addMorphBack: (self iconForMergeable: mergeable) asMorph;				addMorphBack: (self textForMergeable: mergeable) asMorph ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!retrieveStatuses	self statusPanel widget addMorphBack: 'Loading...' asMorph.	[ 	| status generalStatus statuses |		[		status := self pullRequest status.		generalStatus := status at: 'state'.		statuses := status at: 'statuses' ]	on: Error do: [ :e | 		generalStatus := 'Unknown'.		statuses := #() ].		UIManager default defer: [ 		self statusPanel widget			removeAllMorphs;			addMorphBack: (self iconForStatus: generalStatus) asMorph;			addMorphBack: generalStatus asMorph.	 	self checksTable widget dataSource: (IceGitHubPullRequestDataSource elements: statuses) ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusLabel	^ statusLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusLabel: anObject	statusLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusPanel	^ statusPanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusPanel: anObject	statusPanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!textForMergeable: mergeable	mergeable = true ifTrue: [ ^ 'Yes' ].	mergeable = false ifTrue: [ ^ 'There are conflicts' ].	^ mergeable asString	! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toLabel	^ toLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toLabel: anObject	toLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toText	^ toText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toText: anObject	toText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlLabel	^ urlLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlLabel: anObject	urlLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlText	^ urlText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlText: anObject	urlText := anObject! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultType	^ 'merge'! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Accept pull request'! !!IceGitHubRejectPullRequestModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ 500@250! !!IceGitHubRejectPullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	acceptButton label: 'Reject pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!message	^ self messageText text asString! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel	^ messageLabel! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText	^ messageText! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText: anObject	messageText := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Select'! !!IceGitHubSelectListModel class methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!defaultExtent 	^ 550@500! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec>	^ SpecLayout composed		newColumn:[ :col | 			col  				newRow: #listPanel;				newRow: #selectButton height: self buttonHeight ];		yourself! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Select...'! !!IceGitHubSelectListModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!confirmSelection	acceptBlock ifNotNil: [ 		acceptBlock value: selectedItems ].	self window delete! !!IceGitHubSelectListModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createCheckboxFor: anObject	^ CheckboxMorph 		on: (IceGitHubSelectItem list: selectedItems item: anObject) 		selected: #value 		changeSelected: #value:! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!displayBlock: aBlock 	self listPanel displayBlock: aBlock! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	selectedItems := Set new.	super initialize.	self title: self class title! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	listPanel := self instantiate: FastTableModel.	listPanel icons: [ :each | self createCheckboxFor: each ].	selectButton := self newButton.		selectButton 		label: self class buttonLabel;		action: [ self confirmSelection ].		self focusOrder 		add: listPanel;		add: selectButton! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!items: aCollection	self listPanel items: aCollection! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!listPanel	^ listPanel! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!listPanel: anObject	listPanel := anObject! !!IceGitHubSelectListModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!selectButton	^ selectButton! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!selectButton: anObject	selectButton := anObject! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!selectLabel: aString	self selectButton label: aString! !!IceGitHubAPI class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainCredentials	| newCredentials provider |		provider := IceCredentialsProvider default.	newCredentials := IcePlaintextCredentials new.	IceCredentialsProvider default providePlaintextCredentialsTo: newCredentials.	^ newCredentials! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!acceptPullRequest: owner project: projectName number: aNumber data: aDictionary	^ self 		put: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString, '/merge'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!addComment: owner project: projectName number: aNumber data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/issues/', aNumber asString, '/comments'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!addPullRequest: owner project: projectName data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/pulls'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!contentsWithValidationDo: aBlock	^ (self responseWithValidationDo: aBlock) contents! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ credentials ifNil: [ credentials := self class obtainCredentials ]! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials: anObject	credentials := anObject! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!delete: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			delete;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!deleteBranch: owner project: projectName name: branchName	^ self delete: 'repos/', owner, '/', projectName, '/git/refs/heads/', branchName! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!get: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getBranch: owner project: projectName name: branchName	^ self get: 'repos/', owner,'/', projectName, '/branches/', branchName! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getBranches: owner project: projectName	^ self get: 'repos/', owner,'/', projectName, '/branches'! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!getPaginated: aString 	^ IceGitHubAPIPaginatedResult api: self request: aString! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getPullRequests: owner project: projectName	^ self getPaginated: 'repos/', owner, '/', projectName, '/pulls'		! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!getRaw: aString 	^ self responseWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getRepository: owner project: projectName	^ self get: 'repos/', owner,'/', projectName! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!jsonContentsWithValidationDo: aBlock	^ STON fromString: (self contentsWithValidationDo: aBlock)! !!IceGitHubAPI methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newRequestTo: aString	^ ZnClient new 		in: [ :this | 			self credentials ifNotNil: [ 				this 					username: self credentials username 					password: self credentials password ] ]; 		headerAt: 'Accept' put: 'application/vnd.github.v3+json';		url: 'https://api.github.com/', aString;		yourself! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!patch: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			patch;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!post: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			post;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!put: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			put;			response ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!responseWithValidationDo: aBlock	| response |		response := aBlock value.	response isSuccess 		ifFalse: [ IceGitHubError signalFor: response ].	^ response! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!updatePullRequest: owner project: projectName number: aNumber data: aDictionary 	^ self 		patch: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPIPaginatedResult class methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!api: anAPI request: aString	^ self new 		api: anAPI;		request: aString;		yourself		! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!all	| stream |	stream := Array new writeStream.	[ self hasNext ] 	whileTrue: [ stream << self next ].	^ stream contents! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!api	^ api! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!api: anObject	api := anObject! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!hasNext	^ result isNil or: [ self parseMorePages: (result headers at: 'Link' ifAbsent: [ nil ]) ]! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!next 	nextPage ifNil: [ nextPage := 1 ].	[ result := self api getRaw: (self request asUrl ? (#page -> nextPage asString)) asString ]	ensure: [ nextPage := nextPage + 1].	^ STON fromString: result contents! !!IceGitHubAPIPaginatedResult methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseMorePages: aString 	"github does not send 'Links' header if there are no pages, and it does not sends 'next' link	 if we are at the last page"	aString ifNil: [ ^ false ].	^ (aString substrings: ',') anySatisfy: [ :each | each includesSubstring: 'rel="next"' ] ! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!request	^ request! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!request: anObject	request := anObject! !!IceGitHubCommand class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository 	^ self new repository: aRepository ! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials 	^ credentials ifNil: [ credentials := self obtainCredentials ]! !!IceGitHubCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute 	self subclassResponsibility! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!github	^ IceGitHubAPI new 		credentials: self credentials;		yourself! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainCredentials	^ IceGitHubAPI obtainCredentials! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!reportError: error	UIManager default 		alert: error messageBody		title: 'Error creating pull request: ', error messageText! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: aRepository	repository := aRepository! !!IceGitHubNewPullRequestCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute 	(self validateMakePullRequestOn: self repository) ifFalse: [ ^ #() ].		(IceGitHubCreatePullRequestModel 		repository: self repository 		credentials: self credentials		headRemote: self remote)		setModal: true; 		onAccept: [ :pullRequest | 			[ 				pullRequest send.				UIManager default inform: 'Pull request created.' ]			on: IceGitHubError do: [ :e | self reportError: e ] ];		openWithSpec ! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceGitHubNewPullRequestCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validateMakePullRequestOn: aRepository	| status |		status := OrderedCollection new: 2.	aRepository isModified 		ifTrue: [ status add: 'Uncommited changes' ].	(aRepository outgoingCommitsTo: (aRepository pushRemote)) 		ifNotEmpty: [ :commits | '{1} not published' format: { commits size } ].	status ifEmpty: [ ^ true ].		^ UIManager default 		confirm: (('{1} has ongoing modifications ({2}). Do you want to continue anyway?') format: { aRepository name. status asCommaString })! !!IceGitHubRemoveBranchesCommand class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository remote: aRemote	^ self new 		repository: aRepository;		remote: aRemote;		yourself! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!cacheAllBranches	self remoteBranches do: [ :each | | branchName |		branchName := each at: 'name'.		branchesByName 			at: branchName 			ifAbsentPut: [ self remoteBranch: branchName ] ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute 	UIManager default 		informUser: ('Retrieving branch information from {1}' format: { self remote url })		during: [ self cacheAllBranches ].	IceGitHubSelectListModel new 		setModal: true;		title: ('Select branches to remove on remote {1}' format: {self remote remoteName});		selectLabel: 'Remove branches';		items: self remoteBranches;		displayBlock: [ :each | 			'{1} ({2})' format: { 				each at: 'name'. 				self timeSinceLastCommit: each } ];		onAccept: [ :selection | self removeBranches: selection ];		openWithSpec! !!IceGitHubRemoveBranchesCommand methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize 	super initialize.	branchesByName := OrderedDictionary new! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: aRemote	remote := aRemote! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!remoteBranch: aName	^ self requestRemoteBranch: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!remoteBranches	^ branches ifNil: [ branches := self requestRemoteBranches ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranch: json	| branchName |		branchName := json at: 'name'.	IceGitHubAPI new 		credentials: self credentials;		deleteBranch: self remote owner 			project: self remote projectBasename			name: branchName.	UIManager default inform: ('Branch {1} removed.' format: { branchName })			! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranches: aCollection	[ 		aCollection do: [ :each | self removeBranch: each ] ]	on: IceGitHubError do: [ :e | self reportError: e ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!requestRemoteBranch: aName	^ IceGitHubAPI new		getBranch: self remote owner 		project: self remote projectBasename		name: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!requestRemoteBranches	^ IceGitHubAPI new		getBranches: self remote owner 		project: self remote projectBasename! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!timeSinceLastCommit: json	| branchName branchJson lastCommitDate |	branchName := json at: 'name'.	branchJson := branchesByName at: branchName.	lastCommitDate := ((((branchJson at: 'commit') at: 'commit') at: 'author') at: 'date') asDateAndTime.	^ '{1} days' format: { (Date today - lastCommitDate) days }! !!IceGitHubViewPullRequestCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute	UIManager default 		informUser: ('Retrieving pull requests from {1}' format: { self remote })  		during: [ 			IceGitHubPullRequestListBrowser new				repository: self repository;				remote: self remote;				refreshPullRequests;				open ]! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceGitHubPullRequest class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!fromJSON: aDictionary	^ self basicNew		initializeWithJSON: aDictionary;		yourself! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!acceptMessage: messageString type: typeString	IceGitHubAPI new 		acceptPullRequest: self owner 			project: self projectName			number: self number			data: { 				#commit_title -> (messageString lines 					ifNotEmpty: [ :each | each first trimBoth ] 					ifEmpty: [ '' ]). 				#commit_message -> (messageString lines 					ifNotEmpty: [ :lines | (lines allButFirst joinUsing: String lf) trimBoth ] 					ifEmpty: [ '' ]). 				#sha-> self headSHA.				#merge_method -> typeString } asDictionary! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addComment: messageString	IceGitHubAPI new 		addComment: self owner 			project: self projectName			number: self number			data: { #body -> messageString } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!author	^ (self jsonAt: 'user') at: 'login'! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseLabel	^ (self jsonAt: #base) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseSHA	^ (self jsonAt: #base) at: #sha! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!body	^ self jsonAt: #body! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	fetched ifFalse: [ self fetch ].	^ branch ifNil: [		branch := IceRemoteBranch			remoteName: self remote remoteName 			branchName: ((self jsonAt: #head) at: #ref)			inRepository: self repository.		branch ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self branch basename! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detail	^ detail ifNil: [		detail := IceGitHubAPI new get: ((self jsonAt: #url) allButFirst: 23) ]! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	[ ^ self repository fetchFrom: self remote ]	ensure: [ fetched := true ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headLabel	^ (self jsonAt: #head) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headSHA	^ (self jsonAt: #head) at: #sha! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	fetched := false! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWithJSON: aDictionary	json := aDictionary.	self initialize! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!json	^ json! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!jsonAt: aKey	^ self json at: aKey! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergeIntoImage	self repository 		ensureBranch: self branchName;		checkoutBranch: self branchName;		merge: self branch lastCommit! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!number	^ self jsonAt: #number! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner 	^ (((self jsonAt: #base) at: #repo) at: #owner) at: #login! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ ((self jsonAt: #base) at: #repo) at: #name! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!rejectMessage: messageString	messageString trimBoth 		ifNotEmpty: [ self addComment: messageString ].	IceGitHubAPI new 		updatePullRequest: self owner 			project: self projectName			number: self number			data: { #state -> #closed } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	| remote |	remote := IceRemote 		name: self author		url: (((self jsonAt: #head) at: #repo) at: #ssh_url).	^ self repository remotes 		detect: [ :each | each = remote ]		ifFound: [ :each | each ]		ifNone: [ 			self repository addRemote: remote.			remote ].		! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!state	^ self jsonAt: #state! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	^ status ifNil: [ 		status := IceGitHubAPI new 			get: 'repos/', self owner, '/', self projectName, '/commits/', self headSHA, '/status' ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ self jsonAt: #title! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url	^ self jsonAt: #url! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseBranchName	^ baseBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseBranchName: anObject	baseBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseRemote	^ baseRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseRemote: anObject	baseRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!body	^ body! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!body: anObject	body := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ credentials! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials: anObject	credentials := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headBranchName	^ headBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headBranchName: anObject	headBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headRemote	^ headRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headRemote: anObject	headRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!send	| pullRequestData |	pullRequestData := { 		'title' -> self title.		'head' -> (self headRemote owner, ':', self headBranchName).		'base' -> self baseBranchName.		'body' -> self body.	} asDictionary.		IceGitHubAPI new 		credentials: self credentials;		addPullRequest: self baseRemote owner 			project: self baseRemote projectBasename 			data: pullRequestData! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ title! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title: anObject	title := anObject! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!list: selectedItems item: anObject	^ self basicNew 		initializeList: selectedItems item: anObject;		yourself! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #list:item:'! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!addItem	(list includes: item) ifTrue: [ ^ self ].	list add: item ! !!IceGitHubSelectItem methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeList: aCollection item: anObject	list := aCollection.	item := anObject.	self initialize! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!removeItem	(list includes: item) ifFalse: [ ^ self ].	list remove: item ! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!value 	^ list includes: item! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!value: aBoolean	aBoolean 		ifTrue: [ self addItem ]		ifFalse: [ self removeItem ]	! !!IceGitHubPullRequestPlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	"validate if this is a github repository"	^ aRepository origin host = 'github.com'! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newPullRequest: aRepository 	^ self newPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newPullRequest: aRepository remote: aRemote	(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newPullRequestAction	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newPullRequestRemoteAction	^ GLMGenericAction new		action: [ :presentation :model |			self newPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteActionsFor: aRemote	^ { 	self newPullRequestRemoteAction.	self viewPullRequestsRemoteAction.	self removeOldBranchesRemoteAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranches: aRepository	self removeBranches: aRepository remote: aRepository pushRemote! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranches: aRepository remote: aRemote	(IceGitHubRemoveBranchesCommand 		repository: aRepository 		remote: aRemote)		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!removeOldBranchesAction	^ GLMGenericAction new		action: [ :presentation | self removeBranches: presentation selection repository ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!removeOldBranchesRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self removeBranches: model remote: presentation selection ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryActions	^ { 	self newPullRequestAction. 	self viewPullRequestsAction.	self removeOldBranchesAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequest: aRepository 	^ self viewPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequest: aRepository remote: aRemote	(IceGitHubViewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequestsAction	^ GLMGenericAction new		action: [ :presenter | self viewPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequestsRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self viewPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !"Iceberg-Plugin-GitHub"!!IceLibgitVersionReader commentStamp: 'NicoPasserini 7/7/2016 11:58' prior: 0!Reads an MCVersion from a git repository (its blob, not a working copy!!) using libgit bindings.Currently we only support metadata-less repositories.!!IceLibgitCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:26' prior: 0!Utility class for searching through a commit history taking advantage of git revwalk utilities. Found and returned commits will be added to the commit cache of the corresponding IceRepository.!!IceLibgitFileUtils commentStamp: 'NicoPasserini 7/7/2016 12:15' prior: 0!Emulates other 'file utils' classes by reading from a git repository (its blob, not a working copy'). Allows for reading any tree (from any commit) in the repository.!!IceLibgitLocalRepository commentStamp: 'NicoPasserini 6/28/2016 10:56' prior: 0!Adapter which allows an IceRepository to use libgit as underlying storage.!!Trait method!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!Trait method!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!Trait method!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!Trait method!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!Trait method!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!Trait method!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!Trait method!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!Trait method!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!Trait method!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!Trait method!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!IceLibgitTreeBuilder commentStamp: 'NicoPasserini 7/12/2016 11:29' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	builder:		<Object>	changes:		<Object>	children:		<Object>	entryName:		<Object>	originalTree:		<LGitTree> Contains the original contents on which this builder bases. Warning: this will not reflect the actual contents of the builder. Use #buildTree instead.	parent:		<Object>    Implementation Points!!IceSemanticVersion commentStamp: '<historical>' prior: 0!I represent the semver (http://semver.org) of libgit2. Since I exist just to be able to compare versions, I'm limited (reason why I'm not promoted to a more general package).!!IceLibgitStCypressWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitStCypressWriter methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:04'!propertyFileExtension  ^ MCFileTreeRepository defaultPropertyFileExtension! !!IceLibgitStCypressWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    self fileUtils        writeStreamFor: fileName , ext        in: directory        do: [ :fs |             self setFileStream: fs.            visitBlock value ]! !!IceLibgitVersionReader class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!compatibleAuthorNameOf: aString	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ aString reject: [ :each | each = Character space ]! !!IceLibgitVersionReader class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!on: aCommitOrTree iceVersion: iceVersion	^ (self on: aCommitOrTree) 		iceVersion: iceVersion; 		yourself! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ stream! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitVersionReader methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasMonticelloMetadata	^ false! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iceVersion	^ iceVersion! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iceVersion: anObject	iceVersion := anObject.	self packageDirectory: iceVersion package directoryPathString	! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadVersionInfo	^ info := self iceVersion info! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNameFromPackageDirectory	^ iceVersion packageName! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!versionName	^ ('{1}-{2}.{3}' format: {		self packageNameFromPackageDirectory. 		self commit compatibleUsername. 		self versionNumber	})! !!IceLibgitWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!addString: string at: fileNameOrPath encodedTo: ignored    "fileNameOrPath may have one or two elements"    "encodeTo: arg, because FileTree uses UTF8 by default"	| split path fileName |	split := fileNameOrPath lastIndexOf: $/.	path := fileNameOrPath first: split.	fileName := fileNameOrPath copyFrom: split + 1.		(self packageFileDirectory entryByPath: path)		addEntryNamed: fileName withContents: string.! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!snapshotWriterClass	^ IceLibgitStCypressWriter! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!subPackageFileDirectoryFor: directoryNameOrPath	^ self packageFileDirectory entryByPath: directoryNameOrPath ! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!writeVersion: aVersion	directory := aVersion package name, '.package'.	self packageFileDirectory deleteAll.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!commitsDo: aBlock 	self maxNumber 		ifNil: [ super commitsDo: aBlock ]		ifNotNil: [ | count |			count := 0.			super commitsDo: [ :commit |				aBlock value: commit.				count := count + 1.				count == self maxNumber ifTrue: [ ^ self ]			]		]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!firstCommit	^ self commitsDo: [ :commit | ^ commit ] ! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromBranch: branch	[ self revwalk pushReference: (lgitRepository lookupBranch: branch name) ]		on: LGit_GIT_EINVALIDSPEC do: [			"branch real branch, so try to find a corresponding treeish using revparse, 			this will handle stuff like 'master~1'"			self fromLGitId: (lgitRepository revparse: branch name) id		]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromCommit: commit	self fromCommitId: commit id! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromCommitId: commitId	self fromLGitId: (LGitId fromHexString: commitId)! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromHead	self revwalk pushHead! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromLGitId: lGitId	self revwalk pushCommit: lGitId! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromTag: tag	self revwalk.	^ self fromLGitId: (lgitRepository revparse: tag name) id! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!rawResultsDo: aBlockClosure 	self revwalk 		select: [ :result | self shouldInclude: result ]		thenDo: aBlockClosure! !!IceLibgitCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!revwalk	^ revwalk ifNil: [		repository withRepoDo: [ :repo |			"Keep a reference to the repo so that it does not get garbage collected 			(that would free C memory and make leave the revwalk object dumb)"			lgitRepository := repo. 			^ revwalk := LGitRevwalk of: repo.		] 	]! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!shouldInclude: aLGitCommit 	^ self modifyingPackage 		ifNil: [ true ]		ifNotNil: [ :package | 			aLGitCommit changesFileNamed: package directoryPathString ]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoCommit: commit	self revwalk hideCommit: (LGitId fromHexString: commit id)! !!IceLibgitFileUtils class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!current    ^ Current ifNil: [ Current := self new ]! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!deleteAll: aTreeBuilder     ^ aTreeBuilder deleteAll! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!directoryExists: aLGitTreeEntry 	^ aLGitTreeEntry type = LGitObjectTypeEnum git_obj_tree! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!directoryFromEntry: treeEntry 	^ treeEntry object! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!directoryFromPath: aString relativeTo: aCommitOrTree	^ aCommitOrTree 		entryByPath: aString 		ifAbsent: [ 			IceMissingRepositoryEntry new name: aString; owner: aCommitOrTree; signal ] ! !!IceLibgitFileUtils methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!pathNameDelimiter	^ $/! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!readStreamFor: fileName in: tree do: aBlock	(tree entryByPath: fileName) readStreamDo: aBlock! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!writeStreamFor: fileName in: directory do: aBlock 	directory addEntryNamed: fileName withContents: (String streamContents: aBlock).! !!IceLibgitLocalRepository class methodsFor: 'descriptions' stamp: ' 7/24/2017 12:50:04'!description	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!newRepositoryAt: aFileReference origin: anIceRemoteRepository subdirectory: aString	^ self new		location: aFileReference;		origin: anIceRemoteRepository;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!newRepositoryAt: aFileReference subdirectory: aString	^ self new		location: aFileReference;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseCommitInfo: aLGitCommit	^ IceCommitInfo new		commitId: aLGitCommit id hexString;		username: aLGitCommit committer name;		datetime: aLGitCommit time asDateAndTime;		parentIds: (aLGitCommit parents collect: [ :parent | parent id hexString ]);		comment: aLGitCommit message! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/24/2017 12:50:04'!requiredLibGit2MinimumVersion	^ IceSemanticVersion 		major: 0 		minor: 25 		patch: 1! !!IceLibgitLocalRepository class methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!shortName	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/24/2017 12:50:04'!verifyBackendAvailabilityIfNot: aBlock	| presentVersion requiredVersion |		presentVersion := IceSemanticVersion fromArray: LGitLibrary uniqueInstance version.	requiredVersion := self requiredLibGit2MinimumVersion.		requiredVersion <= presentVersion 		ifFalse: [ ^ aBlock cull: requiredVersion cull: presentVersion ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addFilesToIndex: aListOfPaths	self withRepoDo: [ :repo | 		| index |		index := repo index.		index addAll: aListOfPaths.		index writeToDisk.	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addRemote: aRemote	self withRepoDo: [ :repo |		repo addRemote: aRemote remoteName url: aRemote url ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!addTo: aMCRepositoryGroup 	"For now do not add me as an MCRepository"! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!allBranches	self withRepoDo: [ :repo | 			^ OrderedCollection new: 10 streamContents: [ :stream |			repo allBranchesDo: [ :br :isLocal | 				stream nextPut: (					IceBranch 						named: br name 						local: isLocal						inRepository: self frontend) ]]]	! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	"The branch variable and this accessor are useful when you do not have a real git repository yet. Once created it might be safer to use #currentBranch instead."	^ self lookupHead! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!canReadFileNamed: aString 	^ aString endsWith: '.package'! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!changedFilesBetween: aCommitish and: otherCommitish	"Answer a list of files that changed between two commits"	| fromTree toTree |		self withRepoDo: [ :repo | | diff |		fromTree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		toTree := (LGitCommit of: repo fromId: (LGitId fromHexString: otherCommitish id)) tree.				diff := LGitDiff of: repo.		diff diffTree: fromTree toTree: toTree. 		^ diff files ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!checkoutBranch: newBranchName 	self withRepoDo: [ :repo |		repo checkout: newBranchName ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepository	self cloneRepositoryFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryFrom: aRemote	^ self cloneRepositoryFrom: aRemote branch: nil! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryFrom: aRemote branch: aBranchName	| url |		url := aRemote url.	LGitGlobal runSequence: [ 		| repo cloneOptions |		repo := LGitRepository on: self location.		cloneOptions := LGitCloneOptions withCredentialsProvider: IceCredentialsProvider default.				repo clone: url options: cloneOptions.		aBranchName ifNotNil: [ 			repo checkout: aBranchName ].		(LGitRemote of: repo named: 'origin')			lookup;			setUrl: url ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitIdFrom: aLGitCommit 	^ aLGitCommit id hexString! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!commitIndexWithMessage: message andParents: parentCommitishList	self withRepoDo: [ :repo | 		| signature commitId indexTreeId |		[ signature := repo defaultSignature ]		on: LGit_GIT_ENOTFOUND do: [ :e | 			IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].		indexTreeId := repo index writeTreeAndReturnOid.		 		commitId := (LGitCommitBuilder of: repo)			tree: (LGitTree of: repo fromId: indexTreeId);			message: message;			parents: (repo isUnborn				ifTrue: [ #() ]				ifFalse: [ self libGitCommitsFrom: repo for: parentCommitishList ]);			"'HEAD' branch could not exist yet. No problem, libgit will create it, 			but we have to remember it to notify the frontend."			updateReference: ([ repo head name ] 				on: LGit_GIT_EUNBORNBRANCH				do: [ 'refs/heads/', self branch nameForFirstCommit ]);			author: signature;			committer: signature;			writeCommit;			commitId.					 ^ self class parseCommitInfo: (LGitCommit of: repo fromId: commitId) ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitsInBranch: branchName do: aBlock	"Iterates commit in a branch, in reverse chronological order (latest first)"	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushReference: (repo lookupBranch: branchName);			beSortedReverse;			do: aBlock ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitsInCurrentBranchDo: aBlock	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushHead;			do: aBlock.	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!contentOfFileNamed: aPathString commit: aCommitId	self withRepoDo: [ :repo |		| commit |		commit := LGitCommit of: repo fromHexString: aCommitId.		^ (commit entryByPath: aPathString) object contents	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createBranch: branchName	self withRepoDo: [ :repo |		| newBranch |		newBranch := repo createBranch: branchName target: repo head.		repo setHead: newBranch ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!currentBranch	"#currentBranch will look for the branch in the actual repository,	#branch is the branch that was set to me manually. Normally they should return the same value,	but if the repository does not yet exist, #currentBranch will fail."	self withRepoDo: [ :repo |		^ repo head basename	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	self fetchFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetchFrom: aRemote	self withRepoDo: [ :repo | 		(LGitRemote of: repo named: aRemote remoteName) 			lookup; 			fetchWithCredentials: IceCredentialsProvider default ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!frontend	^ frontend! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!frontend: anObject	frontend := anObject! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!guessUsernameOrEmailNotFound: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' ])		ifTrue: [ IceGitUsernameOrEmailNotFound signal ].	notBlock value! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!init	"Initialize new repository (git init)"	LGitGlobal runSequence: [ 		(LGitRepository on: self location) init ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!internalStoreVersion: aMCVersion 	IceMetadatalessFileTreeWriter 		fileOut: aMCVersion 		on: (IceBackendWriterAdapter for: self).! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isCodeMissing	^ self subdirectory isEmptyOrNil 		ifTrue: [ self isMissing ]		ifFalse: [ (self repositoryDirectory / self subdirectory) exists not  ]! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isUnborn	self withRepoDo: [ :repo | ^ repo isUnborn ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!libGitCommitsFrom: aLGitRepository for: aListOfCommitish	^ aListOfCommitish collect: 		[ :commitish | 		LGitCommit of: aLGitRepository fromId: (LGitId fromHexString: commitish id) ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!localBranchNames	self withRepoDo: [ :repo | ^ repo branches collect: #basename ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ location! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: anObject	location := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!lookupBranchNamed: branchName inRemote: remoteName	self withRepoDo: [ :repo |		[ repo lookupRemoteBranch: remoteName, '/', branchName ]			on: LGit_GIT_ENOTFOUND do: [ ^ nil ].				^ IceRemoteBranch 			remoteName: remoteName			branchName: branchName			inRepository: self frontend	]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!lookupHead	self withRepoDo: [ :repo | 		| head |		repo isUnborn ifTrue: [ ^ IceUnbornBranch new ].		head := repo head.		^ head isBranch 			ifTrue: [ IceLocalBranch named: head basename inRepository: self frontend ] 			ifFalse: [ head object asIcebergObjectInRepository: self ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!mcVersionFor: iceVersion	self withRepoDo: [ :repo | 		| commit |		commit := LGitCommit of: repo fromId: (LGitId fromHexString: iceVersion commit id).		[ ^ (IceLibgitVersionReader 				on: commit				iceVersion: iceVersion) 				version ] 			on: IceMissingRepositoryEntry 			do: [ IceVersionDoesNotExist new version: iceVersion; signal ]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: commitId	self withRepoDo: [ :repo | 		| myCommit theirCommit mergeBase |		"Decide if we can fast-forward or we must do a real merge"				myCommit := repo head object.		theirCommit := LGitCommit of: repo fromHexString: commitId.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: theirCommit.				repo head resolve setTargetId: theirCommit id.			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.				mergedIndex hasConflicts 					ifTrue: [ 						"Abort merge and signal for manual merge. 						Index is not saved and repository will be discarded, 						so no further action is needed to abort the merge" 						IceMergeAborted signal 					]					ifFalse: [						"Commit mergedIndex"						signature := repo defaultSignature.						treeId := mergedIndex writeTreeAndReturnOid.						repo checkout_treeish: (LGitTree of: repo fromId: treeId).									(LGitCommitBuilder of: repo)							tree: (LGitTree of: repo fromId: treeId);							message: 'Merge with ', commitId;							parents: { myCommit. theirCommit };							updateReference: repo head name;							author: signature;							committer: signature;							writeCommit.							]			]	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseBetween: aCommitId and: anotherCommitId 	self withRepoDo: [ :repo |		^ (repo 				mergeBaseBetween: (LGitId fromHexString: aCommitId) 				and: (LGitId fromHexString: anotherCommitId)) 				hexString ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!newCommitWalk	^ IceLibgitCommitWalk forRepository: self! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!origin	| remotes |	remotes := self remotes.	remotes ifEmpty: [ ^ nil  ].	^ remotes		detect: [ :each | each isOrigin ]		ifNone: [ remotes first ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	self withRepoDo: [ :repo |		| currentBranch commits walk |				commits := OrderedCollection new.		currentBranch := repo lookupBranch: self branch name.			walk := (LGitRevwalk of: repo)			pushReference: currentBranch;			hideReference: currentBranch upstream			yourself.					[ walk hasNext ] whileTrue: [ 			commits add: walk next		].		^ commits	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!packagesPresentOn: aCommitish	"Answer a list of package names present on this commit"	self withRepoDo: [ :repo | | tree dir sourceEntries |		tree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		self flag: #todo. "this needs to change with multiple dirs"		dir := self subdirectory.		sourceEntries := dir isEmptyOrNil			ifTrue: [ tree entries ]			ifFalse: [ (tree entryByPath: dir) entries ]. 		^ ((sourceEntries 			collect: [ :each | each filename ])			select: [ :each | each endsWith: '.package' ])			collect: [ :each | each copyFrom: 1 to: (each findString: '.package') - 1 ] ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pull	self pullFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pullFrom: aRemote	self withRepoDo: [ :repo | 		| gitRemote myCommit theirCommit mergeBase |		"Fetch"		gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		gitRemote fetchWithCredentials: IceCredentialsProvider default.				"Decide if we can fast-forward or we must do a real merge"		myCommit := repo head object.		theirCommit := repo head upstream object.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: repo head upstream object.				repo fastForward			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.								"Commit index"				signature := repo defaultSignature.				treeId := mergedIndex writeTreeAndReturnOid.					(LGitCommitBuilder of: repo)					tree: (LGitTree of: repo fromId: treeId);					message: 'Merge with ', repo head upstream name;					parents: { myCommit. theirCommit };					updateReference: repo head name;					author: signature;					committer: signature;					writeCommit.					]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!push	self pushTo: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushTo: aRemote	self withRepoDo: [ :repo |		| gitRemote reference remoteBranchName |				gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		reference := repo head.			remoteBranchName := reference name. "TODO: https://github.com/npasserini/iceberg/issues/90"				gitRemote			pushWithRefSpec: (LGitRefSpec new				source: reference name;				destination: remoteBranchName;				yourself)			pushOptions: (LGitPushOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: IceCredentialsProvider default);				yourself).		"Since the push created the branch in the remote, we can now add an upstream to this branch."		reference upstream ifNil: [ 			reference setUpstream: aRemote remoteName, '/', reference basename ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!readableFileNames	self shouldBeImplemented.! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!remoteUrl	self withRepoDo: [ :repo | ^ repo origin url ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remotes	| gitRemotes |	self withRepoDo: [ :repo | gitRemotes := repo allRemotes ].	^ gitRemotes collect: [ :each | 		(IceRemote url: each url)			remoteName: each remoteName;			yourself ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeRemote: aRemote	self withRepoDo: [ :repo |		(LGitRemote of: repo named: aRemote remoteName) 			lookup;			delete ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryDirectory	^ self location! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!revparse: aString 	self withRepoDo: [ :repo | 		^ (repo revparse: aString) asIcebergObjectInRepository: self	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!revparseCommit: aString 	self withRepoDo: [ :repo | 		^ self iceCommitFrom: (repo revparse: aString) object 	]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!setLongpaths: aBoolean global: globalBoolean 	"set user.name and user.email properties. 	 this could be a nonsense with other backends, but git has them and needs them :)"	self withRepoDo: [ :repo | | config |		config := repo config.		globalBoolean ifTrue: [ config := config openGlobal ].		config setBoolean: 'core.longpaths' to: aBoolean ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!stagedFiles	| statusMask modifiedPaths |	statusMask :=  (LGitStatusTypeEnum git_status_index_new value)				| (LGitStatusTypeEnum git_status_index_modified value)				| (LGitStatusTypeEnum git_status_index_deleted value)				| (LGitStatusTypeEnum git_status_index_typechange value)				| (LGitStatusTypeEnum git_status_index_renamed value).		self withRepoDo: 		[ :repo | 		modifiedPaths := repo index 			entriesSelect: [ :path :status | (status & statusMask) > 0 ] ].	^ modifiedPaths 		collect: [ :entry | entry first asFileReference ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!storeVersion: aMCVersion 	self withRepoDo: [ :repo | 		| treeBuilder signature parentCommit head |		head := repo head.		parentCommit := head object.		treeBuilder := IceLibgitTreeBuilder on: parentCommit tree.		IceLibgitWriter fileOut: aMCVersion on: (treeBuilder entryByPath: self subdirectory).				signature := repo defaultSignature.		(LGitCommitBuilder of: repo)			tree: treeBuilder buildTree;			message: aMCVersion info message;			parents: { parentCommit };			updateReference: head;			author: signature;			committer: signature;			writeCommit.			]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ subdirectory! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory: anObject	subdirectory := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!upstream	self withRepoDo: [ :repo | ^ repo head upstream ifNotNil: #name ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: aName email: anEmail global: globalBoolean	"set user.name and user.email properties. 	 this could be a nonsense with other backends, but git has them and needs them :)"	self withRepoDo: [ :repo | | config |		config := repo config.		globalBoolean ifTrue: [ config := config openGlobal ].		config 			setString: 'user.name' to: aName;			setString: 'user.email' to: anEmail ]! !!IceLibgitLocalRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!validate	"TODO"! !!IceLibgitLocalRepository methodsFor: 'private auxiliar' stamp: ' 7/24/2017 12:50:04'!withRepoDo: aBlock	LGitGlobal runSequence: [ 		| repo |		repo := (LGitRepository on: self location) open.		aBlock value: repo ]! !!IceLibgitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!on: aLGitTree	"Creates a tree builder on the root of the repository"	^ self new initializeWithTree: aLGitTree! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/24/2017 12:50:04'!addEntryNamed: name withContents: aString	self builder 		addEntry: (LGitBlob of: self repository fromString: aString)		filename: name.			self changes add: name.	hasChanges := true! !!IceLibgitTreeBuilder methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildTree	self children keysAndValuesDo: [ :childEntryName :childBuilder |		childBuilder hasChanges ifTrue: [ 			self builder 				addEntry: childBuilder buildTree				filename: childEntryName		]	].	^ self builder newTree! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!builder	^ builder ifNil: [ 		builder := LGitTreeBuilder 			of: self repository			fromTree: self initialTree ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changes	^ changes ifNil: [ changes := OrderedCollection new ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	^ children ifNil: [ children := Dictionary new ]! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/24/2017 12:50:04'!deleteAll	self builder clear.! !!IceLibgitTreeBuilder methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!directory	^ self ! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!entryByName: aString	^ self children 		at: aString 		ifAbsentPut: [  			self class new 				initializeWithParent: self 				entryName: aString ]! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!entryByPath: aString	^ (aString = '.' )		ifTrue: [ self ]		ifFalse: [( ($/ split: aString) reject: #isEmpty)			inject: self 			into: [ :treeBuilder :name | treeBuilder entryByName: name ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entryName	^ entryName! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!hasChanges	^ hasChanges		or: [ initialTree isNil "It means that this is a new tree"		or: [ self children anySatisfy: #hasChanges ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!initialTree	^ initialTree! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	hasChanges := false.	! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/24/2017 12:50:04'!initializeWithParent: anIceTreeBuilder entryName: aString	| treeEntry |	parent := anIceTreeBuilder.	entryName := aString.	treeEntry := parent builder getEntryNamed: entryName.	treeEntry isReady "i.e. the entry alredy exists in parent tree"		ifTrue: [ initialTree := treeEntry tree ]		ifFalse: [ 			"The entry didn't exist so this is a new entry"			hasChanges := true ]! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/24/2017 12:50:04'!initializeWithTree: aLGitTree	"This is a builder on the root of a repository"	initialTree := aLGitTree ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parent	^ parent! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(.	self printPathOn: aStream.	aStream nextPut: $)! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printPathOn: aStream	parent 		ifNil: [ 			aStream nextPutAll: initialTree repository workingDirectoryName ]		ifNotNil: [ 				parent printPathOn: aStream.			aStream nextPut: $/;				nextPutAll: entryName ] ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ parent 		ifNotNil: [ self parent repository ]		ifNil: [ self initialTree owner ]! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!fromArray: anArray	^ self 		major: anArray first 		minor: anArray second 		patch: anArray third! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!major: majorNumber minor: minorNumber patch: patchNumber	^ self basicNew 		initializeMajor: majorNumber 			minor: minorNumber 			patch: patchNumber;		yourself! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use one of my siblings'! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!< aMagnitude 	"Answer whether the receiver is less than the argument."	| version |	version := aMagnitude iceSemanticVersion.	^ self major < version major		or: [ self minor < version minor 		or: [ self patch < version patch ] ]! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!= aMagnitude 	"Compare the receiver with the argument and answer with true if the 	receiver is equal to the argument. Otherwise answer false."	| version |		version := aMagnitude iceSemanticVersion.	^ self major = version major 		and: [ self minor = version minor		and: [ self patch = version patch ] ] ! !!IceSemanticVersion methodsFor: 'hash' stamp: ' 7/24/2017 12:50:04'!hash	^ ((self species hash		bitXor: self major)		bitXor: self minor)		bitXor: self patch! !!IceSemanticVersion methodsFor: 'converting' stamp: ' 7/24/2017 12:50:04'!iceSemanticVersion	^ self! !!IceSemanticVersion methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeMajor: majorNumber minor: minorNumber patch: patchNumber	major := majorNumber.	minor := minorNumber. 	patch := patchNumber! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!major	^ major! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!minor	^ minor! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!patch	^ patch! !!IceSemanticVersion methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: stream 	stream 		<< self major asString 		<< '.' << self minor asString 		<< '.' << self patch asString! !!Magnitude methodsFor: '*Iceberg-Libgit' stamp: ' 7/24/2017 12:50:04'!iceSemanticVersion	^ IceSemanticVersion major: self asInteger minor: 0 patch: 0! !"Iceberg-Libgit"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.586.mcz') load.ScriptLoader new update60510.!----End fileIn----!----QUIT----2017-07-24T12:50:16.527607+02:00 Pharo.image priorSource: 1264256!----QUIT----2017-07-24T12:50:28.334187+02:00 Pharo.image priorSource: 2151637!----QUIT/NOSAVE----2017-08-24T17:03:35.58263-03:00 Pharo6.1.image priorSource: 2151717!----QUIT/NOSAVE----2017-08-24T17:06:55.855617-03:00 Pharo6.1.image priorSource: 2151717!----QUIT/NOSAVE----2017-08-24T17:19:42.377955-03:00 Pharo6.1.image priorSource: 2151717!----QUIT/NOSAVE----2017-08-29T13:05:33.034511-03:00 Pharo6.1.image priorSource: 2151717!!ConfigurationOfBotArena class methodsFor: 'development support' stamp: 'ArturoZambrano 8/24/2014 21:43'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfBotArena class methodsFor: 'private' stamp: 'ArturoZambrano 8/24/2014 21:43'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfBotArena class methodsFor: 'private' stamp: 'ArturoZambrano 8/24/2014 21:43'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfBotArena class methodsFor: 'private' stamp: 'ArturoZambrano 8/24/2014 21:43'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfBotArena class methodsFor: 'metacello tool support' stamp: 'ArturoZambrano 8/24/2014 21:43'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfBotArena class methodsFor: 'loading' stamp: 'ArturoZambrano 8/24/2014 21:43'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfBotArena class methodsFor: 'loading' stamp: 'ArturoZambrano 8/24/2014 21:43'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfBotArena class methodsFor: 'loading' stamp: 'ArturoZambrano 8/24/2014 21:43'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfBotArena class methodsFor: 'accessing' stamp: 'ArturoZambrano 8/24/2014 21:43'!project	^self new project! !!ConfigurationOfBotArena class methodsFor: 'development support' stamp: 'ArturoZambrano 8/24/2014 21:43'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfBotArena methodsFor: 'accessing' stamp: 'ArturoZambrano 8/24/2014 22:36'!baseline01: spec	<version: '0.1-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/FedericoBalaguer/BotArena/main'.			spec package: 'BotArena' with: [ spec requires: #('BOSS') ].			spec package: 'BOSS' with: [ spec repository: 'http://smalltalkhub.com/mc/CAR/BOSS/main' ] ]! !!ConfigurationOfBotArena methodsFor: 'accessing' stamp: 'ArturoZambrano 8/24/2014 21:43'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!ConfigurationOfBotArena methodsFor: 'accessing' stamp: 'ArturoZambrano 8/24/2014 22:19'!development: spec <symbolicVersion:#'development'>  spec for: #'common' version: '0.1-baseline'! !!ConfigurationOfBotArena methodsFor: 'accessing' stamp: 'ArturoZambrano 8/24/2014 21:43'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfBotArena methodsFor: 'accessing' stamp: 'federicobalaguer 8/18/2016 12:45'!version01: spec	<version: '0.1' imports: #('0.1-baseline')>	spec		for: #'pharo4.x'		do: [ 			spec				package: 'BotArena' with: 'BotArena-federicobalaguer.38';				package: 'BOSS' with: 'BOSS-federicobalaguer.19' ].	spec		for: #'pharo5.x'		do: [ 			spec				package: 'BotArena' with: 'BotArena-federicobalaguer.38';				package: 'BOSS' with: 'BOSS-federicobalaguer.19' ].! !"ConfigurationOfBotArena"!!BGSGridEditorWindow commentStamp: '<historical>' prior: 0!"create new grid "e := BGSGridEditorWindow editNewGridOfSize: 50@50  withCellExtent: 15@15.e openAsIs.e printGridAsEvalString."edit a grid"grid := BGSGrid new addWallAt: (12@12) ; addWallAt: (12@13) ; addWallAt: (12@14) ; addWallAt: (12@15) ; addWallAt: (12@16) ; yourself.e := BGSGridEditorWindow editGrid: grid.e openAsIs.e printGridAsEvalString. !!BGSSimulationWindow commentStamp: '<historical>' prior: 0!I am a window that displays a simulation.To create an instance and have it immediatly displayed, you can either use one of the following messages:-BGSSimulationWindow onClass:  simulationClass-BGSSimulationWindow on: simulation-BGSSimulationWindow onClass:  simulationClass terrainCellExtent: 5@5-BGSSimulationWindow on: simulation terrainCellExtent: 5@5!!BGSExplorationSimulationWindow commentStamp: 'NouryBouraqadi 12/8/2011 11:20' prior: 0!I am a window that displays an exploration simulation.To create an instance and have it immediatly displayed, you can either use one of the following messages:-BGSExplorationSimulationWindow onClass:  explorationSimulationClass-BGSExplorationSimulationWindow on: explorationSimulation!!BGSChristmasSimulationWindow commentStamp: 'NouryBouraqadi 12/18/2011 20:22' prior: 0!see comment of BGSChristmasSimulation!!BGSBodyPart commentStamp: 'NouryBouraqadi 12/13/2011 21:18' prior: 0!BGSRangeSensor is an abstract superclass for range sensors.Subclasses should implement:-aceptVisitor: aVisitorInstance Variables:	range	<integer> the max distance to detect an obstacle. Cells beyond this distance are ignored.	botBoy <BGSRobotBody> body of robot that owes the sensor!!BGSDirectionalRangeSensor commentStamp: 'NouryBouraqadi 11/24/2011 19:30' prior: 0!I am a sensor that measures the number of empty cells between the robot and an obstacle in a particular direction. An obstacle being any non-empty cell.!!BGSOmnidirectionalRangeSensor commentStamp: 'NouryBouraqadi 11/25/2011 00:16' prior: 0!I am a sensor that detects obstacles in a disk around my position. The radius of the disk is my range + 1 (for my position).!!BGSWireless commentStamp: 'NouryBouraqadi 12/10/2011 21:16' prior: 0!I am a wireless communication interface. I allow communication between my owner and any other robot which has another wireless communication interface.!!BGSCar2012LogConverterToExcel commentStamp: '<historical>' prior: 0!BGSCar2012LogConverterToExcel convertToExcelFileAllLogsIn: (Smalltalk image imagePath, '/scripts/experiment/').BGSCar2012LogConverterToExcel loadLog: (Smalltalk image imagePath, '/scripts/experiment/result-01.st').!!BGSCell commentStamp: 'NouryBouraqadi 11/24/2011 19:17' prior: 0!I am a grid element.  I have a content that can be any visitable object (i.e. responding to acceptVisitor:)Subclasses are likely to override-acceptVisitor: someVisitor!!BGSExplorableCell commentStamp: 'NouryBouraqadi 12/7/2011 17:01' prior: 0!I am a cell in an explorable grid. I can be in two states: explored or unexplored (see IV state). Initially, I am unexplored, but when my content is set, I become explored. However, my state can be directly set using messages: markExplored and markUnexploredInstance Variables:	state	<BGSExplorableCellState> support for the State design pattern!!BGSRobotBody commentStamp: 'NouryBouraqadi 12/10/2011 15:10' prior: 0!I am a robot body deployed in a terrain.I have a collection of parts, each having an identifier. I retreive parts given their identifiers using message:-part: aSymbolInstance Variables:	terrain	<BGSGrid> terrain where I am deployed	position	<Point> coordinates of the cell occupied in terrain	partsDict <Dictionary : Symbol -> BGSBodyPart> gathers component parts such as range sensors and wireless communication interface!!BGSRangeSensorBeltRobotBody commentStamp: 'NouryBouraqadi 12/8/2011 16:52' prior: 0!I am a body of robot. I have an BGSOmnidirectionalRangeSensor that allows me to explore cells all arround my position.!!BGSWall commentStamp: 'NouryBouraqadi 11/14/2011 17:06' prior: 0!BGSWall represent a static obstacle!!BGSExplorableCellState commentStamp: 'NouryBouraqadi 12/8/2011 10:56' prior: 0!I am the state of an BGSExplorableCell.Concrete subclasses should implement:-acceptVisitor: visitor	Double dispatch for the visitor design pattern-isExplored	Answers true if I am an explored state. Answers false otherwise.-markExplored	Switch to explored state.-markUnexplored	Switch to unexplored state Instance Variables:	cell	<BGSExplorableCell> cell for which I am the state!!BGSExploredCellState commentStamp: 'NouryBouraqadi 12/8/2011 10:57' prior: 0!I am the state of a cell that was explored!!BGSUnexploredCellState commentStamp: 'NouryBouraqadi 12/8/2011 10:57' prior: 0!I am the state of a cell that was NOT explored yet!!BGSGrid commentStamp: 'NouryBouraqadi 12/8/2011 11:06' prior: 0!I am a 2D collection of cells. Cells can be of arbitrary kind: empty, wall, robot body, ...Instances are created by the following expression:	BGSGrid extent: aPointwhere aPoint provides the width and the height of the gridOn initialization (i.e. when the extent is defined), I trigger wall building.To ease wall construction a set of facility methods is provided (see protocol building).Subclasses are likely to override method:-buildWalls 		Put walls in the appropriate cells	!!BGSExplorableGrid commentStamp: 'NouryBouraqadi 12/8/2011 11:02' prior: 0!I am a grid with explorable cells. On creation/reset, all my cells are unexplored. I provide explorer robots with informations using messages:-exploredPositions	Positions of cells that have been explored-frontierPositions	Positions of cells that have been explored, but which at least one neighbor has NOT been explored yet-unexploredPositions	Positions of cells that have NOT been eplored yet.!!BGSCheckerboardLikeTerrain commentStamp: 'NouryBouraqadi 12/8/2011 16:55' prior: 0!I am a terrain with one cell obstacles uniformely sperad and aligned.!!BGSChristmasTerrain commentStamp: 'NouryBouraqadi 12/18/2011 20:22' prior: 0!see comment of BGSChristmasSimulation!!BGSTerrainExample commentStamp: 'NouryBouraqadi 11/15/2011 21:47' prior: 0!I am an example of terrain used by the BGCSSimulationExample!!BGSLogger commentStamp: 'NouryBouraqadi 11/13/2011 21:28' prior: 0!Logger maintains a file with logs of a simulation.To start logging simply create a logger by evaluating the expression:	logger := BGSLogger on: someSimulation By default the name of the log file is the class name of the simulation with the current time stamp.A different can be chosen by evaluating:	logger := BGSLogger on: someSimulation logInto: 'myLogFile.txt'Subclasses are likely to redefine methods:-logHeader 	Produces the first line of the log file with names of each column-logStep	Adds a new line to the log file with current simulation data!!BGSExplorationLogger commentStamp: 'NouryBouraqadi 12/8/2011 17:10' prior: 0!I log into a file an exploration simulation.To start logging simply create a logger by evaluating the expression:	logger := BGSExplorationLogger on: someSimulation By default the name of the log file is the class name of the simulation with the current time stamp.A different can be chosen by evaluating:	logger := BGSExplorationLogger on: someSimulation logInto: 'myLogFile.txt'!!BGSRobot commentStamp: 'NouryBouraqadi 11/9/2011 07:43' prior: 0!BGSRobot is a basic robot that has an identifier (id) and body deployed in some terrain.It does nothing. To make it perform some action, subclasses are likely to override method step Instance Variables:	id	<Symbol> Identifier of the robot. It is recommanded to assign each robot a unique ID	body	<BGSRobotBody>!!BGSFrontierExplorerRobot commentStamp: 'NouryBouraqadi 12/8/2011 16:53' prior: 0!I am a robot that builds a map of the terrain. I update the map and move towards a frontier cell until there are no more frontier cells left.I compute path to frontier cells that avoids obstacles while going through only already explored cells.I rely on a BGSRangeSensorBeltRobotBody.Subclasses are likely to override method:-targetFrontierPosition	Answers the frontier to move toInstance Variables:	map	<BGSExplorableGrid> map of the terrain. At the begining all its cells are marked as unexplored.!!BGSNearestFrontierExplorerRobot commentStamp: 'NouryBouraqadi 12/8/2011 16:58' prior: 0!I am an explorer robot that moves towards the nearest frontier!!BGSCollaborativeNearestFrontierExplorerRobot commentStamp: 'NouryBouraqadi 12/8/2011 23:13' prior: 0!I am an explorer robot that moves towards the nearest frontier and shares map with other robots that are within wireless range.!!BGSRandomWalkRobot commentStamp: 'NouryBouraqadi 11/15/2011 21:46' prior: 0!I am a robot that moves to a random free neighboring cell !!BGSSnowFlakeRobot commentStamp: 'NouryBouraqadi 12/18/2011 20:22' prior: 0!see comment of BGSChristmasSimulation!!BGSSimulation commentStamp: 'NouryBouraqadi 12/8/2011 17:00' prior: 0!BGSSimulation is the main entry point to perform simulations. It deploys robots on a terrain and make them perform their actions. A simulation has its own process that drives robots (step message). It can be paused any time (message pause) and it automatically stops when reaching a stop condition.Subclasses should implement methods:-deployRobots-robotClass-robotCountSubclasses are likely to override method:-terrainClass-nameInstance Variables:	robots	<Collection of: BGSRobot>	terrain	<BGSTerrain>	pauseFlagLock	<Mutex>	isPaused	<Boolean>	stepCounter	<Integer> is incremented on every simulation step!!BGSExplorationSimulation commentStamp: 'NouryBouraqadi 12/8/2011 11:19' prior: 0!I am an simulation of an exploration of un unkown terrain.  I stop when all terrain cells are explored.I provide information on the exploration status (typically used for display and log) using messages such as:-frontierPositions	Answers a set with positions of frontier cells-unexploredPositions	Answers a set with positions of unexplored cells!!BGS1RobotFrontierExplorationSimulation commentStamp: 'NouryBouraqadi 12/8/2011 16:56' prior: 0!I am a simulation involving an explorer robot that moves towards the nearest frontier in a chekerboard like terrain!!BGS5CollaborativeRobotsExplorationSimulation commentStamp: 'NouryBouraqadi 12/8/2011 23:27' prior: 0!I am a simulation of an exploration of a terrain using 5 collaborative robots (BGSCollaborativeNearestFrontierExplorerRobot) that share their maps when they are within wireless range!!BGSChristmasSimulation commentStamp: 'NouryBouraqadi 12/18/2011 20:22' prior: 0!Simulation for celebrating christmas 2011. To run it, evaluate the following expression.BGSChristmasSimulationWindow onClass: BGSChristmasSimulation. !!BGSSimulationWithTopLeftIinitialPosition commentStamp: '<historical>' prior: 0!terrain :=  BGSExplorableTerrain extent: 100@100..terrain :=  BGSCheckerboardLikeTerrain extent: 100@100..sim := BGSCar2012Simulation runFor: 4  in: terrain logFileName: (Smalltalk image imagePath, '/result.st').BGSExplorationSimulationWindow on:  sim.sim pause.sim := nil.BGSCar2012DoitLogger allInstances first close.!!BGSSlowedDownSimulation commentStamp: 'NouryBouraqadi 12/13/2011 23:12' prior: 0!In order to allow userconfortably watch simulation (avoid the flashing simulation effect), I introduce a delay to suspend the simulation process every step for a short duration (milliseconds). See references to variable stepDelayInstance Variables:	stepDelay	<Delay>	stepDelayMilliseconds	<ProtoObject | PseudoContext>!!BGSSimulationExample commentStamp: 'NouryBouraqadi 11/16/2011 22:37' prior: 0!SimulationExample is a simple simulation with a three robots that randomly walks in a terrain.Instance Variables:	stepDelay	<Delay> delay between two simulation steps.		To display and log the simulation, evaluate in a workspace the following code snippet	sim := BGSSimulationExample new.	BGSSimulationWindow on:  sim.	logger := BGSLogger on: sim.!!BGSGridView commentStamp: 'NouryBouraqadi 11/14/2011 17:03' prior: 0!BGSGridView is a morph that observes a grid and updates its display according to the grid changes: typically a change of a cell.Subclasses are likely to override methods:-drawCell:at:on: 		Main method that drives cell drwaing-drawRobotBody:at:on: 	Draws a robot as a blue dot in a cell!!BGSExplorableGridView commentStamp: 'NouryBouraqadi 12/8/2011 11:12' prior: 0!I am the view of an BGSExplorableGrid. I display frontiers, explored and unexplored cells in different colors.!!BGSChristmasGridView commentStamp: 'NouryBouraqadi 12/18/2011 20:22' prior: 0!see comment of BGSChristmasSimulation!!BGS1RobotFrontierExplorationSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/14/2011 14:40'!setUp 	super setUp.	simulation := BGS1RobotFrontierExplorationSimulation new.	terrain := simulation terrain! !!BGS1RobotFrontierExplorationSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:53'!testFrontierCountAfterOneStep	simulation step.	self assert: simulation frontierPositionsCount = 4! !!BGS1RobotFrontierExplorationSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:53'!testInitialFrontierCount	self assert: simulation frontierPositionsCount = 3! !!BGS1RobotFrontierExplorationSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:50'!testInitialUnexploredCount	self assert: simulation unexploredPositionsCount =  2496! !!BGS1RobotFrontierExplorationSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/14/2011 14:40'!testRevealingTerrain	terrain markExplored.	terrain cells do: [:aCell| 		self assert: aCell isExplored].! !!BGS1RobotFrontierExplorationSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:54'!testUnexploredCountAfterOneStep	simulation step.	self assert: simulation unexploredPositionsCount =  2494! !!BGSBodyPartTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 11:07'!setUp 	botBody := BGSRobotBody new.	terrain := BGSGrid extent: 10@10.	botBody jumpTo: 5@5 in: terrain.! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/11/2011 09:56'!setUp 	super setUp.	sensor := BGSDirectionalRangeSensor botBody: botBody name: #rangeSensor range: 4! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 11:45'!testDetectionOfObstacleAfterRobotMove	botBody position: 5@6.	terrain addWallAt: 5@1.	(0 to: 3) reversed do: [:expectedDistance|		botBody goForward.		self assert: sensor distanceToObstacle = expectedDistance	].! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 11:05'!testDetectionOfObstacleAfterRobotRotation	terrain addWallAt: 3@3 extent: 5@5.	terrain emptyCellsAt: 4@4 extent: 3@3.	8 timesRepeat: [		botBody turnLeft.		self assert: sensor distanceToObstacle = 1.	]! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 11:00'!testDetectionOfObstacleInFrontOfRobot	{5@1. 5@2. 5@3. 5@4} with: (0 to: 3) reversed do: [:wallPosition :expectedDistance|		terrain addWallAt: wallPosition.		self assert: sensor distanceToObstacle = expectedDistance	].! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/25/2011 09:36'!testInitialRange	self assert: sensor range = 4! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 11:05'!testNoObstacle	self assert: sensor distanceToObstacle = 4! !!BGSDirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 11:15'!testObstacleBeyondRange	botBody position: 5@10.	{5@1. 5@2. 5@3. 5@4. 5@5} do: [:wallPosition|		terrain addWallAt: wallPosition.		self assert: sensor distanceToObstacle = 4	].! !!BGSOmnirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/11/2011 09:55'!setUp 	super setUp.	sensor := BGSOmnidirectionalRangeSensor botBody: botBody name: #proximityBelt! !!BGSOmnirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 21:13'!testNoNeighboringObstacles 	|expectedEmptyPositions|	expectedEmptyPositions := {4@4. 5@4. 6@4. 4@5. 6@5. 4@6. 5@6. 6@6} asSet.	self assert: sensor emptySensedPositions asSet = expectedEmptyPositions! !!BGSOmnirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 21:13'!testSomeNeighboringObstacles	|obstaclePositions|	obstaclePositions := {4@4. 6@5. 5@6} asSet.	obstaclePositions do: [:wallPosition| 		terrain put: BGSWall new inCellAt: wallPosition].	self assert: sensor emptySensedPositions asSet = { 5@4. 6@4. 4@5.  4@6. 6@6} asSet.	self assert: sensor obstacleSensedPositions asSet = obstaclePositions! !!BGSOmnirectionalRangeSensorTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 21:13'!testSurroundedWithObstacles 	terrain addWallAt: (sensor position - 1) extent: 3@3.	self assert: sensor emptySensedPositions isEmpty! !!BGSWirelessTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/11/2011 09:58'!setUp 	super setUp.	wireless := BGSWireless botBody: botBody name: #wifi range: 3.	otherBotBody := BGSRobotBody new.	otherBotBody jumpTo: 1@1 in: terrain.	otherWireless := BGSWireless botBody: otherBotBody name: #wifi range: 3.! !!BGSWirelessTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/10/2011 21:46'!testDetectPeerWithinRange	|rangePositions expectedPeers|	rangePositions := Set new.	2 to: 8 do: [:x|		2 to: 8 do: [:y|			rangePositions add: x@y]].	expectedPeers := {otherWireless} asSet.	rangePositions do: [:aPoint|		otherBotBody position: aPoint.		self assert: wireless peers = expectedPeers].! !!BGSWirelessTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/10/2011 21:27'!testNoPeerWithinRange	|rangePositions outsideRangePositions|	rangePositions := Set new.	2 to: 8 do: [:x|		2 to: 8 do: [:y|			rangePositions add: x@y]].	outsideRangePositions := terrain positions asSet copyWithoutAll: rangePositions.	outsideRangePositions do: [:aPoint|		otherBotBody position: aPoint.		self assert: wireless peers isEmpty].! !!BGSCar2012SimulationTest methodsFor: 'testing' stamp: 'LucFabresse 4/3/2012 13:16'!setUp	super setUp.	simClass := BGSSimulationWithTopLeftIinitialPosition! !!BGSCar2012SimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/30/2012 15:28'!testPositionsFor1Robot	| positions |	positions := simClass positionsForRobotsCount: 1.	self assert: positions asSet = {1@1} asSet! !!BGSCar2012SimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/30/2012 15:28'!testPositionsFor2Robots	| positions |	positions := simClass positionsForRobotsCount: 2.	self assert: positions asSet =  {1@1.  1@3} asSet! !!BGSCar2012SimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/30/2012 15:28'!testPositionsFor3Robots	| positions |	positions := simClass positionsForRobotsCount: 3.	self assert: positions asSet =  {1@1.  1@3. 3@1} asSet! !!BGSCar2012SimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/30/2012 15:28'!testPositionsFor4Robots	| positions |	positions := simClass positionsForRobotsCount: 4.	self assert: positions asSet =  {1@1.  1@3. 3@1. 1@5} asSet! !!BGSCar2012SimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/30/2012 15:28'!testPositionsFor5Robots	| positions |	positions := simClass positionsForRobotsCount: 5.	self assert: positions asSet =  {1@1.  1@3. 3@1. 1@5. 5@1} asSet! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 16:19'!robotClass	^BGSCollaborativeNearestFrontierExplorerRobot! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 16:58'!setUp 	super setUp.	otherBot := self robotClass new.	otherBot jumpTo: 1@1 in: terrain.	otherMap := otherBot map.	{bot. otherBot} with: #(#bot #otherBot) do: [:robot :identifier|			robot id: identifier.			(robot body part: #wireless) range: 2]! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 17:11'!testBroadcastToCloseRobots	otherBot jumpTo: 3@3. 	self assert: bot robotsWithinWirelessRange = {otherBot} asSet.	self assert: otherBot robotsWithinWirelessRange = {bot} asSet.	bot broadcast: #jumpTo: args: {4@4}.	self assert: otherBot position = (4@4).	otherBot broadcast: #jumpTo: args: {6@4}.	self assert: bot position = (6@4).	! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 17:05'!testRobotsCloseEnoughToDetectEachOther	| closePositions |	closePositions := Set new.	3 to: 7 do: [:x|		3 to: 7 do: [:y| closePositions add: x@y]].	closePositions remove: 5@5. "Position of bot "	closePositions do: [:aPoint|		otherBot jumpTo: aPoint. 		self assert: bot robotsWithinWirelessRange = {otherBot} asSet.		self assert: otherBot robotsWithinWirelessRange = {bot} asSet].! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 17:05'!testRobotsTooFarToDetectEachOther	| farPositions |	farPositions := Set new.	1 to: 10 do: [:x|		1to: 2 do: [:y| farPositions add: x@y]].	1 to: 2 do: [:x|		1to: 10 do: [:y| farPositions add: x@y]].	8 to: 10 do: [:x|		1to: 10 do: [:y| farPositions add: x@y]].	1 to: 10 do: [:x|		8to: 10 do: [:y| farPositions add: x@y]].	farPositions do: [:aPoint|		otherBot jumpTo: aPoint. 		self assert: bot robotsWithinWirelessRange isEmpty.		self assert: otherBot robotsWithinWirelessRange isEmpty].! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 4/3/2012 21:08'!testUpdateMapWithCellsMarkedEmptyFromMapWithSameCellsMarkedObstacles	|expectedEmptyCellPositions|	otherMap addWallAt: 1@1 extent: 10@10. 	otherMap put: otherBot body inCellAt: otherBot position.	otherMap markExplored. 	map markExplored.	bot updateMapFrom: otherMap.	expectedEmptyCellPositions := map positions asSet copyWithout: bot position.	self assert: map emptyCellPositions asSet = expectedEmptyCellPositions.	self deny: (map isEmptyCellAt: bot position).	self assert: (map isEmptyCellAt: otherBot position)! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 4/3/2012 20:59'!testUpdateMapWithCellsMarkedObstaclesFromMapWithSameCellsMarkedEmpty	|expectedEmptyCellPositions|	otherMap markExplored. 	map addWallAt: 1@1 extent: 10@10. 	map put: bot body inCellAt: bot position.	map markExplored.	bot updateMapFrom: otherMap.	expectedEmptyCellPositions := map positions asSet copyWithout: bot position.	self assert: map emptyCellPositions asSet = expectedEmptyCellPositions.	self deny: (map isEmptyCellAt: bot position)! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 17:27'!testUpdatingEmptyMapFromOtherMapWithExploredEmptyCells	otherMap emptyCellsAt: 6@7 extent: 3@3.	6 to: 8 do: [:x|		7 to: 9 do: [:y|			self deny: (map cellAt: x@y) isExplored]].	bot updateMapFrom: otherMap.	6 to: 8 do: [:x|		7 to: 9 do: [:y|			self assert:  (map cellAt: x@y) isExplored.			self assert: (map isEmptyCellAt: x@y)]]! !!BGSCollaborativeNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 17:24'!testUpdatingEmptyMapFromOtherMapWithObstacles	otherMap addWallAt: 6@7 extent: 3@3.	6 to: 8 do: [:x|		7 to: 9 do: [:y|			self deny: (map cellAt: x@y) isExplored]].	bot updateMapFrom: otherMap.	6 to: 8 do: [:x|		7 to: 9 do: [:y|			self assert:  (map cellAt: x@y) isExplored.			self deny: (map isEmptyCellAt: x@y)]]! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:17'!assertBotGoTo: botExpectedPosition withHeading: botExpectedHeading emptyCellPositions: emptyCellPositions unexploredPosition: unexploredPosition	map addWallsAtPositions: map positions.	(emptyCellPositions copyWith: bot position) do: [:aPoint| 		map emptyCellAt: aPoint].	map markUnexploredCellAt: unexploredPosition.	bot step.	self assert: bot heading = botExpectedHeading.	self assert: bot position = botExpectedPosition! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:18'!assertBotGoToFrontierAt: frontierPosition withHeading: botExpectedHeading unexploredCellAt: unexploredPosition	self assertBotGoTo: frontierPosition withHeading: botExpectedHeading emptyCellPositions: {frontierPosition} unexploredPosition: unexploredPosition! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/30/2011 23:50'!robotClass	^BGSFrontierExplorerRobot! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/13/2011 19:23'!setUp	super setUp.	terrain := BGSExplorableTerrain extent: 10@10.	bot := self robotClass new.	bot jumpTo: 5@5 in: terrain.	map := bot map.! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 4/3/2012 23:19'!testEmptyCellInMapRemainsEmptyEvenIfObstacleDetected	|expectedEmptyPositions wallPosition|	map positions  do: [:aPoint| 		map emptyCellAt: aPoint].	map put: bot body inCellAt: bot position.	self assert: map unexploredPositions isEmpty.	expectedEmptyPositions := map positions asSet copyWithout: bot position.	self assert: map emptyCellPositions asSet = expectedEmptyPositions.	wallPosition := bot position + (1@1).	terrain addWallAt: wallPosition.	self deny: (terrain isEmptyCellAt: wallPosition).	self assert: (bot obstacleSensedPositions asArray = {wallPosition}).	bot step.	self assert: map emptyCellPositions asSet = expectedEmptyPositions.! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 18:32'!testFrontierPositionsAfterOneStep	{4@4. 6@4. 4@6. 6@6} do: [:aPoint| 		terrain addWallAt: aPoint].	bot jumpTo: 5@5 in: terrain.	self assert: bot frontierPositions size = 4.	bot step.	self assert: bot frontierPositions size = 6! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:12'!testGoToUniqueFrontier1CellEast	self assertBotGoToFrontierAt: 6@5 withHeading: 1@0 unexploredCellAt: 7@5! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:12'!testGoToUniqueFrontier1CellNorth	self assertBotGoToFrontierAt: 5@4 withHeading: 0@ -1 unexploredCellAt: 5@3! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:13'!testGoToUniqueFrontier1CellNorthEast	self assertBotGoToFrontierAt: 6@4 withHeading: 1@ -1 unexploredCellAt: 7@3! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:13'!testGoToUniqueFrontier1CellNorthWest	self assertBotGoToFrontierAt: 4@4 withHeading: -1@ -1 unexploredCellAt: 3@3! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:14'!testGoToUniqueFrontier1CellSouth	self assertBotGoToFrontierAt: 5@6 withHeading: 0@1 unexploredCellAt:  5@7! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:14'!testGoToUniqueFrontier1CellSouthEast	self assertBotGoToFrontierAt: 6@6 withHeading: 1@1 unexploredCellAt: 7@7! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:14'!testGoToUniqueFrontier1CellSouthWest	self assertBotGoToFrontierAt: 4@6 withHeading: -1@1 unexploredCellAt: 3@7! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:14'!testGoToUniqueFrontier1CellWest	self assertBotGoToFrontierAt: 4@5 withHeading: -1@0 unexploredCellAt:  3@5! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:20'!testGoTowardsUniqueFrontier2CellsToTheEast	self assertBotGoTo: 6@5 withHeading: 1@0 emptyCellPositions: {6@5. 7@5} unexploredPosition: 8@5.! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:21'!testGoTowardsUniqueFrontier2CellsToTheNorth	self assertBotGoTo: 5@4 withHeading: 0@ -1 emptyCellPositions: {5@3. 5@4} unexploredPosition: 5@2.! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:22'!testGoTowardsUniqueFrontier2CellsToTheSouth	self assertBotGoTo: 5@6 withHeading: 0@1 emptyCellPositions: {5@6. 5@7} unexploredPosition: 5@8.! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:22'!testGoTowardsUniqueFrontier2CellsToTheWest	self assertBotGoTo: 4@5 withHeading: -1@0 emptyCellPositions: {3@5. 4@5} unexploredPosition: 2@5.! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 17:45'!testInitialExploredPositions	|expectedExploredPositions|	expectedExploredPositions := Set new.	4 to: 6 do: [:x|		4 to: 6 do: [:y| expectedExploredPositions add: x@y]].	self assert: bot exploredPositions asSet = expectedExploredPositions	! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 17:45'!testInitialFrontierPositions	self assert: bot frontierPositions asSet = {		4@4. 5@4. 6@4. 		4@5.         6@5.	 	4@6. 5@6. 6@6}  asSet	! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 17:45'!testInitialUnexploredPositions	|expectedExploredPositions expectedUnexploredPositions|	expectedExploredPositions := Set new.	4 to: 6 do: [:x|		4 to: 6 do: [:y| expectedExploredPositions add: x@y]].	expectedUnexploredPositions := terrain positions asSet copyWithoutAll: expectedExploredPositions.	self assert: bot unexploredPositions asSet  = expectedUnexploredPositions! !!BGSFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 18:44'!testNoMoveIfNoFrontier	|initialPosition|	map positions  do: [:aPoint| 		map emptyCellAt: aPoint].	self assert: map unexploredPositions isEmpty.	initialPosition := bot position.	bot step.	self assert: bot position = initialPosition! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:33'!assertBotPosition: expectedPosition andHeading: expectedHeading forUnexploredPosition: unexploredPosition	map addWallsAtPositions: map positions.	{5@5.	5@2. 5@3. 5@4.  	5@6. 5@7. 5@8.	2@5. 3@5. 4@5.	6@5. 7@5. 8@5} do: [:aPoint| 		map emptyCellAt: aPoint].	{5@1. 5@9. 1@5. 9@5. unexploredPosition} do: [:aPoint|		map markUnexploredCellAt: aPoint].	self assert: map frontierPositions size = 4.	bot step.	self assert: bot position = expectedPosition.	self assert: bot heading = expectedHeading.! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/30/2011 23:51'!robotClass	^BGSNearestFrontierExplorerRobot! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 1/10/2012 17:31'!testGoAroundObstaclesToNearestFrontier	map addWallsAtPositions: map positions.	{5@5. 6@4. 6@6. 7@5. 8@5} do: [:aPoint| 		map emptyCellAt: aPoint].	map markUnexploredCellAt: 9@5.	self assert: map frontierPositions size = 1.	3 timesRepeat: [bot step].	self assert: bot position = (8@5).	self assert: bot heading = (1@0).! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/12/2011 18:34'!testPathToAccessibleFrontier	|inaccessibleFrontierPosition targetFrontierPosition|	inaccessibleFrontierPosition := 7@4.	bot jumpTo: 5@4.	{terrain. map} do: [:grid|		grid cells do: [:cell| cell markUnexplored].		grid 			addWallAt: 4@3 extent: 3@1;			addWallAt: 4@3 extent: 1@7;			addWallAt: 6@3 extent: 1@7;			emptyCellsAt: 5@4 extent: 1@6;			emptyCellAt: inaccessibleFrontierPosition		].	targetFrontierPosition :=  bot pathToFrontier last.	self deny:  targetFrontierPosition = inaccessibleFrontierPosition.	self assert: targetFrontierPosition = (5@9)! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:33'!testTurnThenGoEastTowardsNearestFrontier	self assertBotPosition: 6@5 andHeading: 1@0 forUnexploredPosition: 8@5.! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:38'!testTurnThenGoNorthTowardsNearestFrontier	self assertBotPosition: 5@4 andHeading: 0@ -1 forUnexploredPosition: 5@2.! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:39'!testTurnThenGoSouthTowardsNearestFrontier	self assertBotPosition: 5@6 andHeading: 0@1 forUnexploredPosition: 5@8.! !!BGSNearestFrontierExplorerRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 19:34'!testTurnThenGoWestTowardsNearestFrontier	self assertBotPosition: 4@5 andHeading: -1@0 forUnexploredPosition: 2@5.! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!setUp 	super setUp.	grid := BGSGrid extent: 10@10! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 15:41'!testAccessingInvalidPositions	{0@0. 0@10. 11@11. 10@0} do: [:position|		self shouldnt: [grid cellAt: position] raise: Error.		self deny: (grid isEmptyCellAt: position).	]! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:08'!testAddingRobotBodyAtCellOccupiedByWall	| position wall botBody |	position := 3@3.	grid put: BGSWall new inCellAt: position.	wall := grid cellAt: position.	botBody := BGSRobotBody new.	grid put: botBody inCellAt: position.	self assert: (grid contentOfCellAt: position) == botBody! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:05'!testAddingRobotBodyToEmptyCell	| botBody |	botBody := BGSRobotBody new.	grid put: botBody inCellAt: 3@3.	self assert: (grid contentOfCellAt: 3@3) == botBody! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!testAllCellsAreEmptyByDefault	1 to: grid extent x do: [:x|		1 to: grid extent y do: [:y|			self assert: (grid isEmptyCellAt: x@y)]].		! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:06'!testCellWithRobotIsNOTEmpty	| position |	position := 6@7.	grid put: BGSRobotBody new inCellAt: position.	self deny: (grid isEmptyCellAt: position)! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!testPositionsAroundBottomLeftCell	| neighbors |	neighbors := grid positionsAround: 1@10.	self assert: neighbors asSet = {1@9. 2@9. 2@10. } asSet! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!testPositionsAroundBottomRightCell	| neighbors |	neighbors := grid positionsAround: 10@10.	self assert: neighbors asSet = {9@9. 10@9. 9@10. } asSet! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!testPositionsAroundMiddleCell	| neighbors |	neighbors := grid positionsAround: 4@4.	self assert: neighbors asSet = {3@3. 4@3. 5@3.  3@4. 5@4. 3@5. 4@5. 5@5} asSet! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!testPositionsAroundTopLeftCell	| neighbors |	neighbors := grid positionsAround: 1@1.	self assert: neighbors asSet = {2@1. 1@2. 2@2. } asSet! !!BGSGridTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:41'!testPositionsAroundTopRightCell	| neighbors |	neighbors := grid positionsAround: 10@1.	self assert: neighbors asSet = {9@1. 9@2. 10@2. } asSet! !!BGSGridViewTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/10/2011 19:08'!setUp	super setUp.	grid := BGSGrid extent: 10@10.	gridView := BGSGridView on: grid.! !!BGSGridViewTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/25/2011 09:44'!testExtent	self assert: gridView extent = (121@121).	gridView grid: (BGSGrid extent: 100@100).	self assert: gridView extent = (1111@1111)		! !!BGSExplorationLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 17:45'!initialExpectedLog	|expectedLogStream|	expectedLogStream := String new writeStream.	#(step frontiers unexplored 'robot1-position' 'robot1-heading') do: [:headerString|			expectedLogStream nextPutAll: headerString] 		separatedBy: [			expectedLogStream tab].	expectedLogStream cr.	{0. 3. 2496. 1@1. 0@ -1} do: [:initialValue|			expectedLogStream print: initialValue] 		separatedBy: [			expectedLogStream tab].	expectedLogStream cr.	^expectedLogStream contents! !!BGSExplorationLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 17:27'!loggerClass 	^BGSExplorationLogger ! !!BGSExplorationLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 17:31'!simulationClass 	^BGS1RobotFrontierExplorationSimulation! !!BGSExplorationLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 17:34'!testInitialLog	self assert: logger allLog = self initialExpectedLog! !!BGSLoggerTest methodsFor: 'setUp-tearDown' stamp: 'NouryBouraqadi 12/8/2011 17:16'!loggerClass	^BGSLogger! !!BGSLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:10'!printLogHeaderOn: expectedLogStr botCount: expectedRobotCount	expectedLogStr nextPutAll: 'step'.	1 to: expectedRobotCount do: [ :number | 		expectedLogStr			tab;			nextPutAll: 'robot';			print: number;			nextPutAll: '-position';			tab;			nextPutAll: 'robot';			print: number;			nextPutAll: '-heading' ].	expectedLogStr cr! !!BGSLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:10'!printOn: expectedLogStr step:  step positions: expectedBotPositions 	expectedLogStr print: step.	expectedBotPositions		do: [ :position | 			expectedLogStr				tab;				print: position;				tab;				print: 0 @ -1 ].	expectedLogStr cr! !!BGSLoggerTest methodsFor: 'setUp-tearDown' stamp: 'NouryBouraqadi 12/8/2011 17:26'!setUp 	super setUp.	simulation := self simulationClass new.	logger := self loggerClass on: simulation! !!BGSLoggerTest methodsFor: 'setUp-tearDown' stamp: 'NouryBouraqadi 12/8/2011 17:16'!simulationClass	^BGSSimulationForTest! !!BGSLoggerTest methodsFor: 'setUp-tearDown' stamp: 'JulianGrigera 8/21/2015 19:23'!tearDown	super tearDown.	logger fileName asFileReference ensureDelete! !!BGSLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:06'!testInitialLogForASimulationWith1Robot	| expectedLogStr |	self assert: logger robots size = 1.	expectedLogStr := WriteStream on: String new.	self printLogHeaderOn: expectedLogStr botCount: 1.	self printOn: expectedLogStr step: 0 positions: {(1 @ 1)}.	self assert: logger allLog = expectedLogStr contents! !!BGSLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 10:55'!testInitialLogForASimulationWith3Robots	| expectedLogStr |	2 to: 3 do: [ :botNumber | 		| bot botPosition |		bot := BGSRobot number: botNumber.		botPosition := botNumber @ botNumber.		bot jumpTo: botPosition in: simulation terrain.		simulation addRobot: bot ].	logger := BGSLogger on: simulation.	self assert: logger robots size = 3.	expectedLogStr := WriteStream on: String new.	self printLogHeaderOn: expectedLogStr botCount: 3.	self		printOn: expectedLogStr		step: 0		positions: {(1 @ 1). (2 @ 2). (3 @ 3)}.	self assert: logger allLog = expectedLogStr contents! !!BGSLoggerTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:52'!testLogAfter3StepsForASimulationWith1Robot	| expectedLogStr |	self assert: logger robots size = 1.	3 timesRepeat: [ simulation step ].	self assert: logger stepCount = 3.	expectedLogStr := WriteStream on: String new.	self printLogHeaderOn: expectedLogStr botCount: 1.	(0 to: 3) do: [:step|		self printOn: expectedLogStr step: step positions: {(1 @ 1)}].	self assert: logger allLog = expectedLogStr contents! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 11:07'!setUp	super setUp.	terrain := BGSGrid extent: 10@10.	botBody := BGSRobotBody new.	botBody jumpTo:  5@5 in: terrain! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/17/2011 20:41'!testCanNotMoveForwardOutsideTerrain	botBody position: 5@1.	3 timesRepeat: [botBody goForward.		self assert: botBody position = (5@1)].	! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/17/2011 20:43'!testGoOneCellForward	botBody goForward.	self assert: botBody position = (5@4).	botBody goForward.	self assert: botBody position = (5@3).	! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/11/2011 10:03'!testRetreivePartsByName	| sensor1 sensor2 |	sensor1 := BGSOmnidirectionalRangeSensor botBody: botBody name: #sensor1.	sensor2 := BGSOmnidirectionalRangeSensor botBody: botBody name: #sensor2.	self assert: (botBody part: #sensor1) == sensor1.	self assert: (botBody part: #sensor2) == sensor2.	! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/11/2011 10:14'!testRetreiveUnknownPart	self assert: (botBody part: #unknownPart) isNil	! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/17/2011 21:02'!testTurnLeftAndGoForward	{4@4. 4@5. 4@6. 5@6. 6@6. 6@5. 6@4. 5@4} do: [:expectedPosition|		botBody position: 5@5.		botBody turnLeft.		botBody goForward.		self assert: botBody position = expectedPosition	]! !!BGSRobotBodyTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/17/2011 21:14'!testTurnRightAndGoForward	 {(6@4). (6@5). (6@6). (5@6). (4@6). (4@5). (4@4). (5@4)} do: [:expectedPosition|		botBody position: 5@5.		botBody turnRight.		botBody goForward.		self assert: botBody position = expectedPosition	]! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 11:07'!setUp 	super setUp.	terrain := BGSGrid extent: 10@10.	bot := BGSRobot new.	bot jumpTo: 5@5 in: terrain! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:18'!testGoForwardLessCellsThanAskedToStayInsideTerain	bot goForwardBy: 10.	self assert: bot position = (5@1)! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:06'!testGoForwardUntilReachingAnObstacle	terrain put: BGSWall new inCellAt: 5@2. 	bot goForwardBy: 10.	self assert: bot position = (5@3)! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:14'!testGoSeveralCellsForward	bot goForwardBy: 3.	self assert: bot position = (5@2).	bot goForwardBy: 2.	self assert: bot position = (5@1).	! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:13'!testIdFromANumber	bot number: 243.	self assert: bot id == #robot243! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:13'!testIdStoredAsSymbolEvenIfStringProvided	bot id: 'myCoolRobot'.	self assert: bot id == #myCoolRobot! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:13'!testTurnLeftSeveralSteps	{4@6.  6@5. 4@4} do: [:expectedPosition|		bot jumpTo: 5@5.		bot turnLeftBy: 3.		bot goForward.		self assert: bot position = expectedPosition	]! !!BGSRobotTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/19/2011 18:14'!testTurnRightSeveralSteps	{6@6. 4@5. 6@4} do: [:expectedPosition|		bot jumpTo: 5@5.		bot turnRightBy: 3.		bot goForward.		self assert: bot position = expectedPosition	]! !!BGSSimulationParametrizationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/28/2012 10:38'!setUp	super setUp.	terrain := BGSExplorableTerrain new.	afterStopActionPerformed := false.	stopFlag := false.	robotsCount := 1.	robotsClass := BGSRobot.	simulation := BGSParametrizedExplorationSimulation 				terrain: terrain 				robotsClass: BGSRobot  				positions: {1@1} 				stopOn: [:sim| stopFlag] 				afterStopDo: [:sim| afterStopActionPerformed := true].! !!BGSSimulationParametrizationTest methodsFor: 'testing'!tearDown	super tearDown.	simulation pause! !!BGSSimulationParametrizationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/28/2012 10:32'!testAfterStopAction	simulation run.	(Delay forMilliseconds: 100) wait.	stopFlag := true.	(Delay forMilliseconds: 100) wait.	self assert: simulation autoStopConditionReached.	self assert: afterStopActionPerformed! !!BGSSimulationParametrizationTest methodsFor: 'testing'!testPauseDoesNotTriggerAfterStopAction	simulation run.	(Delay forMilliseconds: 100) wait.	simulation pause.	(Delay forMilliseconds: 100) wait.	self deny: simulation autoStopConditionReached.	self deny: afterStopActionPerformed! !!BGSSimulationParametrizationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/27/2012 11:50'!testRobotsClass	simulation robots do: [:bot|		self assert: (bot isKindOf: robotsClass)]! !!BGSSimulationParametrizationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 3/27/2012 12:12'!testRobotsCount	self assert: simulation robots size = robotsCount! !!BGSSimulationParametrizationTest methodsFor: 'testing'!testSimulationTerrainIsProvidedOnCreation	self assert: simulation terrain == terrain! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/9/2011 07:55'!setUp 	super setUp.	simulation := BGSSimulationForTest new.	robot := simulation robots first.	terrain := simulation terrain! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 10:48'!testAccessRobotById	self assert: (simulation robot: #robot1) == robot.! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/18/2011 18:49'!testAddRobot	| newBot |	newBot := BGSRobot withId: #newBot.	simulation addRobot: newBot.	self assert: (simulation robots includes: newBot).	self assert: (simulation robot: #newBot) == newBot! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 11:36'!testIsRunning	self deny: simulation isRunning.	simulation isPaused: false.	self assert: simulation isRunning.	simulation autoStopConditionFlag: true.	self deny: simulation isRunning.	! !!BGSSimulationTest methodsFor: 'testing' stamp: 'JulianGrigera 8/21/2015 19:25'!testRemoveRobot	simulation removeRobot: robot.	self deny: (simulation robots includes: robot).	self should: [ simulation robot: #robot1 ] raise: KeyNotFound! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:52'!testReset	|wallPosition botInitialPosition botInitialHeading botFinalPosition|	botInitialPosition := robot position.	botInitialHeading := robot heading.	robot jumpTo: 4@3.	robot turnRightBy: 3.	robot goForwardBy: 2.	botFinalPosition := robot position.	self deny: botFinalPosition = botInitialPosition.	self deny: robot heading = botInitialHeading.	wallPosition := 8@7.	terrain addWallAt: wallPosition.	self deny: (terrain isEmptyCellAt: wallPosition).	simulation stepCount: 123.	simulation isPaused: false.	simulation reset.	robot := simulation robot: #robot1.	self assert: robot position = botInitialPosition.	self assert: robot heading = botInitialHeading.	self assert: (terrain isEmptyCellAt: wallPosition).	self deny: (terrain isEmptyCellAt: botInitialPosition).	self assert: (terrain contentOfCellAt: botInitialPosition) == robot body.	self assert: (terrain isEmptyCellAt: botFinalPosition).	self assert: simulation stepCount = 0.	self assert: simulation isPaused.! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:14'!testRobotMoveToCellOccupiedByAWall	| targetPosition initialPosition wall|	targetPosition := 3@4.	terrain addWallAt: targetPosition.	wall := terrain contentOfCellAt: targetPosition.	initialPosition := robot position.	robot jumpTo: targetPosition.	self assert: robot position = initialPosition.	self assert: (terrain contentOfCellAt: targetPosition) == wall.	self assert: (terrain contentOfCellAt: initialPosition) == robot body! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:14'!testRobotMoveToCellOccupiedByOtherRobot	| otherBotBody targetPosition initialPosition|	targetPosition := 3@4.	otherBotBody := BGSRobotBody new.	terrain put: otherBotBody inCellAt: targetPosition.	initialPosition := robot position.	robot jumpTo: targetPosition.	self assert: robot position = initialPosition.	self assert: (terrain contentOfCellAt: targetPosition) == otherBotBody.	self assert: (terrain contentOfCellAt: initialPosition) == robot body! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:14'!testRobotMoveToCellOutsideTerrain	| initialPosition|	initialPosition := robot position.	{0@0. 0@10. 11@11. 10@0} do: [:targetPosition|		robot jumpTo: targetPosition.		self assert: robot position = initialPosition.		self assert: (terrain contentOfCellAt: initialPosition) == robot body		]! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:14'!testRobotMoveToEmptyCell	| targetPosition initialPosition |	targetPosition := 3@4.	self assert: (terrain isEmptyCellAt: targetPosition).	initialPosition := robot position.	robot jumpTo: targetPosition.	self assert: robot position = targetPosition.	self deny: (terrain isEmptyCellAt: targetPosition).	self assert: (terrain contentOfCellAt: targetPosition) == robot body.	self assert: (terrain isEmptyCellAt: initialPosition)! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/9/2011 08:54'!testRobotPosition	self assert: robot position = (1@1)! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:52'!testStepCounterIncremented	simulation step.	self assert: simulation stepCount = 1! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/6/2011 18:52'!testStepCounterIntiallyToZero	self assert: simulation stepCount = 0! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/9/2011 08:50'!testTerrainExtent	self assert: terrain extent = (10@10)! !!BGSSimulationTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 18:15'!testTerrainIncludesRobot	self assert: (terrain contentOfCellAt: 1@1) == robot body! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:52'!assertCellsAreEmptyExceptAll: expectedWallPositions	| expectedEmptyPositions |	expectedWallPositions do: [ :position | self deny: (terrain isEmptyCellAt: position) ].	expectedEmptyPositions := terrain positions asArray copyWithoutAll: expectedWallPositions.	expectedEmptyPositions do: [ :position | self assert: (terrain isEmptyCellAt: position) ]! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 12/8/2011 11:07'!setUp 	super setUp.	terrain := BGSGrid extent: 10@10! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:53'!testAddBigWall	|expectedWallPositions|	terrain addWallAt: 1@1 extent: 4@4.	expectedWallPositions :={		1@1. 2@1. 3@1. 4@1.		1@2. 2@2. 3@2. 4@2.		1@3. 2@3. 3@3. 4@3.		1@4. 2@4. 3@4. 4@4	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 09:47'!testAddSmallWall	| wallPosition |	wallPosition := 3@6.	terrain addWallAt: wallPosition.	self assertCellsAreEmptyExceptAll: {wallPosition}! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 22:10'!testEmptyCells	|expectedWallPositions|	terrain addWallAt: 1@1 extent: 4@4.	terrain emptyCellsAt: 2@2 extent: 2@2.	expectedWallPositions :={		1@1. 2@1. 3@1. 4@1.		1@2.                  4@2.		1@3.                  4@3.		1@4. 2@4. 3@4. 4@4	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 19:22'!testHorizontalLineLeftToRight	| expectedWallPositions |	terrain addLineWallFrom: 5 @ 5 to: 8@5 width: 2.	expectedWallPositions := {		5@5. 6@5. 7@5. 8@5.		5@6. 6@6. 7@6. 8@6.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 21:29'!testHorizontalLineRightToLeft	| expectedWallPositions |	terrain addLineWallFrom: 8 @ 5 to: 5@5 width: 2.	expectedWallPositions := {		5@5. 6@5. 7@5. 8@5.		5@6. 6@6. 7@6. 8@6.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 10:55'!testLineWallLeftToRightBottomToTop	| expectedWallPositions |	terrain addLineWallFrom: 1 @ 4 to: 4@1 width: 3.	expectedWallPositions := {					4@1. 5@1. 6@1.				3@2. 4@2. 5@2.			2@3. 3@3. 4@3.		1@4. 2@4. 3@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 21:27'!testLineWallLeftToRightBottomToTop2	| expectedWallPositions |	terrain addLineWallFrom: 1 @ 4 to: 2@1 width: 3.	expectedWallPositions := {			2@1. 3@1. 4@1.			2@2. 3@2. 4@2.		1@3. 2@3. 3@3.		1@4. 2@4. 3@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions.! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 10:55'!testLineWallLeftToRightTopToBottom	| expectedWallPositions |	terrain addLineWallFrom: 1 @ 1 to: 4@ 4 width: 3.	expectedWallPositions := {		1@1. 2@1. 3@1.			2@2. 3@2. 4@2.				3@3. 4@3. 5@3. 					4@4. 5@4. 6@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 21:28'!testLineWallLeftToRightTopToBottom2	| expectedWallPositions |	terrain addLineWallFrom: 2@1 to: 1 @ 4 width: 3.	expectedWallPositions := {			2@1. 3@1. 4@1.			2@2. 3@2. 4@2.		1@3. 2@3. 3@3.		1@4. 2@4. 3@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions.! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 10:54'!testLineWallRightToLeftBottomToTop	| expectedWallPositions |	terrain addLineWallFrom: 4@4 to: 1@1 width: 3.	expectedWallPositions := {		1@1. 2@1. 3@1.			2@2. 3@2. 4@2.				3@3. 4@3. 5@3. 					4@4. 5@4. 6@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 21:37'!testLineWallRightToLeftBottomToTop2	| expectedWallPositions |	terrain addLineWallFrom: 4@4 to: 3@1 width: 2.	expectedWallPositions := {		3@1. 4@1.		3@2. 4@2.			  4@3. 5@3. 			  4@4. 5@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 17:17'!testLineWallRightToLeftTopToBottom	| expectedWallPositions |	terrain addLineWallFrom: 4@ 1 to: 1@4  width: 3.	expectedWallPositions := {					4@1. 5@1. 6@1.				3@2. 4@2. 5@2.			2@3. 3@3. 4@3.		1@4. 2@4. 3@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions	! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 21:38'!testLineWallRightToLeftTopToBottom2	| expectedWallPositions |	terrain addLineWallFrom:  3@1 to: 4@4 width: 2.	expectedWallPositions := {		3@1. 4@1.		3@2. 4@2.			  4@3. 5@3. 			  4@4. 5@4.	}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 10:53'!testSmallLineWall	|expectedWallPositions|	terrain addLineWallFrom: 5@5 to: 5@5 width: 3.	expectedWallPositions := {5@5. 6@5. 7@5}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 17:29'!testVerticalLineWallBottomToTop	| expectedWallPositions |	terrain addLineWallFrom: 5 @ 6 to: 5@3 width: 2.	expectedWallPositions := {		5@3. 6@3.		5@4. 6@4.		5@5. 6@5.		5@6. 6@6.			}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTerrainTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/15/2011 17:24'!testVerticalLineWallTopToBottom	| expectedWallPositions |	terrain addLineWallFrom: 5 @ 3 to: 5@6 width: 2.	expectedWallPositions := {		5@3. 6@3.		5@4. 6@4.		5@5. 6@5.		5@6. 6@6.			}.	self assertCellsAreEmptyExceptAll: expectedWallPositions! !!BGSTestCoverageDefinition class methodsFor: 'coverage' stamp: 'NouryBouraqadi 11/25/2011 16:37'!packageNamesUnderTest	^#('BotGridSimulator')! !!BGSTestCoverageDefinition class methodsFor: 'coverage' stamp: 'NouryBouraqadi 12/16/2011 17:44'!testPackagesForContinuousIntegration	^SystemOrganization categories select: [:categoryName|		'BotGridSimulator*Test*' match: categoryName]! !!BGSGridEditorWindow class methodsFor: 'instance creation' stamp: 'LucFabresse 4/1/2012 10:31'!editGrid: grid 	^self displayGrid: grid cellExtent: BGSGridView defaultCellExtent 		! !!BGSGridEditorWindow class methodsFor: 'instance creation' stamp: 'LucFabresse 4/1/2012 08:34'!editNewGridOfSize: size	^self editGrid: ( BGSGrid extent: size )! !!BGSGridEditorWindow class methodsFor: 'instance creation' stamp: 'LucFabresse 4/1/2012 10:39'!editNewGridOfSize: size withCellExtent: cellSize	^self  displayGrid: ( BGSGrid extent: size ) cellExtent: cellSize! !!BGSGridEditorWindow methodsFor: 'initialize-release' stamp: 'LucFabresse 4/1/2012 13:09'!gridViewClass	^BGSClickableGridView ! !!BGSGridEditorWindow methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/2/2012 09:40'!printGridAsEvalString	 | stream |		stream := WriteStream on: (String new: (self gridView grid cells size *  self gridView grid cells size)).		stream nextPutAll: 'BGSGrid new' ; lf.		self gridView grid cells do: [ :cell | 		cell content isNil not ifTrue: [ 				stream nextPutAll: ' addWallAt: ';				nextPutAll: cell position printString;				nextPutAll: ' ;' 		]	].			stream nextPutAll: ' yourself .' ; lf.				^stream contents! !!BGSGridWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 12/13/2011 23:25'!displayGrid: grid cellExtent: aPoint	^self new		displayGrid: grid cellExtent: aPoint;		yourself! !!BGSGridWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:25'!displayGrid: aBGSGrid cellExtent: aPoint	self gridView: (self gridViewClass on: aBGSGrid).	self gridView cellExtent: aPoint.	self displayGridView.! !!BGSGridWindow methodsFor: 'displaying' stamp: 'NouryBouraqadi 12/13/2011 23:35'!displayGridView	| newExtent deltaWidth board deltaHeight |	board := AlignmentMorph newRow.	board extent: self gridView extent.	board addMorphBack: self gridView.	deltaWidth := 2 * (self borderWidth + self class borderWidth).	deltaHeight := 2 * (self borderWidth + self class borderWidth) + self labelHeight.	newExtent := board fullBounds extent + (deltaWidth @ deltaHeight).	self extent: newExtent.	self addMorph: board frame: (0 @ 0 extent: 1 @ 1)! !!BGSGridWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 22:46'!gridView	^ gridView! !!BGSGridWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 22:46'!gridView: anObject	gridView := anObject! !!BGSGridWindow methodsFor: 'accessing' stamp: 'LucFabresse 4/1/2012 10:29'!gridViewCellExtent.	^self gridView cellExtent! !!BGSGridWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 22:47'!gridViewClass	^BGSGridView ! !!BGSGridWindow methodsFor: 'displaying' stamp: 'NouryBouraqadi 12/13/2011 22:53'!openInWorld	self openAsIs ! !!BGSGridWindow methodsFor: 'displaying' stamp: 'NouryBouraqadi 12/13/2011 22:53'!wantsExpandBox	^false! !!BGSGridWindow methodsFor: 'displaying' stamp: 'NouryBouraqadi 12/13/2011 22:53'!wantsGrips	^false! !!BGSRobotMapWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/14/2011 14:22'!gridViewClass 	^BGSExplorationMapView ! !!BGSChristmasSimulationWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 12/18/2011 20:10'!on: simulation	(super on: simulation)		position: 40@0;		yourself! !!BGSChristmasSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 10:09'!gridViewClass	^BGSChristmasGridView ! !!BGSExplorationSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:32'!addButtonsToPanel: panel	|botMapsButton|	botMapsButton := self makeButton: 'Robot Maps' action: #showRobotMaps state: nil target: self. 	panel addMorph: botMapsButton.	super addButtonsToPanel: panel.! !!BGSExplorationSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/7/2011 16:43'!addCountersToPanel: panel 	| frontierView unexploredView |	self frontierCounterMorph: (LabelMorph contents: '0').	frontierView := self wrapMorph: self frontierCounterMorph andAddLabel: 'Frontier cells'. 			self unexploredCounterMorph: (LabelMorph contents: '1000').	unexploredView := self wrapMorph: self unexploredCounterMorph andAddLabel: 'Unexplored cells'.	{frontierView. unexploredView} do: [:view|	panel 		addMorph: view		fullFrame: (LayoutFrame 				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (4 @ 4 corner: -8 @ 44)).	].	super addCountersToPanel: panel! !!BGSExplorationSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/7/2011 16:43'!frontierCounterMorph	^ frontierCounterMorph! !!BGSExplorationSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/7/2011 16:43'!frontierCounterMorph: anObject	frontierCounterMorph := anObject! !!BGSExplorationSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 22:45'!gridViewClass	^BGSExplorableGridView ! !!BGSExplorationSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:42'!robotMapCellExtent	^3@3! !!BGSExplorationSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:41'!showRobotMaps	self simulation robots do: [:bot|		|window|		window := BGSRobotMapWindow displayGrid: bot map cellExtent: self robotMapCellExtent.		window setLabel: bot id.		window openInWorld		]! !!BGSExplorationSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/7/2011 16:43'!unexploredCounterMorph	^ unexploredCounterMorph! !!BGSExplorationSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/7/2011 16:43'!unexploredCounterMorph: anObject	unexploredCounterMorph := anObject! !!BGSExplorationSimulationWindow methodsFor: 'display' stamp: 'NouryBouraqadi 12/7/2011 16:45'!update: anObject	super update: anObject.	self frontierCounterMorph contents: self simulation frontierPositionsCount printString.	self unexploredCounterMorph contents: self simulation unexploredPositionsCount printString.! !!BGSSimulationWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 5/4/2012 10:29'!defaultGridCellExtent 	^10@10! !!BGSSimulationWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 5/4/2012 10:29'!on: aSimulation	^self on: aSimulation terrainCellExtent: self defaultGridCellExtent ! !!BGSSimulationWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 5/4/2012 10:34'!on: aSimulation  terrainCellExtent: aPoint	^self new		 gridCellExtent: aPoint;		simulation: aSimulation;		openInWorld;		yourself! !!BGSSimulationWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/12/2011 18:00'!onClass: aSimulationClass	^self on: aSimulationClass new! !!BGSSimulationWindow class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 5/4/2012 10:25'!onClass: aSimulationClass terrainCellExtent: aPoint	^self on: aSimulationClass new terrainCellExtent: aPoint! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/6/2011 18:56'!addButtonsToPanel: panel	| stepBtn runBtn pauseBtn resetBtn inspectBtn|	runBtn := self makeButton: 'Run' action: #run state: #isPaused.	pauseBtn := self makeButton: 'Pause' action: #pause state: #isRunning.	stepBtn := self makeButton: 'Step' action: #stepIfPaused state: #isPaused.	resetBtn := self makeButton: 'Reset' action: #resetSimulation state: #canResetSimulation target: self. 	inspectBtn := self makeButton: 'Inspect' action: #inspect state: nil. 	{inspectBtn. resetBtn. pauseBtn. runBtn. stepBtn} do: [:button|		panel addMorph: button]! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/6/2011 18:58'!addCountersToPanel: panel 	| stepsView |	self stepCounterMorph: (LabelMorph contents: '0').	stepsView := self wrapMorph: self stepCounterMorph andAddLabel: 'Steps:'. 	panel 		addMorph: stepsView		fullFrame: (LayoutFrame 				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (4 @ 4 corner: -8 @ 44))! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:33'!buttonsWidth	^150! !!BGSSimulationWindow methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 11:25'!canResetSimulation	^self simulation isRunning not! !!BGSSimulationWindow methodsFor: 'displaying' stamp: 'LucFabresse 4/2/2012 15:33'!displayGridView	| newExtent deltaWidth board deltaHeight |	board := AlignmentMorph newRow.	board extent: self gridView extent + (self buttonsWidth @ 0).	board addMorphBack: self newControlPanelMorph.	board addMorphBack: self gridView.	deltaWidth := 2 * (self borderWidth + self class borderWidth).	deltaHeight := 2 * (self borderWidth + self class borderWidth) + self labelHeight.	newExtent := board fullBounds extent + (deltaWidth @ deltaHeight).	self extent: newExtent.	self addMorph: board frame: (0 @ 0 extent: 1 @ 1)! !!BGSSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 5/4/2012 10:27'!gridCellExtent	^ gridCellExtent! !!BGSSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 5/4/2012 10:27'!gridCellExtent: anObject	gridCellExtent := anObject! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/22/2011 11:17'!makeButton:  aString action: actionSelector state: stateSelector	 ^self makeButton:  aString action: actionSelector state: stateSelector target: self simulation		! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/22/2011 11:15'!makeButton:  aString action: actionSelector state: stateSelector target: target	| btn labelMorph |	btn := PluggableButtonMorph 		on: target		getState: stateSelector		action: actionSelector.	labelMorph := StringMorph contents: aString.	labelMorph emphasis: 1.	btn		label: labelMorph;		useRoundedCorners;		hResizing: #spaceFill;		onColor: self onButtonColor offColor: self offButtonColor;		borderWidth: 2;		borderColor: #raised.	btn label color: Color darkGray.	btn extent: self buttonsWidth @ 50. "50 is not an important value since it will be changed by the enclosing alignment morph"	^btn! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 22:46'!newControlPanelMorph	| panel |	panel := AlignmentMorph newColumn.	panel color: Color darkGray.	panel extent: self buttonsWidth @ self gridView extent y.	self addCountersToPanel: panel.	self addButtonsToPanel: panel.	^ panel! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/12/2011 17:45'!offButtonColor 	^Color white! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/12/2011 17:45'!onButtonColor 	^Color green ! !!BGSSimulationWindow methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 11:31'!resetSimulation	| shouldReset |	self canResetSimulation ifFalse: [^self].	shouldReset := self proceed: 'Do you really want to reset the simulation?' title: 'Reset simulation?' .	shouldReset ifFalse: [^self].	self simulation reset! !!BGSSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/10/2011 22:31'!simulation	^ simulation! !!BGSSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 5/4/2012 10:26'!simulation: newSimulation	simulation := newSimulation.	simulation addDependent: self.	self displayGrid: simulation terrain cellExtent: self gridCellExtent.	self update: newSimulation! !!BGSSimulationWindow methodsFor: 'displaying' stamp: 'NouryBouraqadi 11/12/2011 17:20'!simulationStatusString	self simulation autoStopConditionReached ifTrue: [^'Stop condition reached'].	self simulation isPaused ifTrue: [^'Paused'].	^'Running'! !!BGSSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/10/2011 22:31'!stepCounterMorph	^ stepCounterMorph! !!BGSSimulationWindow methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/10/2011 22:31'!stepCounterMorph: anObject	stepCounterMorph := anObject! !!BGSSimulationWindow methodsFor: 'displaying' stamp: 'NouryBouraqadi 12/13/2011 23:03'!update: anObject	super update: anObject.	self setLabel: self simulation name, ' - ', self simulationStatusString.	self stepCounterMorph contents: self simulation stepCount printString.! !!BGSSimulationWindow methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/13/2011 11:56'!wrapMorph: aMorph andAddLabel: aString    "creates a wrapping panel for aMorph with  a label above it"    | column strM |    column := AlignmentMorph newColumn                wrapCentering: #topLeft;                cellPositioning: #topLeft;                hResizing: #spaceFill;                vResizing: #shrinkWrap;                borderWidth: 2;                layoutInset: 5;                color: Color transparent;                useRoundedCorners;                borderStyle: (BorderStyle complexAltInset width: 2).    column addMorph: aMorph.    strM := StringMorph contents: aString.    strM color: Color veryVeryLightGray.    column addMorph: strM.    ^ column ! !!BGSBodyPart class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 12/10/2011 21:53'!botBody: robotBody name: aSymbol	^self new		botBody: robotBody name: aSymbol;		yourself! !!BGSBodyPart methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/13/2011 21:20'!acceptVisitor: aVisitor	self subclassResponsibility! !!BGSBodyPart methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 19:28'!botBody	^ botBody! !!BGSBodyPart methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/11/2011 10:05'!botBody: robotBody name: aSymbol	botBody := robotBody.	name := aSymbol.	botBody addPart: self named: aSymbol ! !!BGSBodyPart methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 10:17'!cell	^self botBody cell! !!BGSBodyPart methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 18:27'!isAcceptingVisitorsByDefault	^true! !!BGSBodyPart methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 10:05'!name	^name! !!BGSBodyPart methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 19:28'!position 	^self botBody position! !!BGSBodyPart methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 19:29'!terrain	^self botBody terrain! !!BGSDirectionalRangeSensor class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 12/11/2011 09:56'!botBody: robotBody name: sensorName range: maxDistanceToObstacle	^(self botBody: robotBody name: sensorName)		range: maxDistanceToObstacle;		yourself! !!BGSDirectionalRangeSensor methodsFor: 'visiting' stamp: 'FedericoBalaguer 8/22/2015 19:13'!acceptVisitor: aVisitor	aVisitor visitDirectionalRangeSensor: self 	! !!BGSDirectionalRangeSensor methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/28/2011 19:38'!defaultRange	^1! !!BGSDirectionalRangeSensor methodsFor: 'sensing' stamp: 'NouryBouraqadi 11/19/2011 10:32'!distanceToObstacle	1 to: self range do: [:distance|		(self isObstacleAtDistance: distance) ifTrue: [^distance - 1].	].	^self range! !!BGSDirectionalRangeSensor methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/19/2011 10:35'!heading	^self botBody heading! !!BGSDirectionalRangeSensor methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/28/2011 19:37'!initialize 	super initialize.	self range: self defaultRange! !!BGSDirectionalRangeSensor methodsFor: 'sensing' stamp: 'NouryBouraqadi 11/19/2011 10:51'!isObstacleAtDistance: distance	|cellPosition|	cellPosition := self position + (distance * self heading).	^(self terrain isEmptyCellAt: cellPosition) not! !!BGSDirectionalRangeSensor methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/28/2011 19:38'!range	^ range! !!BGSDirectionalRangeSensor methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/28/2011 19:37'!range: anObject	range := anObject! !!BGSOmnidirectionalRangeSensor methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/13/2011 21:20'!acceptVisitor: aVisitor	aVisitor visitOmnidirectionalRangeSensor: self! !!BGSOmnidirectionalRangeSensor methodsFor: 'sensing' stamp: 'NouryBouraqadi 12/13/2011 21:17'!emptySensedPositions	^self sensedPositions select: [:position|		self terrain isEmptyCellAt: position]! !!BGSOmnidirectionalRangeSensor methodsFor: 'sensing' stamp: 'NouryBouraqadi 12/13/2011 21:40'!obstacleSensedPositions	^self sensedPositions reject: [:position|		self terrain isEmptyCellAt: position]! !!BGSOmnidirectionalRangeSensor methodsFor: 'sensing' stamp: 'NouryBouraqadi 12/13/2011 21:17'!sensedPositions	^self terrain positionsAround: self position! !!BGSWireless class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 12/11/2011 10:16'!botBody: robotBody name: sensorName range: maxDistanceToDetectedPeers	^(self botBody: robotBody name: sensorName)		range: maxDistanceToDetectedPeers;		yourself! !!BGSWireless methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/13/2011 21:20'!acceptVisitor: visitor	visitor visitWireless: self! !!BGSWireless methodsFor: 'communicating' stamp: 'NouryBouraqadi 12/13/2011 17:05'!bot	^self botBody bot! !!BGSWireless methodsFor: 'communicating' stamp: 'NouryBouraqadi 12/13/2011 17:05'!botsInRange 	^self peers collect: [:wireless| wireless bot]! !!BGSWireless methodsFor: 'testing' stamp: 'federicobalaguer 9/7/2016 11:22'!isInRangeOf: aBot	^ aBot wireless range >= range! !!BGSWireless methodsFor: 'communicating' stamp: 'NouryBouraqadi 12/11/2011 10:12'!peerAt: cell	cell content ifNil: [^nil].	^cell content part: self name! !!BGSWireless methodsFor: 'communicating' stamp: 'NouryBouraqadi 12/11/2011 10:11'!peers	| peers |	peers := Set new.	(self terrain cellsAround: self cell range: self range) do: [:cell|		(self peerAt: cell) ifNotNilDo: [:wireless| peers add: wireless]	].	^peers! !!BGSWireless methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 21:18'!range	^ range! !!BGSWireless methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 21:18'!range: anObject	range := anObject! !!BGSCar2012LogConverterToExcel class methodsFor: 'log processing'!convertToExcelFileAllLogsIn: fullDirectoryName	|fs experimentFiles allExperimentValues |		fs :=  FSFilesystem disk referenceTo: fullDirectoryName.	experimentFiles := fs glob: [ :node| (node basename beginsWith: 'result') and: [ node extension = 'st' ]]. 		allExperimentValues := Dictionary new.	experimentFiles do: [ :experimentFile | 		allExperimentValues at: experimentFile basename put: (self loadLog: experimentFile fullName) ].		self writeExcelFile: (fs / fs basename, 'xml') with: allExperimentValues.	! !!BGSCar2012LogConverterToExcel class methodsFor: 'log processing'!loadLog: fullFileName	|stream values|	stream := FileStream fileNamed: fullFileName.	stream readOnly.	values := OrderedCollection new.		[ stream atEnd ] whileFalse: [ 		| line |		line := stream nextLine.		(line first = ${) ifTrue: [			values add: (Compiler evaluate: line)		] ifFalse: [ 			values add: (Array with: line)		]	].	^values	! !!BGSCar2012LogConverterToExcel class methodsFor: 'excel writing'!writeExcelFile: resultFileRef with: experimentValuesDict	| stream |		stream := resultFileRef writeStream.	self writeHeaderOn: stream.	self writeStatisticsSpreadSheetOfValues: experimentValuesDict on: stream.	experimentValuesDict keys sort do: [ :spreadSheetName |		self writeSpreadSheetNamed: spreadSheetName withValues: (experimentValuesDict at: spreadSheetName) on: stream ].	self writeFooterOn: stream.	stream close! !!BGSCar2012LogConverterToExcel class methodsFor: 'excel writing'!writeFooterOn: stream		stream nextPutAll: '</Workbook>'! !!BGSCar2012LogConverterToExcel class methodsFor: 'excel writing'!writeHeaderOn: stream		stream nextPutAll: '<?xml version="1.0"?>';lf;		nextPutAll: '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">'; lf! !!BGSCar2012LogConverterToExcel class methodsFor: 'excel writing'!writeSpreadSheetNamed: spreadSheetName withValues: values on: stream		stream nextPutAll: '<Worksheet ss:Name="';		nextPutAll: spreadSheetName;		nextPutAll: '">'; lf;		nextPutAll: '<Table>'; lf.			values do: [ :row | 		stream nextPutAll: '   <Row>'; lf.				row do: [ :value | 			stream nextPutAll: '      <Cell>'.			self writeValue: value on: stream.			stream nextPutAll: '</Cell>';lf.		].		stream nextPutAll: '   </Row>'; lf.	].	stream nextPutAll: '</Table>'; lf;		nextPutAll: '</Worksheet>'; lf! !!BGSCar2012LogConverterToExcel class methodsFor: 'excel writing'!writeStatisticsSpreadSheetOfValues: experimentValuesDict on: stream		stream nextPutAll: '<Worksheet ss:Name="';		nextPutAll: 'Statistics';		nextPutAll: '">'; lf;		nextPutAll: '<Table>'; lf;		nextPutAll: '   <Row>'; lf;		nextPutAll: '      <Cell><Data ss:Type="String">nbOfRobots</Data></Cell>';lf;		nextPutAll: '      <Cell><Data ss:Type="String">nbOfSteps</Data></Cell>';lf;		nextPutAll: '   </Row>'; lf.		experimentValuesDict keys sort do: [ :spreadSheetName |		stream nextPutAll: '   <Row>'; lf.		stream nextPutAll: '<Cell ss:Formula="=''';			nextPutAll: spreadSheetName;			nextPutAll: '''!!R4C1"><Data ss:Type="Number"></Data></Cell>';lf;			nextPutAll: '<Cell ss:Formula="=MAX(''';			nextPutAll: spreadSheetName;			nextPutAll: '''!!C1)"><Data ss:Type="Number"></Data></Cell>';			nextPutAll: '   </Row>'; lf.	].	stream 	nextPutAll: '</Table>';lf;		nextPutAll: '</Worksheet>'; lf! !!BGSCar2012LogConverterToExcel class methodsFor: 'excel writing'!writeValue: value on: stream	|type|		value isNumber 		ifTrue: [ type := 'Number' ]		ifFalse: [ type := 'String' ].		stream nextPutAll: '<Data ss:Type="';		nextPutAll: type;		nextPutAll: '">';		nextPutAll: value printString;		nextPutAll: '</Data>'! !!BGSCell class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/29/2011 12:05'!at: aPoint in: aGrid	^self new		grid: aGrid;		position: aPoint		yourself! !!BGSCell class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/29/2011 12:05'!wallAt: aPoint in: aGrid	^(self at: aPoint in: aGrid)		wall;		yourself! !!BGSCell methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:50'!acceptContentVisitor: aVisitor	self isEmpty		ifTrue: [ ^ self ].	self content acceptVisitor: aVisitor! !!BGSCell methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:50'!acceptVisitor: aVisitor	aVisitor visitCell: self.	self acceptContentVisitor: aVisitor! !!BGSCell methodsFor: 'content handling' stamp: 'federicobalaguer 9/6/2016 18:51'!changed	grid changed! !!BGSCell methodsFor: 'accessing'!color	^ color! !!BGSCell methodsFor: 'accessing'!color: anObject	color := anObject! !!BGSCell methodsFor: 'content handling' stamp: 'NouryBouraqadi 11/24/2011 15:22'!content	^ content! !!BGSCell methodsFor: 'content handling' stamp: 'NouryBouraqadi 12/14/2011 14:15'!content: anObject	content := anObject.	self updateCellOf: anObject! !!BGSCell methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 3/20/2012 21:13'!defaultColor	^ Color white! !!BGSCell methodsFor: 'content handling' stamp: 'NouryBouraqadi 11/24/2011 15:30'!empty	self content: nil! !!BGSCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:00'!grid	^ grid! !!BGSCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:00'!grid: anObject	grid := anObject! !!BGSCell methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 3/20/2012 21:12'!initialize 	super initialize.	self color: self defaultColor! !!BGSCell methodsFor: 'testing' stamp: 'NouryBouraqadi 11/24/2011 15:20'!isEmpty	^self content isNil! !!BGSCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:00'!position	^ position! !!BGSCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:00'!position: anObject	position := anObject! !!BGSCell methodsFor: 'printing' stamp: 'federicobalaguer 7/8/2014 15:13'!printOn: aStream	aStream nextPutAll: 'aCell at'.	self position printOn: aStream.	aStream nextPutAll: '. '.	self isEmpty		ifTrue: [ ^ aStream nextPutAll: #empty ].	self content printOn: aStream! !!BGSCell methodsFor: 'content handling' stamp: 'NouryBouraqadi 12/14/2011 14:15'!updateCellOf: anObject	anObject ifNotNil: [ anObject cell: self ]! !!BGSCell methodsFor: 'content handling' stamp: 'NouryBouraqadi 11/29/2011 12:01'!wall	self content: self wallClass new! !!BGSCell methodsFor: 'content handling' stamp: 'NouryBouraqadi 11/29/2011 12:02'!wallClass	^BGSWall! !!BGSExplorableCell methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:46'!acceptVisitor: aVisitor	self state acceptVisitor: aVisitor! !!BGSExplorableCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/1/2011 18:16'!content: anObject	super content: anObject.	self markExplored! !!BGSExplorableCell methodsFor: 'initialize-release'!defaultColor	^ Color green! !!BGSExplorableCell methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/28/2011 11:31'!initialize 	super initialize.	self state: BGSUnexploredCellState new ! !!BGSExplorableCell methodsFor: 'testing' stamp: 'NouryBouraqadi 11/29/2011 11:54'!isExplored	^self state isExplored! !!BGSExplorableCell methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 18:20'!isFrontier	self isExplored ifFalse: [^false].	self isEmpty ifFalse: [^false].	^self neighbors anySatisfy: [:aCell| aCell isExplored not]! !!BGSExplorableCell methodsFor: 'annotating' stamp: 'NouryBouraqadi 12/1/2011 18:16'!markExplored 	self state markExplored! !!BGSExplorableCell methodsFor: 'annotating' stamp: 'NouryBouraqadi 12/1/2011 19:01'!markUnexplored	self state markUnexplored! !!BGSExplorableCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 11:58'!neighbors 	^self grid cellsAround: self! !!BGSExplorableCell methodsFor: 'printing' stamp: 'NouryBouraqadi 12/1/2011 18:15'!printOn: aStream	self isExplored ifFalse: [^aStream nextPutAll: #unexplored].	super printOn: aStream! !!BGSExplorableCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/28/2011 11:31'!state	^ state! !!BGSExplorableCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/28/2011 11:38'!state: mapcellState	state := mapcellState.	mapcellState cell: self! !!BGSExplorationMapCell methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/14/2011 14:15'!updateCellOf: anObject	"Do nothing"	^self! !!BGSCellContent methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/11/2011 10:16'!acceptVisitor: aVisitor	aVisitor visitWall: self! !!BGSCellContent methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 10:16'!cell:  aCell	"Do nothing"	^self! !!BGSCellContent methodsFor: 'testing' stamp: 'federicobalaguer 10/6/2015 13:40'!isRobotBody	^ false! !!BGSCellContent methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 10:15'!part: aSymbol	^nil! !!BGSRangeSensorBeltRobotBody methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/11/2011 09:58'!initParts	super initParts.	BGSOmnidirectionalRangeSensor botBody: self name: #rangeSensorBelt ! !!BGSWirelessEnabledRangeSensorBeltRobotBody methodsFor: 'defaults' stamp: 'LucFabresse 4/3/2012 15:20'!defaultWirelessRange 	^10! !!BGSWirelessEnabledRangeSensorBeltRobotBody methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 16:37'!initParts	super initParts.	BGSWireless botBody: self name: #wireless range: self defaultWirelessRange ! !!BGSRobotBody class methodsFor: 'class initialization' stamp: 'NouryBouraqadi 11/17/2011 21:09'!initialize 	Headings := {(0 @ -1). (1 @ -1). (1 @ 0). (1 @ 1). (0 @ 1).  (-1 @ 1). (-1 @ 0). (-1 @ -1)}.! !!BGSRobotBody methodsFor: 'visiting' stamp: 'NouryBouraqadi 11/19/2011 12:29'!acceptVisitor: aVisitor	aVisitor visitRobotBody: self.! !!BGSRobotBody methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/10/2011 21:56'!addPart: newPart named:  newName	self partsDict at: newName put: newPart ! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 16:56'!bot	^ bot! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 16:56'!bot: anObject	bot := anObject! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:09'!cell	^ cell! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:09'!cell: anObject	cell := anObject! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 20:41'!goForward	self position: self position + self heading! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 20:42'!goForwardBy: steps	steps timesRepeat: [self goForward]! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/17/2011 17:43'!heading	^ heading! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 12/18/2011 19:12'!heading: aPoint	heading := aPoint.	self terrain ifNotNil: [self terrain changed] "Trigger observer updates"! !!BGSRobotBody methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/10/2011 15:12'!initParts	self partsDict: Dictionary new.! !!BGSRobotBody methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/10/2011 15:04'!initialize 	super initialize.	self heading: 0 @ -1.	self initParts.	! !!BGSRobotBody methodsFor: 'testing' stamp: 'federicobalaguer 10/6/2015 13:40'!isRobotBody	^ true! !!BGSRobotBody methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/29/2011 16:38'!jumpTo: aPoint in: aBGSTerrain 	aBGSTerrain put: self inCellAt: aPoint ! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 10:15'!part: id	^self partsDict at: id ifAbsent: [nil]! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 15:12'!parts	^self partsDict values! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 15:12'!partsDict	^ partsDict! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 15:12'!partsDict: anObject	partsDict := anObject! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 16:24'!position	^self cell position! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 11/29/2011 16:26'!position: aPoint 	self terrain move: self from: self position to: aPoint.! !!BGSRobotBody methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 16:23'!terrain	self cell ifNil: [^nil].	^self cell grid! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 21:09'!turnLeft	| currentHeadingIndex nextHeadingIndex |	currentHeadingIndex := Headings indexOf: self heading.	nextHeadingIndex := currentHeadingIndex = 1 		ifTrue: [8]		ifFalse: [currentHeadingIndex - 1].	self heading: (Headings at: nextHeadingIndex)! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 21:13'!turnRight	| currentHeadingIndex nextHeadingIndex |	currentHeadingIndex := Headings indexOf: self heading.	nextHeadingIndex := currentHeadingIndex = 8 		ifTrue: [1]		ifFalse: [currentHeadingIndex + 1].	self heading: (Headings at: nextHeadingIndex)! !!BGSRobotBody methodsFor: 'moving' stamp: 'NouryBouraqadi 11/29/2011 22:28'!turnTowards: aPoint	|directionVector|	directionVector := aPoint - self position.	self heading: directionVector x sign @ directionVector y sign! !!BGSRobotBodyWithFrontRangeSensor methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/19/2011 14:22'!defaultFrontSensorRange	^1! !!BGSRobotBodyWithFrontRangeSensor methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/11/2011 09:56'!initParts 	super initParts.	BGSDirectionalRangeSensor botBody: self name: #frontRangeSensor range: self defaultFrontSensorRange! !!BGSWall methodsFor: 'polimorphic' stamp: 'federicobalaguer 10/6/2015 13:30'!bot	^ nil! !!BGSWall methodsFor: 'printing' stamp: 'NouryBouraqadi 11/28/2011 11:59'!printOn: aStream	aStream nextPutAll: #wall! !!BGSExplorableCellState methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/7/2011 16:59'!acceptVisitor: visitor	self subclassResponsibility ! !!BGSExplorableCellState methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/28/2011 11:38'!cell	^ cell! !!BGSExplorableCellState methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/28/2011 11:38'!cell: anObject	cell := anObject! !!BGSExplorableCellState methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/7/2011 17:00'!isExplored	self subclassResponsibility ! !!BGSExplorableCellState methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/7/2011 17:00'!markExplored	self subclassResponsibility ! !!BGSExplorableCellState methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/7/2011 17:00'!markUnexplored	self subclassResponsibility ! !!BGSExploredCellState methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:50'!acceptVisitor: aVisitor	self cell isFrontier ifTrue: [^aVisitor visitFrontierCell: self cell].	aVisitor visitCell: self cell.	self cell acceptContentVisitor: aVisitor! !!BGSExploredCellState methodsFor: 'testing' stamp: 'NouryBouraqadi 12/1/2011 18:18'!isExplored 	^true! !!BGSExploredCellState methodsFor: 'annotating' stamp: 'NouryBouraqadi 12/1/2011 18:17'!markExplored 	"I'm already explored"	^self! !!BGSExploredCellState methodsFor: 'annotating' stamp: 'NouryBouraqadi 12/1/2011 19:01'!markUnexplored	self cell state: BGSUnexploredCellState new! !!BGSUnexploredCellState methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:51'!acceptVisitor: aVisitor	aVisitor visitUnexploredCell: self cell! !!BGSUnexploredCellState methodsFor: 'testing' stamp: 'NouryBouraqadi 11/29/2011 11:55'!isExplored 	^false! !!BGSUnexploredCellState methodsFor: 'annotating' stamp: 'NouryBouraqadi 12/1/2011 18:12'!markExplored 	self cell state: BGSExploredCellState new! !!BGSUnexploredCellState methodsFor: 'annotating' stamp: 'NouryBouraqadi 12/1/2011 19:01'!markUnexplored	"I am already unexplored"	^self! !!BGSExplorableGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/30/2011 22:56'!cellClass	^BGSExplorableCell! !!BGSExplorableGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 11:51'!exploredPositions 	^self positions asSet select: [:aPoint| (self cellAt: aPoint) isExplored]! !!BGSExplorableGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 20:22'!frontierPositions  	^self positions asSet select: [:aPoint| (self cellAt: aPoint) isFrontier]! !!BGSExplorableGrid methodsFor: 'exploring' stamp: 'NouryBouraqadi 4/3/2012 20:28'!markExplored	self cells do: [:each| each markExplored].! !!BGSExplorableGrid methodsFor: 'annoting' stamp: 'NouryBouraqadi 12/1/2011 19:00'!markUnexploredCellAt: aPoint	(self cellAt: aPoint) markUnexplored! !!BGSExplorableGrid methodsFor: 'annoting' stamp: 'NouryBouraqadi 12/1/2011 20:08'!markUnexploredPositions: positions	positions do: [:aPoint|		self markUnexploredCellAt: aPoint]! !!BGSExplorableGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/1/2011 20:07'!reset	super reset.	self markUnexploredPositions: self positions.! !!BGSExplorableGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 20:30'!unexploredPositions  	^self positions asSet reject: [:aPoint| (self cellAt: aPoint) isExplored]! !!BGSCheckerboardLikeTerrain methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/30/2011 23:22'!buildWalls	|interObstacleSpace|	interObstacleSpace := 5.	interObstacleSpace to: (self extent x - interObstacleSpace) by: interObstacleSpace do: [:x|		interObstacleSpace to: (self extent y - interObstacleSpace) by: interObstacleSpace do: [:y|			self addWallAt: x@y]]! !!BGSChristmasTerrain methodsFor: 'obstacles' stamp: 'NouryBouraqadi 12/18/2011 10:25'!addHorizontalLineWallFrom: origin to: corner width: width color: aColor	| start stop|	origin x < corner x 		ifTrue: [			start := origin.			stop := corner]		ifFalse: [			start := corner.			stop := origin].	self addWallAt: start extent: (stop x - start x + 1) @width  color: aColor! !!BGSChristmasTerrain methodsFor: 'obstacles' stamp: 'NouryBouraqadi 12/18/2011 10:25'!addLineWallFrom: origin to: corner width: width color: aColor	| a b |	"y = a . x + b"	origin x = corner x		ifTrue: [ ^ self addVerticalLineWallFrom: origin to: corner width: width color: aColor].	origin y = corner y		ifTrue: [ ^ self addHorizontalLineWallFrom: origin to: corner width: width  color: aColor].	a := (origin y - corner y) / (origin x - corner x).	b := origin y - (a * origin x).	a abs < 1		ifTrue: [ 			^ self addXDrivenLineWallFrom: origin to: corner width: width a: a b: b  color: aColor].	self addYDrivenLineWallFrom: origin to: corner width: width a: a b: b  color: aColor! !!BGSChristmasTerrain methodsFor: 'obstacles' stamp: 'NouryBouraqadi 12/18/2011 10:29'!addVerticalLineWallFrom: origin to: corner width: width color: aColor	| start stop|	origin y < corner y 		ifTrue: [			start := origin.			stop := corner]		ifFalse: [			start := corner.			stop := origin].	self addWallAt: start extent: width@ (stop y - start y + 1)  color: aColor! !!BGSChristmasTerrain methodsFor: 'obstacles' stamp: 'NouryBouraqadi 12/18/2011 10:26'!addWallAt: origin extent: widthAndHeight color: aColor	| corner |	corner := origin + widthAndHeight - 1.	origin x to: corner x do: [:x|		origin y to: corner y do: [:y|			(self cellAt: x@y) color: aColor.			self put: BGSWall new inCellAt: x@y]].	self changed! !!BGSChristmasTerrain methodsFor: 'obstacles' stamp: 'NouryBouraqadi 12/18/2011 10:29'!addXDrivenLineWallFrom: origin to: corner width: width a: a b: b color: aColor	| startX endX |	startX := origin x min: corner x.	endX := origin x max: corner x.	startX to: endX do: [ :x | 		| y |		y := ((a * x) + b) rounded.		self addWallAt: x @ y extent: width @ 1 color: aColor]! !!BGSChristmasTerrain methodsFor: 'obstacles' stamp: 'NouryBouraqadi 12/18/2011 10:29'!addYDrivenLineWallFrom: origin to: corner width: width a: a b: b color: aColor	| startY endY |	startY := origin y min: corner y.	endY := origin y max: corner y.	startY to: endY do: [ :y | 		| x |		x := ((y - b) / a) rounded.		self addWallAt: x @ y extent: width @ 1 color: aColor]! !!BGSChristmasTerrain methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/17/2011 22:42'!buildLargeTreeAt: top	|topX topY|	topX := top x.	topY := top y.	self addLineWallFrom: top to: (topX+7)@(topY+9) width: 1.	self addLineWallFrom: top to: (topX-7)@(topY+9) width: 1.	self addLineWallFrom: (topX+6)@(topY+10) to: (topX+3)@(topY+10) width: 1.	self addLineWallFrom: (topX-6)@(topY+10) to: (topX-3)@(topY+10) width: 1.	self addLineWallFrom: (topX+4)@(topY+11) to: (topX+13)@(topY+20) width: 1.	self addLineWallFrom: (topX-4)@(topY+11) to: (topX-13)@(topY+20) width: 1.	self addLineWallFrom: (topX+12)@(topY+21) to: (topX+7)@(topY+21) width: 1.	self addLineWallFrom: (topX-12)@(topY+21) to: (topX-7)@(topY+21) width: 1.	self addLineWallFrom: (topX+8)@(topY+22) to: (topX+18)@(topY+30) width: 1.	self addLineWallFrom: (topX-8)@(topY+22) to: (topX-18)@(topY+30) width: 1.	self addLineWallFrom: (topX+17)@(topY+31) to: (topX+3)@(topY+31) width: 1.	self addLineWallFrom: (topX-17)@(topY+31) to: (topX-3)@(topY+31) width: 1.	self addWallAt: (topX-2)@(topY+31) extent: 5@10.	self emptyCellsAt: (topX-1)@(topY+31) extent: 3@9.! !!BGSChristmasTerrain methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/17/2011 23:21'!buildLittleTreeAt: top	|topX topY|	topX := top x.	topY := top y.	self addLineWallFrom: top to: (topX+4)@(topY+5) width: 1.	self addLineWallFrom: top to: (topX-4)@(topY+5) width: 1.	self addLineWallFrom: (topX+3)@(topY+6) to: (topX+5)@(topY+9) width: 1.	self addLineWallFrom: (topX-3)@(topY+6) to: (topX-5)@(topY+9) width: 1.	self addLineWallFrom: (topX+4)@(topY+10) to: (topX+7)@(topY+13) width: 1.	self addLineWallFrom: (topX-4)@(topY+10) to: (topX-7)@(topY+13) width: 1.	self addWallAt: (topX-1)@(topY+10) extent: 3@4.	self emptyCellsAt: topX@(topY+10) extent: 1@3.! !!BGSChristmasTerrain methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 19:49'!buildTreeAt: top halfWidth: segmentHalfWidth segmentHeight: segmentHeight increment: deltaXY baseHalfWidth: baseHalfWidth color: aColor	|topRight topLeft middleRight middleLeft bottomRight bottomLeft baseWidth|		topRight := top.	topLeft := top. 	3 timesRepeat: [		middleRight := (topRight x + deltaXY)@(topRight y + segmentHeight).		middleLeft := (topLeft x - deltaXY)@(topLeft y + segmentHeight).		bottomRight := topRight + (segmentHalfWidth@segmentHeight).		bottomLeft := topLeft +   (segmentHalfWidth negated@segmentHeight).		self addLineWallFrom: topRight to: bottomRight width: 1 color: aColor.		self addLineWallFrom: topLeft to: bottomLeft width: 1  color: aColor.		self addLineWallFrom: middleRight to: bottomRight width: 1  color: aColor.		self addLineWallFrom: middleLeft to: bottomLeft width: 1 color: aColor.		self emptyCellAt: bottomRight - (1@0).		self emptyCellAt: bottomLeft + (1@0).		topRight := middleRight.		topLeft := middleLeft.	].	self addLineWallFrom: middleRight to: middleLeft width: 1 color: aColor. 	self fillStartingAt: top+(0@1) color: Color green borderColor: aColor. 	middleLeft x - 1 to: middleRight x + 1 do: [:x|		(self cellAt: x@ middleRight y) empty].	baseWidth := (2 * baseHalfWidth) + 1.	self addWallAt: (top x - baseHalfWidth)@(middleRight y) extent: baseWidth@segmentHeight color: Color brown.	self emptyCellsAt:  (top x - baseHalfWidth)@(middleRight y) extent: baseWidth@segmentHeight! !!BGSChristmasTerrain methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 19:58'!buildWalls 	"Sky"	1 to: 50 do: [:x|		1 to: 20 do: [:y|			(self cellAt: x@y) color: Color blue]].	"Ground"	1 to: 50 do: [:x|		21 to: 50 do: [:y|			(self cellAt: x@y) color: Color gray]].	self buildTreeAt: 19@12 halfWidth: 7 segmentHeight: 9 increment: 4 baseHalfWidth: 2 color: Color black.	self buildTreeAt: 38@6 halfWidth: 5 segmentHeight: 6 increment: 2 baseHalfWidth: 1 color: Color black.! !!BGSChristmasTerrain methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 19:43'!fillStartingAt: aPoint color: aColor borderColor: borderColor	(self cellAt: aPoint) color = borderColor ifTrue: [^self].	(self cellAt: aPoint) color = aColor ifTrue: [^self].		(self cellAt: aPoint) color: aColor.	{1@0. -1@0. 0@1. 0@ -1} do: [:delta|		self fillStartingAt: aPoint + delta color: aColor borderColor: borderColor.	]! !!BGSExplorableTerrain methodsFor: 'updating' stamp: 'NouryBouraqadi 12/13/2011 21:41'!update: aRobot	aRobot sensedPositions do: [:aPoint| 		(self cellAt: aPoint) markExplored]! !!BGSExplorationMap methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/14/2011 14:16'!cellClass	^BGSExplorationMapCell! !!BGSExplorationMap methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/14/2011 14:03'!initialize 	super initialize.	self latestBotPosition: -1 @ -1  "Invalid point so it will be ignored on the first update "! !!BGSExplorationMap methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/14/2011 13:58'!latestBotPosition	^ latestBotPosition! !!BGSExplorationMap methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/14/2011 13:58'!latestBotPosition: anObject	latestBotPosition := anObject! !!BGSExplorationMap methodsFor: 'updating' stamp: 'NouryBouraqadi 4/3/2012 23:09'!update: aRobot	self		emptyCellAt: self latestBotPosition;		latestBotPosition: aRobot position;		put: aRobot body inCellAt: self latestBotPosition;		emptyCellsAtAllPositions:  aRobot emptySensedPositions;		addWallsAtPositions: aRobot obstacleSensedPositions! !!BGSExplorationMap methodsFor: 'updating' stamp: 'NouryBouraqadi 4/3/2012 21:07'!updateFrom: otherMap 	| emptyPositions positionsToConsider positionsToIgnore|	emptyPositions := self exploredPositions select: [:position| self isEmptyCellAt: position].	positionsToIgnore := emptyPositions copyWith: self latestBotPosition.	positionsToConsider := otherMap exploredPositions copyWithoutAll: positionsToIgnore.	positionsToConsider do: [:aPoint|		self put: (otherMap contentOfCellAt: aPoint) inCellAt: aPoint].	self emptyCellAt: otherMap latestBotPosition! !!BGSGrid class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/9/2011 08:19'!extent: aPoint	^self new		extent: aPoint;		yourself! !!BGSGrid methodsFor: 'building low-level' stamp: 'NouryBouraqadi 12/8/2011 11:03'!addHorizontalLineWallFrom: origin to: corner width: width	| start stop|	origin x < corner x 		ifTrue: [			start := origin.			stop := corner]		ifFalse: [			start := corner.			stop := origin].	self addWallAt: start extent: (stop x - start x + 1) @width! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!addLineWallFrom: origin to: corner width: width	| a b |	"y = a . x + b"	origin x = corner x		ifTrue: [ ^ self addVerticalLineWallFrom: origin to: corner width: width ].	origin y = corner y		ifTrue: [ ^ self addHorizontalLineWallFrom: origin to: corner width: width ].	a := (origin y - corner y) / (origin x - corner x).	b := origin y - (a * origin x).	a abs < 1		ifTrue: [ 			^ self addXDrivenLineWallFrom: origin to: corner width: width a: a b: b ].	self addYDrivenLineWallFrom: origin to: corner width: width a: a b: b! !!BGSGrid methodsFor: 'building low-level' stamp: 'NouryBouraqadi 12/8/2011 11:03'!addVerticalLineWallFrom: origin to: corner width: width	| start stop|	origin y < corner y 		ifTrue: [			start := origin.			stop := corner]		ifFalse: [			start := corner.			stop := origin].	self addWallAt: start extent: width@ (stop y - start y + 1)! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!addWallAt: aPoint	self addWallAt: aPoint extent: 1@1! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!addWallAt: origin extent: widthAndHeight	| corner |	corner := origin + widthAndHeight - 1.	origin x to: corner x do: [:x|		origin y to: corner y do: [:y|			self put: BGSWall new inCellAt: x@y]].	self changed! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!addWallsAtPositions: points	points do: [:each|		self addWallAt: each]! !!BGSGrid methodsFor: 'building low-level' stamp: 'NouryBouraqadi 12/8/2011 11:03'!addXDrivenLineWallFrom: origin to: corner width: width a: a b: b	| startX endX |	startX := origin x min: corner x.	endX := origin x max: corner x.	startX to: endX do: [ :x | 		| y |		y := ((a * x) + b) rounded.		self addWallAt: x @ y extent: width @ 1 ]! !!BGSGrid methodsFor: 'building low-level' stamp: 'NouryBouraqadi 12/8/2011 11:03'!addYDrivenLineWallFrom: origin to: corner width: width a: a b: b	| startY endY |	startY := origin y min: corner y.	endY := origin y max: corner y.	startY to: endY do: [ :y | 		| x |		x := ((y - b) / a) rounded.		self addWallAt: x @ y extent: width @ 1 ]! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 11:03'!buildWalls	^self! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 12:06'!cellAt: aPoint	(self isValidPosition: aPoint) ifFalse: [^self cellClass wallAt: aPoint in: self].	^self cells at: aPoint x at: aPoint y! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/25/2011 20:16'!cellClass	^BGSCell! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 08:33'!cells	^ cells! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 08:33'!cells: anObject	cells := anObject! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/29/2011 20:26'!cellsAround: aCell 	^(self positionsAround: aCell position) collect: [:aPoint|		self cellAt: aPoint]! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 10:09'!cellsAround: aCell range: neighborRadius	^(self positionsAround: aCell position range: neighborRadius) collect: [:aPoint|		self cellAt: aPoint]! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 15:43'!contentOfCellAt: position	^(self cellAt: position) content! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/29/2011 12:05'!createCells	^Matrix rows: self extent x columns: self extent y tabulate: [:row :column| 			self cellClass at: row@column in: self]! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 21:53'!defaultExtent	^50@50! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!emptyCellAt: aPoint	(self cellAt: aPoint) empty.	self changed! !!BGSGrid methodsFor: 'accessing' stamp: 'LucFabresse 4/3/2012 14:25'!emptyCellPositions 	^self positions asSet select: [:aPoint| self isEmptyCellAt: aPoint]! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!emptyCellsAt: origin extent: widthAndHeight	| corner |	corner := origin + widthAndHeight - 1.	origin x to: corner x do: [:x|		origin y to: corner y do: [:y|			self emptyCellAt: x@y]]! !!BGSGrid methodsFor: 'building' stamp: 'NouryBouraqadi 12/8/2011 11:02'!emptyCellsAtAllPositions: points	points do: [:each|		self emptyCellAt: each]! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 08:20'!extent	^extent! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 11:03'!extent: aPoint	extent := aPoint.	self cells: self createCells.	self buildWalls ! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 21:53'!initialize 	super initialize.	self extent: self defaultExtent! !!BGSGrid methodsFor: 'testing' stamp: 'NouryBouraqadi 11/10/2011 19:24'!isEmptyCellAt: aPoint	^(self cellAt: aPoint) isEmpty! !!BGSGrid methodsFor: 'testing' stamp: 'NouryBouraqadi 11/10/2011 19:42'!isValidPosition: aPoint	aPoint ifNil: [^false].	^aPoint >= (1@1)  and: [aPoint <= self extent]! !!BGSGrid methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/24/2011 15:29'!makeEmptyCellAt: position	(self cellAt: position) empty! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 18:04'!move: botBody from: position1 to: position2	(self isValidPosition: position2) ifFalse: [^position1].	(self isEmptyCellAt: position2) ifFalse: [^position1].	self put: botBody inCellAt: position2.	(self isValidPosition: position1) ifTrue: [self makeEmptyCellAt: position1].	^position2			! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/15/2011 09:51'!positions	^self cells indicesCollect: [:x :y| x@y]! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/25/2011 09:43'!positionsAround: aPoint	^self positionsAround: aPoint range: 1! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/25/2011 09:42'!positionsAround: aPoint range: neighborRadius	| positions |	positions := OrderedCollection new: 8.	neighborRadius negated to: neighborRadius do: [:deltaX|		neighborRadius negated to: neighborRadius do: [:deltaY|			|newPosition|			newPosition := aPoint + (deltaX@deltaY).			positions add: newPosition]].	^positions select: [:each|		each ~= aPoint and: [self isValidPosition: each]]! !!BGSGrid methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 18:08'!put: anObject inCellAt: aPoint	(self cells at: aPoint x at: aPoint y) content: anObject.	self changed! !!BGSGrid methodsFor: 'initialize-release' stamp: 'federicobalaguer 9/28/2015 23:52'!reset 	self extent: self extent! !!BGSTerrainExample methodsFor: 'obstacle construction' stamp: 'NouryBouraqadi 11/19/2011 21:25'!buildWalls	"Left eye"	self addWallAt: 11@10 extent: 10@10.	self emptyCellsAt: 12@11 extent: 8@8.	"Right eye"	self addWallAt: 31@10 extent: 10@10.	self emptyCellsAt: 32@11 extent: 8@8.	"Mouth"	self addLineWallFrom:  11@35 to: 39@35 width: 1.	self addLineWallFrom: 11@35 to: 21@40  width: 2.	self addWallAt: 21@40 extent: 10@1.	self addLineWallFrom: 30@40 to: 39@35  width: 2.! !!BGSTerrainForTest methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 22:36'!defaultExtent	^10@10! !!BGSCar2012DoitLogger methodsFor: 'logging' stamp: 'LucFabresse 3/30/2012 18:09'!logHeader 	| columnNames |	columnNames := #('step' 'frontiers' 'unexplored') asOrderedCollection.			self robots collect: [:bot|		columnNames add: bot id, '-position'.		columnNames add: bot id, '-heading'	].	self logValues: columnNames asArray! !!BGSCar2012DoitLogger methodsFor: 'logging' stamp: 'LucFabresse 3/30/2012 18:11'!logStep	| currentValues |		currentValues := OrderedCollection new.		{self stepCount. self frontiersCount. self unexploredCount} 		do: [:counter| currentValues add: counter].	self robots		do: [ :bot | 		currentValues add: bot position;			add: bot heading	].		self logValues: currentValues! !!BGSCar2012DoitLogger methodsFor: 'initialize-release' stamp: 'LucFabresse 3/30/2012 18:09'!logValues: values		self log: '{ '.		values do: [ :aValue | 				(aValue  isKindOf: String) 					ifTrue: [ self log: aValue printString ] 					ifFalse: [ self log: aValue].				self log: '. '		].		self logLf: '}.'	! !!BGSCar2012DoitLogger methodsFor: 'initialize-release' stamp: 'LucFabresse 3/30/2012 18:10'!simulation: aBGSSimulation fileName: aString	fileName := aString.	simulation := aBGSSimulation.	self stream: (FileStream fileNamed: fileName).		self stream 		nextPut: $";		print: DateAndTime now; 		nextPut: $"; lf;		nextPut: $";		nextPutAll: self simulation class name;		nextPutAll: ' runFor:  ';		print: self robots size;		nextPutAll: ' logFileName: ';		print: fileName; 		nextPut: $"; lf.			self logValues: {'numberOfRobots'};		logValues: {self robots size}.			simulation addDependent: self.	self logHeader! !!BGSExplorationLogger methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/8/2011 17:32'!frontiersCount 	^self simulation frontierPositionsCount ! !!BGSExplorationLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 12/8/2011 17:40'!logHeader 	#('step' 'frontiers' 'unexplored') 		do: [:counterName| self log: counterName]		separatedBy: [self tab].	self robots do: [:bot|		self 			tab;			log: bot id, '-position';			tab;			log: bot id, '-heading'	].	self cr.! !!BGSExplorationLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 12/8/2011 17:42'!logStep	{self stepCount. self frontiersCount. self unexploredCount} 		do: [:counter| self log: counter]		separatedBy: [self tab].	self robots		do: [ :bot | 		self 			tab			log: bot position;			tab;			log: bot heading	].	self cr.! !!BGSExplorationLogger methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/8/2011 17:32'!unexploredCount 	^self simulation unexploredPositionsCount ! !!BGSLogger class methodsFor: 'instance creation' stamp: 'JulianGrigera 8/21/2015 19:21'!on: aBGSSimulation	| fileName timestampString |	timestampString := String streamContents: [ :stream | DateAndTime now printSeparateDateAndTimeOn: stream ].	fileName := aBGSSimulation className , timestampString , '.txt'.	^ self on: aBGSSimulation logInto: fileName! !!BGSLogger class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/13/2011 21:18'!on: aBGSSimulation logInto: fileName	|cleanFileName|	cleanFileName := fileName		replaceAll:  Character space with: $-;		replaceAll: $: with: $-. 	^self new		simulation: aBGSSimulation fileName: fileName;		yourself! !!BGSLogger methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/13/2011 19:36'!allLog	^self stream contents ! !!BGSLogger methodsFor: 'initialize-release' stamp: 'lvt 10/18/2007 10:20'!close	self stream close.! !!BGSLogger methodsFor: 'logging' stamp: 'lvt 10/18/2007 11:33'!cr	self stream cr.! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/6/2011 22:10'!crLog: anObject	self stream cr.	self log: anObject! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/6/2011 21:50'!crtab	self stream crtab! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/6/2011 22:10'!crtabLog: anObject	self stream crtab.	self log: anObject! !!BGSLogger methodsFor: 'accessing' stamp: 'lvt 10/18/2007 09:36'!fileName	^ fileName! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/7/2011 08:11'!log: anObject 	(anObject isKindOf: String) ifTrue: [^self stream nextPutAll: anObject].	anObject printOn: self stream! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/6/2011 22:11'!logCr: anObject	self log: anObject.	self stream cr! !!BGSLogger methodsFor: 'logging'!logCrLf: anObject	self log: anObject.	self stream crlf! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 12/8/2011 17:11'!logHeader	self log: 'step'.	self robots do: [:bot|		self 			tab;			log: bot id, '-position';			tab;			log: bot id, '-heading'	].	self cr.! !!BGSLogger methodsFor: 'logging'!logLf: anObject	self log: anObject.	self stream lf! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 12/6/2011 18:52'!logStep	self log: self stepCount.	self robots		do: [ :bot | 		self 			tab			log: bot position;			tab;			log: bot heading	].	self cr.! !!BGSLogger methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/13/2011 19:56'!robots	^self simulation robots! !!BGSLogger methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/13/2011 19:23'!simulation	^ simulation! !!BGSLogger methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/13/2011 20:08'!simulation: aBGSSimulation fileName: aString	fileName := aString.	self stream: (FileStream fileNamed: fileName).	simulation := aBGSSimulation.	simulation addDependent: self.	self logHeader.	self update: simulation! !!BGSLogger methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/6/2011 18:52'!stepCount	^self simulation stepCount! !!BGSLogger methodsFor: 'accessing' stamp: 'lvt 10/18/2007 10:08'!stream	^ stream! !!BGSLogger methodsFor: 'initialize-release' stamp: 'lvt 10/18/2007 10:08'!stream: anObject	stream := anObject! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/6/2011 21:50'!tab	self stream tab! !!BGSLogger methodsFor: 'logging' stamp: 'NouryBouraqadi 11/13/2011 20:15'!update: anObject	self logStep! !!BGSFrontierExplorerRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/24/2011 19:25'!bodyClass 	^BGSRangeSensorBeltRobotBody! !!BGSFrontierExplorerRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/13/2011 21:15'!emptySensedPositions	^self rangeSensorBelt emptySensedPositions! !!BGSFrontierExplorerRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 22:33'!exploredPositions	^self map exploredPositions! !!BGSFrontierExplorerRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 23:46'!frontierPositions	^self map frontierPositions! !!BGSFrontierExplorerRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/12/2011 18:27'!frontierPositionsSorted	^self frontierPositions asOrderedCollection! !!BGSFrontierExplorerRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 19:23'!jumpTo: aPoint in: terrain	super jumpTo: aPoint in: terrain.	self map: (BGSExplorationMap extent: terrain extent).	self map emptyCellAt: aPoint.	{terrain. (self map)} do:  [:grid| self addDependent: grid].	self changed! !!BGSFrontierExplorerRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/24/2011 23:30'!map	^map! !!BGSFrontierExplorerRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/11/2011 22:33'!map: anObject	map := anObject! !!BGSFrontierExplorerRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/13/2011 21:15'!obstacleSensedPositions	^self rangeSensorBelt obstacleSensedPositions! !!BGSFrontierExplorerRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 1/10/2012 17:35'!pathTo: targetPosition 	"Answers a sequence of positions of adjacent cells that lead from current position to targetPosition"	"We use A-* algo" 		|consideredPositions positionsToConsider path gScoreDict cameFromDict fScoreDict neighborExploredPositions |	consideredPositions := Set new.	positionsToConsider := Set with: self position.	cameFromDict := Dictionary new.	gScoreDict := Dictionary newFrom: {self position -> 0}.	fScoreDict := Dictionary newFrom: {self position -> (self position dist: targetPosition)}.	[positionsToConsider isEmpty] whileFalse: [		|currentPosition neighborEmptyPositions nonProcessedNeighbors|		currentPosition := (positionsToConsider asSortedCollection: [:a :b| (fScoreDict at: a) <  (fScoreDict at: b)]) first.		currentPosition = targetPosition ifTrue: [^self pathTo: targetPosition throughDict: cameFromDict].		positionsToConsider remove: currentPosition.		consideredPositions add: currentPosition.		neighborExploredPositions :=  (self map positionsAround: currentPosition) select: [:each| (self map cellAt: each) isExplored].		neighborEmptyPositions := neighborExploredPositions select: [:each| self map isEmptyCellAt: each].		nonProcessedNeighbors := neighborEmptyPositions copyWithoutAll: consideredPositions.		nonProcessedNeighbors do: [:position|			|tentativeGScore tentativeIsBetter|			tentativeGScore := (gScoreDict at: currentPosition) +  1. "(currentPosition dist: position) == 1 always" 			(positionsToConsider includes: position) ifFalse: [				positionsToConsider add: position.				tentativeIsBetter := true.			] ifTrue: [				tentativeIsBetter := (gScoreDict at: position) > tentativeGScore. 			].						tentativeIsBetter ifTrue: [ 					cameFromDict at: position put: currentPosition.					gScoreDict at: position put: tentativeGScore.					fScoreDict at: position put: tentativeGScore + (position dist: targetPosition)			]		]	].	^#()! !!BGSFrontierExplorerRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/6/2011 18:34'!pathTo: targetPosition throughDict: parentsDict	|path currentPosition|	path := OrderedCollection new.	currentPosition := targetPosition.	[currentPosition = self position] whileFalse: [		path addFirst: currentPosition.		currentPosition := parentsDict at: currentPosition.	].	^path	! !!BGSFrontierExplorerRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/13/2011 21:54'!pathToFrontier	| pathToFrontier frontiers |	frontiers := self frontierPositionsSorted.	pathToFrontier := #().	[pathToFrontier isEmpty] whileTrue: [		|frontierPosition|		frontiers ifEmpty: [^#()].		frontierPosition := frontiers removeFirst.		pathToFrontier := self pathTo: frontierPosition].	^pathToFrontier! !!BGSFrontierExplorerRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/18/2011 18:54'!rangeSensorBelt	^self body part: #rangeSensorBelt! !!BGSFrontierExplorerRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/13/2011 21:16'!sensedPositions	^self rangeSensorBelt sensedPositions! !!BGSFrontierExplorerRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/13/2011 21:55'!step	"Go towards the nearest frontier"	| path |	self frontierPositions ifEmpty: [ ^ self ].	path := self pathToFrontier.	path ifEmpty: [^self].	self turnTowards: path first.	self goForward.	self changed! !!BGSFrontierExplorerRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/25/2011 00:00'!unexploredPositions	^self map unexploredPositions! !!BGSCollaborativeNearestFrontierExplorerRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 23:44'!bodyClass	^BGSWirelessEnabledRangeSensorBeltRobotBody! !!BGSCollaborativeNearestFrontierExplorerRobot methodsFor: 'communicating' stamp: 'NouryBouraqadi 12/13/2011 17:11'!broadcast: selector args: args 	self robotsWithinWirelessRange do: [:bot|		bot perform: selector withArguments: args] ! !!BGSCollaborativeNearestFrontierExplorerRobot methodsFor: 'sensing' stamp: 'NouryBouraqadi 12/13/2011 17:05'!robotsWithinWirelessRange	^self wireless botsInRange! !!BGSCollaborativeNearestFrontierExplorerRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/13/2011 17:34'!step	super step.	self broadcast: #updateMapFrom: args: {self map}! !!BGSCollaborativeNearestFrontierExplorerRobot methodsFor: 'updating' stamp: 'NouryBouraqadi 12/13/2011 17:20'!updateMapFrom: aBGSExplorableGrid 	self map updateFrom: aBGSExplorableGrid! !!BGSCollaborativeNearestFrontierExplorerRobot methodsFor: 'communicating' stamp: 'NouryBouraqadi 12/13/2011 16:46'!wireless	^self body part: #wireless! !!BGSNearestFrontierExplorerRobot methodsFor: 'accessing ' stamp: 'NouryBouraqadi 12/12/2011 18:14'!frontierPositionsSorted	|myPosition|	myPosition := self position.	^self frontierPositions asSortedCollection: [:a :b| (myPosition dist: a) < (myPosition dist: b)].! !!BGSRandomWalkRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/24/2011 18:45'!bodyClass 	^BGSRobotBodyWithFrontRangeSensor! !!BGSRandomWalkRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 15:05'!frontRangeSensor	^self body part: #frontRangeSensor! !!BGSRandomWalkRobot methodsFor: 'sensing' stamp: 'NouryBouraqadi 11/24/2011 18:46'!hasObstacleInFront	^self frontRangeSensor distanceToObstacle = 0! !!BGSRandomWalkRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 11/24/2011 18:43'!step	self turnBy: (-2 to: 2) atRandom.  "Change direction by -90, -45, 0, 45, or 90 degrees (negative is to the left and positive to the right)"	self goForward! !!BGSRobot class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/9/2011 08:13'!number: aNumber	^self new		number: aNumber;		yourself! !!BGSRobot class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/9/2011 07:39'!withId: aSymbol	^self new		id: aSymbol;		yourself! !!BGSRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 07:34'!body	^ body! !!BGSRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 16:57'!body: aRobotBody	body := aRobotBody.	body bot: self! !!BGSRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/9/2011 07:44'!bodyClass	^BGSRobotBody.! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 21:44'!goForward	self body goForward! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/19/2011 18:16'!goForwardBy: steps	steps timesRepeat: [self goForward]! !!BGSRobot methodsFor: 'sensing' stamp: 'NouryBouraqadi 11/19/2011 17:35'!heading	^self body heading! !!BGSRobot methodsFor: 'sensing' stamp: 'federicobalaguer 7/8/2014 08:36'!heading: aNumber	^self body heading: aNumber! !!BGSRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 07:34'!id	^ id! !!BGSRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/9/2011 08:06'!id: anObject	id := anObject asSymbol! !!BGSRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/9/2011 07:34'!initialize 	super initialize.	self body: self bodyClass new.! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/19/2011 17:32'!jumpTo: aPoint	self body position: aPoint! !!BGSRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/29/2011 16:19'!jumpTo: aPoint in: terrain	self body jumpTo: aPoint in: terrain! !!BGSRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 08:07'!number: aNumber	self id: 'robot', aNumber printString! !!BGSRobot methodsFor: 'sensing' stamp: 'NouryBouraqadi 11/9/2011 07:38'!position	^self body position! !!BGSRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 11/9/2011 07:38'!step	^self! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/19/2011 17:30'!turnBy: number 	number < 0 ifTrue: [^self turnLeftBy: number negated].	self turnRightBy: number! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 21:43'!turnLeft	self body turnLeft! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/19/2011 17:31'!turnLeftBy: steps	steps timesRepeat: [self turnLeft]! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/17/2011 21:43'!turnRight	self body turnRight! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/19/2011 17:31'!turnRightBy: steps 	steps timesRepeat: [self turnRight]! !!BGSRobot methodsFor: 'moving' stamp: 'NouryBouraqadi 11/29/2011 22:29'!turnTowards: aPoint	self body turnTowards: aPoint! !!BGSSnowFlakeRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 15:46'!bodyClass 	^BGSRangeSensorBeltRobotBody! !!BGSSnowFlakeRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 11:03'!initialize	super initialize.	body heading: 0@1.! !!BGSSnowFlakeRobot methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 15:53'!jumpTo: aPoint in: terrain	super jumpTo: aPoint in: terrain.	self addDependent: terrain.	self changed! !!BGSSnowFlakeRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/18/2011 15:54'!rangeSensorBelt	^self body part: #rangeSensorBelt! !!BGSSnowFlakeRobot methodsFor: 'exploring' stamp: 'NouryBouraqadi 12/18/2011 15:54'!sensedPositions	^self rangeSensorBelt sensedPositions! !!BGSSnowFlakeRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 18:43'!simulation	^ simulation! !!BGSSnowFlakeRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 18:43'!simulation: anObject	simulation := anObject! !!BGSSnowFlakeRobot methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 19:11'!step	|rotation bodyCell|	bodyCell := self body cell.	bodyCell color = Color gray ifTrue: [		bodyCell color: Color white].	rotation := (-1 to: 1) atRandom.	self turnBy: rotation.	self goForward.	self turnBy: rotation negated.	self changed! !!BGSSnowFlakeRobot methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 19:01'!terrain	^self simulation terrain! !!BGS1RobotFrontierExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/30/2011 23:10'!deployRobots	(self robot: #robot1) jumpTo: 1@1 in: self terrain! !!BGS1RobotFrontierExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/8/2011 17:05'!name 	^'Single robot exploring the nearest frontier'! !!BGS1RobotFrontierExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/30/2011 23:24'!robotClass	^BGSNearestFrontierExplorerRobot! !!BGS1RobotFrontierExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/29/2011 20:44'!robotCount	^1! !!BGS1RobotFrontierExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 16:57'!terrainClass	^BGSCheckerboardLikeTerrain! !!BGS5CollaborativeRobotsExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 23:36'!deployRobots	#(robot1 robot2 robot3 robot4 robot5) with: {29@17. 29@22. 29@27. 29@32. 29@37} do: [:botId :aPoint|		(self robot: botId) jumpTo: aPoint in: self terrain]! !!BGS5CollaborativeRobotsExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 5/4/2012 10:18'!name	^'Yamauchi''s Collaborative Exploration with 5 Robots'! !!BGS5CollaborativeRobotsExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 23:27'!robotClass	^BGSCollaborativeNearestFrontierExplorerRobot! !!BGS5CollaborativeRobotsExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 23:27'!robotCount	^5! !!BGS5CollaborativeRobotsExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/14/2011 10:12'!terrainClass	^BGSCheckerboardLikeTerrain! !!BGSChristmasSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 18:59'!addRobot: bot	super addRobot: bot.	bot simulation: self! !!BGSChristmasSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 19:57'!autoStopConditionReached 	^self flakesCount > 490! !!BGSChristmasSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 11:05'!deployRobots	^self! !!BGSChristmasSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 19:05'!flakesCount	^ flakesCount! !!BGSChristmasSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 19:05'!flakesCount: anObject	flakesCount := anObject! !!BGSChristmasSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 20:02'!name 	^'Bot Grid Simulator - Merry Christmas 2011'! !!BGSChristmasSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 19:05'!reset	super reset.	self flakesCount: 0! !!BGSChristmasSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 19:39'!revealTerrain	|unexploredPositions numberOfRevealedCells |	unexploredPositions := self unexploredPositions.	numberOfRevealedCells := 500 min: unexploredPositions size.	numberOfRevealedCells timesRepeat: [(self terrain cellAt: unexploredPositions atRandom) markExplored].	self terrain changed! !!BGSChristmasSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 18:22'!robotClass	^BGSSnowFlakeRobot ! !!BGSChristmasSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 11:27'!robotCount	^self robots size! !!BGSChristmasSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 19:55'!snow	| botCount botNumber possibleX |	(self stepCount \\ 5) isZero		ifTrue: [ 			botCount := (5 to: 15) atRandom.			possibleX := (2 to: 50 by: 3) asSet.			botNumber := self robots size + 1.			botCount				timesRepeat: [ 					| x bot |					x := possibleX atRandom.					possibleX remove: x.					self flakesCount: self flakesCount + 1.					bot := self robotClass number: self flakesCount.					bot jumpTo: x @ 1 in: self terrain.					self addRobot: bot.					botNumber := botNumber + 1 ] ]! !!BGSChristmasSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 18:28'!step	self unexploredPositionsCount isZero		ifTrue: [ self snow ]		ifFalse: [ self revealTerrain ].	super step! !!BGSChristmasSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/11/2011 21:32'!terrainClass 	^BGSChristmasTerrain! !!BGSExplorationSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 11/30/2011 23:15'!autoStopConditionReached 	^self unexploredPositions isEmpty! !!BGSExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/30/2011 23:14'!frontierPositions 	^self terrain frontierPositions! !!BGSExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/6/2011 18:53'!frontierPositionsCount	^self frontierPositions size! !!BGSExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 18:49'!terrainClass 	^BGSExplorableTerrain! !!BGSExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/30/2011 23:14'!unexploredPositions	^self terrain unexploredPositions! !!BGSExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/6/2011 18:53'!unexploredPositionsCount	^self unexploredPositions size! !!BGSCar2012DemoSimulation class methodsFor: 'as yet unclassified' stamp: 'LucFabresse 5/4/2012 18:37'!runDemoFor: robotsCount	|sim terrain |		terrain :=  (BGSCheckerboardLikeTerrain extent: 60@60).	sim := self 			terrain: terrain 			robotsClass: BGSCollaborativeNearestFrontierExplorerRobot			positions: (BGSMeanSimulationWithRandomPosition positionsIn: terrain forRobotsCount: robotsCount)			stopOn: [:simulation| simulation unexploredPositionsCount = 0 ] 			afterStopDo: [].		BGSExplorationSimulationWindow on: sim terrainCellExtent: 8@8.! !!BGSCar2012RandomMeanSimulation class methodsFor: 'simulating' stamp: 'LucFabresse 4/3/2012 13:02'!positionsForRobotsCount: robotsCount	|positions|	positions := OrderedCollection withAll: {1@1. 1@3}.	3 to: robotsCount do: [:index|		|previousPosition delta|		previousPosition := positions atLast: 2.				index even 			ifTrue: [delta := 0@2]			ifFalse: [delta := 2@0].		positions add: previousPosition + delta	].	^positions first: robotsCount	! !!BGSCar2012RandomMeanSimulation class methodsFor: 'simulating' stamp: 'LucFabresse 4/3/2012 13:02'!runFor: robotsCount in: aTerrain logFileName: fullFileName 	|sim logger |	sim := self 			terrain: aTerrain 			robotsClass: BGSCollaborativeNearestFrontierExplorerRobot			positions: (self positionsForRobotsCount: robotsCount)			stopOn: [:simulation| simulation unexploredPositionsCount = 0 ] 			afterStopDo: [				logger close.				Smalltalk image snapshot: false andQuit: true].	logger := BGSCar2012DoitLogger on: sim logInto: fullFileName.	sim run.	^sim! !!BGSMeanSimulationWithRandomPosition class methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/3/2012 14:26'!positionsIn: aTerrain forRobotsCount: robotsCount	^ aTerrain emptyCellPositions asArray shuffle first: robotsCount ! !!BGSMeanSimulationWithRandomPosition class methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/4/2012 17:28'!runFor: robotsCount in: aTerrain logFileName: fullFileName 	|sim results fileStr lock|		lock := Semaphore new.	results := OrderedCollection new.	1 to: 30 do: [ :i |		sim := self 			terrain: aTerrain 			robotsClass: BGSCollaborativeNearestFrontierExplorerRobot			positions: (self positionsIn: aTerrain forRobotsCount: robotsCount)			stopOn: [:simulation| simulation unexploredPositionsCount = 0 ] 			afterStopDo: [				results add: sim stepCount.				lock signal.				].		sim run.		lock wait.		].		fileStr := FileStream fileNamed: fullFileName.	fileStr print:  robotsCount.		fileStr tab;		print: (results average asFloat roundTo: 2).				results do: [ :result | 		fileStr tab;			print: result	].			fileStr lf 		close.	Smalltalk image snapshot: false andQuit: true			! !!BGSParametrizedExplorationSimulation class methodsFor: 'instance creation'!terrain: terrain robotsClass: robotClass positions: points stopOn: stopConditionBlock afterStopDo: afterStopBlock	^self basicNew		terrain: terrain; 		robotClass: robotClass;		robotInitialPositions: points;		stopConditionBlock: stopConditionBlock;		afterStopBlock: afterStopBlock;		initialize;		yourself! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!afterStopBlock	^ afterStopBlock! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!afterStopBlock: anObject	afterStopBlock := anObject! !!BGSParametrizedExplorationSimulation methodsFor: 'testing' stamp: 'NouryBouraqadi 3/28/2012 10:39'!autoStopConditionReached	^self stopConditionBlock cull: self! !!BGSParametrizedExplorationSimulation methodsFor: 'initialize-release'!deployRobots	self robots with: self robotInitialPositions do: [:bot :point|		bot jumpTo: point in: self terrain]! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!robotClass	^robotClass! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!robotClass: anObject	robotClass := anObject! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!robotCount	^robotInitialPositions size! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!robotInitialPositions	^ robotInitialPositions! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!robotInitialPositions: anObject	robotInitialPositions := anObject! !!BGSParametrizedExplorationSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 3/28/2012 10:42'!runLoop	[super runLoop] ensure: [		self autoStopConditionReached ifTrue: [			self afterStopBlock cull: self]]! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing'!stopConditionBlock	^ stopConditionBlock! !!BGSParametrizedExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 3/27/2012 12:29'!stopConditionBlock: anObject	stopConditionBlock := anObject! !!BGSSimulationWithTopLeftIinitialPosition class methodsFor: 'simulating' stamp: 'NouryBouraqadi 3/30/2012 15:45'!positionsForRobotsCount: robotsCount	|positions|	positions := OrderedCollection withAll: {1@1. 1@3}.	3 to: robotsCount do: [:index|		|previousPosition delta|		previousPosition := positions atLast: 2.				index even 			ifTrue: [delta := 0@2]			ifFalse: [delta := 2@0].		positions add: previousPosition + delta	].	^positions first: robotsCount	! !!BGSSimulationWithTopLeftIinitialPosition class methodsFor: 'simulating' stamp: 'LucFabresse 4/2/2012 15:17'!runFor: robotsCount in: aTerrain logFileName: fullFileName 	|sim logger |	sim := self 			terrain: aTerrain 			robotsClass: BGSCollaborativeNearestFrontierExplorerRobot			positions: (self positionsForRobotsCount: robotsCount)			stopOn: [:simulation| simulation unexploredPositionsCount = 0 ] 			afterStopDo: [				logger close.				Smalltalk image snapshot: false andQuit: true].	logger := BGSCar2012DoitLogger on: sim logInto: fullFileName.	sim run.	^sim! !!BGSSlowedDownExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 15:38'!defaultStepDelayMilliseconds	^100! !!BGSSlowedDownExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 15:38'!initialize 	super initialize.	self stepDelayMilliseconds: self defaultStepDelayMilliseconds! !!BGSSlowedDownExplorationSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/18/2011 15:38'!resetStepDelay	stepDelay := Delay forMilliseconds: self stepDelayMilliseconds! !!BGSSlowedDownExplorationSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/18/2011 15:38'!runLoop	^ [ [ self autoStopConditionReached or: [ self isPaused ] ] whileFalse: [ 			self step.			self stepDelay wait] ]		ensure: [ self changed ]! !!BGSSlowedDownExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 15:38'!stepDelay	(stepDelay isNil or: [stepDelay beingWaitedOn]) ifTrue: [self resetStepDelay].	^stepDelay! !!BGSSlowedDownExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 15:38'!stepDelayMilliseconds	^ stepDelayMilliseconds! !!BGSSlowedDownExplorationSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 15:38'!stepDelayMilliseconds: number	stepDelayMilliseconds := number.! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/22/2011 10:54'!addRobot: bot	self robotsDict at: bot id put: bot! !!BGSSimulation methodsFor: 'testing' stamp: 'NouryBouraqadi 11/9/2011 08:31'!autoStopConditionReached	^false! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/22/2011 10:53'!createRobots	(1 to: self robotCount) collect: [:botNumber | 			self addRobot: (self robotClass number: botNumber)].! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 21:54'!createTerrain	^self terrainClass new! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 22:28'!deployRobots	self subclassResponsibility ! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 3/27/2012 12:15'!initialize 	super initialize.	pauseFlagLock := Mutex new.	self reset.! !!BGSSimulation methodsFor: 'testing' stamp: 'NouryBouraqadi 11/9/2011 07:57'!isPaused	^pauseFlagLock critical: [isPaused]! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/12/2011 16:47'!isPaused: aBoolean	pauseFlagLock critical: [		isPaused := aBoolean.		self changed]! !!BGSSimulation methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 11:41'!isRunning	^((pauseFlagLock critical: [self isPaused]) or: [self autoStopConditionReached]) not! !!BGSSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 11/9/2011 08:31'!pause	self isPaused: true! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/18/2011 18:49'!removeRobot: aBGSRobot 	^self robotsDict removeKey: aBGSRobot id ifAbsent: [nil]! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/7/2011 16:50'!reset	self pause.	self stepCount: 0.	self terrain reset.	self robotsDict: Dictionary new.	self createRobots.	self deployRobots.	self changed! !!BGSSimulation methodsFor: 'accessing' stamp: 'federicobalaguer 8/27/2014 15:40'!robot: robotId	^self robotsDict at: robotId! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 22:30'!robotClass	^self subclassResponsibility! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/9/2011 08:17'!robotCount	self subclassResponsibility! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/22/2011 10:50'!robots	^self robotsDict values! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/22/2011 10:50'!robotsDict	^ robotsDict! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/22/2011 10:50'!robotsDict: anObject	robotsDict := anObject! !!BGSSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 11/12/2011 17:28'!run	pauseFlagLock		critical: [ 			self isPaused				ifFalse: [ ^ self ].			self isPaused: false ].	[ self runLoop ] forkAt: Processor userBackgroundPriority! !!BGSSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 3/28/2012 10:36'!runLoop	^ [ [ self autoStopConditionReached or: [ self isPaused ] ] whileFalse: [ self step] ]		ensure: [ self changed ]! !!BGSSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/6/2011 18:52'!step	self stepCount: self stepCount + 1.	self robots do: [ :r | r step ].! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/7/2011 16:51'!stepCount	^ stepCount! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/7/2011 16:51'!stepCount: newCount	stepCount := newCount.	self changed! !!BGSSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 11/12/2011 17:40'!stepIfPaused	self isRunning ifTrue: [^self].	self autoStopConditionReached ifTrue: [^self].	self step! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 3/27/2012 12:15'!terrain	^ terrain ifNil: [terrain := self createTerrain]! !!BGSSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 07:57'!terrain: anObject	terrain := anObject! !!BGSSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/8/2011 11:07'!terrainClass	^BGSGrid! !!BGSSimulation methodsFor: 'accessing' stamp: 'federicobalaguer 7/10/2014 11:28'!tracePositionFor: robotId 	^self robotsDict at: robotId ifAbsent: [nil]! !!BGSSimulationForTest methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/22/2011 11:33'!autoStopConditionFlag	^ autoStopConditionFlag! !!BGSSimulationForTest methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/22/2011 11:33'!autoStopConditionFlag: anObject	autoStopConditionFlag := anObject! !!BGSSimulationForTest methodsFor: 'testing' stamp: 'NouryBouraqadi 11/22/2011 11:33'!autoStopConditionReached	^self autoStopConditionFlag ! !!BGSSimulationForTest methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/19/2011 17:33'!deployRobots	self robots first jumpTo: 1@1 in: self terrain! !!BGSSimulationForTest methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/22/2011 11:33'!initialize 	super initialize.	self autoStopConditionFlag: false! !!BGSSimulationForTest methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 22:33'!robotClass	^BGSRobot! !!BGSSimulationForTest methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/7/2011 17:14'!robotCount	^1! !!BGSSimulationForTest methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 22:36'!terrainClass	^BGSTerrainForTest! !!BGSSimulationExample methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/6/2011 18:52'!autoStopConditionReached 	^self stepCount = 100! !!BGSSimulationExample methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/10/2011 15:05'!deployRobots	self robots do: [:bot|		(bot body part: #frontRangeSensor) range: 3].	self robots with: {17@17. 37@17. 26@37} do: [:bot :position|		bot jumpTo: position in: self terrain]! !!BGSSimulationExample methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/8/2011 17:02'!name 	^'Basic Simulation Example'! !!BGSSimulationExample methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/12/2011 16:52'!robotClass	^BGSRandomWalkRobot! !!BGSSimulationExample methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/15/2011 22:19'!robotCount	^3! !!BGSSimulationExample methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/12/2011 16:56'!terrainClass	^BGSTerrainExample! !!BGSSlowedDownSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:07'!defaultStepDelayMilliseconds	^100! !!BGSSlowedDownSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:02'!initialize 	super initialize.	self stepDelayMilliseconds: self defaultStepDelayMilliseconds! !!BGSSlowedDownSimulation methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 23:02'!resetStepDelay	stepDelay := Delay forMilliseconds: self stepDelayMilliseconds! !!BGSSlowedDownSimulation methodsFor: 'stepping' stamp: 'NouryBouraqadi 12/13/2011 23:04'!runLoop	^ [ [ self autoStopConditionReached or: [ self isPaused ] ] whileFalse: [ 			self step.			self stepDelay wait] ]		ensure: [ self changed ]! !!BGSSlowedDownSimulation methodsFor: 'accessing' stamp: 'JulianGrigera 8/21/2015 19:10'!stepDelay	(stepDelay isNil or: [stepDelay schedulerBeingWaitedOn]) ifTrue: [self resetStepDelay].	^stepDelay! !!BGSSlowedDownSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 23:02'!stepDelayMilliseconds	^ stepDelayMilliseconds! !!BGSSlowedDownSimulation methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 23:02'!stepDelayMilliseconds: number	stepDelayMilliseconds := number.! !!BGSSimulationScriptGenerator class methodsFor: 'generating' stamp: 'LucFabresse 4/3/2012 14:31'!generateAt: folderFullPath minBots: minBotsCount maxBots: maxBotsCount	"self generateTopLeftInitialPositionAt: folderFullPath minBots: minBotsCount maxBots: maxBotsCount"	self generateMeanRandomPositionExperimentAt: folderFullPath minBots: minBotsCount maxBots: maxBotsCount! !!BGSSimulationScriptGenerator class methodsFor: 'generating' stamp: 'LucFabresse 4/5/2012 10:10'!generateExperiment: experimentClass at: folderFullPath minBots: minBotsCount maxBots: maxBotsCount	minBotsCount to: maxBotsCount do: [:botsCount|		|fileStr|		fileStr := FileStream fileNamed: folderFullPath, '/', (botsCount printStringPadded: 3), '.st'.		fileStr			nextPutAll: 'NonInteractiveTranscript stdout install.' ; crlf;			nextPutAll: experimentClass asString;			nextPutAll: ' runFor:'; 			space;			print: botsCount;			space;			nextPutAll: 'in: ';			nextPutAll: ' (BGSCheckerboardLikeTerrain extent: 100@100)  ';			"nextPutAll: ' (BGSExplorableTerrain extent: 100@100)  ';"			nextPutAll: 'logFileName:';			space;			nextPut: $' ;			nextPutAll: folderFullPath;			nextPut: $/ ;			nextPutAll: 'result-';			nextPutAll: (botsCount printStringPadded: 3);			nextPutAll:  '.st''.';			crlf;			close	]! !!BGSSimulationScriptGenerator class methodsFor: 'generating' stamp: 'LucFabresse 4/3/2012 13:17'!generateMeanRandomPositionExperimentAt: folderFullPath minBots: minBotsCount maxBots: maxBotsCount		self generateExperiment: BGSMeanSimulationWithRandomPosition at: folderFullPath minBots: minBotsCount maxBots: maxBotsCount! !!BGSSimulationScriptGenerator class methodsFor: 'generating' stamp: 'LucFabresse 4/3/2012 13:16'!generateTopLeftInitialPositionAt: folderFullPath minBots: minBotsCount maxBots: maxBotsCount	self generateExperiment: BGSSimulationWithTopLeftIinitialPosition at: folderFullPath minBots: minBotsCount maxBots: maxBotsCount! !!BGSClickableGridView methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/1/2012 15:02'!cellAtAbsolutePosition: position	| clickedCell topLeftCellOriginPosition |	topLeftCellOriginPosition := (self boxForCellAt: (1@1)) origin.	clickedCell := ((position - topLeftCellOriginPosition) // self cellFrameExtent).		clickedCell := clickedCell + (1@1).	^clickedCell.		! !!BGSClickableGridView methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/1/2012 19:58'!emptyCellAt: cellPosition	"remove wall if any"	self grid emptyCellAt: cellPosition.	! !!BGSClickableGridView methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/1/2012 14:40'!initialize 	super initialize.	self on: #mouseDown send: #mouseDownEvt: to: self! !!BGSClickableGridView methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/1/2012 19:51'!mouseDownEvt: evt			| cellPosition |	cellPosition := self cellAtAbsolutePosition:  evt position.		evt redButtonPressed 		ifTrue: [ self setWallToCellAt: cellPosition ] 		ifFalse: [ 			evt yellowButtonPressed ifTrue: [ self emptyCellAt: cellPosition ]]! !!BGSClickableGridView methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/2/2012 09:17'!setWallToCellAt: cellPosition		((self grid isEmptyCellAt: cellPosition) or: [ ((self grid contentOfCellAt: cellPosition) isKindOf: BGSWall) not]) ifTrue: [		self grid addWallAt: cellPosition.	]! !!BGSClickableGridView methodsFor: 'as yet unclassified' stamp: 'LucFabresse 4/1/2012 19:40'!toggleWallOfCell: cellPosition	"add /remove wall "		(self grid isEmptyCellAt: cellPosition) ifTrue: [		self grid put: BGSWall new inCellAt: cellPosition.		Transcript cr; show: 'ADD WALL'.	] ifFalse: [		(self grid cellAt: cellPosition) empty.		Transcript cr; show: 'RM WALL'.	].	"self halt "	! !!BGSChristmasGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/18/2011 10:17'!drawCell: cell on: aCanvas	| box cellColor |	box := self boxForCellAt: self visitedCellPosition.	aCanvas fillRectangle: box color: cell color! !!BGSChristmasGridView methodsFor: 'drawing' stamp: 'federicobalaguer 7/3/2014 15:51'!drawFrontierCell: cell	self drawCell: cell on: self canvas ! !!BGSChristmasGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/18/2011 15:49'!drawParts	^self! !!BGSChristmasGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/18/2011 18:39'!drawRobotBody: botBody on: aCanvas	|box emptyCells|	box := self boxForCellAt: self visitedCellPosition.	emptyCells := (botBody terrain cellsAround: botBody cell) select: [:cell| cell isEmpty].	emptyCells isEmpty 		ifFalse: [				aCanvas fillOval: box color: Color white.			aCanvas frameOval: box color: Color gray		] 		ifTrue: [aCanvas fillRectangle: box color: Color white]! !!BGSChristmasGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/18/2011 10:31'!drawWall: wall on: aCanvas	^self! !!BGSChristmasGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/18/2011 18:40'!unexploredCellColor 	^Color yellow! !!BGSExplorableGridView methodsFor: 'drawing' stamp: 'federicobalaguer 7/3/2014 15:51'!drawFrontierCell: cell	| box cellColor |	box := self boxForCellAt: cell position.	self canvas fillRectangle: box color: self frontierCellColor! !!BGSExplorableGridView methodsFor: 'drawing' stamp: 'federicobalaguer 7/3/2014 15:51'!drawUnexploredCell: cell	| box cellColor |	box := self boxForCellAt: cell position.	self canvas fillRectangle: box color: self unexploredCellColor! !!BGSExplorableGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/1/2011 19:55'!frontierCellColor	^Color yellow! !!BGSExplorableGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/1/2011 20:10'!unexploredCellColor	^Color lightGray ! !!BGSExplorableGridView methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:52'!visitFrontierCell: cell	self drawFrontierCell: cell! !!BGSExplorableGridView methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/1/2011 19:52'!visitUnexploredCell: cell	self drawUnexploredCell: cell! !!BGSExplorationMapView methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/14/2011 14:20'!drawParts	"We do not want these details at this level"	^self! !!BGSExplorationMapView methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/14/2011 14:24'!drawRobotBody: botBody on: aCanvas	| box |	box := self boxForCellAt: botBody position.	aCanvas fillRectangle: box color: self robotBodyColor! !!BGSExplorationMapView methodsFor: 'as yet unclassified' stamp: 'NouryBouraqadi 12/14/2011 14:24'!robotBodyColor	^Color red! !!BGSGridView class methodsFor: 'accessing' stamp: 'LucFabresse 4/1/2012 10:32'!defaultCellExtent 	^10@10! !!BGSGridView class methodsFor: 'instance creation' stamp: 'NouryBouraqadi 11/10/2011 18:17'!on: aBGSGrid	^self new		grid: aBGSGrid;		yourself! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/10/2011 20:13'!boxForCellAt: aPoint	| center |	center := self centerOfCellAt: aPoint.	^ Rectangle center: center extent: self cellExtent! !!BGSGridView methodsFor: 'accessing' stamp: 'federicobalaguer 7/3/2014 15:51'!canvas	^ canvas! !!BGSGridView methodsFor: 'accessing' stamp: 'federicobalaguer 7/3/2014 15:52'!canvas: anObject	canvas := anObject! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/13/2011 22:29'!cellExtent	^cellExtent! !!BGSGridView methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 22:36'!cellExtent: anObject	cellExtent := anObject.	self updateExtent! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/10/2011 18:52'!cellFrameExtent	^self cellExtent + (1@1)! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/10/2011 19:14'!centerOfCellAt: aPoint	^ aPoint * self cellFrameExtent + self position! !!BGSGridView methodsFor: 'initialize-release' stamp: 'LucFabresse 4/1/2012 10:30'!defaultCellExtent	^self class defaultCellExtent! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 3/20/2012 21:10'!drawCell: cell on: aCanvas	| box cellColor |	box := self boxForCellAt: self visitedCellPosition.	aCanvas fillRectangle: box color: cell color! !!BGSGridView methodsFor: 'drawing' stamp: 'federicobalaguer 7/3/2014 15:51'!drawDirectionalRangeSensor: sensor	|origin lineLengthFactor extremity|	origin := self centerOfCellAt: sensor position.	extremity :=  self centerOfCellAt: (sensor position + (sensor heading * sensor range)). 	self canvas 		line: origin 		to: extremity 		color: self rangeSensorColor! !!BGSGridView methodsFor: 'drawing' stamp: 'federicobalaguer 7/3/2014 15:51'!drawOmnidirectionalRangeSensor: sensor	|box boxCenter boxExtent|	boxCenter := self centerOfCellAt: sensor position.	boxExtent := self cellFrameExtent  * 2. "Go to the middle of the most far covered cell" 	box := Rectangle center: boxCenter extent: boxExtent.	self canvas 		 	frameOval: box color: self rangeSensorColor.! !!BGSGridView methodsFor: 'drawing' stamp: 'federicobalaguer 7/3/2014 15:52'!drawOn: aCanvas	| renderer |	super drawOn: aCanvas.	self canvas: aCanvas.	self resetBotParts.	self grid cells		with: self grid positions		do: [ :cell :position | 			self visitedCellPosition: position.			cell acceptVisitor: self ].	"Parts should be drawn at the end cause their drawings go over multiple cells"	"Otherwise, part of it will be covered by cell drawings"	self drawParts! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/14/2011 14:20'!drawParts	self parts do: [ :each | each acceptVisitor: self ]! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/30/2011 23:28'!drawRobotBody: botBody on: aCanvas	|box headingLineOrigin headingLineExtremity extremityExtent|	box := self boxForCellAt: self visitedCellPosition.	aCanvas fillOval: box color: self robotBodyColor.	headingLineOrigin := self centerOfCellAt: self visitedCellPosition.	extremityExtent := (self cellExtent -  self robotBodyHeadingLineWidth) / 2 * botBody heading.	headingLineExtremity := headingLineOrigin + extremityExtent truncated.	aCanvas 		line: headingLineOrigin 		to: headingLineExtremity 		width: self robotBodyHeadingLineWidth  		color: self robotBodyHeadingLineColor! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/24/2011 18:30'!drawWall: wall on: aCanvas	| box |	box := self boxForCellAt: self visitedCellPosition.	aCanvas fillRectangle: box color: self wallColor! !!BGSGridView methodsFor: 'drawing' stamp: 'federicobalaguer 9/7/2016 20:02'!drawWireless: wireless	| origin aRobot |	origin := self centerOfCellAt: wireless position.	aRobot := wireless bot.	wireless peers		do: [ :peer | 			| extremity |			extremity := self centerOfCellAt: peer position.			self canvas				line: origin				to: extremity				width:					((peer bot isPeerOf: aRobot)						ifTrue: [ 2 ]						ifFalse: [ 1 ])				color: self wirelessColor ]! !!BGSGridView methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/9/2011 21:46'!grid	^ grid! !!BGSGridView methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 22:36'!grid: anObject	grid := anObject.	self updateExtent.	grid addDependent: self! !!BGSGridView methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/13/2011 22:29'!initialize	super initialize.	self 		cellExtent: self defaultCellExtent;		useGradientFill;		borderWidth: 2;		useRoundedCorners;		setBorderStyle: #complexRaised.	self	fillStyle direction: self extent.	self color: self simulationBackgroundColor! !!BGSGridView methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/10/2011 15:11'!parts	^botParts! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/19/2011 11:58'!rangeSensorColor	^Color red! !!BGSGridView methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 12/10/2011 15:13'!resetBotParts 	botParts := Set new! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/19/2011 09:36'!robotBodyColor	^Color blue! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/19/2011 12:22'!robotBodyHeadingLineColor	^Color cyan! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/30/2011 23:32'!robotBodyHeadingLineWidth	^4! !!BGSGridView methodsFor: 'initialize-release' stamp: 'NouryBouraqadi 11/10/2011 18:02'!simulationBackgroundColor	^ Color 		r: 0.10		g: 0.50		b: 0.30! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/10/2011 20:31'!update: anObject	self changed! !!BGSGridView methodsFor: 'accessing' stamp: 'NouryBouraqadi 12/13/2011 22:37'!updateExtent	self grid ifNil: [^self].	self extent: (1 + self grid extent) * self cellFrameExtent! !!BGSGridView methodsFor: 'visiting' stamp: 'federicobalaguer 7/3/2014 15:51'!visitCell: cell	self drawCell: cell on: self canvas! !!BGSGridView methodsFor: 'visiting' stamp: 'NouryBouraqadi 11/24/2011 19:32'!visitDirectionalRangeSensor: sensor	self drawDirectionalRangeSensor: sensor! !!BGSGridView methodsFor: 'visiting' stamp: 'NouryBouraqadi 11/24/2011 19:40'!visitOmnidirectionalRangeSensor: sensor	self drawOmnidirectionalRangeSensor: sensor! !!BGSGridView methodsFor: 'visiting' stamp: 'federicobalaguer 7/3/2014 15:51'!visitRobotBody: aRobotBody	self drawRobotBody: aRobotBody on: self canvas.	self parts addAll: aRobotBody parts! !!BGSGridView methodsFor: 'visiting' stamp: 'federicobalaguer 7/3/2014 15:51'!visitWall: wall	self drawWall: wall on: self canvas! !!BGSGridView methodsFor: 'visiting' stamp: 'NouryBouraqadi 12/13/2011 17:29'!visitWireless: wireless	self drawWireless: wireless! !!BGSGridView methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/16/2011 22:33'!visitedCellPosition	^ visitedCellPosition! !!BGSGridView methodsFor: 'accessing' stamp: 'NouryBouraqadi 11/16/2011 22:33'!visitedCellPosition: anObject	visitedCellPosition := anObject! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 11/19/2011 09:35'!wallColor	^Color black! !!BGSGridView methodsFor: 'drawing' stamp: 'NouryBouraqadi 12/13/2011 22:04'!wirelessColor.	^Color magenta! !"BOSS"!!Battery commentStamp: '<historical>' prior: 0!I represent the robot's battery. I have a capacity and a charge that decreases, and I can recharge myself.!!Brush commentStamp: 'federicobalaguer 8/22/2017 16:13' prior: 0!This class represent a Brush used by a OTFRobot. The brush can be up or down. When the brush is down, it paints the cell underneath the robotWhen the brush is up, it does nothing!!BrushState commentStamp: '<historical>' prior: 0!Represento un posible estado en el que se encuentre el robot del que formo parte.!!BrushDown commentStamp: '<historical>' prior: 0!I represent the state of a robot in which the brush is down.!!BrushUp commentStamp: '<historical>' prior: 0!I represent the state of a robot in which the brush is up.!!EndlessBattery commentStamp: 'federicobalaguer 7/11/2014 14:55' prior: 0!An EndlessBattery is a battery with infinite charge!!ManifestBotArena commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ChargeBatteryError commentStamp: '<historical>' prior: 0!I represent the error situation when the robot tries to move without enough battery charge.!!MethodList commentStamp: 'ArturoZambrano 8/24/2014 21:19' prior: 0!A MethodList  is part of the MinimalBrowser, it lists the methods for a class.!!MinimalBrowser commentStamp: 'ArturoZambrano 8/24/2014 21:20' prior: 0!MinimalBrowser shows the definition of instance methods for a given class. It depends on Spec.!!OTFRobot commentStamp: 'federicobalaguer 7/10/2014 12:03' prior: 0!OTFRobot (On-The-Fly Robot) works within OnTheFlySimulation!!ServiceProviderBot commentStamp: 'federicobalaguer 9/23/2016 12:51' prior: 0!This class represents entities on the arena that give services to Robots and can communicate with other robots that have a wirelss module.!!WalkingBrushRobot commentStamp: '<historical>' prior: 0!I am a robot and I am able to do simple things like move through a certain space, leaving marks of the paths I am doing. I have a battery that consumes itself according to my moves, and can be recharged at every moment.!!BGSArenaWindow commentStamp: 'federicobalaguer 9/24/2016 18:26' prior: 0!BGSArenaWindow beginnerViewOn: (OnTheFlyConfigurableSimulation endlessWalkingBrush).BGSArenaWindow beginnerViewOn: (OnTheFlyConfigurableSimulation batteryWalkingBrush).BGSArenaWindow expertViewOn: (OnTheFlyConfigurableSimulation endlessWalkingBrush).BGSArenaWindow expertViewOn: (OnTheFlyConfigurableSimulation batteryWalkingBrush).BGSArenaWindow wirelessViewOn: (OnTheFlyConfigurableSimulation wirelessBrush ).!!ArenaBehavior methodsFor: 'initialiaze' stamp: 'federicobalaguer 8/20/2014 09:38'!createAndDeployRobotsOn: simulation	self subclassResponsibility! !!ArenaBehavior methodsFor: 'initialiaze' stamp: 'federicobalaguer 8/27/2014 11:28'!createAndDeployRobotsOn: simulation from: arenaWindow	self subclassResponsibility! !!ArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/20/2014 09:46'!handleRedButtonOnEmptyCell: cellPosition window: arenaWindow	^ self subclassResponsibility! !!ArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/20/2014 09:47'!handleYellowButtonOnBot: cellPosition window: arenaWindow	^ self subclassResponsibility! !!ArenaBehavior methodsFor: 'initialiaze' stamp: 'federicobalaguer 8/27/2014 12:07'!initializeBindingsFor: arenaWindow	self subclassResponsibility! !!ArenaBehavior methodsFor: 'private' stamp: 'federicobalaguer 8/14/2014 15:20'!makeButton:  aString action: actionSelector state: stateSelector target: target	| btn labelMorph |	btn := PluggableButtonMorph 		on: target		getState: stateSelector		action: actionSelector.	labelMorph := StringMorph contents: aString.	labelMorph emphasis: 1.	btn		label: labelMorph;		useRoundedCorners;		hResizing: #spaceFill;		onColor: target onButtonColor offColor: target offButtonColor;		borderWidth: 2;		borderColor: #raised.	btn label color: Color darkGray.	btn extent: target buttonsWidth @ 50. "50 is not an important value since it will be changed by the enclosing alignment morph"	^btn! !!ArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 9/29/2015 12:20'!resetSimulation: arenaWindow	^ self subclassResponsibility	! !!BasicArenaBehavior methodsFor: 'buttons creations' stamp: 'federicobalaguer 8/20/2014 13:02'!addButtonsToPanel: panel of: aWindow	| resetBtn wrkSpaceBtn browserBtn objectListBtn |	resetBtn := self		makeButton: 'Reset'		action: #resetSimulation		state: #canResetSimulation		target: aWindow.	wrkSpaceBtn := self		makeButton: 'Open Workspace'		action: #openWorkspaceWithContent		state: #hasWorkspace		target: aWindow .	browserBtn := self		makeButton: 'Browse Definition'		action: #openBrowserOnRobot		state: #hasBrowser		target: aWindow .	objectListBtn := self		makeButton: 'Available Objects'		action: #browseAvailableObjects		state: #canResetSimulation		target: aWindow .	{resetBtn.	wrkSpaceBtn.	browserBtn.	objectListBtn} do: [ :button | panel addMorph: button ]! !!BasicArenaBehavior methodsFor: 'initialize' stamp: 'federicobalaguer 8/26/2014 16:35'!createAndDeployRobotsOn: simulation	simulation createAndDeployRobot: 'robotech' position: simulation terrain extent / 2.	! !!BasicArenaBehavior methodsFor: 'initialize' stamp: 'federicobalaguer 8/27/2014 12:11'!createAndDeployRobotsOn: simulation from: arenaWindow	self createAndDeployRobotsOn: simulation.	self initializeBindingsFor: arenaWindow .	simulation robots notEmpty		ifTrue: [ arenaWindow  addBinding: #robotech object: simulation robots first ]! !!BasicArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/20/2014 09:44'!handleRedButtonOnEmptyCell: cellPosition window: arenaWindow! !!BasicArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/20/2014 11:13'!handleYellowButtonOnBot: aRobot window: arenaWindow	! !!BasicArenaBehavior methodsFor: 'initialize' stamp: 'federicobalaguer 8/28/2014 15:35'!initializeBindingsFor: arenaWindow	| binding auxbat |	binding := arenaWindow cleanBindings.	binding		at: #backupBattery		put:			((auxbat := Battery new)				charge: auxbat defaultCapacity;				yourself).	binding at: #endlessBattery put: EndlessBattery new! !!BasicArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/27/2014 12:23'!resetSimulation: arenaWindow	arenaWindow simulation reset.	self createAndDeployRobotsOn: arenaWindow simulation from: arenaWindow! !!EnhancedArenaBehavior methodsFor: 'buttons creations' stamp: 'federicobalaguer 8/14/2014 11:52'!addButtonsToPanel: panel of: aWindow	| resetBtn wrkSpaceBtn browserBtn addBotBtn|	resetBtn := self		makeButton: 'Reset'		action: #resetSimulation		state: #canResetSimulation		target: aWindow.	wrkSpaceBtn := self		makeButton: 'Open Workspace'		action: #openWorkspace		state: #hasWorkspace		target: aWindow .	browserBtn := self		makeButton: 'Browse Definition'		action: #openBrowser		state: #hasBrowser		target: aWindow .	addBotBtn := self		makeButton: 'Add Robot'		action: #addRobot		state: #canResetSimulation		target: aWindow .	{resetBtn.	wrkSpaceBtn.	browserBtn.	addBotBtn} do: [ :button | panel addMorph: button ]! !!EnhancedArenaBehavior methodsFor: 'initialize' stamp: 'federicobalaguer 8/20/2014 09:39'!createAndDeployRobotsOn: simulation! !!EnhancedArenaBehavior methodsFor: 'initialize' stamp: 'federicobalaguer 8/27/2014 12:26'!createAndDeployRobotsOn: simulation from: arenaWindow	self initializeBindingsFor: arenaWindow! !!EnhancedArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/20/2014 09:44'!handleRedButtonOnEmptyCell: cellPosition window: arenaWindow	arenaWindow addRobotOnPosition: cellPosition! !!EnhancedArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 8/20/2014 11:13'!handleYellowButtonOnBot: aRobot window: arenaWindow	! !!EnhancedArenaBehavior methodsFor: 'initialiaze' stamp: 'federicobalaguer 8/27/2014 12:37'!initializeBindingsFor: arenaWindow	arenaWindow cleanBindings ! !!EnhancedArenaBehavior methodsFor: 'callback' stamp: 'federicobalaguer 9/29/2015 12:13'!resetSimulation: arenaWindow	arenaWindow simulation reset.	arenaWindow changed.	self initializeBindingsFor: arenaWindow! !!ServiceArenaBehavior methodsFor: 'accessing' stamp: 'federicobalaguer 9/23/2016 17:42'!createAndDeployRobotsOn: simulation	simulation createAndDeployServiceAgent: 'c3po'! !!ServiceArenaBehavior methodsFor: 'accessing' stamp: 'federicobalaguer 9/23/2016 18:34'!createAndDeployRobotsOn: simulation from: arenaWindow	| agent |	self createAndDeployRobotsOn: simulation.	self initializeBindingsFor: arenaWindow.	simulation robots notEmpty		ifFalse: [ ^ self ].	agent := simulation robots first.	arenaWindow addBinding: agent id object: agent! !!ServiceArenaBehavior methodsFor: 'accessing' stamp: 'federicobalaguer 9/24/2016 17:16'!resetSimulation: arenaWindow	arenaWindow simulation reset.	self createAndDeployRobotsOn: arenaWindow simulation from: arenaWindow! !!Battery class methodsFor: 'instance-creation' stamp: 'federicobalaguer 7/11/2014 19:36'!fullyCharged	| instance |	^ (instance := self new)		charge: instance capacity;		yourself! !!Battery methodsFor: 'consume' stamp: 'NahuelGarbezza 12/9/2012 18:02'!canConsume: amount	^self charge >= amount! !!Battery methodsFor: 'accessing' stamp: 'NahuelGarbezza 12/9/2012 18:00'!capacity	^ capacity! !!Battery methodsFor: 'private' stamp: 'NahuelGarbezza 12/9/2012 18:03'!capacity: anObject	capacity := anObject! !!Battery methodsFor: 'accessing' stamp: 'NahuelGarbezza 12/9/2012 17:59'!charge	^ charge! !!Battery methodsFor: 'private' stamp: 'NahuelGarbezza 12/9/2012 17:59'!charge: anObject	charge := anObject! !!Battery methodsFor: 'consume' stamp: 'federicobalaguer 9/6/2016 18:10'!consume: amount	(self canConsume: amount)		ifTrue: [ self charge: self charge - amount ]		ifFalse: [ ChargeBatteryError signal ]! !!Battery methodsFor: 'private' stamp: 'federicobalaguer 7/11/2014 19:32'!defaultCapacity	^100! !!Battery methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/28/2014 17:01'!initialize	self capacity: self defaultCapacity.	self charge: 0.	^ self! !!Brush class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/23/2017 14:24'!forRobot: aOTFRobot	^ self new initializeRobot: aOTFRobot! !!Brush methodsFor: 'accessing' stamp: 'federicobalaguer 8/22/2017 17:56'!goDown	robot setBrushCommand: [ status brushDownFor: self ]! !!Brush methodsFor: 'accessing' stamp: 'federicobalaguer 8/23/2017 14:27'!goUp	robot setBrushCommand: [ status brushUpFor:  self ]! !!Brush methodsFor: 'accessing' stamp: 'federicobalaguer 8/23/2017 14:24'!initializeRobot: anObject	robot := anObject.	status := BrushUp new	! !!Brush methodsFor: 'accessing' stamp: 'gbosetti 8/27/2017 19:59'!isDown    ^status isDown ! !!Brush methodsFor: 'accessing' stamp: 'gbosetti 8/27/2017 19:59'!isUp    ^status isUp ! !!Brush methodsFor: 'accessing' stamp: 'federicobalaguer 8/22/2017 17:54'!robot	^ robot! !!Brush methodsFor: 'accessing' stamp: 'federicobalaguer 8/22/2017 17:54'!setStatus: anObject		status := anObject! !!Brush methodsFor: 'accessing' stamp: 'federicobalaguer 8/22/2017 17:54'!tracePosition	status tracePositionFor: robot! !!BrushDown methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!brushDownFor: aRobot	"Nothing to do"! !!BrushDown methodsFor: 'actions' stamp: 'federicobalaguer 8/23/2017 14:28'!brushUpFor: aBrush	aBrush setStatus: BrushUp new! !!BrushDown methodsFor: 'testing' stamp: 'NahuelGarbezza 12/9/2012 18:33'!isDown	^true! !!BrushDown methodsFor: 'testing' stamp: 'NahuelGarbezza 12/9/2012 18:33'!isUp	^false! !!BrushDown methodsFor: 'printing' stamp: 'NahuelGarbezza 12/9/2012 18:38'!printOn: aStream	aStream << 'Brush down'! !!BrushDown methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!toggleBrushFor: aRobot	self brushUpFor: aRobot! !!BrushDown methodsFor: 'actions' stamp: 'federicobalaguer 9/6/2016 18:52'!tracePositionFor: aRobot	| bodyCell |	bodyCell := aRobot body cell.	bodyCell color: Color black.	bodyCell changed! !!BrushState methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!brushDownFor: aRobot	self subclassResponsibility! !!BrushState methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!brushUpFor: aRobot	self subclassResponsibility! !!BrushState methodsFor: 'testing' stamp: 'NahuelGarbezza 12/9/2012 18:33'!isDown	self subclassResponsibility! !!BrushState methodsFor: 'testing' stamp: 'NahuelGarbezza 12/9/2012 18:33'!isUp 	self subclassResponsibility! !!BrushState methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!toggleBrushFor: aRobot	self subclassResponsibility! !!BrushState methodsFor: 'actions' stamp: 'federicobalaguer 7/10/2014 11:28'!tracePositionFor: aRobot	self subclassResponsibility! !!BrushUp methodsFor: 'actions' stamp: 'federicobalaguer 8/22/2017 17:54'!brushDownFor: aBrush		aBrush setStatus: BrushDown new.! !!BrushUp methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!brushUpFor: aRobot	"Nothing to do"! !!BrushUp methodsFor: 'testing' stamp: 'NahuelGarbezza 12/9/2012 18:33'!isDown	^false! !!BrushUp methodsFor: 'testing' stamp: 'NahuelGarbezza 12/9/2012 18:33'!isUp	^true! !!BrushUp methodsFor: 'printing' stamp: 'NahuelGarbezza 12/9/2012 18:36'!printOn: aStream	aStream << 'Brush up'! !!BrushUp methodsFor: 'actions' stamp: 'federicobalaguer 8/25/2014 16:23'!toggleBrushFor: aRobot	self brushDownFor: aRobot! !!BrushUp methodsFor: 'actions' stamp: 'federicobalaguer 7/10/2014 11:32'!tracePositionFor: aRobot	"	nothing to do"	! !!EndlessBattery methodsFor: 'consume' stamp: 'federicobalaguer 7/9/2014 09:30'!canConsume: aNumber	^ true! !!EndlessBattery methodsFor: 'consume' stamp: 'federicobalaguer 7/9/2014 09:30'!consume: aNumber	! !!OTFCommand class methodsFor: 'instance-creation' stamp: 'federicobalaguer 8/6/2014 16:46'!actionBlock: aBlock	^ self actionBlock: aBlock times: 1! !!OTFCommand class methodsFor: 'instance-creation' stamp: 'federicobalaguer 7/10/2014 15:09'!actionBlock: aBlock times: aNumber	"aBlock has no arguments, aNumber is an Integer"	^ self new		actionBlock: aBlock timesToGo: aNumber;		yourself! !!OTFCommand methodsFor: 'initialize - release' stamp: 'federicobalaguer 7/10/2014 15:10'!actionBlock: aBlock timesToGo: aNumber	actionBlock := aBlock.	timesToGo := aNumber! !!OTFCommand methodsFor: 'executing' stamp: 'federicobalaguer 8/12/2014 16:08'!executeCommand	actionBlock value.	timesToGo := timesToGo - 1.! !!OTFCommand methodsFor: 'testing' stamp: 'federicobalaguer 7/10/2014 15:30'!hasStepsToGo	^ timesToGo > 0! !!OTFCommand methodsFor: 'testing' stamp: 'federicobalaguer 7/10/2014 15:52'!stepsToGo	^ timesToGo ! !!Workspace methodsFor: '*BotArena' stamp: 'federicobalaguer 8/19/2014 08:58'!addBindingKey: aString value: object	((bindings includesKey: aString) and: [ (bindings at: aString) notNil ])		ifFalse: [ bindings at: aString put: object ]		ifTrue: [ self error: 'Key already in use' ]! !!ManifestBotArena class methodsFor: 'code-critics' stamp: 'federicobalaguer 8/30/2016 23:03'!ruleRBClassNotReferencedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#BGSArenaWindow)) #'2016-08-30T23:03:10.557924-03:00') )! !!ManifestBotArena class methodsFor: 'code-critics' stamp: 'federicobalaguer 9/7/2016 09:42'!ruleRBInconsistentMethodClassificationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#WalkingBrushWirelessRobot #bodyClass #false)) #'2016-09-07T09:42:59.548629-03:00') )! !!ManifestBotArena class methodsFor: 'code-critics' stamp: 'federicobalaguer 8/22/2017 17:54'!ruleRBUnaryAccessingMethodWithoutReturnRuleV1FalsePositive	^ #()! !!ChargeBatteryError class methodsFor: 'signaling' stamp: 'NahuelGarbezza 12/9/2012 18:32'!signal	^self signal: 'No hay suficiente bateria para moverse!!'! !!BGSCastleWall methodsFor: 'as yet unclassified' stamp: 'DiegoTorres 8/30/2014 13:56'!bot! !!MethodList class methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :column | 					column						add: #label height: self toolbarHeight;						add: #protocols ];		yourself! !!MethodList methodsFor: 'as yet unclassified' stamp: 'FedericoBalaguer 8/21/2015 16:14'!initializeWidgets	protocols := self newList.	label := self newLabel.	label label: 'Protocol'.	protocols displayBlock: [ :m | m selector  ].	self focusOrder add: protocols! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!items:aCollection protocols items:aCollection.! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!label ^label! !!MethodList methodsFor: 'as yet unclassified' stamp: 'JulianGrigera 8/21/2015 19:08'!label: aString	label label: aString! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!protocols ^protocols! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!resetSelection protocols resetSelection ! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!text:aString   label text:aString.! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!title  ^'Art-Protocol Widget tutorial'! !!MethodList methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 23:41'!whenSelectedItemChanged: aBlock	protocols whenSelectedItemChanged: aBlock! !!MinimalBrowser class methodsFor: 'spec' stamp: 'ArturoZambrano 8/11/2014 23:09'!defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :col | 					col						add: #list;						add: #text ];		yourself! !!MinimalBrowser class methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/30/2014 20:20'!on:aClass ^self basicNew		klass: aClass; initialize;		yourself! !!MinimalBrowser methodsFor: 'protocol' stamp: 'ArturoZambrano 8/11/2014 15:13'!initialExtent^ 750@600! !!MinimalBrowser methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/30/2014 20:15'!initializePresenter	list		whenSelectedItemChanged: [ :item | item ifNil: [ text text: '' ] ifNotNil: [ text text: (klass methodNamed: item) sourceCode ] ].	text		whenTextIsAccepted: [ :newText | 		       klass compile: newText.				self updateMessagesAndCode.			]! !!MinimalBrowser methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/30/2014 20:14'!initializeWidgets	text := self newText.	list := self instantiate: MethodList.	self updateMessagesAndCode.	self focusOrder		add: list;		add: text! !!MinimalBrowser methodsFor: 'protocol' stamp: 'ArturoZambrano 8/11/2014 23:30'!klass: aClass klass:= aClass.! !!MinimalBrowser methodsFor: 'protocol' stamp: 'ArturoZambrano 8/11/2014 23:10'!list^ list! !!MinimalBrowser methodsFor: 'suggestions' stamp: 'German 9/2/2016 08:39'!selectedMessage	^ nil! !!MinimalBrowser methodsFor: 'suggestions' stamp: 'German 9/2/2016 08:37'!selectedMethod	^ klass methodNamed: list protocols selectedItem! !!MinimalBrowser methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/11/2014 15:13'!text	   ^text	! !!MinimalBrowser methodsFor: 'protocol' stamp: 'ArturoZambrano 8/13/2014 21:27'!title^ 'MiniBrowser on: ', klass name.! !!MinimalBrowser methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 8/30/2014 20:14'!updateMessagesAndCode	list items: klass methodDictionary keys sorted.	list label: 'Methods'.	list protocols displayBlock: [ :m | m ].	text behavior: klass.	text aboutToStyle: true! !!OTFRobot methodsFor: 'private' stamp: 'federicobalaguer 8/28/2014 15:04'!addCommand: otfCommand	semaphore wait.	commands addLast: otfCommand.	Transcript		show: commands size;		cr.	self changed.	Processor yield! !!OTFRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 9/7/2016 09:42'!bodyClass	^ BGSRobotBodyWithFrontRangeSensor	"BGSRangeSensorBeltRobotBody"! !!OTFRobot methodsFor: 'stepping' stamp: 'federicobalaguer 7/10/2014 16:06'!currentCommand	| first |	^ (first := commands first) stepsToGo > 0		ifTrue: [ first ]		ifFalse: [ self error: 'Missing Command' ]! !!OTFRobot methodsFor: 'private' stamp: 'federicobalaguer 7/11/2014 16:40'!directionMap	^ Dictionary new		at: 0 put: 0 @ -1;		at: 45 put: 1 @ -1;		at: 90 put: 1 @ 0;		at: 135 put: 1 @ 1;		at: 180 put: 0 @ 1;		at: 225 put: -1 @ 1;		at: 270 put: -1 @ 0;		at: 315 put: -1 @ -1;		at: 360 put: 0 @ -1;		yourself! !!OTFRobot methodsFor: 'stepping' stamp: 'federicobalaguer 7/10/2014 15:34'!goForward	self hasStepsToGo 		ifTrue: [ super goForward ]! !!OTFRobot methodsFor: 'stepping' stamp: 'federicobalaguer 7/10/2014 15:33'!handleStep: aDistance	! !!OTFRobot methodsFor: 'testing' stamp: 'federicobalaguer 7/10/2014 16:12'!hasStepsToGo	^ (commands notEmpty) and: [self currentCommand hasStepsToGo ]! !!OTFRobot methodsFor: 'private' stamp: 'federicobalaguer 8/12/2014 13:39'!headingFromDirection: aDirection	^ self heading: (self directionMap at: aDirection)! !!OTFRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/28/2014 15:02'!initialize	super initialize.	commands := OrderedCollection new. 	semaphore := Semaphore forMutualExclusion . 	body heading: 0 @ -1! !!OTFRobot methodsFor: 'testing' stamp: 'federicobalaguer 8/19/2014 14:46'!isIdle	^ self hasStepsToGo not! !!OTFRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 7/4/2014 14:37'!jumpTo: aPoint in: terrain	super jumpTo: aPoint in: terrain.	self addDependent: terrain.	self changed! !!OTFRobot methodsFor: 'exploring' stamp: 'federicobalaguer 7/4/2014 14:37'!rangeSensorBelt	^self body part: #rangeSensorBelt! !!OTFRobot methodsFor: 'exploring' stamp: 'federicobalaguer 7/4/2014 14:37'!sensedPositions	^self rangeSensorBelt sensedPositions! !!OTFRobot methodsFor: 'private' stamp: 'federicobalaguer 8/12/2014 16:04'!setDirection: aDirection	self addCommand: (OTFCommand actionBlock: [ self headingFromDirection: aDirection ])! !!OTFRobot methodsFor: 'private' stamp: 'federicobalaguer 10/5/2015 15:23'!setStepsToGo: aNumber	aNumber > 0		ifTrue: [ self addCommand: (OTFCommand actionBlock: [ self goForward ] times: aNumber) ]! !!OTFRobot methodsFor: 'stepping' stamp: 'federicobalaguer 8/28/2014 15:16'!step	| cmd |	(cmd := self currentCommand) executeCommand.	self handleStep: 1.	cmd hasStepsToGo		ifFalse: [ 			commands remove: cmd.			semaphore signal.			Transcript				show: 'Command removed';				cr ].	self changed! !!ServiceProviderBot methodsFor: 'protocol - checking' stamp: 'federicobalaguer 9/24/2016 08:50'!blockEvaluationTest: aBot	| block |	block := [ Time millisecondClockValue \\ 4 ].	^ block value = (aBot evaluateBlock: block)! !!ServiceProviderBot methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/24/2016 17:43'!bodyClass	^ BGSWirelessEnabledRobotBody! !!ServiceProviderBot methodsFor: 'protocol primitive' stamp: 'federicobalaguer 9/24/2016 08:52'!checkNeighbour: aBot	^ (self identityTest: aBot) and: [ self blockEvaluationTest: aBot ]! !!ServiceProviderBot methodsFor: 'protocol' stamp: 'federicobalaguer 9/24/2016 09:01'!checkNeighbours	self peerBots		do: [ :each | 			(self checkNeighbour: each)				ifFalse: [ ^ self error: 'A robot fails to answer the basic check' ] ]! !!ServiceProviderBot methodsFor: 'protocol primitive' stamp: 'federicobalaguer 9/24/2016 08:45'!fixBatteryOf: aBot	aBot requiresBatteryCharge		ifTrue: [ aBot battery fullRecharge ]! !!ServiceProviderBot methodsFor: 'protocol primitive' stamp: 'federicobalaguer 9/26/2016 12:30'!helpNeighbour: aBot	self checkNeighbour: aBot.	^ self fixBatteryOf: aBot! !!ServiceProviderBot methodsFor: 'protocol' stamp: 'federicobalaguer 9/26/2016 12:30'!helpNeighbours	self peerBots do: [ :each | self helpNeighbour: each ]! !!ServiceProviderBot methodsFor: 'protocol - checking' stamp: 'federicobalaguer 9/24/2016 08:52'!identityTest: aBot	^ aBot publicKey = aBot id hash! !!ServiceProviderBot methodsFor: 'testing' stamp: 'federicobalaguer 9/23/2016 12:53'!isPeerOf: anotheBot	^ self peerBots includes: anotheBot! !!ServiceProviderBot methodsFor: 'accessing' stamp: 'federicobalaguer 9/23/2016 12:53'!peerBots	^ self wireless peers collect: [ :each | each bot ]! !!ServiceProviderBot methodsFor: 'protocol' stamp: 'federicobalaguer 9/26/2016 12:47'!swirlOneNeighbour	| peer |	self peerBots isEmpty		ifTrue: [ ^ self ].	peer := self peerBots first.	(self checkNeighbour: peer)		ifFalse: [ ^ self ].	peer brushDown.	1 to: 10 do: [ :number | peer turn: 45 advance: number ]! !!ServiceProviderBot methodsFor: 'accessing' stamp: 'federicobalaguer 9/24/2016 08:57'!wireless	^ self body part: #wireless! !!WalkingBrushRobot class methodsFor: 'instance creation' stamp: 'federicobalaguer 7/11/2014 19:37'!newWithPosition: aPosition	^ self new		position: aPosition;		battery: Battery fullyCharged;		yourself! !!WalkingBrushRobot class methodsFor: 'instance creation' stamp: 'federicobalaguer 7/11/2014 19:37'!withBattery	^ self new		battery: Battery fullyCharged ;		yourself! !!WalkingBrushRobot class methodsFor: 'instance creation' stamp: 'federicobalaguer 7/11/2014 15:00'!withoutBattery	^ self new		battery: EndlessBattery new;		yourself! !!WalkingBrushRobot methodsFor: 'battery' stamp: 'NahuelGarbezza 12/9/2012 18:21'!battery	^ battery! !!WalkingBrushRobot methodsFor: 'battery' stamp: 'NahuelGarbezza 12/9/2012 18:21'!battery: aBattery	battery := aBattery! !!WalkingBrushRobot methodsFor: 'brush' stamp: 'federicobalaguer 8/22/2017 17:54'!brushDown	(self battery canConsume: 1)		ifTrue: [ brush goDown	"self setBrushCommand: [ self state brushDownFor: self ] " ]		ifFalse: [ ChargeBatteryError signal ]! !!WalkingBrushRobot methodsFor: 'brush' stamp: 'federicobalaguer 8/22/2017 17:19'!brushUp	(self battery canConsume: 1)		ifTrue: [ brush goUp. "self setBrushCommand: [ self state brushUpFor: self ]" ]		ifFalse: [ ChargeBatteryError signal ]! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 7/8/2014 13:14'!direction	^ self directionMap keyAtValue: self heading! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 10/4/2016 09:39'!direction: aDirection	"aDirection should be 0, 45, 90, 135, 180, 225, 270, 315 or its multiples"	(self battery canConsume: 1)		ifTrue: [ (aDirection isDivisibleBy: 45)				ifTrue: [ self setDirection: aDirection % 360 ] ]		ifFalse: [ ChargeBatteryError signal ]! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 7/7/2014 23:44'!east	self direction: 90! !!WalkingBrushRobot methodsFor: 'private' stamp: 'federicobalaguer 8/23/2017 14:20'!handleStep: aDistance	brush tracePosition.	self battery consume: aDistance! !!WalkingBrushRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/22/2017 16:55'!initialize	super initialize.	brush := Brush forRobot: self.	"self state: self initialState."	self headingFromDirection: 0.	^ self! !!WalkingBrushRobot methodsFor: 'brush' stamp: 'gbosetti 8/27/2017 19:58'!isBrushDown	^brush isDown! !!WalkingBrushRobot methodsFor: 'brush' stamp: 'gbosetti 8/27/2017 19:58'!isBrushUp	^brush isUp! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'federicobalaguer 9/6/2016 18:10'!move: aDistance	(self battery canConsume: aDistance)		ifTrue: [ self setStepsToGo: aDistance ]		ifFalse: [ ChargeBatteryError signal ]! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 7/7/2014 23:45'!north	self direction: 0! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'federicobalaguer 7/8/2014 15:14'!position	^ self body position! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'federicobalaguer 9/6/2016 18:10'!position: aPoint	(self battery canConsume: 1)		ifTrue: [ self addCommand: (OTFCommand actionBlock: [ self jumpTo: aPoint ] times: 1) ]		ifFalse: [ ChargeBatteryError signal ]! !!WalkingBrushRobot methodsFor: 'printing' stamp: 'federicobalaguer 9/6/2016 18:20'!printOn: aStream	aStream		nextPutAll: 'Robot at ';		nextPutAll: self position printString;		nextPutAll: ', direction ';		nextPutAll: self direction printString! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 10/4/2016 09:39'!quarter	self direction: (self direction + 90) % 360! !!WalkingBrushRobot methodsFor: 'private' stamp: 'federicobalaguer 8/12/2014 16:05'!setBrushCommand: aBlock	self addCommand: (OTFCommand actionBlock: aBlock)! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 7/7/2014 23:45'!south	self direction: 180! !!WalkingBrushRobot methodsFor: 'private' stamp: 'federicobalaguer 8/22/2017 17:54'!state	^ brush! !!WalkingBrushRobot methodsFor: 'private' stamp: 'federicobalaguer 8/22/2017 17:54'!state: aState	brush := aState! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'federicobalaguer 7/7/2014 23:45'!west	self direction: 270! !!WalkingBrushWirelessRobot methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/7/2016 09:42'!bodyClass	^ BGSWirelessEnabledRangeSensorBeltRobotBody! !!WalkingBrushWirelessRobot methodsFor: 'testing' stamp: 'federicobalaguer 9/7/2016 11:21'!isPeerOf: anotheBot	^ self peerBots includes: anotheBot! !!WalkingBrushWirelessRobot methodsFor: 'accessing' stamp: 'federicobalaguer 10/6/2015 17:21'!peerBots	^ self wireless peers collect: [ :each | each bot ]! !!WalkingBrushWirelessRobot methodsFor: 'accessing' stamp: 'federicobalaguer 10/6/2015 17:15'!wireless	^self body part: #wireless! !!RandomTraceRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 7/3/2014 10:35'!bodyClass 	^BGSRobotBodyWithFrontRangeSensor "BGSRangeSensorBeltRobotBody" ! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/20/2014 14:25'!brushDown	self traceOn! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/20/2014 14:25'!brushUp	self traceOff! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:50'!direction	^ 0! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:50'!direction: aNumber	! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:50'!east	! !!RandomTraceRobot methodsFor: 'stepping' stamp: 'federicobalaguer 6/26/2014 13:41'!goForward	stepsToGo > 0		ifTrue: [ 			super goForward.			stepsToGo := stepsToGo - 1 ]! !!RandomTraceRobot methodsFor: 'testing' stamp: 'federicobalaguer 6/26/2014 15:09'!hasStepsToGo	^ stepsToGo > 0! !!RandomTraceRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 6/26/2014 13:42'!initialize	super initialize.	traceOn := true.	stepsToGo := 0.	body heading: 0 @ 1! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:48'!isBrushDown	^ true! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:48'!isBrushUp	^ false! !!RandomTraceRobot methodsFor: 'testing' stamp: 'federicobalaguer 8/20/2014 13:55'!isIdle	^ self hasStepsToGo not! !!RandomTraceRobot methodsFor: 'initialize-release' stamp: 'federicobalaguer 6/26/2014 10:10'!jumpTo: aPoint in: terrain	super jumpTo: aPoint in: terrain.	self addDependent: terrain.	self changed! !!RandomTraceRobot methodsFor: 'stepping' stamp: 'federicobalaguer 6/26/2014 15:19'!move: aNumber	stepsToGo := aNumber.	self changed! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/28/2014 13:17'!north"nothing to do"! !!RandomTraceRobot methodsFor: 'exploring' stamp: 'federicobalaguer 6/26/2014 10:12'!rangeSensorBelt	^self body part: #rangeSensorBelt! !!RandomTraceRobot methodsFor: 'exploring' stamp: 'federicobalaguer 6/26/2014 10:11'!sensedPositions	^self rangeSensorBelt sensedPositions! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:50'!south! !!RandomTraceRobot methodsFor: 'stepping' stamp: 'federicobalaguer 6/26/2014 13:26'!step	| bodyCell |	bodyCell := self body cell.	"bodyCell color = Color gray"	traceOn		ifTrue: [ bodyCell color: Color black ].	self turnBy: (-2 to: 2) atRandom.	self goForward.	self changed! !!RandomTraceRobot methodsFor: 'stepping' stamp: 'federicobalaguer 6/26/2014 13:24'!traceOff	traceOn := false! !!RandomTraceRobot methodsFor: 'stepping' stamp: 'federicobalaguer 6/26/2014 13:23'!traceOn	traceOn := true! !!RandomTraceRobot methodsFor: 'bot compatibility' stamp: 'federicobalaguer 8/6/2014 15:51'!west! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/20/2014 09:24'!basicViewOn: aSimulation	^self on: aSimulation terrainCellExtent: self defaultGridCellExtent factory: (BasicArenaBehavior new)! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/20/2014 13:09'!beginnerViewOn: aSimulation	^self on: aSimulation terrainCellExtent: self defaultGridCellExtent ! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'FedericoBalaguer 5/4/2012 10:29'!defaultGridCellExtent 	^10@10! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/20/2014 09:24'!expertViewOn: aSimulation	^ self on: aSimulation terrainCellExtent: self defaultGridCellExtent factory: EnhancedArenaBehavior new! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/20/2014 09:24'!on: aSimulation terrainCellExtent: aPoint	^ self on: aSimulation terrainCellExtent: aPoint factory: BasicArenaBehavior new! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/14/2014 15:19'!on: aSimulation terrainCellExtent: aPoint factory: aFactory	^ self new		factory: aFactory;		gridCellExtent: aPoint;		simulation: aSimulation;			openInWorld;		yourself! !!BGSArenaWindow class methodsFor: 'instance creation' stamp: 'federicobalaguer 9/24/2016 17:02'!wirelessViewOn: aSimulation	^ self on: aSimulation terrainCellExtent: self defaultGridCellExtent factory: ServiceArenaBehavior new! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/26/2014 16:40'!addBinding: aSymbol object: anObject	bindings at: aSymbol put: anObject! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/14/2014 15:15'!addButtonsToPanel: panel	^factory addButtonsToPanel: panel of: self ! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'FedericoBalaguer 12/6/2011 18:58'!addCountersToPanel: panel 	| stepsView |	self stepCounterMorph: (LabelMorph contents: '0').	stepsView := self wrapMorph: self stepCounterMorph andAddLabel: 'Steps:'. 	panel 		addMorph: stepsView		fullFrame: (LayoutFrame 				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (4 @ 4 corner: -8 @ 44))! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'Gabriela 10/6/2015 20:58'!addRobot	| aName |	aName := self textEntry: 'Enter a new name' title: 'Enter Robot Name'.	aName ifNil: [ ^ self ].	bindings		at: aName		ifPresent: [ :robot | self alert: 'A Robot named: ' , aName , ' already exists. Please, choose another name' title: 'Robot creation error' ]		ifAbsent: [ self addRobotAndBinding: aName ]! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/25/2014 22:55'!addRobotAndBinding: aName	| robot |	robot := simulation createAndDeployRobot: aName.	bindings at: aName put: robot! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/31/2016 08:01'!addRobotOnPosition: cellPosition	| aName |	aName := self textEntry: 'Enter a new name' title: 'Enter Robot Name'.	aName ifNil: [ ^ self ].	bindings		at: aName		ifPresent: [ :robot | self alert: 'A Robot named: ' , aName , ' already exists. Please, choose another name' title: 'Robot creation error' ]		ifAbsent: [ self updateBinding: aName robot: (simulation createAndDeployRobot: aName position: cellPosition)]			! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/30/2016 22:57'!bindings	bindings		ifNil: [ bindings := Dictionary new.			bindings at: #robotech put: nil ].	^ bindings! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/25/2014 17:15'!browseAvailableObjects	bindings inspect! !!BGSArenaWindow methodsFor: 'private ' stamp: 'FedericoBalaguer 12/13/2011 23:33'!buttonsWidth	^150! !!BGSArenaWindow methodsFor: 'testing' stamp: 'FedericoBalaguer 11/22/2011 11:25'!canResetSimulation	^self simulation isRunning not! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'federicobalaguer 8/27/2014 12:38'!cleanBindings	self bindings removeAll.	^ bindings! !!BGSArenaWindow methodsFor: 'displaying' stamp: 'federicobalaguer 8/19/2014 16:23'!displayGridView	| newExtent deltaWidth board deltaHeight |	board := AlignmentMorph newRow.	board extent: self gridView extent + (self buttonsWidth @ 0).	self gridView container: self.	board addMorphBack: self newControlPanelMorph.	board addMorphBack: self gridView.	deltaWidth := 2 * (self borderWidth + self class borderWidth).	deltaHeight := 2 * (self borderWidth + self class borderWidth) + self labelHeight.	newExtent := board fullBounds extent + (deltaWidth @ deltaHeight).	self extent: newExtent.	self addMorph: board frame: (0 @ 0 extent: 1 @ 1)! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'federicobalaguer 8/14/2014 15:14'!factory: aFactory	factory := aFactory! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'FedericoBalaguer 5/4/2012 10:27'!gridCellExtent	^ gridCellExtent! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'FedericoBalaguer 5/4/2012 10:27'!gridCellExtent: anObject	gridCellExtent := anObject! !!BGSArenaWindow methodsFor: 'private ' stamp: 'federicobalaguer 8/6/2014 12:37'!gridViewClass	^BotArenaGridView ! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/20/2014 09:44'!handleRedButtonOnEmptyCell: cellPosition	factory handleRedButtonOnEmptyCell: cellPosition window: self! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/20/2014 10:50'!handleYellowButtonOnBot: aRobot	factory handleYellowButtonOnBot: aRobot window: self	! !!BGSArenaWindow methodsFor: 'testing' stamp: 'federicobalaguer 7/3/2014 13:40'!hasBrowser	^ browser isNil! !!BGSArenaWindow methodsFor: 'testing' stamp: 'federicobalaguer 8/25/2014 17:06'!hasWorkspace	^ false! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'FedericoBalaguer 12/13/2011 22:46'!newControlPanelMorph	| panel |	panel := AlignmentMorph newColumn.	panel color: Color darkGray.	panel extent: self buttonsWidth @ self gridView extent y.	self addCountersToPanel: panel.	self addButtonsToPanel: panel.	^ panel! !!BGSArenaWindow methodsFor: 'private ' stamp: 'FedericoBalaguer 11/12/2011 17:45'!offButtonColor 	^Color white! !!BGSArenaWindow methodsFor: 'private ' stamp: 'FedericoBalaguer 11/12/2011 17:45'!onButtonColor 	^Color green ! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 9/13/2016 16:57'!openBrowser	Smalltalk tools browser openOnClass: self simulation robotClass! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'ArturoZambrano 8/30/2014 20:16'!openBrowserOnRobot	(browser := MinimalBrowser on: self simulation robotClass) openWithSpec! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/30/2016 23:32'!openWorkspace	playground := Smalltalk tools workspace openContents: ''.	playground setBindings: bindings! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/30/2016 23:04'!openWorkspaceWithContent		playground := Smalltalk tools workspace openContents: self workspaceContent.	playground setBindings: bindings! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/31/2016 08:03'!resetSimulation	| shouldReset |	self canResetSimulation		ifFalse: [ ^ self ].	shouldReset := self		proceed: 'Do you really want to reset the simulation?'		title: 'Reset simulation?'.	shouldReset		ifFalse: [ ^ self ].	factory resetSimulation: self.	self resyncPlaygroundBindings! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/31/2016 08:03'!resyncPlaygroundBindings	| wnd |	(playground notNil		and: [ (wnd := playground window) notNil and: [ wnd isInWorld ] ])		ifTrue: [ playground setBindings: bindings ]		ifFalse: [ playground := nil ]! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'FedericoBalaguer 11/10/2011 22:31'!simulation	^ simulation! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'federicobalaguer 8/27/2014 11:40'!simulation: newSimulation	simulation := newSimulation.	simulation addDependent: self.	self displayGrid: simulation terrain cellExtent: self gridCellExtent.	factory createAndDeployRobotsOn: simulation from: self.	self update: simulation! !!BGSArenaWindow methodsFor: 'displaying' stamp: 'FedericoBalaguer 11/12/2011 17:20'!simulationStatusString	self simulation autoStopConditionReached ifTrue: [^'Stop condition reached'].	self simulation isPaused ifTrue: [^'Paused'].	^'Running'! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'FedericoBalaguer 11/10/2011 22:31'!stepCounterMorph	^ stepCounterMorph! !!BGSArenaWindow methodsFor: 'accessing' stamp: 'FedericoBalaguer 11/10/2011 22:31'!stepCounterMorph: anObject	stepCounterMorph := anObject! !!BGSArenaWindow methodsFor: 'displaying' stamp: 'federicobalaguer 8/22/2017 10:47'!update: anObject	super update: anObject.	self setLabel: self simulation printString, ' - ', self simulationStatusString.	self stepCounterMorph contents: self simulation stepCount printString.! !!BGSArenaWindow methodsFor: 'callbacks' stamp: 'federicobalaguer 8/31/2016 08:04'!updateBinding: aName robot: aBot	bindings at: aName put: aBot.	self resyncPlaygroundBindings! !!BGSArenaWindow methodsFor: 'private ' stamp: 'federicobalaguer 7/11/2014 16:35'!workspaceContent	| wst |	wst := WriteStream on: String new.	wst		nextPut: $";		nextPutAll: 'La forma de indicarle a un objeto que hacer, es mediante el envío de mensajes.';		nextPut: $";		cr;		cr;		nextPut: $";		nextPutAll: ' Para que el robot se mueva 10 celdas, le enviamos a robotech el mensaje #move: con parámetro 10';		nextPut: $";		cr;		nextPutAll: 'robotech move: 10.';		cr;		cr;		nextPut: $";		nextPutAll:				' Para que el robot se oriente hacia la derecha, le enviamos a robotech el mensaje #direction: con parámetro 90';		nextPut: $";		cr;		nextPutAll: 'robotech direction: 90.';		cr;		cr;		nextPut: $";		nextPutAll: 'Podemos enviarle a un objeto una serie de mensajes en cascada utilizando ;';		nextPut: $";		cr;		nextPutAll:				'robotech brushDown; direction: 0; move: 3; direction: 90; move: 3; direction: 180; move: 3; direction: 270; move: 3.'.	^ wst contents! !!BGSArenaWindow methodsFor: 'initialize-release' stamp: 'FedericoBalaguer 11/13/2011 11:56'!wrapMorph: aMorph andAddLabel: aString    "creates a wrapping panel for aMorph with  a label above it"    | column strM |    column := AlignmentMorph newColumn                wrapCentering: #topLeft;                cellPositioning: #topLeft;                hResizing: #spaceFill;                vResizing: #shrinkWrap;                borderWidth: 2;                layoutInset: 5;                color: Color transparent;                useRoundedCorners;                borderStyle: (BorderStyle complexAltInset width: 2).    column addMorph: aMorph.    strM := StringMorph contents: aString.    strM color: Color veryVeryLightGray.    column addMorph: strM.    ^ column ! !!BGSWirelessEnabledRobotBody methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/24/2016 17:42'!defaultWirelessRange	^ 25! !!BGSWirelessEnabledRobotBody methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/24/2016 17:42'!initParts	super initParts.	BGSWireless botBody: self name: #wireless range: self defaultWirelessRange! !!BotArenaGridView methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/6/2014 12:29'!cellAtAbsolutePosition: position	| clickedCell topLeftCellOriginPosition |	topLeftCellOriginPosition := (self boxForCellAt: (1@1)) origin.	clickedCell := ((position - topLeftCellOriginPosition) // self cellFrameExtent).		clickedCell := clickedCell + (1@1).	^clickedCell.	! !!BotArenaGridView methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/19/2014 16:19'!container: arenaWindow	container := arenaWindow! !!BotArenaGridView methodsFor: 'initialize - release' stamp: 'federicobalaguer 10/6/2015 13:50'!handleEvent: evt position: cellPosition cellContent: clickedCellContent	evt redButtonPressed		ifTrue: [ 			clickedCellContent isNil				ifTrue: [ container handleRedButtonOnEmptyCell: cellPosition ]				ifFalse: [ clickedCellContent bot inspect ] ].	evt yellowButtonPressed		ifTrue: [ 			clickedCellContent notNil				ifTrue: [ container handleYellowButtonOnBot: clickedCellContent bot ] ]! !!BotArenaGridView methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/28/2015 23:52'!initialize 	super initialize.	self on: #click send: #mouseDownEvt: to: self.	! !!BotArenaGridView methodsFor: 'initialize - release' stamp: 'federicobalaguer 10/6/2015 13:50'!mouseDownEvt: evt	| cellPosition clickedCellContent |	cellPosition := self cellAtAbsolutePosition: evt position.	clickedCellContent := self grid contentOfCellAt: cellPosition.	(clickedCellContent isNil or: [ clickedCellContent isRobotBody ])		ifTrue: [ self handleEvent: evt position: cellPosition cellContent: clickedCellContent ]! !!BGSCastleExample methodsFor: 'as yet unclassified' stamp: 'DiegoTorres 8/30/2014 13:55'!addWallAt: origin extent: widthAndHeight	| corner |	corner := origin + widthAndHeight - 1.	origin x to: corner x do: [:x|		origin y to: corner y do: [:y|			self put: BGSCastleWall new inCellAt: x@y]].	self changed! !!BGSCastleExample methodsFor: 'as yet unclassified' stamp: 'DiegoTorres 9/1/2014 11:40'!buildWalls	"Left eye"		self addWallAt: 20@20 extent: 3@3.	self addWallAt: 30@20 extent: 3@3.				self addWallAt: 30@30 extent: 3@3.		self addWallAt: 20@30 extent: 3@3.		self addWallAt: 23@23 extent:7@7.	! !!CastleSimulation methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/6/2015 16:39'!terrainClass	^ BGSCastleExample! !!OnTheFlyConfigurableSimulation class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/11/2014 15:54'!batteryWalkingBrush	^ self basicNew		robotClass: WalkingBrushRobot constructorSelector: #withBattery;		initialize;		yourself! !!OnTheFlyConfigurableSimulation class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/11/2014 15:54'!endlessWalkingBrush	^ self basicNew		robotClass: WalkingBrushRobot constructorSelector: #withoutBattery;		initialize;		yourself! !!OnTheFlyConfigurableSimulation class methodsFor: 'instance creation' stamp: 'federicobalaguer 8/11/2014 15:54'!randomTrace	^ self basicNew		robotClass: RandomTraceRobot;		initialize;		yourself! !!OnTheFlyConfigurableSimulation class methodsFor: 'instance creation' stamp: 'federicobalaguer 9/24/2016 17:03'!wirelessBrush	^ self basicNew		robotClass: WalkingBrushWirelessRobot constructorSelector: #withBattery;		initialize;		yourself! !!OnTheFlyConfigurableSimulation methodsFor: 'testing' stamp: 'federicobalaguer 8/19/2014 14:46'!autoStopConditionReached	^self robots allSatisfy: [ :each| each isIdle  ]! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/23/2016 12:58'!createAndDeployRobot: aName	^ self createAndDeployRobot: aName position: self terrain emptyCellPositions atRandom! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/19/2014 15:54'!createAndDeployRobot: aName position: aPosition	| bot |	bot := self robotWithId: aName asSymbol.	self addRobot: bot.	bot rangeSensorBelt.	bot jumpTo: aPosition in: self terrain.	bot addDependent: self.	^ bot! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/23/2016 17:04'!createAndDeployServiceAgent: aName	^ self		createAndDeployServiceBot: aName		position: self terrain emptyCellPositions atRandom! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 9/23/2016 17:05'!createAndDeployServiceBot: aName position: aPosition	| agent |	agent := ServiceProviderBot new		id: aName asSymbol;		yourself.	self addRobot: agent.	"agent rangeSensorBelt."	agent jumpTo: aPosition in: self terrain.	agent addDependent: self.	^ agent! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/12/2014 23:00'!createRobots	! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/12/2014 23:00'!deployRobots	! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/19/2014 08:56'!initialize	super initialize.	lastBotNumber := 0! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/11/2014 15:54'!robotClass	^ robotClass! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/11/2014 15:54'!robotClass: aClass	self robotClass: aClass constructorSelector: #new! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/11/2014 15:54'!robotClass: aClass constructorSelector: aSymbol	robotClass := aClass.	constructorSelector := aSymbol! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/12/2014 22:56'!robotCount	^ 0! !!OnTheFlyConfigurableSimulation methodsFor: 'initialize - release' stamp: 'federicobalaguer 8/19/2014 15:44'!robotWithId: botNumber	^ (robotClass perform: constructorSelector)		id: botNumber;		yourself! !!OnTheFlyConfigurableSimulation methodsFor: 'stepping' stamp: 'federicobalaguer 8/28/2014 14:11'!run	pauseFlagLock		critical: [ 			self isPaused				ifFalse: [ ^ self ].			self isPaused: false ].	[ self runLoop ] forkAt: Processor userInterruptPriority! !!OnTheFlyConfigurableSimulation methodsFor: 'stepping' stamp: 'federicobalaguer 8/28/2014 16:16'!step	self stepCount: self stepCount + 1.	self robots		do: [ :each | 			each hasStepsToGo				ifTrue: [ each step ] ]! !!OnTheFlyConfigurableSimulation methodsFor: 'dependencies' stamp: 'federicobalaguer 8/19/2014 15:05'!update: aRobot	aRobot hasStepsToGo		ifFalse: [ self pause ]		ifTrue: [ 			self isPaused				ifTrue: [ self run ] ]! !"BotArena"!----SNAPSHOT----2017-08-29T14:15:37.852766-03:00 Pharo6.1.image priorSource: 2151717!----SNAPSHOT----2017-08-29T14:16:52.837039-03:00 Pharo6.1.image priorSource: 2368263!!WalkingBrushRobot methodsFor: 'direction' stamp: 'EncinasJavier 8/29/2017 14:28'!nortEast	self direction: 45! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'EncinasJavier 8/29/2017 14:31'!southEast	self direction: 135.! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'EncinasJavier 8/29/2017 14:31'!southWest	self direction: 225.! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'EncinasJavier 8/29/2017 14:32'!northWest	self direction: 315.! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 14:35'!trace: aDistance	self brushDown.	self move:aDistance.	self brushUp.! !----SNAPSHOT----2017-08-29T15:06:06.474757-03:00 Pharo6.1.image priorSource: 2368350!----QUIT/NOSAVE----2017-08-29T15:06:50.664505-03:00 Pharo6.1.image priorSource: 2369069!----SNAPSHOT----2017-08-29T15:08:02.350336-03:00 Pharo6.1.image priorSource: 2369069!!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 15:45'!dash: aDistance	(aDistance / 2)repeat:[self trace:1;trace:1.]! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 15:47' prior: 35923851!dash: aDistance	(aDistance / 2) timesRepeat: [self trace:1;trace:1.]! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 15:48' prior: 35923428!trace: aDistance	self brushDown.	self brushUp.	self move:aDistance.! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 15:48' prior: 35924018!dash: aDistance	(aDistance / 2) timesRepeat: [self trace:1;move:1.]! !----SNAPSHOT----2017-08-29T15:54:08.563994-03:00 Pharo6.1.image priorSource: 2369246!----SNAPSHOT----2017-08-29T16:03:54.194602-03:00 Pharo6.1.image priorSource: 2370007!!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:03'!dash: aDistance spacing: anSpacing	(0 = aDistance % anSpacing ) ifTrue:	((aDistance / anSpacing) timesRepeat: [self trace:anSpacing;move:anSpacing.])	! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:06' prior: 35924699!dash: aDistance spacing: anSpacing	(0 = aDistance \\ anSpacing ) ifTrue:	((aDistance / anSpacing) timesRepeat: [self trace:anSpacing;move:anSpacing.])	! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:06' prior: 35924957!dash: aDistance spacing: anSpacing	(0 = aDistance \\ anSpacing ) ifTrue:	((aDistance / anSpacing) timesRepeat: [self trace:anSpacing;move:anSpacing.]).! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:07' prior: 35925216!dash: aDistance spacing: anSpacing	(0 = (aDistance \\ anSpacing) ) ifTrue:	((aDistance / anSpacing) timesRepeat: [self trace:anSpacing;move:anSpacing.]).! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:09' prior: 35924192!trace: aDistance	self brushDown.	self move:aDistance.	self brushUp.! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:10' prior: 35925734!trace: aDistance	aDistance repeat:[self brushDown;brushUp;move:1].! !!WalkingBrushRobot methodsFor: 'positioning' stamp: 'EncinasJavier 8/29/2017 16:10' prior: 35925911!trace: aDistance	aDistance timesRepeat:[self brushDown;brushUp;move:1].! !----SNAPSHOT----2017-08-29T16:12:09.118796-03:00 Pharo6.1.image priorSource: 2370094!!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:41'!squareOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize"	self 	east;			move:aSize;			south;			move:aSize;			west;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:42' prior: 35926342!squareOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize"	self 	east;			move:aSize;			south;			move:aSize;			west;			move:aSize;			north;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:43'!squareOfSize: aSize at: aPoint	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize"	self 	position: aPoint; 				east;			move:aSize;			south;			move:aSize;			west;			move:aSize;			north;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:43' prior: 35926923!squareOfSize: aSize at: aPoint	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize en un punto dado"	self 	position: aPoint; 				east;			move:aSize;			south;			move:aSize;			west;			move:aSize;			north;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:44'!squareAtHomeOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize en un punto dado"	self 	position: (25@25); 				east;			move:aSize;			south;			move:aSize;			west;			move:aSize;			north;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:45'!rotatedSquareOfSize: aSize	"Realiza un rombo con una esquina a la posicion actual y de lado aSize "	self			nortEast;			move:aSize;			south;			move:aSize;			west;			move:aSize;			north;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:46' prior: 35927956!rotatedSquareOfSize: aSize	"Realiza un rombo con una esquina a la posicion actual y de lado aSize "	self			nortEast;			move:aSize;			southEast;			move:aSize;			northWest;			move:aSize;			southEast;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:47' prior: 35928278!rotatedSquareOfSize: aSize	"Realiza un rombo con una esquina a la posicion actual y de lado aSize "	self			nortEast;			move:aSize;			southEast;			move:aSize;			southWest;			move:aSize;			northWest;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:49'!rotatedSquareOfSize: aSize at: aPoint	"Realiza un rombo con una esquina a la posicion actual y de lado aSize en un punto dado"	self 	position:aPoint;			nortEast;			move:aSize;			southEast;			move:aSize;			southWest;			move:aSize;			northWest;			move:aSize.	! !Object subclass: #PatrolCouple	instanceVariableNames: 'patrol sniper'	classVariableNames: ''	package: 'BotArena-Robots'!!PatrolCouple class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 14:54'!patrol: aRobot sniper: anotherRobot	"Constructor de #PatrolCouple"	^(self new) patrol: aRobot; sniper: anotherRobot.	! !----SNAPSHOT----2017-09-05T14:56:23.706166-03:00 Pharo6.1.image priorSource: 2371730!!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 14:58'!patrol	^ patrol! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 14:58'!patrol: anObject	patrol := anObject! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 14:58'!sniper	^ sniper! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 14:58'!sniper: anObject	sniper := anObject! !!PatrolCouple methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:06'!reset	"Ambos robots se posicionan enfrentados a distancia 5 uno del otro (uno mira a south y el otro mira a north uno de ellos posicionado en el 20@20)"	sniper 	position: 20@20;					north.	patrol 	position: 20@22;				south.! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:06' prior: 35930148!reset	"Ambos robots se posicionan enfrentados a distancia 5 uno del otro (uno mira a south y el otro mira a north uno de ellos posicionado en el 20@20)"	sniper 	position: 20@20;					south.	patrol 	position: 20@25;				north.! !!WalkingBrushRobot methodsFor: 'direction' stamp: 'EncinasJavier 9/5/2017 15:11'!northEast	self direction: 45! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:11' prior: 35928613!rotatedSquareOfSize: aSize	"Realiza un rombo con una esquina a la posicion actual y de lado aSize "	self			northEast;			move:aSize;			southEast;			move:aSize;			southWest;			move:aSize;			northWest;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:11' prior: 35928932!rotatedSquareOfSize: aSize at: aPoint	"Realiza un rombo con una esquina a la posicion actual y de lado aSize en un punto dado"	self 	position:aPoint;			northEast;			move:aSize;			southEast;			move:aSize;			southWest;			move:aSize;			northWest;			move:aSize.	! !WalkingBrushRobot removeSelector: #nortEast!!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:12' prior: 35930929!rotatedSquareOfSize: aSize	"Realiza un rombo con una esquina a la posicion actual y de lado aSize "	self			southEast;			move:aSize;			southWest;			move:aSize;			northWest;			move:aSize;			northEast;			move:aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:13' prior: 35931265!rotatedSquareOfSize: aSize at: aPoint	"Realiza un rombo con una esquina a la posicion actual y de lado aSize en un punto dado"	self 	position:aPoint;			rotatedSquareOfSize: aSize.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:13' prior: 35927614!squareAtHomeOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize en un punto dado"	self rotatedSquareOfSize: aSize at: (25@25)				! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:13' prior: 35932322!squareAtHomeOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize en un punto dado"	self squareOfSize: aSize at: (25@25)				! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:14' prior: 35927268!squareOfSize: aSize at: aPoint	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize en un punto dado"	self 	position: aPoint; 				squareOfSize: aSize.	! !----SNAPSHOT----2017-09-05T15:14:17.228413-03:00 Pharo6.1.image priorSource: 2375113!!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:18'!regularPatrol	"patrol hace un cuadrado de lado 10 rotado 45 grados alrededor de sniper, sniper en el centro gira en sentido de las agujas del reloj"	self patrol rotatedSquareOfSize: 10.	self sniper east;south;west;north.				! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:19' prior: 35933221!regularPatrol	"patrol hace un cuadrado de lado 10 rotado 45 grados alrededor de sniper, sniper en el centro gira en sentido de las agujas del reloj"	self patrol rotatedSquareOfSize: 10.	self sniper northEast;east;southEast;south;southWest;west;northWest;north.				! !----SNAPSHOT----2017-09-05T15:21:35.994942-03:00 Pharo6.1.image priorSource: 2378624!!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:22' prior: 35930473!reset	"Ambos robots se posicionan enfrentados a distancia 5 uno del otro (uno mira a south y el otro mira a north uno de ellos posicionado en el 20@20)"	patrol 	position: 20@20;					south.	sniper 	position: 20@25;				north.! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:23'!regularPatrolTrace	"patrol hace un cuadrado de lado 10 rotado 45 grados alrededor de sniper, sniper en el centro gira en sentido de las agujas del reloj. Con Trace"	self patrol brushDown;rotatedSquareOfSize: 10;brushUp.	self sniper northEast;east;southEast;south;southWest;west;northWest;north.				! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:28'!doRegularPatrol	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ self regularPatrol. 						self patrol position: (self patrol position + (5@0))						self sniper position: (self sniper position + (5@0))]			! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:29'!shiftEast	"la pareja se mueve 5 posiciones al este"		self patrol position: (self patrol position + (5@0)).		self sniper position: (self sniper position + (5@0)).			! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:31' prior: 35934693!doRegularPatrol	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self regularPatrol. 							self shiftEast.]			! !----SNAPSHOT----2017-09-05T15:31:24.327046-03:00 Pharo6.1.image priorSource: 2379387!!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:32'!doRegularPatrolTrace	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self patrol brushDown.							self doRegularPatrol.							self patrol brushUp.							self shiftEast ]			! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:34' prior: 35935581!doRegularPatrolTrace	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self patrol brushDown.							self doRegularPatrolTrace.							self patrol brushUp.							self shiftEast ]			! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:34' prior: 35935884!doRegularPatrolTrace	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self patrol brushDown.							self RegularPatrolTrace.							self patrol brushUp.							self shiftEast ]			! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:34' prior: 35936192!doRegularPatrolTrace	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self patrol brushDown.							self regularPatrolTrace.							self patrol brushUp.							self shiftEast ]			! !!PatrolCouple methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:36' prior: 35936498!doRegularPatrolTrace	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self patrol brushDown.							self regularPatrolTrace.							self patrol brushUp.							self shiftEast.							self battery charge: 100.]			! !----QUIT/NOSAVE----2017-09-05T15:38:32.460603-03:00 Pharo6.1.image priorSource: 2380984!!PatrolCouple methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:42'!chargeBots	patrol battery charge: patrol battery capacity.	sniper battery charge: sniper battery capacity.! !!PatrolCouple methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:42'!doTheRegularPatrol	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self regularPatrol. 							self shiftEast.]			! !PatrolCouple removeSelector: #doRegularPatrol!!PatrolCouple methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:42' prior: 35937426!doTheRegularPatrol	"regularPatrol moviendose 5 veces 5 posiciones al este"	5 timesRepeat: [ 	self regularPatrol. 							self shiftEast.							self chargeBots.]			! !!PatrolCouple methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:43'!doTheRegularPatrolTrace	"regularPatrol moviendose 5 veces 5 posiciones al este"	self patrol brushDown.	self doTheRegularPatrol.	self patrol brushUp.			! !----SNAPSHOT----2017-09-05T15:44:04.220057-03:00 Pharo6.1.image priorSource: 2380984!Object subclass: #CastleWatch	instanceVariableNames: 'northWatch southWatch eastWatch westWatch'	classVariableNames: ''	package: 'BotArena-Robots'!!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!northWatch	^ northWatch! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!northWatch: anObject	northWatch := anObject! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!southWatch	^ southWatch! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!southWatch: anObject	southWatch := anObject! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!eastWatch	^ eastWatch! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!eastWatch: anObject	eastWatch := anObject! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!westWatch	^ westWatch! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 15:47'!westWatch: anObject	westWatch := anObject! !!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:48'!regularWatch! !!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:50' prior: 35939371!regularWatch	"los robots realizan un cuadrado de lado 3 en su correspondiente flanco"		self eastWatch smallTracedSquare.	self westWatch smallTracedSquare.	self northWatch smallTracedSquare.	self southWatch smallTracedSquare.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:52'!smallTracedSquare	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self brushDown.	self squareOfSize: 3	self brushUp.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:52' prior: 35939815!smallTracedSquare	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self brushDown.	self squareOfSize: 3.	self brushUp.! !----SNAPSHOT----2017-09-05T15:52:38.861188-03:00 Pharo6.1.image priorSource: 2383709!!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:57'!reset	"resetea las posiciones del watch"	self eastWatch position: 36@30.	self westWatch position: 16@30.	self northWatch position: 31@36.	self southWatch position: 31@18.! !!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:57' prior: 35940377!reset	"resetea las posiciones del watch"		self eastWatch position: 36@30.	self westWatch position: 16@30.	self northWatch position: 31@36.	self southWatch position: 31@18.! !!CastleWatch class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 15:59'!noWatch: robotA soWatch: robotB eaWatch: robotC weWatch: robotD	^(self new) northWatch: robotA; southWatch: robotB; westWatch: robotC; eastWatch: robotD.! !----SNAPSHOT----2017-09-05T16:00:40.162499-03:00 Pharo6.1.image priorSource: 2385771!----SNAPSHOT----2017-09-05T16:07:32.704942-03:00 Pharo6.1.image priorSource: 2386657!!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:08' prior: 35940659!reset	"resetea las posiciones del watch"		self eastWatch position: 38@20.	self westWatch position: 14@22.	self northWatch position: 21@14.	self southWatch position: 21@38.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:10' prior: 35940063!smallTracedSquare	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self brushDown.	self squareOfSize: 2.	self brushUp.! !!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:11'!paranoidatch	"los robots realizan un cuadrado de lado 3 en su correspondiente flanco"		self eastWatch smallRectangleV.	self westWatch smallRectangleV.	self northWatch smallRectangleH.	self southWatch  smallRectangleH.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:13'!rectangleOfBase: aBase alt: anAlt	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self brushDown.	self brushUp.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:16' prior: 35942201!rectangleOfBase: aBase alt: anAlt	"realiza un rectangulo de lado aBase y an Alt" 		self	east;			move:aBase;			south;			move:anAlt;			west;			move:aBase;			north;			move:anAlt.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:17'!tracedRectangleOfBase: aBase alt: anAlt	"realiza un rectangulo de lado aBase y an Alt - traced" 		self 	brushDown;				east;			move:aBase;			south;			move:anAlt;			west;			move:aBase;			north;			move:anAlt;			brushUp.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:17' prior: 35926628!squareOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize"	self rectangleOfBase: aSize alt: aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:17'!tracedSquareOfSize: aSize	"Realiza un cuadrado con una esquina a la posicion actual y de lado aSize"	self tracedRectangleOfBase: aSize alt: aSize.	! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:18' prior: 35941655!smallTracedSquare	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self tracedSquareOfSize: 2.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:18'!smallRectangle	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self tracedSquareOfSize: 2.! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:19'!smallRectangleV	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self tracedSquareOfSize: 2.! !WalkingBrushRobot removeSelector: #smallRectangle!!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:20' prior: 35943969!smallRectangleV	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self tracedRectangleOfBase: 3 alt: 9! !!WalkingBrushRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:20'!smallRectangleH	"realiza un cuadrado de lado 3 marcado. Practica 2 ejercicio 5"	self tracedRectangleOfBase: 9 alt: 3.! !!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 16:22' prior: 35941366!reset	"resetea las posiciones del watch"		self eastWatch position: 38@32.	self westWatch position: 14@32.	self northWatch position: 21@14.	self southWatch position: 21@38.! !!CastleWatch methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/5/2017 16:23'!paranoidWatch	"los robots realizan un cuadrado de lado 3 en su correspondiente flanco"		self eastWatch smallRectangleV.	self westWatch smallRectangleV.	self northWatch smallRectangleH.	self southWatch  smallRectangleH.! !CastleWatch removeSelector: #paranoidatch!----SNAPSHOT----2017-09-05T16:23:07.144031-03:00 Pharo6.1.image priorSource: 2386744!!CastleWatch methodsFor: 'accessing' stamp: 'EncinasJavier 9/5/2017 16:23' prior: 35944671!reset	"resetea las posiciones del watch"		self eastWatch position: 38@20.	self westWatch position: 14@20.	self northWatch position: 21@14.	self southWatch position: 21@38.! !----SNAPSHOT----2017-09-05T16:24:28.833484-03:00 Pharo6.1.image priorSource: 2390777!----SNAPSHOT----2017-09-05T16:24:35.90873-03:00 Pharo6.1.image priorSource: 2391137!----QUIT/NOSAVE----2017-09-05T16:24:37.94579-03:00 Pharo6.1.image priorSource: 2391224!----SNAPSHOT----2017-09-12T14:16:36.988605-03:00 Pharo6.1.image priorSource: 2391224!Object subclass: #Wallpost	instanceVariableNames: 'text likes isFeatured'	classVariableNames: ''	package: 'BotArena'!!Wallpost methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 14:20'!text	^ text! !!Wallpost methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 14:20'!text: anObject	text := anObject! !!Wallpost methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 14:20'!likes	^ likes! !!Wallpost methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 14:20'!likes: anObject	likes := anObject! !!Wallpost methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 14:20'!isFeatured	^ isFeatured! !!Wallpost methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 14:20'!isFeatured: anObject	isFeatured := anObject! !!Wallpost methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/12/2017 14:23'!initialize	isFeatured:= false.	likes:= 0.	text:= 'Undefined Post'.	! !!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 14:56'!sumOf	"retorna la suma de mis primeros (yo) numeros"	^self timesRepeat:[self + self ]! !!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 14:58' prior: 35946901!sumOf	"retorna la suma de mis primeros (yo) numeros"	|t|	t:= 1.	^self timesRepeat:[t + (t+1) ].! !!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 14:58' prior: 35947081!sumOf	"retorna la suma de mis primeros (yo) numeros"	|t|	t:= 1.	self timesRepeat:[t + (t+1) ].	^t.! !!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 15:00' prior: 35947273!sumOf	"retorna la suma de mis primeros (yo) numeros"	|t|	t:= 1.	self timesRepeat:[t:= t + (t+1) ].	^t.! !!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 15:00' prior: 35947469!sumOf	"retorna la suma de mis primeros (yo) numeros"	|t|	t:= 1.	self timesRepeat:[t:= t +t ].	^t.! !----SNAPSHOT----2017-09-12T15:02:36.442244-03:00 Pharo6.1.image priorSource: 2391399!!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 15:09' prior: 35947669!sumOf	"retorna la suma de mis primeros (yo) numeros"	|sum|	sum:=0.	1 to: self do:[:i|sum:= sum + i].! !!Number methodsFor: 'arithmetic' stamp: 'EncinasJavier 9/12/2017 15:10' prior: 35947951!sumOf	"retorna la suma de mis primeros (yo) numeros"	|sum|	sum:=0.	1 to: self do:[:i|sum:= sum + i].	^sum.! !----SNAPSHOT----2017-09-12T15:25:33.864743-03:00 Pharo6.1.image priorSource: 2393342!Object subclass: #Triagle	instanceVariableNames: 'base altura'	classVariableNames: ''	package: 'BotArena'!!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:32'!base	^ base! !!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:32'!base: anObject	base := anObject! !!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:32'!altura	^ altura! !!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:32'!altura: anObject	altura := anObject! !!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:38'!hipotenusa	^((self base square)+(self altura square ))sqrt.! !!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:38'!perimetro	^ self base + self altura + self hipotenusa.! !!Triagle methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 15:39'!superficie	^ (self base * self altura)/2.! !!Triagle class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 9/12/2017 15:51'!base: aBase altura: anAltura	^((self new)base: aBase; altura: anAltura).! !----SNAPSHOT----2017-09-12T16:02:35.058368-03:00 Pharo6.1.image priorSource: 2393832!Battery subclass: #EnergyRecoveryCell	instanceVariableNames: 'stepsToRecovery'	classVariableNames: ''	package: 'BotArena-Modules'!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 16:04'!stepsToRecovery	^ stepsToRecovery! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 16:04'!stepsToRecovery: anObject	stepsToRecovery := anObject! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 16:23'!consume: amount	(self canConsume: amount)		ifTrue: [ (amount / 10) timesRepeat: [self charge: self charge - 10 ].					self charge: self charge -(amount % 10)				]		ifFalse: [ ChargeBatteryError signal ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 16:25' prior: 35949994!consume: amount	(self canConsume: amount)		ifTrue: [ (amount / 10) timesRepeat: [self charge: self charge - 10 + 1 ].					self charge: self charge -(amount % 10)				]		ifFalse: [ ChargeBatteryError signal ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 9/12/2017 16:35' prior: 35950305!consume: amount	(self canConsume: amount)		ifTrue: [ (amount / 10) timesRepeat: [self charge: self charge - 10. self bonusCharge ].					self charge: self charge - (amount % 10). self addSteps: amount % 10.					stepsToRecovery >= 10 ifTrue:[self bonusCharge. self resetCharge.]				]		ifFalse: [ ChargeBatteryError signal ]! !----SNAPSHOT----2017-09-12T22:54:09.696616-03:00 Pharo6.1.image priorSource: 2394991!----QUIT/NOSAVE----2017-09-12T22:54:16.151705-03:00 Pharo6.1.image priorSource: 2396518!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 9/26/2017 13:15' prior: 35950620!consume: amount	(self canConsume: amount)		ifTrue: [ self charge: self charge - amount + (amount/10 floor)]						ifFalse: [ ChargeBatteryError signal ]! !----SNAPSHOT----2017-09-26T13:16:10.587483-03:00 Pharo6.1.image priorSource: 2396518!----QUIT/NOSAVE----2017-09-26T13:16:20.139695-03:00 Pharo6.1.image priorSource: 2396954!!WalkingBrushRobot methodsFor: 'initialize-release' stamp: 'EncinasJavier 9/26/2017 14:06'!flecha: largo	self north; move:largo.	self east; move:largo.	self northWest; move:largo.	self southWest; move:largo.! !!WalkingBrushRobot methodsFor: 'initialize-release' stamp: 'EncinasJavier 9/26/2017 14:07' prior: 35951656!flecha: largo	self north; move:largo.	self east; move:largo.	self northWest; move:largo.	self southWest; move:largo.	self west; move:largo.! !!WalkingBrushRobot methodsFor: 'initialize-release' stamp: 'EncinasJavier 9/26/2017 14:08' prior: 35951888!flecha: largo	self north; move:largo.	self east; move:largo.	self northWest; move:largo.	self southWest; move:largo.	self east; move:largo.! !!WalkingBrushRobot methodsFor: 'initialize-release' stamp: 'EncinasJavier 9/26/2017 14:10' prior: 35952144!flecha: largo	self brushDown.	self north; move:largo.	self east; move:largo.	self northWest; move:largo.	self southWest; move:largo.	self east; move:largo.! !!WalkingBrushRobot methodsFor: 'initialize-release' stamp: 'EncinasJavier 9/26/2017 14:19' prior: 35952400!flecha: largo"(VISADO)dibuja una flecha de 4 trazos de largo largo"	self brushDown.	self north; move:largo.	self east; move:largo.	self direction:315; move:largo.	self direction:225; move:largo.	self east; move:largo.! !----QUIT----2017-09-26T14:35:29.186037-03:00 Pharo6.1.image priorSource: 2396954!Battery subclass: #EnergyRecoveryCell	instanceVariableNames: ''	classVariableNames: ''	package: 'BotArena-Modules'!Battery subclass: #EnergyRecoveryCell	instanceVariableNames: 'energyUntilCut energyCut '	classVariableNames: ''	package: 'BotArena-Modules'!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:24'!energyUntilCut	^energyUntilCut! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:24'!energyUntilCut: amount	energyUntilCut:= amount.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:25'!energyToCut: amount	energyToCut:= amount	! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:25'!energyToCut	^energyToCut	! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:33' prior: 35951228!consume: amount	(self canConsume: amount)		ifTrue: [ self charge: self charge - amount + (amount/10 floor).					self addAmountConsumed: self charge.					self canCut.					]						ifFalse: [ ChargeBatteryError signal ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:37'!canCut	( amountConsumed = energyUntilCut  ) 		ifTrue: [ self capacity: self capacity - energyToCut ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:39'!amountConsumed	^amountConsumed.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:40'!addAmountConsumed: amount	self amountConsumed: self amountConsumed  + amount! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:41'!amountConsumed: amount	amountConsumed:= amount.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:43' prior: 35954161!canCut	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyUntilCut  ) 		ifTrue: [ self capacity: self capacity - energyToCut ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/3/2017 14:45' prior: 35953851!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	(self canConsume: amount)		ifTrue: [ self charge: self charge - amount + (amount/10 floor).					self addAmountConsumed: self charge.					self canCut.					]						ifFalse: [ ChargeBatteryError signal ]! !----QUIT----2017-10-03T16:55:31.098365-03:00 Pharo6.1.image priorSource: 2398469!----QUIT/NOSAVE----2017-10-14T18:00:13.906814-03:00 Pharo6.1.image priorSource: 2401112!----SNAPSHOT----2017-10-14T18:16:49.979936-03:00 Pharo6.1.image priorSource: 2401112!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/14/2017 19:15' prior: 35955136!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	(self canConsume: amount)		ifTrue: [ self charge: self charge - amount + (amount//10 floor).					self addAmountConsumed: self charge.					self canCut.					]						ifFalse: [ ChargeBatteryError signal ]! !Battery subclass: #EnergyRecoveryCell	instanceVariableNames: 'energyUntilCut energyToCut amountConsumed'	classVariableNames: ''	package: 'BotArena-Modules'!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/14/2017 19:26'!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyUntilCut  ) 		ifTrue: [ self capacity: self capacity - energyToCut ]! !----QUIT----2017-10-14T21:34:14.526205-03:00 Pharo6.1.image priorSource: 2401285!EnergyRecoveryCell removeSelector: #reduceMaxCap!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:28'!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyUntilCut  ) 		ifTrue: [ self capacity: self capacity - energyToCut ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:28' prior: 35955906!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	(self canConsume: amount)		ifTrue: [ self charge: self charge - amount + (amount//10 floor).					self addAmountConsumed: self charge.					self reduceMaxCap.					]						ifFalse: [ ChargeBatteryError signal ]! !EnergyRecoveryCell removeSelector: #canCut!EnergyRecoveryCell removeSelector: #energyToCut!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:29'!energyToCut	^ energyToCut! !EnergyRecoveryCell removeSelector: #stepsToRecovery!EnergyRecoveryCell removeSelector: #stepsToRecovery:!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:30'!energyToReduce	^ energyToCut! !EnergyRecoveryCell removeSelector: #energyToCut!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:32'!energyToReduce: amount	energyToCut:= amount	! !EnergyRecoveryCell removeSelector: #energyToCut:!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:33'!energyUntil	^energyUntilCut! !EnergyRecoveryCell removeSelector: #energyUntilCut!Battery subclass: #EnergyRecoveryCell	instanceVariableNames: 'energyUntil energyToReduce amountConsumed'	classVariableNames: ''	package: 'BotArena-Modules'!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:38' prior: 35958210!energyToReduce	^ energyToReduce! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:38' prior: 35958378!energyToReduce: amount	energyToReduce:= amount	! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:38' prior: 35958564!energyUntil	^energyUntil! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:39'!energyUntil: amount	energyUntil:= amount.! !EnergyRecoveryCell removeSelector: #energyUntilCut:!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 14:39' prior: 35957035!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyUntil  ) 		ifTrue: [ self capacity: self capacity - energyToReduce ]! !!EnergyRecoveryCell class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/16/2017 14:55'!withCharge: initialCap reducing: energyToReduce every: energyCap	^(EnergyRecoveryCell new)! !!EnergyRecoveryCell class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/16/2017 14:56' prior: 35959872!withCharge: initialCharge reducing: energyToReduce every: energyCap	^(EnergyRecoveryCell new) charge: initialCharge ! !!EnergyRecoveryCell class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/16/2017 14:58' prior: 35960084!withCharge: initialCharge reducing: energyToReduce every: energyCap	^(EnergyRecoveryCell new) charge: initialCharge; energyToReduce: energyToReduce; energyUntil: energyCap.! !----SNAPSHOT----2017-10-16T15:18:56.958712-03:00 Pharo6.1.image priorSource: 2402383!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:19' prior: 35957390!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	|totalConsumed|	(self canConsume: amount)		ifTrue: [ totalConsumed:= self charge - amount. 			self charge: self charge - totalConsumed + (amount//10 floor).			self addAmountConsumed: totalConsumed.			self reduceMaxCap			]				ifFalse: [ ChargeBatteryError signal ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:20'!initialize	! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:22' prior: 35961245!initialize	self capacity: self defaultCapacity.	self charge: 0.	self energyToReduce: 2.	self energyUntil: 10.	^ self! !----SNAPSHOT----2017-10-16T15:23:50.669364-03:00 Pharo6.1.image priorSource: 2406066!Battery subclass: #EnergyRecoveryCell	instanceVariableNames: 'energyCap energyToReduce amountConsumed'	classVariableNames: ''	package: 'BotArena-Modules'!Battery subclass: #EnergyRecoveryCell	instanceVariableNames: 'energyUntil energyToReduce amountConsumed'	classVariableNames: ''	package: 'BotArena-Modules'!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35959316!energyUntil: amount	energyCap:= amount.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35959517!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyCap  ) 		ifTrue: [ self capacity: self capacity - energyToReduce ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35959202!energyUntil	^energyCap! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35961995!energyUntil: amount	energyCap:= amount.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35962140!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyCap  ) 		ifTrue: [ self capacity: self capacity - energyToReduce ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35962493!energyUntil	^energyCap! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27'!energyCap	^energyCap! !EnergyRecoveryCell removeSelector: #energyUntil!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27'!energyCap: amount	energyCap:= amount.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35961362!initialize	self capacity: self defaultCapacity.	self charge: 0.	self energyToReduce: 2.	self energyCap: 10.	^ self! !!EnergyRecoveryCell class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/16/2017 15:27' prior: 35960322!withCharge: initialCharge reducing: energyToReduce every: energyCap	^(EnergyRecoveryCell new) charge: initialCharge; energyToReduce: energyToReduce; energyCap: energyCap.! !EnergyRecoveryCell removeSelector: #energyUntil:!----SNAPSHOT----2017-10-16T15:28:25.97182-03:00 Pharo6.1.image priorSource: 2407054!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:28' prior: 35963534!initialize	self capacity: self defaultCapacity.	self charge: 0.	self energyToReduce: 2.	self energyCap: 50.	^ self! !!EnergyRecoveryCell class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/16/2017 15:33' prior: 35963774!withCharge: initialCharge reducing: energyToReduce every: energyCap	^(EnergyRecoveryCell new) charge: initialCharge; energyToReduce: energyToReduce; energyCap: energyCap; amountConsumed: 0.! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:34' prior: 35964187!initialize	self capacity: self defaultCapacity.	self charge: 0.	self energyToReduce: 2.	self energyCap: 50.	self amountConsumed: 0.	^ self! !----SNAPSHOT----2017-10-16T15:34:08.271446-03:00 Pharo6.1.image priorSource: 2409567!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 15:36' prior: 35960687!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	|totalConsumed|	(self canConsume: amount)		ifTrue: [ totalConsumed:= self charge - amount. 			self charge: self charge - totalConsumed + (amount//10).			self addAmountConsumed: totalConsumed.			self reduceMaxCap			]				ifFalse: [ ChargeBatteryError signal ]! !----SNAPSHOT----2017-10-16T18:12:24.734876-03:00 Pharo6.1.image priorSource: 2410437!----SNAPSHOT----2017-10-16T18:13:32.444172-03:00 Pharo6.1.image priorSource: 2411092!----SNAPSHOT----2017-10-16T18:13:49.406792-03:00 Pharo6.1.image priorSource: 2411179!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:15' prior: 35965058!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	|totalConsumed|	(self canConsume: amount)		ifTrue: [ totalConsumed:= self charge - amount . 			self charge: self charge - totalConsumed + (amount/10).			self addAmountConsumed: totalConsumed + (amount %10).			self reduceMaxCap			]				ifFalse: [ ChargeBatteryError signal ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:15' prior: 35964722!initialize	self capacity: self defaultCapacity.	self charge: self defaultCapacity.	self energyToReduce: 2.	self energyCap: 50.	self amountConsumed: 0.	^ self! !----SNAPSHOT----2017-10-16T18:15:57.59024-03:00 Pharo6.1.image priorSource: 2411266!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:26' prior: 35962766!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyCap  ) 		ifTrue: [ self capacity: self capacity - energyToReduce ]		ifFalse: [self halt]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:27' prior: 35966824!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyCap  ) 		ifTrue: [ self capacity: self capacity - energyToReduce ]		ifFalse: [ ^self ]! !----SNAPSHOT----2017-10-16T18:27:40.619323-03:00 Pharo6.1.image priorSource: 2412204!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:29' prior: 35965887!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	|totalConsumed|	(self canConsume: amount)		ifTrue: [ totalConsumed:= self charge - amount . 			self charge: self charge - totalConsumed + (amount//10).			self addAmountConsumed: totalConsumed + (amount %10).			self reduceMaxCap			]				ifFalse: [ ChargeBatteryError signal ]! !----SNAPSHOT----2017-10-16T18:29:34.57135-03:00 Pharo6.1.image priorSource: 2413040!!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:31' prior: 35967661!consume: amount	"consume la cantidad de energia especificada. por cada 10 unidades consumidas, se añadira una unidad 	de carga. Luego añade al total consumido, y pregunta si este supero el tope"	|totalConsumed|	(self canConsume: amount)		ifTrue: [ totalConsumed:= self charge - amount . 			self charge: self charge - totalConsumed + (amount // 10).			self addAmountConsumed: totalConsumed + (amount % 10).			self reduceMaxCap			]				ifFalse: [ ChargeBatteryError signal ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:32' prior: 35967200!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyCap  ) 		ifTrue: [ self capacity: self capacity - energyToReduce ]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:34' prior: 35968918!reduceMaxCap	"si la cantidad consumida es mayor o igual a la cantidad tope de energia, va a recortarse dada la 	cantidad especificada en energyToCut"			( amountConsumed >= energyCap  ) 		ifTrue: [ self capacity: self capacity - energyToReduce .					self amountConsumed: 0.]! !!EnergyRecoveryCell methodsFor: 'accessing' stamp: 'EncinasJavier 10/16/2017 18:34' prior: 35969272!reduceMaxCap	amountConsumed >= energyCap		ifFalse: [ ^ self ].	self capacity: self capacity - energyToReduce.	self amountConsumed: 0! !----SNAPSHOT----2017-10-16T18:35:26.136489-03:00 Pharo6.1.image priorSource: 2413711!----SNAPSHOT----2017-10-16T19:27:09.977313-03:00 Pharo6.1.image priorSource: 2415363!----QUIT/NOSAVE----2017-10-16T19:27:14.673283-03:00 Pharo6.1.image priorSource: 2415450!Object subclass: #Document	instanceVariableNames: 'title body'	classVariableNames: ''	package: 'OBJ1'!!Document methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 14:32'!title	^ title! !!Document methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 14:32'!title: anObject	title := anObject! !!Document methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 14:32'!body	^ body! !!Document methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 14:32'!body: anObject	body := anObject! !!Document methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 14:36'!size	"tamaño del titulo, el body y 10% del body"		^ self body size + self title size + ((self body size)/10)*100! !!Document class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 14:39'!body: aBody title: aTitle		^(self new) body: aBody; title: aTitle; yourself.! !!Document methodsFor: 'initialization' stamp: 'EncinasJavier 10/17/2017 14:40'!initialize	self body: ''.	self title: 'no title'.! !!Document methodsFor: 'initialization' stamp: 'EncinasJavier 10/17/2017 14:44'!addLine: aString	self body: self body, aString.! !!Document methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 14:49' prior: 35970647!size	"tamaño del titulo, el body y 10% del body"		^ self body size + self title size + ((self body size)*10)/100! !----SNAPSHOT----2017-10-17T14:50:52.065987-03:00 Pharo6.1.image priorSource: 2415450!!Document methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 14:54' prior: 35971295!size	"tamaño del titulo, el body y 10% del body"		^ self body size + self title size + ((self body size)*10)//100! !!Document methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 14:55' prior: 35971590!size	"tamaño del titulo, el body y 10% del body"		^ (self body size) + (self title size) + (((self body size)*10)//100)! !Object subclass: #Perfil	instanceVariableNames: 'karma name posts likes'	classVariableNames: ''	package: 'OBJ1'!!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!karma	^ karma! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!karma: anObject	karma := anObject! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!name1	^ name! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!name: anObject	name := anObject! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!posts	^ posts! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!posts: anObject	posts := anObject! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!likes	^ likes! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 15:59'!likes: anObject	likes := anObject! !!Perfil methodsFor: 'initialization' stamp: 'EncinasJavier 10/17/2017 16:01'!initialize	self karma: 0.	self name: 'no name'.	self posts: 0.	self likes: 0.! !!Perfil class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:18'!withName: aName	^(self new) name: aName;yourself.! !!Perfil class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:21' prior: 35973101!withName: aName	^(self new) name: aName;  yourself.! !!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 16:22'!name	^ name! !Perfil removeSelector: #name!!Perfil methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 16:23'!name	^ name! !Perfil removeSelector: #name1!!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:43'!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self sumarPuntos ] ifFalse: [ self otroSumarPuntos ].	self resetKarma.! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:44'!resetKarma	self likes: 0; posts: 0.! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:44'!sumarPuntos	self karma: self karma + 2.! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:46'!otroSumarPuntos	(posts//likes) > 50 ifTrue: [ self karma: self karma + 3 ]									! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:46'!anotherAddKarma	(posts//likes) > 50 ifTrue: [ self karma: self karma + 3 ]									! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:46' prior: 35973642!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self sumarPuntos ] ifFalse: [ self anotherAddKarma ].	self resetKarma.! !Perfil removeSelector: #otroSumarPuntos!!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:46'!addKarma	self karma: self karma + 2.! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:46' prior: 35974486!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma ] ifFalse: [ self anotherAddKarma ].	self resetKarma.! !Perfil removeSelector: #sumarPuntos!!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:47'!reset	self likes: 0; posts: 0.! !!Perfil methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 16:47' prior: 35974900!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma ] ifFalse: [ self anotherAddKarma ].	self reset.! !Perfil removeSelector: #resetKarma!----SNAPSHOT----2017-10-17T16:47:17.603736-03:00 Pharo6.1.image priorSource: 2416982!----SNAPSHOT----2017-10-17T16:59:33.068938-03:00 Pharo6.1.image priorSource: 2421046!----SNAPSHOT----2017-10-17T17:02:55.710624-03:00 Pharo6.1.image priorSource: 2421133!(Smalltalk globals at: #Perfil) rename: #Profile!!User methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 17:35'!karma	^ karma! !!User methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 17:35'!posts: anObject	posts := anObject! !!User methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 17:35'!likes	^ likes! !!User methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 17:35'!name	^ name! !!User methodsFor: 'accessing' stamp: 'EncinasJavier 10/17/2017 17:35'!posts	^ posts! !!User methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 17:35'!reset	self likes: 0; posts: 0.! !!User methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 17:35'!anotherAddKarma	(posts//likes) > 50 ifTrue: [ self karma: self karma + 3 ]									! !!User methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 17:35'!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma ] ifFalse: [ self anotherAddKarma ].	self reset.! !!User methodsFor: 'common' stamp: 'EncinasJavier 10/17/2017 17:35'!addKarma	self karma: self karma + 2.! !!User methodsFor: 'private' stamp: 'EncinasJavier 10/17/2017 17:35'!name: anObject	name := anObject! !!User methodsFor: 'private' stamp: 'EncinasJavier 10/17/2017 17:35'!likes: anObject	likes := anObject! !!User methodsFor: 'private' stamp: 'EncinasJavier 10/17/2017 17:35'!karma: anObject	karma := anObject! !!User methodsFor: 'initialization' stamp: 'EncinasJavier 10/17/2017 17:35'!initialize	self karma: 0.	self name: 'no name'.	self posts: 0.	self likes: 0.! !!User class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/17/2017 17:35'!withName: aName	^(self new) name: aName;  yourself.! !----QUIT----2017-10-17T19:29:04.204828-03:00 Pharo6.1.image priorSource: 2421220!User subclass: #Silver	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!User subclass: #Gold	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!Gold methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/22/2017 22:17'!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma ] ifFalse: [ self anotherAddKarma ].	self reset.! !!Silver methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/22/2017 22:17'!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma ] ifFalse: [ self anotherAddKarma ].	self reset.! !!User methodsFor: 'common' stamp: 'EncinasJavier 10/22/2017 22:17' prior: 35976583!calculateKarma	self subclassResponsibility ! !!Gold methodsFor: 'common' stamp: 'EncinasJavier 10/22/2017 22:20' prior: 35977806!calculateKarma	self post * self likes / Float halfPi.	self reset.! !!Silver methodsFor: 'common' stamp: 'EncinasJavier 10/22/2017 22:20' prior: 35978030!calculateKarma	self post * self likes / Float pi.	self reset.! !!Silver methodsFor: 'common' stamp: 'EncinasJavier 10/22/2017 22:21' prior: 35978544!calculateKarma	self karma: self karma + (self post * self likes / Float pi).	self reset.! !!Gold methodsFor: 'common' stamp: 'EncinasJavier 10/22/2017 22:21' prior: 35978387!calculateKarma	self karma: self karma + (self post * self likes / Float halfPi).	self reset.! !----QUIT----2017-10-22T22:28:45.324453-03:00 Pharo6.1.image priorSource: 2423025!Object subclass: #Product		instanceVariableNames: 'name price' 		classVariableNames: ''		package: 'OBJ1'!Object subclass: #Cart		instanceVariableNames: 'quantity value' 		classVariableNames: ''		package: 'OBJ1'!!Product methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:15'!name1	^ name! !!Product methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:15'!name: anObject	name := anObject! !!Product methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:15'!price	^ price! !!Product methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:15'!price: anObject	price := anObject! !!Product methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:16'!name	^ name! !!Product methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:17' prior: 35979756!name	^ name! !!RBMoveVariableDefinitionTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:17' prior: 56027977!testNonExistantName	self		shouldFail: (RBMoveVariableDefinitionRefactoring 				bindTight: (1 to: 10)				in: RBLintRuleTest				selector: #name);		shouldFail: (RBMoveVariableDefinitionRefactoring 				bindTight: (self 						convertInterval: (44 to: 54)						for: (RBLintRuleTest sourceCodeAt: #displayName))				in: RBLintRuleTest				selector: #displayName);		shouldFail: (RBMoveVariableDefinitionRefactoring 				bindTight: (self 						convertInterval: (16 to: 25)						for: (RBLintRuleTest sourceCodeAt: #displayName))				in: RBLintRuleTest				selector: #displayName)! !!RBAddParameterTest methodsFor: 'failure tests' stamp: 'EncinasJavier 10/23/2017 15:17' prior: 55439451!testModelBadInitializationCode	| refactoring |	model removeClassNamed: #RBRefactoring.	refactoring := RBAddParameterRefactoring 		model: model		addParameterToMethod: #name		in: RBLintRuleTest		newSelector: #name1:		initializer: 'AddParameterRefactoring new'.	self shouldFail: refactoring! !!RBAddParameterTest methodsFor: 'failure tests' stamp: 'EncinasJavier 10/23/2017 15:17' prior: 55440730!testNonExistantName	self shouldFail: (RBAddParameterRefactoring 			addParameterToMethod: #name			in: RBLintRuleTest			newSelector: #name1:			initializer: 'nil')! !Product removeSelector: #name1!!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:18'!quantity	^ quantity! !!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:18'!quantity: anObject	quantity := anObject! !!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:18'!value1	^ value! !!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:18'!value: anObject	value := anObject! !!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:18'!value	^ value! !!GLMTransmissionTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:18' prior: 27222473!testWhenCondition	"Tests that the transmission is triggered only when the origin changes."	| transmission port1 port2 |	transmission := GLMTransmission new.	port1 := (GLMSimplePort new)		name: #port1;		value: #value.	port2 := GLMSimplePort new name: #port2.	transmission addActiveOrigin: port1.	transmission destination: port2.	transmission condition: [ :entity | entity = #value ].	self assert: transmission meetsCondition.	transmission transmit.	self assert: port2 value equals: #value! !!GLMFinderTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:18' prior: 26509695!testPortPublishing	| browser |	browser := GLMFinder new.	(browser pane port: #entity) value: #value.	self assert: browser panes size equals: 1.	self assert: browser pane ports size equals: 1.	self assert: (browser pane port: #entity) value equals: #value.	(browser panes first port: #selection) value: #value2.	self assert: browser panes size equals: 2.	self assert: browser pane ports size equals: 3.	self assert: (browser pane port: #entity) value equals: #value.	self assert: (browser pane port: #selection) value equals: #value2.	(browser panes last port: #selection) value: #value3.	self assert: browser panes size equals: 3.	self assert: browser pane ports size equals: 3.	self assert: (browser pane port: #entity) value equals: #value.	self assert: (browser pane port: #selection) value equals: #value3.	(browser panes first port: #hover) value: #value4.	self assert: browser panes size equals: 3.	self assert: browser pane ports size equals: 4.	self assert: (browser pane port: #entity) value equals: #value.	self assert: (browser pane port: #selection) value equals: #value3.	self assert: (browser pane port: #hover) value equals: #value4! !!GLMFinderTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:18' prior: 26519022!testPaneName	| browser |	browser := GLMFinder new.	browser addPresentation: (GLMPresentation new title: 'presentation1').	(browser pane port: #entity) value: #value.	self assert: browser panes first name equals: '1'.	(browser panes first port: #selection) value: #value2.	self assert: browser panes last name equals: '2'! !!GLMFinderTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:18' prior: 26514213!testUnregisterAnnouncementsWhenRemovingPane	| announcer browser presentation actualFirstPresentation actualLastPresentation |	announcer := GLMAnnouncer new.	browser := GLMFinder new.	presentation := GLMPresentation new.	presentation title: [ :entity | entity ].	browser addPresentation: presentation.	presentation updateOn: GLMTestAnnouncement from: [ announcer ].	browser entity: #value.	actualFirstPresentation := browser panes first presentations first.	actualFirstPresentation registerAnnouncements.	self assert: announcer numberOfSubscriptions equals: 1.	self assert: announcer glmSubscriptions anyOne announcementClass equals: GLMTestAnnouncement.	self assert: announcer glmSubscriptions anyOne subscriber presentation equals: actualFirstPresentation.	self assert: announcer glmSubscriptions anyOne subscriber presentation == actualFirstPresentation.	(browser panes first port: #selection) value: #value2.	browser panes last presentations first registerAnnouncements.	actualLastPresentation := browser panes last presentations first.	self assert: announcer numberOfSubscriptions equals: 2.	self		assert: (announcer glmSubscriptions allSatisfy: [ :each | each announcementClass = GLMTestAnnouncement ]).	self		assert:			(announcer glmSubscriptions anySatisfy: [ :each | each subscriber presentation = actualFirstPresentation ]).	self		assert:			(announcer glmSubscriptions				anySatisfy: [ :each | each subscriber presentation == actualFirstPresentation ]).	(browser panes first port: #selection) value: #value3.	actualLastPresentation := browser panes last presentations first.	"because we removed the other pane"	self assert: announcer numberOfSubscriptions equals: 1.	self assert: announcer glmSubscriptions anyOne announcementClass equals: GLMTestAnnouncement.	self assert: announcer glmSubscriptions anyOne subscriber presentation equals: actualFirstPresentation.	self assert: announcer glmSubscriptions anyOne subscriber presentation == actualFirstPresentation! !!GLMFinderTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:18' prior: 26516947!testPaneCreation	| browser |	browser := GLMFinder new.	browser addPresentation: (GLMPresentation new title: 'presentation1').	self assert: browser panes isEmpty.	"Outer entity changed."	(browser pane port: #entity) value: #value.	self assert: browser panes size equals: 1.	self assert: browser panes first browser == browser.	self assert: (browser panes first port: #entity) value equals: #value.	self assert: browser panes first presentations size equals: 1.	self assert: browser panes first presentations first title equals: 'presentation1'.	self assert: browser panes first presentations first ~~ browser transmission transmissionStrategy presentations first.	"First pane selection changed."	(browser panes first port: #selection) value: #value2.	self assert: browser panes size equals: 2.	self assert: browser panes last browser == browser.	self assert: (browser panes last port: #entity) value equals: #value2.	self assert: browser panes last presentations first title equals: 'presentation1'.	self assert: browser panes last presentations first ~~ browser transmission transmissionStrategy presentations first.	self assert: browser panes last presentations first ~~ browser panes first presentations first.	"Second pane selection changed."	(browser panes last port: #selection) value: #value3.	self assert: browser panes size equals: 3.	self assert: browser panes last browser == browser.	self assert: (browser panes last port: #entity) value equals: #value3.	"First pane selection changed again."	(browser panes first port: #selection) value: #value4.	self assert: browser panes size equals: 2.	self assert: browser panes last browser == browser.	self assert: (browser panes last port: #entity) value equals: #value4.	"Outer entity changed again."	(browser pane port: #entity) value: #value5.	self assert: browser panes size equals: 1.	self assert: browser panes last browser == browser.	self assert: (browser panes last port: #entity) value equals: #value5! !!GLMFinderTest methodsFor: 'tests' stamp: 'EncinasJavier 10/23/2017 15:18' prior: 26510948!testPanesHaveDifferentRegistries	| browser |	browser := GLMFinder new.	browser addPresentation: (GLMPresentation new title: 'presentation1').	self assert: browser panes isEmpty.	"Outer entity changed."	(browser pane port: #entity) value: #value.	self assert: browser panes size equals: 1.	(browser panes first port: #selection) value: #value2.	self assert: browser panes size equals: 2.	self deny: (browser panes first instVarNamed: 'registry') == (browser panes second instVarNamed: 'registry')! !Cart removeSelector: #value1!!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:20'!addProduct: aProduct	self quantity: self quantity + 1.	self value: self value + aProduct price.	! !!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 15:21' prior: 35988963!addProduct: aProduct	"Añade 1 producto y su precio al total del carrito"	self quantity: self quantity + 1.	self value: self value + aProduct price.	! !!Cart methodsFor: 'accessing' stamp: 'EncinasJavier 10/23/2017 16:44'!checkout	"devuelve el precio neto del total del carrito de compras"	| desc1 desc2 |	desc1:= 0. desc2:= 0.	(self quantity > 10) ifTrue: [ desc1:= (self value // 10 ) * 100 ].	(self value > 10000) ifTrue: [ desc2:= (self value // 5 ) * 100 ].	^((self value - desc1) - desc2).	! !!Product class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/23/2017 16:52'!name: aName value: aValue	^(self new)name: aName;value: aValue; yourself.! !!Cart methodsFor: 'initialization' stamp: 'EncinasJavier 10/23/2017 16:57'!initialize	value:= 0	! !!Cart methodsFor: 'initialization' stamp: 'EncinasJavier 10/23/2017 16:57' prior: 35989911!initialize	value:= 0.	quantity:= 0.! !----SNAPSHOT----2017-10-23T17:10:47.565663-03:00 Pharo6.1.image priorSource: 2424540!----QUIT----2017-10-23T17:21:35.357155-03:00 Pharo6.1.image priorSource: 2435638!----QUIT----2017-10-23T17:38:07.676269-03:00 Pharo6.1.image priorSource: 2435725!!Product class methodsFor: 'instance creation' stamp: 'EncinasJavier 10/24/2017 14:32'!new	self error: 'Instancie esta clase con name: value:'! !!Product class methodsFor: 'instance creation' stamp: 'EncinasJavier 10/24/2017 14:32' prior: 35989757!name: aName value: aValue	^(super new)name: aName;value: aValue; yourself.! !!Product class methodsFor: 'instance creation' stamp: 'EncinasJavier 10/24/2017 14:33'!name: aName price: aValue	^(super new)name: aName;price: aValue; yourself.! !----SNAPSHOT----2017-10-24T14:38:42.279892-03:00 Pharo6.1.image priorSource: 2435808!!BGSRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/24/2017 14:58' prior: 35834240!bodyClass	^BGSRangeSensorBeltRobotBody.! !!BGSRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/24/2017 14:58' prior: 35991011!bodyClass	"BGSRobotBody"	^BGSRangeSensorBeltRobotBody.! !!BGSRobot methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/24/2017 15:02' prior: 35991157!bodyClass	^BGSRobotBody.! !----QUIT----2017-10-24T21:29:10.715623-03:00 Pharo6.1.image priorSource: 2436390!----QUIT/NOSAVE----2017-10-30T15:18:09.861953-03:00 Pharo6.1.image priorSource: 2436916!Object subclass: #Medition	instanceVariableNames: 'value timestamp'	classVariableNames: ''	package: 'OBJ1'!!Medition methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 15:33'!value1	^ value! !!Medition methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 15:33'!value: anObject	value := anObject! !!Medition methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 15:33'!timestamp	^ timestamp! !!Medition methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 15:33'!timestamp: anObject	timestamp := anObject! !!Medition methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 16:10' prior: 35991709!value1	^ value! !!Medition methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 16:10'!value	^ value! !Medition removeSelector: #value1!Object subclass: #TemperatureMonitor	instanceVariableNames: 'temperatureList'	classVariableNames: ''	package: 'OBJ1'!!TemperatureMonitor methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 16:12'!temperatureList	^ temperatureList! !!TemperatureMonitor methodsFor: 'accessing' stamp: 'EncinasJavier 10/30/2017 16:12'!temperatureList: anObject	temperatureList := anObject! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 16:19'!addAbsoluteTemperature: aValue clock: aNumber	"agrega una medicion absoluta"	! !----SNAPSHOT----2017-10-30T16:34:17.468355-03:00 Pharo6.1.image priorSource: 2436916!!TemperatureMonitor methodsFor: 'initialization' stamp: 'EncinasJavier 10/30/2017 16:34'!initialize	temperatureList:= OrderedCollection new.	! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 16:35' prior: 35992771!addAbsoluteTemperature: aValue clock: aNumber	"agrega una medicion absoluta"	temperatureList addFirst: Medition with: aValue at: aNumber.! !!Medition class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/30/2017 16:37'!with: aValue at: aNumber	^(self new)! !!Medition class methodsFor: 'initialize-release' stamp: 'EncinasJavier 10/30/2017 16:37' prior: 35993421!with: aValue at: aNumber	^(self new)value: aValue; timestamp: aNumber;yourself.! !!Medition class methodsFor: 'initialize-release' stamp: 'EncinasJavier 10/30/2017 16:37' prior: 35993569!with: aValue at: aNumber	^((self new)value: aValue; timestamp: aNumber;yourself).! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 16:38' prior: 35993187!addAbsoluteTemperature: aValue clock: aNumber	"agrega una medicion absoluta"	self temperatureList addFirst: Medition with: aValue at: aNumber.! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 16:44' prior: 35993945!addAbsoluteTemperature: aValue clock: aNumber	"agrega una medicion absoluta"	self temperatureList addFirst: (Medition with: aValue at: aNumber).! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 16:59'!addDifferentialTemperature: aValue clock: aNumber	"agrega una medicion absoluta"		self temperatureList addFirst: (Medition with: (self currentTemperature + aValue) at: aNumber).! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:03'!currentTemperature	^self temperatureList asSortedCollection sortBlock: [ :temp1 :temp2 | temp1 timestamp < temp2 timestamp ]! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:04' prior: 35994689!currentTemperature	^(self temperatureList asSortedCollection sortBlock: [ :temp1 :temp2 | temp1 timestamp < temp2 timestamp ]) first! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:13'!averageTemperature	^(self temperatureList inject: 0 into: [ :sum :temp | sum + temp value]) // (self temperatureList size)! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:14'!allTemperatures	^self temperatureList! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:16'!allTemperatureValues	^self temperatureList collect: [ :temp | temp value ]! !TemperatureMonitor removeSelector: #allTemperatures!!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:18'!reset	self temperatureList: OrderedCollection new ! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:26' prior: 35995683!reset	|current|		current:= Medition with: (self currentTemperature) at: 0.	(self temperatureList: OrderedCollection with: current).! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:27' prior: 35995836!reset	|current|		current:= Medition with: (self currentTemperature) at: 0.	(self temperatureList: OrderedCollection with: current).! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/30/2017 17:30' prior: 35996074!reset	|current|		current:= Medition with: (self currentTemperature) at: 0.	(self temperatureList: (OrderedCollection with: current)).! !----QUIT----2017-10-30T17:30:05.311407-03:00 Pharo6.1.image priorSource: 2438421!!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 13:54' prior: 35995135!averageTemperature	^self ! !!TemperatureMonitor methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 13:55'!addDiffereTemperature: aValue clock: aNumber	"agrega una medicion absoluta"	self temperatureList addFirst: (Medition with: aValue at: aNumber)! !Object subclass: #Profile	instanceVariableNames: 'karma name posts likes friends blockec'	classVariableNames: ''	package: 'OBJ1'!Object subclass: #Profile	instanceVariableNames: 'karma name posts likes friends blocked'	classVariableNames: ''	package: 'OBJ1'!!Profile methodsFor: 'accessing' stamp: 'EncinasJavier 10/31/2017 14:11'!friends	^ friends! !!Profile methodsFor: 'accessing' stamp: 'EncinasJavier 10/31/2017 14:11'!friends: anObject	friends := anObject! !!Profile methodsFor: 'accessing' stamp: 'EncinasJavier 10/31/2017 14:11'!blocked	^ blocked! !!Profile methodsFor: 'accessing' stamp: 'EncinasJavier 10/31/2017 14:11'!blocked: anObject	blocked := anObject! !!Profile methodsFor: 'initialization' stamp: 'EncinasJavier 10/31/2017 14:12' prior: 35972926!initialize	self karma: 0.	self name: 'no name'.	self posts: 0.	self likes: 0.	self blocked: OrderedCollection new.	self friends: OrderedCollection new.! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:14'!agregarUsuario: unUsuario		self friends addFirst: unUsuario! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:14' prior: 35997915!agregarUsuario: unUsuario	"agrega un usuario a mi lista de amigos"	self friends addFirst: unUsuario! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:15'!bloquearUsuario: unUsuario	"agrega un usuario a mi lista de bloqueados"	self blocked addFirst: unUsuario! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:18'!addKarma: aValue	self karma: self karma + aValue.! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:19' prior: 35975301!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma: 2 ] ifFalse: [ self anotherAddKarma ].	self reset.! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:21' prior: 35998565!calculateKarma	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma: 2 ] ifFalse: [ self anotherAddKarma ].	self reset.! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:26'!checkFriends	[(self blocked / self friends) between: 0 and: 0.1] ifTrue: [^true]																		ifFalse: [^false]! !Profile removeSelector: #checkFriends!!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:30' prior: 35998796!calculateKarma	"self blocked / self friends nunca va a ser negativo"	[(self blocked / self friends) between: 0 and: 0.1] 		ifTrue: [  	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma: 2 ] ifFalse: [ self anotherAddKarma ]].	self reset.! !!Profile class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/31/2017 14:31' prior: 35973261!withName: aName	^(self new) initialize; name: aName; yourself.! !!Profile class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/31/2017 14:33' prior: 35999633!withName: aName	^(super new) initialize; name: aName; yourself.! !!Profile class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 10/31/2017 14:34'!new	self error: 'instancie esta clase con withName:'! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:39' prior: 35999259!calculateKarma	"self blocked / self friends nunca va a ser negativo"	((self blocked / self friends) between: 0 and: 0.1) 		ifTrue: [  	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma: 2 ] ifFalse: [ self anotherAddKarma ]].	self reset.! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:39' prior: 36000110!calculateKarma	"self blocked / self friends nunca va a ser negativo"	((self blocked size / self friends size) between: 0 and: 0.1) 		ifTrue: [  	((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma: 2 ] ifFalse: [ self anotherAddKarma ]].	self reset.! !----SNAPSHOT----2017-10-31T14:44:47.808459-03:00 Pharo6.1.image priorSource: 2442021!----SNAPSHOT----2017-10-31T14:45:45.938571-03:00 Pharo6.1.image priorSource: 2446310!Profile removeSelector: #addKarma!!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:48' prior: 35974297!anotherAddKarma	(posts//likes) > 50 ifTrue: [ self addKarma: 3]									! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:49' prior: 36001040!anotherAddKarma	(posts//likes) > 50 ifTrue: [ self addKarma: 3]									! !!Profile methodsFor: 'common' stamp: 'EncinasJavier 10/31/2017 14:49' prior: 36000465!calculateKarma	"self blocked / self friends nunca va a ser negativo"	((self blocked size / self friends size) between: 0 and: 0.1) 		ifTrue: [  	self addKarma: 1.				((self posts // self likes) between: 31 and: 50) ifTrue:[ self addKarma: 2 ] ifFalse: [ self anotherAddKarma ]].	self reset.! !!Profile methodsFor: 'initialization' stamp: 'EncinasJavier 10/31/2017 14:51' prior: 35997682!initialize	self karma: 0.	self name: 'no name'.	self posts: 0.	self likes: 0.	self blocked: OrderedCollection new.	self friends: (OrderedCollection with: 'AmigoQueDefinitivamenteNoEsUnCero').! !----QUIT----2017-11-02T16:31:58.749611-03:00 Pharo6.1.image priorSource: 2446397!----QUIT/NOSAVE----2017-11-15T22:22:52.425449-03:00 Pharo6.1.image priorSource: 2447536!----SNAPSHOT----2017-11-17T15:55:25.578363-03:00 Pharo6.1.image priorSource: 2447536!Object subclass: #ShiftCipher		instanceVariableNames: 'key alhphabet' 		classVariableNames: ''		package: 'OBJ1'!!ShiftCipher class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 16:41'!key: aKey alphabet: anAlphabet	^(self new)key: aKey; alphabet: anAlphabet;yourself. ! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:41'!key	^ key! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:41'!key: anObject	key := anObject! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:41'!alhphabet	^ alhphabet! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:41'!alhphabet: anObject	alhphabet := anObject! !!ShiftCipher class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 16:42' prior: 36002440!key: aKey alphabet: anAlphabet	^self new key: aKey; alphabet: anAlphabet;yourself.! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:43'!alphabet	^ alhphabet! !ShiftCipher removeSelector: #alhphabet!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:44'!alphabet: anObject	alhphabet := anObject! !ShiftCipher removeSelector: #alhphabet:!----SNAPSHOT----2017-11-17T16:46:21.892573-03:00 Pharo6.1.image priorSource: 2447709!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 16:57' prior: 36003236!alphabet	^ alhphabet! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 17:06'!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: ((self alphabet findString: letter asString) + self key) ].! !----SNAPSHOT----2017-11-17T17:06:32.371466-03:00 Pharo6.1.image priorSource: 2449034!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 17:07'!decipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (( self alphabet findString: letter asString) - self key) ].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 17:24' prior: 36003751!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: ((			( self alphabet findString: letter asString) + self key) addIfOutOfBounds)			].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 17:33' prior: 36004291!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineIndexWith: 			(self alphabet findString: letter asString) + self key )			].! !----QUIT----2017-11-17T17:33:49.295331-03:00 Pharo6.1.image priorSource: 2449457!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:34'!determineIndexWith: anInteger	! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:34' prior: 36004551!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineIndexWith: 			(self alphabet findString: letter asString) )			].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:40' prior: 36004884!determineIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^anInteger + self key - self alphabet size ]			ifFalse:		[ ^anInteger  + self key ]! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:41' prior: 36005013!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineIndexWith: 			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:42'!determineCipherIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^anInteger + self key - self alphabet size ]			ifFalse:		[ ^anInteger  + self key ]! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:42' prior: 36005546!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineCipherIndexWith: 			(self alphabet findString: letter asString) )							].! !ShiftCipher removeSelector: #determineIndexWith:!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:44'!determineDecipherIndexWith: anInteger	(( anInteger - self key ) < 0)			ifTrue: 		[ ^anInteger - self key + self alphabet size ]			ifFalse:		[ ^anInteger - self key ]! !!GTSpotterHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self name! !!GTInspectorSelfNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ 'self'! !!GTPlaygroundHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self name! !!RFThisContextReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#context! !!RubShoutStylerDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #shoutStyler! !!KMModifiedKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self character key.! !!GLMHighlighterTextStylerDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ nil! !!RubExtraSelectionDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #findReplaceSelection! !!CustomHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	"Returns a unique key identifying the receiver in the help system"		^''! !!RubLineNumberDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #lineNumbers! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	"Answer the lookup key of the receiver."	^self basicAt: 1! !!GTInspectorDynamicNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ label! !!NautilusAnnotationDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #SourceCodeAnnotation! !!GTInspectorContextNamedTempNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self tempName! !!RFSelectorReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#selector! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^self class key! !!LeafNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^key! !!RFEReceiverReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#receiver! !!RubParagraph class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ nil! !!HelpTopic methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey 		"Returns a unique key identifying the receiver in the help system"				^key! !!RFArgumentsReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#arguments! !!LookupKey methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	"Answer the lookup key of the receiver."	^key! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ key! !!RubCommentAnnotationDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #commentAnnotation! !!KMSingleKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ key! !!NautilusKeyPressed methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey		^ key! !!GTInspectorIndexedNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self index! !!GTInspectorSlotNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self slot name! !!GTInspectorProtoObjectNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ slotName! !!RFEntityReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#entity! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^'HelpOnHelp'! !!RubColumnDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #column! !!RubCurrentLineBarDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #selectionBar! !!KeyNotFound methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self object! !!RubGhostTextDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #ghostText! !!RubScrolledTextExtra class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ nil! !!RubParagraph methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^self class key! !!RFVariableReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#variable! !!KMKeymap methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ name! !!RubAdornmentDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #adornment! !!RubCodeSizeFeedback class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #codeSizeFeedback! !!RFObjectReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#object! !!RFClassReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#class! !!GTDebuggerHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self name! !!RubWorkspaceBar class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #workspaceBar! !!RFReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^self subclassResponsibility! !!RFNameReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#name! !!RFValueReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#value! !!GTInspectorHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self name! !!GTInspectorVariableNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	"Answer the key of this object variable (slot, indexed attribute, computed value)."	^ self subclassResponsibility! !!RubTextSegmentIconBox class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #textSegmentIcons! !!RubParagraphDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ self subclassResponsibility ! !!RubOpeningClosingDelimiterDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #openingClosingDelimitersHighlight! !!Pragma methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	"Answer the keyword of the pragma (the selector of its message pattern).	 This accessor provides polymorphism with Associations used for properties."	^keyword! !!RFNodeReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#node! !!RFNewValueReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#newValue! !!KeyboardEvent methodsFor: 'keyboard' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^Smalltalk os keyForValue: keyValue! !!RFSenderReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#sender! !!RubAnnotationDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #annotation! !!GTInspectorWrapperNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ label ifNil: [ self hostObject key ]! !!RFLinkReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^#link! !!SpecHelpTopics class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^'Spec'! !!RubScrolledTextExtra methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^self class key! !!RubTextSegmentIconDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!Differencekey	^ #textSegmentIcons! !!CriticBrowser methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21774745!rules: rulesCollection	self rulesModel roots: ((		(rulesCollection groupedBy: #group) associations collect: [ :as |			CriticBrowserRulesGroup				named: as Differencekey				rules: as value ])					sorted: [ :a :b | a name < b name ])! !!SortedCollectionTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60530529!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!BytecodeEncoder methodsFor: 'temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18701326!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:str|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| str nextPut: { remoteLocal Differencekey. { index. innerIndex } }]]							ifFalse: [str nextPut: { local Differencekey. index }]]])].	^blockExtentsToTempsMap! !!FLExtensionWrapper methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24319334!readTargetClassFrom: aPragma argumentNames: argumentNames argumentValues: argumentValues	| class |	class := Smalltalk		at: (argumentValues at: (argumentNames indexOf: 'flExtensionOf:'))		ifAbsent: [ ^ nil ].			^ (aPragma method pragmas anySatisfy: [ :pragma |		pragma Differencekey = #flExtensionClassSide ])			ifTrue: [ class class ]			ifFalse: [ class ]! !!FLExtensionWrapper methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24322121!readArgumentsFrom: aPragma	^ {		aPragma Differencekey keywords.		aPragma arguments }! !!RubScrolledTextExtra methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36014717!Differencekey	^self class Differencekey! !!RubScrolledTextExtra methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58149538!key	^self class Differencekey! !!RubScrolledTextExtra class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58154191!classOfRulerNamed: aKey 	^ self allSubclasses detect: [ :cls | cls Differencekey = aKey ] ifNone: [  ]! !!StandardFonts class methodsFor: 'font accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62268159!systemFontLabelOf: aSelector	^ self systemFontAspectsAndLabels		detect: [ :assoc | assoc Differencekey = aSelector ]		ifFound: [ :assoc | assoc value ]		ifNone: [ '' ]! !!StandardFonts class methodsFor: 'font accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62266897!systemFontAspects	^ self systemFontAspectsAndLabels collect: [:assoc | assoc Differencekey]! !!Nautilus methodsFor: 'history' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52297564!registerHistoryNewEntry	| lastEntry wrapper |		self browsingHistory isPaused ifTrue: [ ^ self ].	wrapper := NautilusHistoryEntry with: self.	self browsingHistory entries ifNotEmpty: [ :entries |		lastEntry := entries last Differencekey.		( lastEntry selectedClass isNil 		or: [ ( wrapper selectedClass notNil 			and: [ wrapper selectedMethod = lastEntry selectedMethod 			and: [ wrapper selectedClass theNonMetaClass = lastEntry selectedClass theNonMetaClass ] ] ) ] ) 				ifTrue: [ ^ self ] ].		self browsingHistory add: wrapper.	self historyChanged.! !!Nautilus methodsFor: 'history' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52298946!adopt: anAssociation	self browsingHistory pauseDuring: [		anAssociation Differencekey applyTo: self ]! !!PackageWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54098700!selectedPackages	| associations |	associations := packagesSelection associations select: [ :assoc | assoc value ].	associations := associations collect: [ :assoc | assoc Differencekey ].	^ associations select: [ :each | each notNil ]! !!PackageWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54099750!selectedGroups	| associations |	associations := groupsSelection associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc Differencekey ].	^ associations select: [:each | each notNil ]! !!LiteralDictionaryTest methodsFor: 'tests - literal specific behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31190988!testIncludesWithEqualElementFromDifferentClasses| dict |dict := self classToBeTested new.dict at: 1 put: 'element1'.dict at: #Differencekey put: 1.0.self deny: (dict includesKey: 1.0).self assert: (dict includes: 1)! !!RBSelectorEnvironment class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56606745!referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString |	literalPrintString := aLiteral isVariableBinding		ifTrue: [ aLiteral Differencekey asString ]		ifFalse: [			aLiteral isString				ifTrue: [ aLiteral ]				ifFalse: [ aLiteral printString ] ].	classDict := IdentityDictionary new.	anEnvironment classesDo: [ :class | 		| selectors |		selectors := (class thoroughWhichSelectorsReferTo: aLiteral)			select: [ :selector | anEnvironment includesSelector: selector in: class ].		selectors isEmpty 			ifFalse: [ classDict at: class put: selectors asIdentitySet ] ].	^ (self onEnvironment: anEnvironment)		on: classDict;		label: 'References to: ' , literalPrintString;		searchStrings: (Array with: literalPrintString);		yourself! !!GTSpotterHeaderBrick methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27907310!helpButton: aBrick	| tree item |	helpButton ifNotNil: [self removeBrick: helpButton].	helpButton := aBrick.		self themer spotterThemer helpButtonWidgetStyleFor: helpButton.	self themer spotterThemer helpButtonStyleFor: helpButton.		helpButton		hintTitle: 'Spotter help';		action: [ 			self spotterModel exitDueTo: #actionButton.			tree := HelpBrowser open instVarNamed: #treeMorph.			item := tree allItems detect: [:each | 				each complexContents item Differencekey = GTSpotterHelp Differencekey].			tree selection: item ].		self addBrickBack: helpButton! !!ZnMessage methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85380442!gtInspectorContentsIn: composite	<gtInspectorPresentationOrder: 40>	self hasEntity		ifTrue: [ 			self contentType isBinary				ifTrue: [ 					composite table						title: 'Contents';						display: [ {'entity' -> self entity} ];						column: 'Key' evaluated: #Differencekey;						column: 'Value' evaluated: #value;						send: #value ]				ifFalse: [ 					composite text						title: 'Contents';						format: self contents ] ]! !!FLAnalyzer methodsFor: 'protected' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24229389!pluggableSubstitutionMappers	^pluggableSubstitutions collect: [:aLink |		FLPluggableSubstitutionMapper 			when: aLink Differencekey			substituteBy: aLink value]! !!GTRawObjectVariablesBrowser methodsFor: 'private - updating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27686986!generateCacheFor: anObject	| valuesCache |		valuesCache := OrderedDictionary new.	((self basicVariableNodesFor: anObject) do: [ :assoc | 		valuesCache 			at: assoc Differencekey 			put: (self generateHashFor: assoc value) ]).		^ valuesCache! !!GTRawObjectVariablesBrowser methodsFor: 'private building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27689693!variablesIn: composite	^ composite fastTreeTable		useCache;		hasChildren: [ :aNode | aNode Differencekey ~= 'self' ];		children: [ :aNode | aNode childrenNodesFor: self ];		icon: [ :aNode | self iconFor: aNode value ];		display: [ :anObject | 			self variableNodesFor: anObject ];		column: 'Variable' translated			evaluated: [ :aNode | (GTObjectPrinter asNonTruncatedTextFrom: aNode label) ];		column: 'Value' translated			evaluated: [ :aNode | | rawValue displayValue |				[ rawValue := aNode rawValue. ] 					on: Error 					do: [ displayValue := Text string: aNode errorMessage attribute: TextColor red ].				displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ]			modified: [ :newValue :editedNode :curentPresentation | 				self updateVariableNode: editedNode basedOn: newValue.				curentPresentation requestRefresh ];		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse' translated;		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect' translated;		dynamicActionsOnSelection: [ :presentation |			(presentation rawSelection isKindOf: GTInspectorVariableNode) 				ifTrue: [presentation rawSelection inspectorActionsForNode ]				ifFalse: [ #() ] ];		selectionAct: [:list | 			((list selection value pointersToExcept: { list selection value })									reject: [ :each | each pointsOnlyWeaklyTo: list selection value ]) inspect ] 			on: $t			entitled: 'Open pointers to' translated	! !!GTEventRecorder methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27478649!gtInspectorActionHelp	<gtInspectorAction>	^ GLMGenericAction new		action: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner Differencekey = GTEventRecorderHelp Differencekey) and: [				each title = 'Client' ] ] ] ];		icon: GLMUIThemeExtraIcons glamorousHelp;		title: 'Help'! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50956784!packageNamed: aString forLoad: ignored forMap: map ifAbsent: absentBlock  "at the end of the day, I don't the forLoad arg is important ...    it just ends up triggering an error ... when during a real load, you would    not get error. After a decent period of mourning we should just scrub this    arg from system"  | importSpec |  ^ map    at: aString    ifAbsent: [       (self importArray notNil or: [ self import notNil ])        ifTrue: [           "expect the 'missing' name to be satisfied within context of imported project"          importArray            ifNotNil: [               importArray                do: [ :assoc |                   ((assoc value includes: aString) and: [ map includesKey: assoc Differencekey ])                    ifTrue: [                       importSpec := (map at: assoc Differencekey)                        mergeImportLoads: {aString};                        yourself ] ].              importSpec ifNotNil: [ ^ importSpec ] ].          (importSpec isNil and: [ self import notNil ])            ifTrue: [               ^ (map at: self import ifAbsent: absentBlock)                mergeImportLoads: {aString};                yourself ] ].      (aString = 'default' or: [ aString = 'ALL' ])        ifTrue: [           self project groupSpec            name: aString;            includes: self packageNames;            yourself ]        ifFalse: [ absentBlock value ] ]! !!InspectorNavigator methodsFor: 'history' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 29479381!inspectHistoryItem: historyItem	"self inspect: historyItem key .	self selectedIndex: historyItem value."	self inspector: historyItem Differencekey! !!FTBasicTreeListDataSource class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24594093!exampleBasicInspect: anObject	| ds ft |	ds := FTBasicTreeListDataSource new .		ds	root: #ROOT->anObject;		children: [ :item | item value gtInspectorVariableValuePairs ];		sortChildrenBy: [ :a :b | a Differencekey name <= b Differencekey name ];		display: [ :item :cell | cell addMorphBack: item printString asMorph ];		yourself.		ft := FTTableMorph new 		extent: 600@(World clearArea height - 80);		dataSource: ds.		ft openInWindow position: 20@10.		^ds! !!FTBasicTreeListDataSource class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24592849!exampleStateTree	| ds ft |	ds := FTBasicTreeListDataSource new .		ds	roots: { #self -> ds } ;		children: [ :item | item value gtInspectorVariableValuePairs ];		sortChildrenBy: [ :a :b | a Differencekey name <= b Differencekey name ];		display: [ :item :cell | cell 			addMorphBack: item value systemIcon asMorph;			addMorphBack: (item Differencekey printString asMorph emphasis: 1; yourself);			addMorphBack: (Morph new color: Color transparent; height: 1; width: 10; yourself);			addMorphBack: (item value printString) asMorph ];		yourself.			ds expand: 3.		ft := FTTableMorph new 		extent: 600@(World clearArea height - 80);		dataSource: ds.		ft openInWindow position: 20@10! !!FTBasicTreeListDataSource class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24595101!exampleInspect: anObject	| ds ft |	ds := FTBasicTreeListDataSource new .		ds	root: #ROOT->anObject;		children: [ :item | item value gtInspectorVariableValuePairs ];		sortChildrenBy: [ :a :b | a Differencekey name <= b Differencekey name ];		display: [ :item :cell | cell 			addMorphBack: item value class systemIcon asMorph;			addMorphBack: (item Differencekey asStringMorph emphasis: 1; yourself);			addMorphBack: (Morph new color: Color transparent; height: 1; width: 10; yourself);			addMorphBack: item value asStringMorph ];		yourself.		ds expand: 1.		ft := FTTableMorph new 		extent: 800@(World clearArea height // 2);		dataSource: ds.		ft openInWindow position: 20@10.		^ds! !!TabContainerMorph methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63352176!addTabs: associations	associations do: [:each |		self tab 			addTab: (Text fromString: each Differencekey) 			withAction: [ self setContent: each value ].		container submorphs isEmpty ifTrue: [ container addMorph: each value ]]! !!WeakIdentityKeyDictionary methodsFor: 'enumeration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84426851!valuesDo: aBlock 	"See comments in Dictionary>>valuesDo:.  The code keeps the key so it's	not collected during the evaluation of aBlock"	tally = 0 ifTrue: [ ^self ].	1 to: array size do:		[ :eachIndex | 			| eachAssociation eachKey |			eachAssociation := array at: eachIndex.			nil == eachAssociation ifFalse:				[					eachKey := eachAssociation Differencekey.					nil == eachKey ifFalse: [ aBlock value: eachAssociation value ]				]		]! !!PluggableTabBarMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54678803!performActiveTabAction	"Look up the Symbol or Block associated with the currently active tab, and perform it."		| tabActionAssoc aSymbolOrBlock |		tabActionAssoc := self tabs detect: [ :assoc | assoc Differencekey = self activeTab.] ifNone: [ Association new ].	aSymbolOrBlock := tabActionAssoc value.	aSymbolOrBlock ifNil: [ ^ false ].	^ aSymbolOrBlock isSymbol		ifTrue: [ self target perform: aSymbolOrBlock ]		ifFalse: [ aSymbolOrBlock value ].	! !!PluggableTabBarMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54681242!mouseDown: anEvent	| xPosition newTab |	xPosition := anEvent cursorPoint x.	newTab :=		((self tabs detect: [ :anAssociation | | tabBounds |				tabBounds := anAssociation Differencekey bounds.				xPosition between: tabBounds left and: tabBounds right]			ifNone: [nil])		Differencekey).	newTab ifNil: [^ self].	newTab = activeTab ifFalse: [ self activeTab: newTab ]! !!PluggableTabBarMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54681865!layoutChanged	"Fix up our tabs bounds"	| tabsCount |	super layoutChanged.	tabsCount := self tabs size.	tabsCount isZero ifFalse: [ | tabInnerExtent count |		tabInnerExtent := ((self width -				((self tabs first Differencekey outerGap + self tabs last Differencekey outerGap) // 2)					- tabsCount)			 		// tabsCount)			@ (self height).		count := 1.		self tabs do: [ :anAssociation | | tab |			tab := anAssociation Differencekey.			tab innerExtent: tabInnerExtent.			count = 1				ifTrue: [tab position: self position]				ifFalse: [					tab position:						(self position translateBy:							((tabInnerExtent x + 1) * (count - 1))@0)].			count := count + 1  ]	].	self changed.! !!PluggableTabBarMorph methodsFor: 'access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54681673!color: aFillStyle	color := aFillStyle.	self tabs do: [ :anAssociation |		anAssociation Differencekey color: aFillStyle ]! !!PluggableTabBarMorph methodsFor: 'private - access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54679793!activeTab	activeTab ifNil: [		self tabs size > 0 ifTrue: [			activeTab := self tabs first Differencekey.			activeTab active: true]].	^ activeTab ! !!PluggableTabBarMorph methodsFor: 'drawing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54681006!drawOn: aCanvas	self tabs size > 0 ifFalse: [^ self ].	self tabs do: [ :anAssociation | | tab |		tab := anAssociation Differencekey.		tab drawOn: aCanvas]! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63031787!popIntoLiteralVariable: anAssociation 	"Print the Remove Top Of Stack And Store Into Literal Variable bytecode."	self addBytecode: 'popIntoLit: ' , anAssociation Differencekey! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63028069!pushConstant: obj	"Print the Push Constant, obj, on Top Of Stack bytecode."	self addBytecode: (String streamContents:				[:s |				s nextPutAll: 'pushConstant: '.				(obj isKindOf: LookupKey)					ifFalse: [obj printOn: s]					ifTrue: [obj Differencekey						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj Differencekey]						ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]]).! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63029972!pushLiteralVariable: anAssociation	"Print the Push Contents Of anAssociation On Top Of Stack bytecode."	self addBytecode: 'pushLit: ' , anAssociation Differencekey! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63024064!storeIntoLiteralVariable: anAssociation 	"Print the Store Top Of Stack Into Literal Variable Of Method bytecode."	self addBytecode: 'storeIntoLit: ' , anAssociation Differencekey! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22318184!rangeForPC: concretePC contextIsActiveContext: contextIsActive  	"Answer the indices in the source code for the supplied pc."		| pc |		self sortedSourceMap 		ifEmpty: [ ^(1 to: 0) ].	pc := self abstractPCFor: concretePC when: contextIsActive.	(self sortedSourceMap first Differencekey > pc)		ifTrue: [ ^self sortedSourceMap first value ].		^self abstractSourceMap 		at: pc 		ifAbsent: [			(self sortedSourceMap 				findBinary: [:assoc | pc - assoc Differencekey ] 				ifNone: [ | end |					end := self sortedSourceMap last value last.					nil -> (end +1 to: end)]) value ]! !!GTSpotter methodsFor: '*GT-SpotterExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27748858!spotterForGlobalVarsFor: aStep	<spotterOrder: 40>	aStep listProcessor			allCandidates: [ Smalltalk globals associations select:[:assoc | 			assoc value isBehavior not and:[ 				assoc value isTrait not]] ];			title: 'Global variables';			itemName:[:global | global Differencekey ];			filter: GTFilterSubstring;			wantsToDisplayOnEmptyQuery: false! !!MetaLink methodsFor: 'installing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32870585!checkForCompatibilityWith: aNode	| supported |		supported := Set new.	RFReification subclasses do: [:plugin |		(plugin entities anySatisfy: [:class | aNode isKindOf: class]) ifTrue: [		supported add: plugin Differencekey]].	self allReifications do: [ :each | (supported includes: each) ifFalse: [^false  ]  ].	^true! !!IceRepositoriesBrowser methodsFor: 'building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 35520247!addRepositoryInfoTo: composite	composite fastTable		title: 'General';		display: #detailedInfo;		column: 'Name' evaluated: #Differencekey width: 80;		column: 'Value' evaluated: #value! !!GLMTreeBrick methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27227178!headerFor: anObject in: aCollapsable	|header|		header := GLMBrick new.	header		hSpaceFill;		vShrinkWrap.			header addBrickBack:		((anObject isVariableBinding			ifTrue: [ anObject Differencekey asBrick ]			ifFalse: [ anObject asBrick ])				hSpaceFill).					(self hasChildren: anObject) ifTrue: [		header addBrickFirst: (self newToggleButtonFor: aCollapsable) ].		^ header! !!Class methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19197936!gtInspectorInstanceVariablesIn: composite	"This provides a list of all class instance variables and the corresponding values"	<localClassMethod>     "This method is supposed to be local in Class because of a good reason.    We use this pragma to test if Class does not contain some accidental     local selectors."	<gtInspectorPresentationOrder: 21>	composite table		title: 'InstVars';		display: [ self class allInstVarNames sorted collect: [ :each | each -> (self instVarNamed: each) ] ];		column: 'Variable' evaluated: [ :each | each Differencekey ];		column: 'Value' evaluated: [ :each | each value ]! !!Class methodsFor: 'pool variables' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19261499!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [self sharedPools remove: aDictionary.				self sharedPools isEmpty ifTrue: [self sharedPools: nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet := self subclasses asOrderedCollection.	satisfiedSet := Set new.	[workingSet isEmpty] whileFalse:		[aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal Differencekey 								, ' is still used in code of class '								, sub name]]].	self sharedPools remove: aDictionary.	self sharedPools isEmpty ifTrue: [self sharedPools: nil]! !!Class methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19202463!declareClassVariables: newVars 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	|  conflicts |		conflicts := false.		"Remove. Warn if vars are removed that are still used"	"self flag: something wrong here. put to true and add an ivar to a class"	(self classVariables reject: [:x | newVars includes: x]) do: [:var | self removeClassVarNamed: var name interactive: false].		(newVars reject: [:var | self classVariables includes: var]) do: [:var | "adding"			"check if new vars defined elsewhere"			(self innerBindingOf: var Differencekey) 				ifNotNil: [(DuplicatedVariableError new) variable: var name;						signal: var name , ' is defined elsewhere'.					conflicts := true]].	newVars notEmpty		ifTrue: 			[self classPool: self classPool.			"in case it was nil"			newVars do: [:var | self classPool declareVariable: var from: Undeclared]].	^conflicts! !!GTInspector methodsFor: 'building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27568230!compose	self title: [:anObject | 'Inspector on ', (self printObjectAsAnItem: anObject)].	self act: [:b | b update] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.	self act: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner Differencekey = GTInspectorHelp Differencekey) and: [				each title = 'Overview' ] ] ] ] 		icon: GLMUIThemeExtraIcons glamorousHelp 		entitled: 'Help'.	self act: [:b | b presentationFilter changeFilterRequestFor: b ] entitled: 'Filter presentations'.	self pager with: [ :browser | 		browser fixedSizePanes: self class numberOfInspectorPanes.		browser show: [ :a :each |			a title: [ self printObjectAsAnItem: each ].			a dynamicActions: [ :aPresentation | 				each gtInspectorActions asOrderedCollection ].			a titleAction: [ :aPresentation | self closeActionFor: aPresentation ].			a dynamic 				display: [ :x | 					(GLMCompositePresentation new with: [:d | 						each 							gtInspectorPresentationsIn: d 							inContext: self ])							startOn: x ] ] ].				self browser when: GLMPaneAdded send: #actOnPaneAdded: to: self.	self browser when: GLMPaneRemoved send: #actOnPaneRemoved: to: self.		self class isStepRefreshEnabled ifTrue: [ 		self wantsAutomaticRefresh: true.		self wantsSteps: true.		self stepTime: self class stepRefreshRate ].	! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63085953!allReferencesToPool: aPool from: aClass	"Answer all the references to variables from aPool"	| list |	list := OrderedCollection new.	aClass		withAllSubclassesDo: [ :cls | 			cls				selectorsAndMethodsDo: [ :sel :meth | 					meth literals						detect: [ :lit | lit isVariableBinding and: [ (aPool bindingOf: lit Differencekey) notNil ] ]						ifFound: [ list add: (self createMethodNamed: sel realParent: aClass) ] ] ].	^ list! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63087886!allReferencesToPool: aPool	"Answer all the references to variable aPool"	| list |	list := OrderedCollection new.	self		allClassesDo: [ :cls | 			cls				selectorsAndMethodsDo: [ :sel :meth | 					meth literals						detect: [ :lit | (lit isVariableBinding and: [ lit Differencekey notNil ]) and: [ (aPool bindingOf: lit Differencekey) notNil ] ]						ifFound: [ list add: (self createMethodNamed: sel realParent: cls) ] ] ].	^ list! !!SystemNavigation methodsFor: '*Tool-Base' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63109578!browseUndeclaredReferences	"	SystemNavigation new browseUndeclaredReferences	"		Undeclared removeUnreferencedKeys.	Undeclared associations do: [:binding |		self			browseMessageList: (self allReferencesTo: binding )			name: 'References to Undeclared: ', binding Differencekey printString ]! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63108131!methodsWithUnboundGlobals	"This says that for any global, it should match either the class's notion of what bindingOf: the key is, or bindingOf: should be nil and the binding should be in Undeclared. If the class answers a different binding through bindingOf: or answers no binding and the binding is not in Undeclared then the variable in the method is wrong.	For a clean image the result should be empty. If it is not empty, evaluating Compiler recompileAll probably solves the problem. However, we should investigate why the method gets an incorrect state."	"SystemNavigation new methodsWithUnboundGlobals"	^self allMethodsSelect:		[:m|		m literals anySatisfy:			[:l|			l isVariableBinding			and: [l Differencekey isSymbol "avoid class-side methodClass literals"			and: [ (l value isKindOf: Slot) not			and: [(m methodClass classBindingOf: l Differencekey)					ifNil: [(Undeclared associationAt: l Differencekey ifAbsent: []) ~~ l]					ifNotNil: [:b| b ~~ l]]]]]]! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63092613!instanceSideMethodsWithNilKeyInLastLiteral	"This answers all the instance side methods that has NIL as the key in their last literal. There should be none (only class side methods have this)"	^ self		allMethodsSelect: [ :each | 			(((each literalAt: each numLiterals) Differencekey isNil and: [ (each literalAt: each numLiterals) value isMeta not ])				and: [ each methodClass ~= UndefinedObject ]) and: [ each isInstalled ] ]! !!SystemNavigation methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63088398!headingAndAutoselectForLiteral: aLiteral do: binaryBlock	"Evaluate aBlock with either Users of ... or Senders of ... plus the auto-select string	 for the given literal.  aLiteral can be a Symbol, a VariableBinding or an arbitrary object."	| autoSelect |	^aLiteral isSymbol		ifTrue: [binaryBlock value: 'Senders of ', aLiteral value: aLiteral ]		ifFalse:			[autoSelect := aLiteral isVariableBinding							ifTrue: [aLiteral Differencekey]							ifFalse: [aLiteral printString].			binaryBlock value: 'Users of ', autoSelect value: autoSelect]! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63081261!obsoleteMethodReferences	"SystemNavigation new obsoleteMethodReferences"	"Open a browser on all referenced behaviors that are obsolete"	| obsClasses references |	references := Array new writeStream.	obsClasses := self obsoleteBehaviors.	'Scanning for methods referencing obsolete classes' 		displayProgressFrom: 0 to: obsClasses size		during: 			[ :bar | 			obsClasses keysAndValuesDo: 					[ :index :each | | obsRefs | 					bar current: index.					obsRefs := each pointersToExcept: obsClasses.					obsRefs do: 							[ :ref | 							"Figure out if it may be a global"							(ref isVariableBinding and: [ref Differencekey isString	"or Symbol"]) 								ifTrue: 									[(ref pointersTo) do: 											[:meth | 											meth isCompiledMethod												ifTrue: [meth methodReference ifNotNil: [:mref | references nextPut: mref]]]]]]].	^ references contents! !!Context methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21658538!gtInspectorVariableNodesIn: aCollection	"We override the variables with context specific ones"	| tempVariableValueNodes |		tempVariableValueNodes := self gtInspectorTempNodes sort: [:aNode :anotherNode | aNode Differencekey < anotherNode Differencekey ].	aCollection addAll: tempVariableValueNodes.	super gtInspectorVariableNodesIn: aCollection! !!Context methodsFor: '*GT-BytecodeDebugger' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21695756!gtBytecodeDebuggerRetrieveContextValues	|fieldList displayedTemp slotsSize tempNames |	fieldList := OrderedCollection new.	displayedTemp := OrderedCollection new.	tempNames := self tempNames.		self stackPtr to: 1 by: -1 do: [ :tempIndex ||tempNode|		fieldList add:			(tempIndex <= tempNames size				ifTrue: [ 					displayedTemp add: (tempNames at: tempIndex).					tempNode := GTInspectorContextNamedTempNode 						hostObject: self 						tempName: (tempNames at: tempIndex) 						tempIndex: tempIndex.					GTInspectorWrapperNode 						hostObject: tempNode						label: (tempIndex - 1) asString, ' [', (tempNames at: tempIndex), ']'  ]				ifFalse: [					 tempNode := GTInspectorContextIndexedTempNode hostObject: self tempIndex: tempIndex.					 GTInspectorWrapperNode 					 	hostObject: tempNode						label: (tempIndex - 1) asString ]) ].		(tempNames copy asOrderedCollection removeAll: displayedTemp; yourself) ifNotEmpty: [ :uninitializedTemps |		uninitializedTemps do: [ :each |			GTInspectorDynamicNode hostObject: self label: ('- [', each, ']') value: nil ] ].		fieldList addAll: (self gtDebuggerDoItBindings collect: [:aBinding |		(GTInspectorDynamicNode hostObject: self label: aBinding Differencekey value: aBinding value)			variableTag: 'temp';			yourself ]).		slotsSize := self receiver class allSlots size.	fieldList 		addAll: ((self receiver class allSlots reverse) collect: [:slot ||slotNode|			slotNode :=  GTInspectorSlotNode hostObject: self receiver slot: slot.			GTInspectorWrapperNode 				hostObject: slotNode				label: ('rcv', (slotsSize := slotsSize - 1) asString, ' [', slot name , ']')  ]).		^ fieldList asOrderedCollection 		addFirst: (GTInspectorSelfNode hostObject: self receiver);		addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);		yourself! !!Context methodsFor: '*GT-Debugger' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21687148!gtDebuggerRetrieveVariableValuePairs	|fieldList|	fieldList := SortedCollection 						sortBlock: [:variablePair1 :variablePair2 | 							variablePair1 Differencekey < variablePair2 Differencekey].	fieldList		addAll: ((self receiver class allSlots collect: [ :slot | 			GTInspectorSlotNode hostObject: self receiver slot: slot ])).			fieldList addAll: self gtInspectorTempNodes.	fieldList addAll: (self gtDebuggerDoItBindings collect: [:aBinding |		(GTInspectorDynamicNode hostObject: self label: aBinding Differencekey value: aBinding value)			variableTag: 'temp';			yourself ]).		^ fieldList asOrderedCollection 		addFirst: (GTInspectorSelfNode hostObject: self receiver);		addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);		addLast: (GTInspectorDynamicNode hostObject: self label: 'stack top' value: ( self stackPtr > 0 ifTrue: [ self top]));		yourself! !!MorphTreeNodeMorph methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51814398!buildRowMorph	| rowControls colAndControls |	controls := OrderedCollection new.	colAndControls := container columns 		collect: [:col | | v |			v := col rowMorphFor: complexContents.			controls add: v.			col -> v].	rowControls := OrderedCollection new.	colAndControls		do: [:ctrl | | col morph |			col := ctrl Differencekey.			morph := ctrl value.			morph clipSubmorphs: true.			morph vResizing: #shrinkWrap.  			rowControls add: morph.			(morph = controls last and: [container lastColumnUnbounded]) ifFalse: [morph hResizing: #rigid].			(col resizable not and: [col shrinkWrap])				ifTrue: [col currentWidth < morph width 						ifTrue: [col forceWidthTo: morph width]]].	self addAllMorphs: rowControls.	self layoutChanged	! !!PragmaType class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 55101557!all	| pragmas |	pragmas := OrderedCollection new.	Object withAllSubclassesDo: [:each |		Pragma withPragmasIn: each do: [:p |			pragmas add: p]].	^ (pragmas groupedBy: #keyword) associations collect: [ :association |		PragmaType new			keyword: association Differencekey; 			pragmas: association value ] ! !!VirtualMachine methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84331660!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 0>	composite table		title: 'Details';		display: [ 			{ 				'VM directory' -> self vmDirectory asFileReference.				'VM build date' -> self buildDate.				'VM version' -> self version.				'Image directory' -> self imagePath asFileReference parent.				'Image version' -> self imageVersionNumber.			} ];		column: 'Property' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!ClassWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19540069!selectedClasses	| associations |	associations := self classesSelection associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc Differencekey ].	^ associations select: [:each | each notNil ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50703256!mixedStackCall	^MetacelloPlatform current 		stackCacheFor: #mixedStack		at: #Differencekey 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 3 ifTrue: [ ^value ].			value := value + 1.			cache at: #x put: value.			self assert: self cachedReturnOfValue == 6.			self mixedStackCall ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50699423!testClearCache	MetacelloPlatform current 		stackCacheFor: #cached		at: #Differencekey 		doing: [:cache | | value |			cache at: #x put: 1.			self assert: (cache at: #x ifAbsent: []) == 1.			MetacelloClearStackCacheNotification signal.			self assert: (cache at: #x ifAbsent: []) == nil ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50700289!directReturnOfValue	^MetacelloPlatform current 		stackCacheFor: #direct		at: #Differencekey 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 5 ifTrue: [ ^value ].			value := value + 1.			cache at: #x put: value.			self directReturnOfValue ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50700887!mixedStack	^MetacelloPlatform current 		stackCacheFor: #mixed		at: #Differencekey 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 3 ifTrue: [ ^value ].			value := value + 1.			cache at: #x put: value.			self assert: self directReturnOfValue == 6.			self assert: self mixedStackCall == 4.			self mixedStack ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50696574!testPrimeStackCache	| cached collection cacheNil direct mixed mixedStack block defaultDictionary |	defaultDictionary := Dictionary new.	block := [ 		cached := Dictionary new.		collection := Dictionary new.		cacheNil := Dictionary new.		direct := Dictionary new.		mixed := Dictionary new.		mixedStack := Dictionary new.		MetacelloPlatform current useStackCacheDuring: [ :dict | self cachedReturnOfValue ] defaultDictionary: cached.		MetacelloPlatform current useStackCacheDuring: [ :dict | self collectionCacheKey ] defaultDictionary: collection.		MetacelloPlatform current useStackCacheDuring: [ :dict | self cacheNil ] defaultDictionary: cacheNil.		MetacelloPlatform current useStackCacheDuring: [ :dict | self directReturnOfValue ] defaultDictionary: direct.		MetacelloPlatform current useStackCacheDuring: [ :dict | self mixedStack ] defaultDictionary: mixed.		MetacelloPlatform current useStackCacheDuring: [ :dict | self mixedStackCall ] defaultDictionary: mixedStack ].		"Test without priming stack cache ... each defaultDictionary is used independently"	block value.	self assert: ((cached at: #cached) at: #Differencekey) == 6.	self assert: ((collection at: #collection) at: #x) == 6.	self assert: ((cacheNil at: #cacheNil) at: #Differencekey) == nil.	self assert: ((direct at: #direct) at: #x) == 6.	self assert: ((mixed at: #cached) at: #Differencekey) == 6.	self assert: ((mixed at: #mixed) at: #x) == 4.	self assert: ((mixed at: #mixedStack) at: #x) == 4.	self assert: ((mixed at: #direct) at: #x) == 6.	self assert: ((mixedStack at: #cached) at: #Differencekey) == 6.	self assert: ((mixedStack at: #mixedStack) at: #x) == 4.		"Prime stack cache with defaultDictionary .... all values should be stored there instead of individual defaults."	MetacelloPlatform current primeStackCacheWith: defaultDictionary doing: block.	self assert: ((defaultDictionary at: #cached) at: #Differencekey) == 6.	self assert: ((defaultDictionary at: #collection) at: #x) == 6.	self assert: ((defaultDictionary at: #cacheNil) at: #Differencekey) == nil.	self assert: ((defaultDictionary at: #direct) at: #x) == 6.	self assert: ((defaultDictionary at: #cached) at: #Differencekey) == 6.	self assert: ((defaultDictionary at: #mixed) at: #x) == 4.	self assert: ((defaultDictionary at: #mixedStack) at: #x) == 4.	self assert: ((defaultDictionary at: #direct) at: #x) == 6.	self assert: ((defaultDictionary at: #cached) at: #Differencekey) == 6.	self assert: ((defaultDictionary at: #mixedStack) at: #x) == 4! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50702853!cachedReturnOfValue	^MetacelloPlatform current 		stackCacheFor: #cached		at: #Differencekey 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 5 				ifTrue: [ cache at: #Differencekey put: value ]				ifFalse: [ 					value := value + 1.					cache at: #x put: value ].			self cachedReturnOfValue ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50700647!cacheNil	^MetacelloPlatform current 		stackCacheFor: #cacheNil		at: #Differencekey 		doing: [:cache | | value |			cache at: #Differencekey put: nil.			self cacheNil ]! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27610207!testArrayPairsUnderLimit	| limit pairs|		limit := 2*GTInspector indexableDisplayLimit - 1.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = limit.	(pairs collect: #Differencekey) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #Differencekey) = (1 to: limit) asOrderedCollection).! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27612928!testArrayPairsSmall	| pairs |		pairs := (1 to: 10) asArray gtInspectorVariableValuePairs.	self assert: pairs size = 10.	(pairs collect: #Differencekey) allSatisfy: [ :e | (pairs at: e) = e ].! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27612341!testArrayPairsLong		| limit pairs |		limit := 3*GTInspector indexableDisplayLimit.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = (2*GTInspector indexableDisplayLimit).	(pairs collect: #Differencekey) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #Differencekey) = ((1 to: GTInspector indexableDisplayLimit ) asOrderedCollection 		addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection; yourself)).! !!GTInspectorVariableValuePairsTest methodsFor: 'context' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27611224!testContextNodes	| pairs x tempVariables indexVariables instVariables |		x:=42.	pairs := OrderedCollection new.	[:y| y+1+x ] asContext gtInspectorVariableNodesIn: pairs.		pairs := pairs withIndexCollect: [ :e :i | i -> e].		tempVariables := pairs select: [ :e | e value label beginsWith: '[' ].	indexVariables := pairs select: [ :e | e value Differencekey isInteger ].	instVariables := pairs select: [ :e | e value isKindOf: GTInspectorSlotNode ].		self assert: (tempVariables sort last Differencekey) < (indexVariables first Differencekey).	self assert: (indexVariables sort last Differencekey) < (instVariables first Differencekey).! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27611918!testArrayPairsEqualLimit	| limit pairs|		limit := 2*GTInspector indexableDisplayLimit.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = limit.	(pairs collect: #Differencekey) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #Differencekey) = (1 to: limit) asOrderedCollection).! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27610634!testArrayPairsOverLimit	| limit pairs |		limit := 2*GTInspector indexableDisplayLimit + 1.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = (2*GTInspector indexableDisplayLimit).	(pairs collect: #Differencekey) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #Differencekey) = ((1 to: GTInspector indexableDisplayLimit ) asOrderedCollection 		addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection; yourself)).! !!GTPlayground methodsFor: 'accessing-dynamic' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27655715!currentBindingsSorted	^ self currentBindings associations asSortedCollection: [ :first :second | first Differencekey < second Differencekey ]! !!GTPlayground methodsFor: 'accessing-dynamic' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27659491!removeBinding: anAssociation	|bindings|	bindings := self currentBindings copy.	bindings removeKey: anAssociation Differencekey ifAbsent: [ ].	self setBindings: bindings.! !!GTPlayground methodsFor: 'building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27659739!compose	self title: self defaultPlaygroundTitle.	self act: [:b | b update] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.	self act: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner Differencekey = GTPlaygroundHelp Differencekey) and: [				each title = 'Overview' ] ] ] ] 		icon: GLMUIThemeExtraIcons glamorousHelp 		entitled: 'Help'.			self act: [ :b | 			SettingBrowser new 				changePackageSet: { (RPackageOrganizer default packageNamed: 'GT-Playground') }; 				open; 				expandAll ] 		icon: (Smalltalk ui icons iconNamed: #smallCogInitialState)		entitled: 'Global Setting'.			self custom:			(GTInspector new				noTitle; 				noActions;				wantsAutomaticRefresh: true;				showFirst: [ :composite |					self codeIn: composite ];				yourself);		when: GLMBrowserClosing do: [ :ann |			self actOnBrowserClosing: ann ].		GTInspector isStepRefreshEnabled ifTrue: [		self wantsAutomaticRefresh: true.		self wantsSteps: true.		self stepTime: GTInspector stepRefreshRate ]	! !!GTSpotterMorph methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27952769!initializeListeners	self activeHand addEventListener: self.	Morph announcer weak when: MorphLostFocus send: #onLostFocus: to: self.	self bindingDictionnary		associationsDo: [ :anAssociation | self bindKeyCombination: anAssociation Differencekey toAction: anAssociation value ].	processorKeyBindings := Dictionary new.! !!DAManuallyAddedDependentPackageNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21891355!children	^ self content dependencies flatCollect: 		[ :dependency | 		dependency users collect: 			[ :association | | method sentMessages |			method := association Differencekey.			sentMessages := association value.			DAMessageSendDependencyNode new				content: method;				parentNode: self;				sentMessages: sentMessages 				yourself ] ]! !!FLMigration methodsFor: 'evaluating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24418271!applyTo: aVariablesMapping 		variables do: [:link |		aVariablesMapping 			map: link Differencekey 			to: link value ]	! !!SelectRuleBrowser class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 59502875!items	| rules rulesByGroup integrationRules |	rules := (ReRuleManager visibleRuleClasses collect: #new) sorted: [ :a :b |		a name < b name ].	integrationRules := rules select: [ :r |		PharoCriticRules pharoHardLintRules includes: r class ].	rulesByGroup := ((rules groupedBy: #group) associations collect: [ :as |		CriticBrowserRulesGroup named: as Differencekey rules: as value ]).	rulesByGroup sort: [ :a :b | a name < b name ].	^ rulesByGroup copyWithFirst: (		CriticBrowserRulesGroup			named: 'Pharo integration rules'			rules: integrationRules)! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36006373!determineDecipherIndexWith: anInteger	(( anInteger - self Differencekey ) < 0)			ifTrue: 		[ ^anInteger - self Differencekey + self alphabet size ]			ifFalse:		[ ^anInteger - self Differencekey ]! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36004055!decipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (( self alphabet findString: letter asString) - self Differencekey) ].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36005789!determineCipherIndexWith: anInteger	(( anInteger + self Differencekey ) > self alphabet size)			ifTrue: 		[ ^anInteger + self Differencekey - self alphabet size ]			ifFalse:		[ ^anInteger  + self Differencekey ]! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22371742!fixDependents	"They are not used much, but need to be right"	DependentsFields associationsDo:		[:pair |		pair value do:			[:dep |			(references at: dep ifAbsent: [nil]) ifNotNil:				[:newDep| | newModel |				newModel := references at: pair Differencekey ifAbsent: [pair Differencekey].				newModel addDependent: newDep]]].! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52482283!testAsTestMethod	{((self stubClass >> #one) -> (self stubTestClass >> #testOne)).	((self stubClass >> #one:) -> (self stubTestClass >> #testOne)).	((self stubClass >> #two) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #two:) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #oneTwo:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #untestedOne) -> nil).	((self stubClass >> #untestedOne:) -> nil).	((self stubClass >> #untestedTwo) -> nil).	((self stubClass >> #untestedTwo:) -> nil).	((self stubClass >> #untestedOne:two:) -> nil).	((self stubClass >> #untestedOneTwo:) -> nil).	((self stubClass class >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass class >> #untestedOne:two:) -> nil).	((self stubTestClass >> #testOne) -> (self stubTestClass >> #testOne)).	((self stubTestClass >> #testTwo) -> (self stubTestClass >> #testTwo)).	((self stubTestClass >> #testOneTwo) -> (self stubTestClass >> #testOneTwo))}		do: [ :each | self assert: each Differencekey asTestMethod == each value ]! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52483719!testCorrespondingTestCase	"tests that classes and their meta classes have the same test class	corresponding to them"	{(Behavior -> BehaviorTest).	(Behavior class -> BehaviorTest).	(BehaviorTest -> nil).	(Class -> ClassTest).	(Class class -> ClassTest).	(ClassTest -> nil).	(Metaclass -> MetaclassTest).	(Metaclass class -> MetaclassTest).	(MetaclassTest -> nil).	(NautilusUtilsTestStub -> NautilusUtilsTestStubTest).	(NautilusUtilsTestStub class -> NautilusUtilsTestStubTest).	(NautilusUtilsTestStubTest -> nil).	(NautilusUtilsTestStubUntested -> nil).	(NautilusUtilsTestStubUntested class -> nil)}		do: [ :each | self assert: each Differencekey correspondingTestCase == each value ]! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52484485!testCorrespondingTestedMethods	{(self stubTestClass >> #testOne) ->		{(self stubClass >> #one).		(self stubClass >> #one:)}.	(self stubTestClass >> #testTwo) ->		{(self stubClass >> #two).		(self stubClass >> #two:)}.	(self stubTestClass >> #testOneTwo) ->		{(self stubClass >> #one:two:).		(self stubClass >> #oneTwo:).		(self stubClass class >> #one:two:)}.	(self stubTestClass >> #stubClass) ->		{}.	(self stubTestClass >> #newStub) ->		{}} do: [ :each |		self assert: each Differencekey correspondingTestedMethods asSet = each value asSet].	"non-test methods should have no corresponding tested methods"	self stubClass methods , self stubClass class methods do: [ :each | 			self assert: each correspondingTestedMethods isEmpty ]! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52486101!testCorrespondingTestMethod	{((self stubClass >> #one) -> (self stubTestClass >> #testOne)).	((self stubClass >> #one:) -> (self stubTestClass >> #testOne)).	((self stubClass >> #two) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #two:) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #oneTwo:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #untestedOne) -> nil).	((self stubClass >> #untestedOne:) -> nil).	((self stubClass >> #untestedTwo) -> nil).	((self stubClass >> #untestedTwo:) -> nil).	((self stubClass >> #untestedOne:two:) -> nil).	((self stubClass >> #untestedOneTwo:) -> nil).	((self stubClass class >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass class >> #untestedOne:two:) -> nil).	((self stubTestClass >> #testOne) -> nil).	((self stubTestClass >> #testTwo) -> nil).	((self stubTestClass >> #testOneTwo) -> nil)}		do: [ :each | self assert: each Differencekey correspondingTestMethod == each value ]! !!NetNameResolver class methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52506392!waitForResolverNonBusyUntil: deadline	"Wait up to the given number of seconds for the resolver to be non busy.	Return the resolver state."	| status passed |	status := self resolverStatus.	[ status = ResolverBusy and: [ (passed := Time millisecondsSince: deadline Differencekey) < deadline value] ]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline value - passed).			status := self resolverStatus ].	^ status! !!Callback methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18827763!evaluatorForSignature: signature "<String|Array>"	"Search the methods marked with the signature: primtiive for those that match signature.	 signature is typically a literal Array for the function's C signature, e.g. #(int (*)(int, char *))."	Pragma withPragmasIn: self class do:		[:pragma|		 (pragma Differencekey == #signature:		  and: [(pragma argumentAt: 1) = signature]) ifTrue:			[^pragma method]].	self error: 'could not find Callback signature'! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58115318!decoratorNamed: aKey	^ self Differencekey = aKey		ifTrue: [ self ]		ifFalse: [ next decoratorNamed: aKey ]! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36008627!Differencekey	^self class Differencekey! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58112872!key	^self class Differencekey! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58113212!hasDecoratorNamed: aKey	^ self Differencekey = aKey or: [ next hasDecoratorNamed: aKey ]! !!RubParagraphDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58116448!classOfDecoratorNamed: aKey 	^ self allSubclasses detect: [ :cls | cls Differencekey = aKey ] ifNone: [  ]! !!SystemHelp class methodsFor: 'conversion' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63077559!asHelpTopic 	|topic helpOnHelp sortedTopics |	topic := HelpTopic named: 'Help'.	self allSystemHelpPragmas do: [:each | 		topic subtopics addAll: each method methodClass theNonMetaClass asHelpTopic subtopics	].	topic sortSubtopicsByTitle.	helpOnHelp := topic subtopics detect: [:t | t Differencekey = 'HelpOnHelp'] ifNone: [self error: 'Help for the help system is removed'].	sortedTopics := topic subtopics.	sortedTopics remove: helpOnHelp.	sortedTopics addLast: helpOnHelp.	topic subtopics: sortedTopics.	^topic.! !!Date methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22076757!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'year' -> self year.					'month' -> self monthIndex.					'month name' -> self monthName.					'day of month' -> self dayOfMonth.					'day of week' -> self dayOfWeekName.					'day of year' -> self dayOfYear.					'iso' -> self yyyymmdd } ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 33416956!packageSpecsInLoadOrderForMap: packageMap  | loadOrder pkgs packageNames importNames importSpec importProjectSpecs importProjectNameMap |  loadOrder := self packageSpecsInLoadOrder.  importNames := (packageNames := (packageMap values    collect: [ :pkg | pkg name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ])    ifTrue: [ ^ loadOrder select: [ :pkg | packageNames includes: pkg name ] ].  loadOrder do: [ :pkg | importNames remove: pkg name ifAbsent: [  ] ].  pkgs := OrderedCollection new.  importProjectSpecs := Dictionary new.  importProjectNameMap := Dictionary new.  importArray    ifNotNil: [       loadOrder        do: [ :pkg |           importArray            do: [ :assoc |               assoc Differencekey = pkg name                ifTrue: [                   importProjectSpecs at: pkg name put: pkg.                  (assoc value select: [ :each | importNames includes: each ])                    do: [ :each |                       (importProjectNameMap                        at: pkg name                        ifAbsent: [ importProjectNameMap at: pkg name put: Set new ])                        add: each ] ] ] ] ].  self import    ifNotNil: [       loadOrder        do: [ :pkg |           pkg name = self import            ifTrue: [               importProjectSpecs at: pkg name put: pkg.              importProjectNameMap at: pkg name put: importNames ] ] ].  loadOrder    do: [ :pkg |       (packageNames includes: pkg name)        ifTrue: [ pkgs add: pkg ].      importProjectSpecs        at: pkg name        ifPresent: [ :importProjectSpec |           "insert the imports at this point"          (importProjectNameMap at: pkg name ifAbsent: [ #() ])            do: [ :importedName |               pkgs                add:                  (importSpec := importProjectSpec copy                    name: importedName;                    mergeImportLoads: {importedName};                    yourself).              importSpec projectReference name: importedName ] ] ].  ^ pkgs! !!SourceFileArray methodsFor: 'public - string reading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 61196388!timeStampAt: sourcePointer for: sourceDataPointers	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	| preamble stamp tokens stampPosition |	stamp := ''.	preamble := self sourcedDataAt: sourcePointer.	(preamble includesSubstring: sourceDataPointers Differencekey)		ifTrue: [ 			tokens := preamble parseLiterals.			stampPosition := tokens indexOf: sourceDataPointers value.			stampPosition = 0				ifFalse: [ 					"New format gives change stamp and unified prior pointer"					stamp := tokens at: stampPosition + 1 ] ].	^ stamp! !!SourceFileArray methodsFor: 'public - string reading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 61211069!protocolAt: sourcePointer for: sourceDataPointers	"Answer the protocol for a given method, retrieved from the sources or changes file. Answer unfound protocol if no protocol is available."	| preamble protocol tokens protocolPosition |	protocol := 'unfound protocol'.	"this is to indicate that the tagging in the source does not use the correct format.	We will have to fix that. For example some traits methods are wrongly tagged.	see http://code.google.com/p/pharo/issues/detail?id=4581"	preamble := self sourcedDataAt: sourcePointer.	preamble = 'Trait method' ifTrue: [ ^ nil ].	(preamble includesSubstring: sourceDataPointers Differencekey) ifTrue: [ 		tokens := preamble parseLiterals.		protocolPosition := tokens indexOf: sourceDataPointers Differencekey.		protocolPosition = 0			ifFalse: [ 				"New format gives change protocol and unified prior pointer"				protocol := tokens at: protocolPosition + 1 ] ].	^ protocol! !!RectangleTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 57575597!testStoreOn	| assoc assoc2 |	assoc := (0 @ 0 extent: 1 @ 1) -> 0.	assoc2 := self class compiler evaluate: assoc storeString.	self assert: assoc Differencekey = assoc2 Differencekey.	self assert: assoc value = assoc2 value! !!Character methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19063290!gtInspectorCharacterIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Character';		display: [			{'self' -> self.			'codepoint' -> self codePoint.			'unicode' -> (String streamContents: [ :stream | 				stream << 'U+'.				self codePoint printOn: stream base: 16 nDigits: 4 ])} ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: [ :each | each value printString ];		send: #value! !!LGitReturnCodeEnum class methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 34945289!setUpHandlers	^ (self declaration associations collect: [ :nameToValue |		nameToValue Differencekey -> (LGitCallReturnHandler for: (self perform: nameToValue Differencekey)) ]) asDictionary! !!HookGenerator methodsFor: 'initialize' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28731306!entity: anEntity node: aNode links: aCollection	plugins := Dictionary new.	node := aNode.	entity := anEntity.	links := aCollection.		"register all the plugins that can reify information for this node"	RFReification subclasses do: [:plugin |		(plugin entities anySatisfy: [:class | entity isKindOf: class])	 ifTrue: [			plugins at: plugin Differencekey put: plugin]		].! !!HookGenerator methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28727048!preamble	| preamble |	"Very simplistic now: needs to do some optimizatons"		preamble := OrderedCollection new.	links do: [:link |  		plugins do: [ :plugin | (link allReifications includes: plugin Differencekey) ifTrue: [preamble addAll: ((plugin entity: entity link: link) preamble: entity)]].		link control = #instead ifTrue: [				"for instead links, the preamble needs to clean the stack. For now just implemented for message sends"				entity isMessage ifTrue: [					entity numArgs + 1 timesRepeat: [preamble add: (RFStorePopIntoTempNode named: #RFBalancestack)]]]].	^preamble! !!IRBytecodeGenerator methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28787563!addLastLiteral: object	lastLiteral ifNil: [ ^ lastLiteral := object ].	((lastLiteral literalEqual: object)		or: [ 			"case of metaclass, they have no unique association"			(lastLiteral isKindOf: Association) and: [ lastLiteral Differencekey isNil ] ])		ifFalse: [ self error: 'there can only be one last literal' ]! !!IRBytecodeGenerator methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28797938!bytecodes	| stream |	self updateJumpOffsets.	stream := (ByteArray new: 100) writeStream. 	primitiveBytes ifNotNil: [stream nextPutAll: primitiveBytes contents].	orderSeq do: [ :seqId | |lastInstr|			"If the instruction will emit bytes, record the first byte emitted as the instructions bytecode index"			lastInstr := IRInstruction new -> 1.			(instrMaps at: seqId) do: [ :assoc | |nextInstr|				nextInstr := assoc.				lastInstr Differencekey bytecodeIndex: ((nextInstr value - lastInstr value) > 0 ifTrue: [ 					stream position + lastInstr value]).				lastInstr := assoc.				  ].			lastInstr Differencekey bytecodeIndex: ((seqBytes at: seqId) size < lastInstr value ifFalse: [  stream position + lastInstr value]).			stream nextPutAll: (seqBytes at: seqId) ].	^ stream contents! !!MorphTreeNavigationBar methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51771336!pageSearchText: aString	| founds chosen chosenNode |	pageSearchText := aString.	self changed: #pageSearchText.	founds := OrderedCollection new.	self nodeList doWithIndex: [:n :idx |		(n includesSubstringAnywhere: pageSearchText)			ifTrue: [founds add: idx -> n]].	founds ifEmpty: [ ^ self flash ].	founds size > 1 		ifTrue: [ 			chosen := 				UIManager default 					chooseFrom: (founds collect: [:l | l value] ) 					values: (founds collect: [:l | l Differencekey] ) 					lines: nil 					title: ''.			chosen ifNil: [^self]]		ifFalse: [chosen := founds first Differencekey].	self currentPage: (self pageOfNodeIndex: chosen).	chosenNode := self nodeList at: chosen.	treeMorph scroller 		submorphsDo: [:sm | 			sm complexContents ==  chosenNode				ifTrue: [treeMorph listManager setSelectedMorph: sm.					^ treeMorph scrollSelectionIntoView]]! !!GTInspectorVariableNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27608249!label	"Answer the label of this object variable (slot, indexed attribute, computed value)."	^ self Differencekey asString! !!Association methodsFor: '*Glamour-Helpers' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17439797!asGlamourTargetIdentifier	^ GLMPortIdentifier new 		paneName: self Differencekey;		portName: self value! !!Association methodsFor: '*Glamour-Helpers' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17439440!asGlamourOriginIdentifier	^ GLMPortIdentifier new 		paneName: self Differencekey;		portName: self value! !!Association methodsFor: 'self evaluating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17441755!isSelfEvaluating	^ self class == Association and: [self Differencekey isSelfEvaluating and: [self value isSelfEvaluating]]! !!FileReference methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24954660!gtInspectorFuelIn: composite	<gtInspectorPresentationOrder: 40>	"(FileSystem disk workingDirectory / 'GTtest.fuel') writeStreamDo: [ :stream |	FLSerializer newDefault		at: #author putAdditionalObject: 'Author: Max Leske';		at: #date putAdditionalObject: DateAndTime now;		addPreMaterializationAction: [ Smalltalk inform: 'starting materialization' ];		addPostMaterializationAction: [ :materialization | materialization inspect ];		serialize: 'foo' on: stream binary ].	FLMaterializer materializeFromFileNamed: 'GTtest.fuel'"	composite table			title: 'Fuel Header';			display: [				(FLMaterializer materializeHeaderFromFileNamed: self fullName) gtGetMetaData ];			column: 'Property' evaluated: [:assoc| assoc Differencekey ];			column: 'Value' evaluated: [:assoc| assoc value];			when: [ self isFile and: [self extension = 'fuel' ] ]! !!Time methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64202834!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'hours' -> self hours.					'minutes' -> self minutes.					'seconds' -> self seconds.					'nanoseconds' -> self nanoSecond.					'meridian' -> self meridianAbbreviation.					'iso' -> self print24 } ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!OpalBytecodeEncoder methodsFor: 'temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53541637!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:str|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| str nextPut: { remoteLocal Differencekey. { index. innerIndex } }]]							ifFalse: [str nextPut: { local Differencekey. index }]]])].	^blockExtentsToTempsMap! !!KeyedTree methodsFor: 'copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30305530!postCopy	"Must copy the associations, or later store will affect both the		original and the copy.	Copy any subtrees too!!"	array := array collect: [:assoc |			assoc ifNil: [nil]				ifNotNil: [Association							key: assoc Differencekey							value: ((assoc value isKindOf: KeyedTree)									ifTrue: [assoc value copy]									ifFalse: [assoc value])]]! !!SymbolTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62962902!testReadFrom	self expectedBehavior do: [:association |		self assert: (association Differencekey value == association value)]! !!SymbolTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62946738!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!Integer methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 29563934!gtInspectorIntegerIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Integer';		display: [ | associations |			associations :=	{					'decimal' -> self printString.					'hex' -> self printStringHex.					'octal' -> (self printStringBase: 8).					'binary' -> (self printStringBase: 2)} asOrderedCollection.			(self between: 0 and: 16r10FFFF)				ifTrue: [ associations add: 'character' -> self asCharacter ].			associations ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: [ :each | each value printString ];		send: #value! !!Dictionary methodsFor: '*Slot' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22528373!declareVariable: newGlobal from: aDictionary 	"Add aGlobal to the receiver. If key already exists, do nothing. If aDictionary 	includes key, then remove it from aDictionary and use its association as 	the element of the receiver."	| globalName |	globalName :=  newGlobal Differencekey.	self associationAt: globalName ifPresent:  [:existingGlobal |		"need to take care to migrate existing variables to new global if class if different"		(existingGlobal class == newGlobal class) 			ifTrue: [^self].		newGlobal value: existingGlobal value.		self removeKey: globalName.		self add: newGlobal.		].	(aDictionary includesKey: globalName)		ifTrue:  [			self add: ((aDictionary associationAt: globalName) primitiveChangeClassTo: ClassVariable new).			aDictionary removeKey: globalName]		ifFalse: [			self add: newGlobal]! !!Dictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22532149!keysAndValuesDo: aBlock	^self associationsDo:[:assoc|		aBlock value: assoc Differencekey value: assoc value].! !!Dictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22541525!isHealthy	"Test that object hashes match their positions stored in set's array,	answer true if everything ok, false otherwise		Dictionary allInstances select: [:dict |		dict isHealthy not ]	Dictionary allSubInstances select: [:dict |		dict isHealthy not ]	"	array withIndexDo: [:elem :i |		elem ifNotNil: [			(self scanFor: elem Differencekey) == i ifFalse: [ ^ false ]			]	].	^ true! !!Dictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22529730!keyForIdentity: anObject	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"	self associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc Differencekey]].	^ nil! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22534428!noCheckAdd: anObject	"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association."	array at: (self findElementOrNil: anObject Differencekey) put: anObject.	tally := tally + 1! !!Dictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22545886!add: anAssociation	| index element |	index := self findElementOrNil: anAssociation Differencekey.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: anAssociation]		ifFalse: [element value: anAssociation value].	^ anAssociation! !!Dictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22525718!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc Differencekey ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !!Dictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22533281!includesAssociation: anAssociation  ^ (self         associationAt: anAssociation Differencekey      ifAbsent: [ ^ false ]) value = anAssociation value! !!Dictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22537336!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	Note: There can be multiple keys with the same value. Only one is returned." 	self associationsDo: 		[:association | value == association value ifTrue: [^association Differencekey]].	^exceptionBlock value! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22543524!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			array				at: (self scanForEmptySlotFor: association Differencekey)				put: association ] ]! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22535207!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element Differencekey = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element Differencekey = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22531606!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := array at: (index := index \\ array size + 1)) == nil ] whileFalse: [		| newIndex |		(newIndex := self findElementOrNil: element Differencekey) = index ifFalse: [			array swap: index with: newIndex ] ]! !!Dictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22525067!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | aBlock value: association Differencekey]! !!Dictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22530922!keysAndValuesRemove: keyValueBlock	"Removes all entries for which keyValueBlock returns true."	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."	| removals |	removals := OrderedCollection new.	self associationsDo:		[:assoc | (keyValueBlock value: assoc Differencekey value: assoc value)			ifTrue: [removals add: assoc Differencekey]]. 	removals do:		[:aKey | self removeKey: aKey]! !!Dictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22543941!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast." 	self associationsDo: 		[:association | value = association value ifTrue: [^association Differencekey]].	^exceptionBlock value! !!Dictionary methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22539413!gtInspectorItemsIn: composite	^ (composite fastTable)		title: 'Items';		display: [ self associations ];		"children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];"		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each Differencekey ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		selectionAct: [ :table |			table rawSelection do: [ :assoc | self removeKey: assoc Differencekey ].			table update ]			entitled: 'Remove item(s)';		selectionPopulate: #selection 			entitled: 'Open key'			with: [ :table | (table rawSelection collect: #Differencekey) gtInspectorInterestingObject ];		beMultiple;		send: [ :selection | 			selection isNil 			ifTrue:[nil]			ifFalse:[ (selection size = 1) 				ifTrue: [ selection anyOne value ] 				ifFalse: [ selection collect: #value ] ]]		"withSmalltalkSearch;		showOnly: 50;		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'"! !!Dictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22530513!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := self species new.	self associationsDo:[:each |		newCollection at: each Differencekey put: (aBlock value: each value).	].	^newCollection! !!Dictionary class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22549295!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x Differencekey)			ifTrue: [self error: 'Duplicate key: ', x Differencekey printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}	{1->#a. 2->#b. 3->#c} as: NewDictionary	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}	{1->#a. 2->#b. 1->#c} as: NewDictionary"! !!FontChooserMorph methodsFor: 'interface building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25438293!languages		^ self pangrams collect: #Differencekey! !!PluggableDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54577894!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element Differencekey = anObject]				ifNotNil: [equalBlock value: element Differencekey value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element Differencekey = anObject]				ifNotNil: [equalBlock value: element Differencekey value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableDictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54578994!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self equalBlock = aDictionary equalBlock ifFalse: [^false].	self hashBlock = aDictionary hashBlock ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc Differencekey ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !!LabelModel methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30855876!emphasisForCode: aCode	^ {(#bold -> 1).	(#italic -> 2).	(#underline -> 4).	(#narrow -> 8).	(#struck -> 16)}		collect: [ :pair | 			(aCode bitAnd: pair value) = 0				ifFalse: [ pair Differencekey ] ]		thenReject: #isNil! !!MorphTreePager methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51832326!choosePage	| choiceList chosen |	choiceList := OrderedCollection new.	self allIntervals 		doWithIndex: [:assoc :idx | | choiceString |			choiceString := idx asString, ': ', (self nodeList at: assoc Differencekey) asString, ' ... ', (self nodeList at: assoc value) asString.			choiceList add: idx -> choiceString].	chosen := 		UIManager default 			chooseFrom: (choiceList collect: [:c | c value])			values: (choiceList collect: [:c | c Differencekey])			lines: nil 			title: 'Choose a page'.	chosen ifNil: [^self].	self currentPage: chosen.! !!NautilusPluginManager methodsFor: 'lists behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52348068!selectedPluginClasses	| associations list |	list := self getPluginClassesList.	pluginClassesSelected ifNil: [ ^ {} ].	associations := pluginClassesSelected associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc Differencekey ].	associations := associations sort: [:a : b | (list indexOf: a ifAbsent: [ 0 ]) <= (list indexOf: b ifAbsent: [ 0 ])].	^ associations select: [:each | each notNil ]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51614078!sortedPropertyNames	"answer the receiver's property names in a sorted way"	| props |	props := (Array new: 10) writeStream.	locked == true ifTrue: [props nextPut: #locked].	visible == false ifTrue: [props nextPut: #visible].	sticky == true ifTrue: [props nextPut: #sticky].	balloonText ifNotNil: [props nextPut: #balloonText].	externalName ifNotNil: [props nextPut: #externalName].	eventHandler ifNotNil: [props nextPut: #eventHandler].	 otherProperties ifNotNil: [otherProperties associationsDo: [:a | props nextPut: a Differencekey]].	^props contents sort: [:s1 :s2 | s1 <= s2]! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22358442!codeAnyLitInd: association	^VariableNode new		name: association Differencekey		key: association		index: 0		type: LdLitIndType! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22359824!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol := selector Differencekey.	(node := BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node := self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: symbol precedence! !!GTEventTool methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27509629!gtInspectorActionHelp	<gtInspectorAction>	^ GLMGenericAction new		action: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner Differencekey = GTEventRecorderHelp Differencekey) and: [				each title = 'Data Analysis' ] ] ] ];		icon: GLMUIThemeExtraIcons glamorousHelp;		title: 'Help'! !!HeapTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28605595!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!GLMRubricSmalltalkTextModel methodsFor: 'bindings' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27046315!appendVariableBinding: anAssociationList	anAssociationList ifNotNil: [		anAssociationList do: [ :anAssociation | 			self variableBindings add: 				((anAssociation class = WorkspaceVariable) 					ifTrue: [ anAssociation ] 					ifFalse: [ (WorkspaceVariable key: anAssociation Differencekey value: anAssociation value) ]) ] ]! !!ZnUrlTests methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85733566!testReferenceResolution	"RFC 3986 Section 5"		| baseUri specification result succeeded failed |	baseUri := 'http://a/b/c/d;p?q' asZnUrl.	specification := {		"Examples 5.4.1 - Normal" 		" 'g:h' -> 'g:h'. " "we do not support unknown schemes without //"		'mailto:john@acme.com' -> 'mailto:john@acme.com'. "this we can do"		'g' -> 'http://a/b/c/g'.		'./g' -> 'http://a/b/c/g'.		'g/' -> 'http://a/b/c/g/'.		'/g' -> 'http://a/g'.		'//g' -> 'http://g/'.  "a trailing slash is added automatically"		'//a.com/assets/img.jpg' -> 'http://a.com/assets/img.jpg'.		'?y' -> 'http://a/b/c/d;p?y'.		'g?y' -> 'http://a/b/c/g?y'.		'#s' -> 'http://a/b/c/d;p?q#s'.		'g#s' -> 'http://a/b/c/g#s'.		'g?y#s' -> 'http://a/b/c/g?y#s'.		';x' -> 'http://a/b/c/;x'.		'g;x' -> 'http://a/b/c/g;x'.		'g;x?y#s' -> 'http://a/b/c/g;x?y#s'.		'' -> 'http://a/b/c/d;p?q'.		'.' -> 'http://a/b/c/'.		'./' -> 'http://a/b/c/'.		'..' -> 'http://a/b/'.		'../' -> 'http://a/b/'.		'../g' -> 'http://a/b/g'.		'../..' -> 'http://a/'.		'../../' -> 'http://a/'.		'../../g' -> 'http://a/g'.		"Examples 5.4.2 - Abnormal" 		'../../../g' -> 'http://a/g'.		'../../../../g' -> 'http://a/g'.		'/./g' -> 'http://a/g'.		'/../g' -> 'http://a/g'.		'g.' -> 'http://a/b/c/g.'.		'.g' -> 'http://a/b/c/.g'.		'g..' -> 'http://a/b/c/g..'.		'..g' -> 'http://a/b/c/..g'.		'./../g' -> 'http://a/b/g'.		'./g/.' -> 'http://a/b/c/g/'.		'g/./h' -> 'http://a/b/c/g/h'.		'g/../h' -> 'http://a/b/c/h'.		'g;x1/./y' -> 'http://a/b/c/g;x1/y'.		'g;x1/../y' -> 'http://a/b/c/y'.		'g?y/./x' -> 'http://a/b/c/g?y/./x'.		'g?y/../x' -> 'http://a/b/c/g?y/../x'.		'g#s/./x' -> 'http://a/b/c/g#s/./x'.		'g#s/../x' -> 'http://a/b/c/g#s/../x'.		'http://g' -> 'http://g/' "a trailing slash is added automatically"	}.	result := specification withIndexCollect: [ :spec :index | | resolved success |		resolved := baseUri withRelativeReference: spec Differencekey.		success := resolved asString = spec value.		{ #input -> spec Differencekey. #expected -> spec value. #index -> index.		#resolved -> resolved. #result -> success } asDictionary ].	succeeded := result select: [ :each | each at: #result ].	failed := result reject: [ :each | each at: #result ].	self assert: failed isEmpty! !!MethodNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51175144!selector 	"Answer the message selector for the method represented by the receiver."	(selectorOrFalse isSymbol)		ifTrue: [^selectorOrFalse].	^selectorOrFalse Differencekey.! !!MethodNode methodsFor: 'converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51180222!preenLocalIfNotNilArg	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where	 the block already declares the variable and the decompile case where it does not."	| varsToHide |	varsToHide := Set new.	self nodesDo:		[:node| | variable |		(node isMessageNode		and: [node macroPrinter == #printIfNilNotNil:indent:		and: [node receiver isMessageNode		and: [node receiver selector Differencekey == #==		and: [node receiver receiver isAssignmentNode		and: [(variable := node receiver receiver variable) isTemp		and: [variable isRemote not		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:			[node arguments last arguments isEmpty				ifTrue: [node arguments last arguments: { variable }.						varsToHide add: variable]				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].			 node receiver receiver: node receiver receiver value]].	varsToHide notEmpty ifTrue:		[self nodesDo:			[:node|			((node == self or: [node isBlockNode])			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !!MethodNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51177261!printOn: aStream	| selectorNode |	selectorNode := self selectorNode.	precedence = 1		ifTrue:			[selectorNode isForFFICall				ifTrue: [selectorNode							printAsFFICallWithArguments: arguments							on: aStream							indent: 0]				ifFalse: [aStream nextPutAll: selectorNode Differencekey]]		ifFalse:			[selectorNode Differencekey keywords with: arguments do:				[:kwd :arg |				aStream nextPutAll: kwd; space; nextPutAll: arg Differencekey; space]].	comment == nil ifFalse:		[aStream crtab: 1.		 self printCommentOn: aStream indent: 1].	block printTemporaries: temporaries on: aStream doPrior: [aStream crtab: 1].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printStatementsOn: aStream indent: 0! !!MethodFinder methodsFor: 'initialize' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51108741!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) ""Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf 	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet""accessing" byteAt: endsWithDigit #findAnySubstring:startingAt: #findBetweenSubstrings: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: #includesSubstring: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: #skipAnySubstring:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: endsWith: endsWithAnyOf: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padLeftTo: padRightTo: padLeftTo:with: padRightTo:with:"converting" asByteArray asDate asFileName asText asTime asUrl capitalized compressWithTable: contractTo: correctAgainst: initialIntegerOrNil keywords quoted withoutPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes truncateWithElipsisTo: trimBoth uncapitalized withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits trimRight trimLeft"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable withInternetLineEndings withSqueakLineEndings withoutQuoting urlEncoded UrlDecoded"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: translateToLowercase match:) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "testing" isInfix isKeyword isUnary) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo: upToAll: ) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" #Differencekey nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: distanceTo: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other"  indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter alphaMixed:with:"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses := #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls := Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 )  (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sort: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray].self initialize3."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!MethodFinder methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51127213!test2: anArray	"look for bad association"	anArray do: [:sub |		sub class == Association ifTrue: [			(#('true' '$a' '2' 'false') includes: sub value printString) ifFalse: [				self error: 'bad assn'].			(#('3' '5.6' 'x' '''abcd''') includes: sub Differencekey printString) ifFalse: [				self error: 'bad assn'].		].		sub class == Array ifTrue: [			sub do: [:element | 				element isString ifTrue: [element first asciiValue < 32 ifTrue: [						self error: 'store into string in data']].				element class == Association ifTrue: [					element value class == Association ifTrue: [						self error: 'bad assn']]]].		sub class == Date ifTrue: [sub year isInteger ifFalse: [				self error: 'stored into input date!!!!']].		sub class == Dictionary ifTrue: [				sub size > 0 ifTrue: [					self error: 'store into dictionary']].		sub class == OrderedCollection ifTrue: [				sub size > 4 ifTrue: [					self error: 'store into OC']].		].! !!LiteralVariable methodsFor: '*Reflectivity' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31194909!availableReifications	^RFReification subclasses 		select: [ :e | e entities includesAny: self class withAllSuperclasses ]		thenCollect: #Differencekey! !!LiteralVariable methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31201915!isSelfEvaluating	^ self Differencekey isSelfEvaluating and: [self value isSelfEvaluating]! !!ZnMultiValueDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85451074!add: anAssociation	self checkLimitForKey: anAssociation Differencekey.	^ super add: anAssociation! !!GTInspectorWrapperNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36014338!Differencekey	^ label ifNil: [ self hostObject Differencekey ]! !!GTInspectorWrapperNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27613441!key	^ label ifNil: [ self hostObject Differencekey ]! !!BehaviorTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18277981!testBinding	self assert: Object binding value = Object.	self assert: Object binding Differencekey = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding Differencekey isNil.! !!GTInspectorContextNamedTempNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27580944!label	^ '[' , self Differencekey , ']'! !!OCKeyedSet methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52914334!initialize: n 	super initialize: n. 	keyBlock := [:element | element Differencekey]. ! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64331766!registerDebugger: anObject withRank: anInteger	|debuggers|		debuggers  := tools at: #debuggers ifAbsent: [		tools at: #debuggers put: OrderedCollection new ]. 	(debuggers anySatisfy: [:each| each Differencekey == anObject] ) ifFalse: [ 		debuggers add: anObject -> anInteger ].	WorldState defaultWorldMenu! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64333075!debuggerDispatcherFor: aContext matching: aBlock	| debuggers |	debuggers := self debuggersWithRanksMatching: [ :aDebugger | 		(aBlock value: aDebugger) and: [ 			aDebugger handlesContext: aContext ] ].	(debuggers size > 0) ifTrue: [ ^ (debuggers at: 1) Differencekey ].	^ nil! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64330291!debuggersWithRanksMatching: aBlock	^ ((self registeredDebuggersWithRanks) 			select: [ :aPair | aBlock value: aPair Differencekey ])			sort: [ :pair1 :pair2 | pair1 value > pair2 value ].! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64326473!debuggersMatching: aBlock	^ (self debuggersWithRanksMatching: aBlock) 			inject: OrderedCollection new			into: [ :aCollection :aPair | aCollection add: aPair Differencekey; yourself ]! !!AbstractNautilusUI methodsFor: 'menus behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 16972573!copyClasses		| association |	self okToChange ifFalse: [^ self].	association := self copyClasses: (self selectedClasses collect: [:e | e theNonMetaClass ]).	association Differencekey		ifTrue: [			self selectedClass: association value.			self updateClassView]! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 34948375!makeSelectorsLegalIn: aDictionary	aDictionary associationsDo: [ :nameToValue |		| selector |		selector := nameToValue Differencekey asLowercase asSymbol.		nameToValue key: selector ]! !!TabGroupMorph methodsFor: 'page' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63365397!labelsAndPages: assocs	"Replace the tabs and the associated pages."	self contentMorph removeAllMorphs.	self tabSelectorMorph removeAllMorphs.	assocs do: [:a | self addPage: a value label: a Differencekey]! !!IRReconstructor methodsFor: 'remapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28868217!remapTemp: aTemp toRemote: aRemote	(temps removeKey: aTemp ifAbsent: [ #() ])		do: [ :tempAccess |			tempAccess name: aRemote.			self rememberReference: tempAccess to: aRemote in: temps ].			(remoteTemps removeKey: aTemp ifAbsent: [ #() ])		do: [ :tempAccess |			tempAccess tempVectorName: aRemote.			self rememberReference: tempAccess to: aRemote in: remoteTemps. ].	(closureCopiedValues removeKey: aTemp ifAbsent: [ #() ])		do: [ :aClosureAndIndex | |closure index|			closure := aClosureAndIndex Differencekey.			index := aClosureAndIndex value.			closure copiedValues at: index put: aRemote.			closure tempMap at: aRemote put: (closure tempMap removeKey: aTemp).			self rememberReference: aClosureAndIndex to: aRemote in: closureCopiedValues. ].! !!RubTextEditor methodsFor: 'keymapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58384232!defaultCommandKeymapping	| cmdMap |			cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	{(Character home -> #cursorHome:).	(Character end -> #cursorEnd:).	(Character backspace -> #backspace:).	(Character pageUp -> #cursorPageUp:).	(Character newPage -> #cursorPageDown:).	(Character cr -> #crWithIndent:).	(Character escape -> #escape:).	(Character arrowLeft -> #cursorLeft:).	(Character arrowRight -> #cursorRight:).	(Character arrowUp -> #cursorUp:).	(Character arrowDown -> #cursorDown:).	(Character space -> #selectWord:).	(Character delete -> #forwardDelete:) } do: [ :assoc | 		cmdMap at: assoc Differencekey asciiValue + 1 put: assoc value ].	'([{''"<' do: [ :char | cmdMap at: char asciiValue + 1 put: #enclose: ].	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.	'0123456789-=' do: [ :char | cmdMap at: char asciiValue + 1 put: #changeEmphasis: ].	^ cmdMap! !!RubTextEditor methodsFor: 'keymapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58367229!defaultShiftCommandKeymapping	"Initialize the shift-command-key (or control-key) shortcut table."	| cmdMap |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	{(Character home -> #cursorHome:).	(Character end -> #cursorEnd:).	(Character backspace -> #forwardDelete:).	(Character pageUp -> #cursorPageUp:).	(Character newPage -> #cursorPageDown:).	(Character cr -> #crWithIndent:).	(Character escape -> #offerMenuFromEsc:).	(Character arrowLeft -> #cursorLeft:).	(Character arrowRight -> #cursorRight:).	(Character arrowUp -> #cursorUp:).	(Character arrowDown -> #cursorDown:).	(Character space -> #selectWord:).	(Character delete -> #forwardDelete:)}		do: [ :assoc | 			| char symbol |			char := assoc Differencekey.			symbol := assoc value.			cmdMap at: char asciiValue + 1 put: symbol	"plain keys" ].	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	'9[,''' do: [ :char | cmdMap at: char asciiValue + 1 put: #shiftEnclose: ].	^ cmdMap! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50523392!execute: statements  statements    do: [ :assoc |       assoc value        ifNil: [ self perform: assoc Differencekey ]        ifNotNil: [ self perform: assoc Differencekey withArguments: assoc value ] ].  projectSpecGenerator := self projectSpecGenerator.  projectSpecGenerator target    execute: [ :projectSpec |       | engine |      engine := MetacelloScriptEngine new        options: self options copy;        projectSpec: projectSpec;        yourself.      engine perform: actionArg Differencekey withArguments: actionArg value.      engine root ifNotNil: [ :root | self roots add: root ] ]    against: self.  ^ (self singleRoot and: [ self roots size == 1 ])    ifTrue: [ self roots first ]    ifFalse: [ self roots ]! !!MethodDictionary methodsFor: '*FuelTests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51064888!isEqualRegardlessMethodsTrailerTo: aMethodDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value"	self == aMethodDictionary ifTrue: [ ^ true ].	(aMethodDictionary isDictionary) ifFalse: [^false].	self size = aMethodDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		((aMethodDictionary at: assoc Differencekey ifAbsent: [^false]) isEqualRegardlessTrailerTo:  assoc value)			ifFalse: [^false]].	^true! !!MethodDictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51066984!add: anAssociation	^ self at: anAssociation Differencekey put: anAssociation value! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63803457!testIfSequence6	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d a b c).	self assert: patch size = 5.	"lcs is abc"	self assert: (patch count: [ :each | each Differencekey = #match ]) = 3.	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 1.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 1.	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: ('abc' includes: each value first) ]			ifFalse: [ self assert: each value first = $d ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63802419!testSameSequenceWithRepetitions	| patch |	patch := self patchSequenceFor: #(a a b a) and: #(a a b a).	self assert: patch size = 4.		self assert: (patch allSatisfy: [ :each | each Differencekey = #match ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63805256!testEmptyLcs3	| patch |	patch := self patchSequenceFor: #(a b c) and: #(d e f g).	self assert: patch size = 7.		patch do: [ :each |		each Differencekey = #remove ifTrue: [ self assert: ('abc' includes: each value first) ].		each Differencekey = #insert ifTrue: [ self assert: ('defg' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63806453!testIfSequence3	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(b d c a).	self assert: patch size = 6.	"lcs is bd"	self assert: (patch count: [ :each | each Differencekey = #match ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 2.	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: ('bd' includes: each value first) ]			ifFalse: [ self assert: ('ac' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63802694!testIfSequence5	| patch matches nonMatches |	patch := self patchSequenceFor: #(a b c d) and: #(c d a b).	self assert: patch size = 6.	"lcs is ab or cd"	matches := (patch select: [ :each | each Differencekey = #match ])		collect: [ :each | each value first ] as: String.	self assert: (#('ab' 'cd') includes: matches).	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 2.	nonMatches := #('ab' 'cd') detect: [ :each | each ~= matches ].	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: (matches includes: each value first) ]			ifFalse: [ self assert: (nonMatches includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63801638!testIfSequence2	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(c d b a).	self assert: patch size = 6.	"lcs is cd"	self assert: (patch count: [ :each | each Differencekey = #match ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 2.	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: ('cd' includes: each value first) ]			ifFalse: [ self assert: ('ab' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63806204!testEmptyLcs2	| patch |	patch := self patchSequenceFor: #() and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each Differencekey = #insert ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63804750!testSameSequence	| patch |	patch := self patchSequenceFor: #(a b c) and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each Differencekey = #match ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63801058!testIfSequence1	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d c b a).	self assert: patch size = 7.	"lcs is any one letter sequence"	self assert: (patch count: [ :each | each Differencekey = #match ]) = 1.	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 3.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 3.	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: each value first = $d ]			ifFalse: [ self assert: ('abc' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63805006!testEmptyLcs1	| patch |	patch := self patchSequenceFor: #(a b c) and: #().	self assert: patch size = 3.	self assert: (patch allSatisfy: [ :each | each Differencekey = #remove ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63805634!testIfSequence4	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d b c a).	self assert: patch size = 6.	"lcs is bc"	self assert: (patch count: [ :each | each Differencekey = #match ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 2.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 2.	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: ('bc' includes: each value first) ]			ifFalse: [ self assert: ('ad' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63804017!testIfPatchIsMinimal	| patch |	patch := self patchSequenceFor: #(a a a b) and: #(a b a a).	self assert: patch size = 5.	"lcs is aaa"	self assert: (patch count: [ :each | each Differencekey = #match ]) = 3.	self assert: (patch count: [ :each | each Differencekey = #insert ]) = 1.	self assert: (patch count: [ :each | each Differencekey = #remove ]) = 1.	patch do: [ :each | 		each Differencekey = #match 			ifTrue: [ self assert: each value first = $a ]			ifFalse: [ self assert: each value first = $b ] ]! !!TraitCompositionTest methodsFor: 'testing-enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64529270!testClassMethodsTakePrecedenceOverTraitsMethods	| keys |	keys := Set new.	self t4 methodDict bindingsDo: [:each | keys add: each Differencekey].	self assert: keys size = 6.	self 		assert: (keys includesAllOf: #(						#m12						#m13						#m13						#m21						#m22						#m11						#m42					)).	self assert: (self t4 methodDict at: #m11) sourceCode = 'm11 ^41'! !!ThemeIcons methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64118546!gtInspectorIconsIn: composite	<gtInspectorPresentationOrder: 40>	composite list 		title: 'Icons';		display: [ icons associations sorted: [ :a :b | a Differencekey < b Differencekey ] ];		icon: [ :each | each value ];		format: [ :each | each Differencekey ]! !!ChangeSet methodsFor: 'filein/out' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18961451!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | method | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method := aClass compiledMethodAt: mAssoc Differencekey ifAbsent: [nil].					method ifNotNil:						[(self hasReportableSlip: method)							ifTrue: [ slips add: (aClass >> mAssoc Differencekey) methodReference ]]]]].	^ slips! !!ChangeSet methodsFor: 'moving changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18953201!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass includesSelector:  mAssoc Differencekey) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc Differencekey) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc Differencekey]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!ChangeSet methodsFor: 'filein/out' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18957476!fileOutChangesFor: class on: stream	"Write out all the method changes for this class."	| changes |	changes := Set new.	(self methodChangesAtClass: class name)		associationsDo: [ :mAssoc | 			(mAssoc value = #remove or: [ mAssoc value = #addedThenRemoved ])				ifFalse: [ changes add: mAssoc Differencekey ] ].	changes isEmpty		ifTrue: [ ^ self ].	class fileOutChangedMessages: changes on: stream.	stream cr! !!ChangeSet methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18947957!methodChanges	| methodChangeDict |	methodChangeDict := Dictionary new.	changeRecords associationsDo:		[:assn | | changeTypes |		changeTypes := assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn Differencekey put: changeTypes]].	^ methodChangeDict! !!ChangeSet methodsFor: 'method changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18964143!changedMessageList	"Used by a message set browser to access the list view information."	| messageList |	messageList := OrderedCollection new.	changeRecords associationsDo: [:clAssoc | | className classIsMeta |		className := clAssoc Differencekey asSymbol.		classIsMeta := (className findTokens: ' ') size > 1.		(clAssoc value allChangeTypes includes: #comment) ifTrue:			[messageList add:				(RGCommentDefinition new					parentName: className) asActive ].		clAssoc value methodChangeTypes associationsDo: [:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add:					((RGMethodDefinition named: mAssoc Differencekey)						parentName: className;						isMetaSide: classIsMeta) asActive ]]].	^ messageList asArray sort! !!ChangeSet methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18968082!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified |	notClassified := {'as yet unclassified' asSymbol. #all}.	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | aSelector | (aClass includesSelector:  (aSelector := mAssoc Differencekey)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'filein/out' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18950532!hasReportableSlip: aMethod	"Answer whether the receiver contains anything that should be brought 	to the attention of the author when filing out. Customize the lists here 	to suit your preferences. If slips do not get reported in spite of your 	best efforts here, make certain that the Preference 'checkForSlips' is set 	to true."	aMethod containsHalt ifTrue: [ ^true ].	#(#flag:) do: [ :aLit | (aMethod hasLiteral: aLit) ifTrue: [ ^ true ] ].	((aMethod literals 		select: #isVariableBinding		thenCollect: #Differencekey) includes: #Transcript) ifTrue: [ ^true ].	^ false! !!WeakIdentityKeyDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84428676!testFinalizeValuesWhenLastChainContinuesAtFront	| objectWithHashModulo dictionary capacity a b c |		objectWithHashModulo := [ :requestedHash :modulo | | object |        [		object := Object new.			object hash \\ modulo = requestedHash ] whileFalse.        object ].				dictionary := self classToBeTested new.		capacity := dictionary capacity.		a := objectWithHashModulo value: capacity - 2 value: capacity.		dictionary at: a put: 1.		b := objectWithHashModulo value: capacity - 1 value: capacity.		dictionary at: b put: 2.		c := objectWithHashModulo value: capacity - 2 value: capacity.		dictionary at: c put: 3.		self assert: dictionary capacity = capacity.		self assert: (dictionary array at: capacity - 1) Differencekey == a.		self assert: (dictionary array at: capacity) Differencekey == b.		self assert: (dictionary array at: 1) Differencekey == c.		a := nil.		Smalltalk garbageCollect.		dictionary finalizeValues.		self assert: (dictionary includesKey: b).		self assert: (dictionary includesKey: c).		self assert: dictionary slowSize = 2.! !!AssemblyManifest class methodsFor: '*Tool-DependencyAnalyser-UI' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17432765!includes: aPackageName	^ (self parts collect: #Differencekey) 		includes: aPackageName! !!StringTest methodsFor: 'testing - formatting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62763474!testFormatExtended	self		assert: ('This is {foo} !!' format: (Dictionary with: #foo->'a test'))		equals: 'This is a test !!'. 	{  		[ '\{ \} \\ foo {foo} bar {bar}' format: { #foo->12. #bar->'string' } asDictionary ] -> '{ } \ foo 12 bar string'.  		[ '\{ \} \\ foo {bar} bar {foo}' format: { 'bar'->12. 'foo'->'string' } asDictionary ] -> '{ } \ foo 12 bar string'.  		[ '\{x}' format: {} ] -> '{x}'.  		[ '\{x}{x}' format: { #x->$a } asDictionary ] -> '{x}a'.  	} do: [ :each | 		self assert: each Differencekey value equals: each value ]! !!StringTest methodsFor: 'testing - internet' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62774827!testWithSqueakLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String cr).		'abc', String lf -> ('abc', String cr).		'abc', String crlf -> ('abc', String cr).		String cr, 'abc' -> (String cr, 'abc').		String lf, 'abc' -> (String cr, 'abc').		String crlf, 'abc' -> (String cr, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String cr, String cr, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String cr, 'abc', String cr, String cr, 'abc', String cr).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String cr, 'abc', String cr, String cr, 'abc', String cr).	} do: [ :each |		self assert: each Differencekey withSqueakLineEndings = each value ]! !!StringTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62643096!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!StringTest methodsFor: 'testing - internet' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62726723!testWithInternetLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String crlf).		'abc', String lf -> ('abc', String crlf).		'abc', String crlf -> ('abc', String crlf).		String cr, 'abc' -> (String crlf, 'abc').		String lf, 'abc' -> (String crlf, 'abc').		String crlf, 'abc' -> (String crlf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).	} do: [ :each |		self assert: each Differencekey withInternetLineEndings = each value ]! !!StringTest methodsFor: 'testing - internet' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62670295!testWithUnixLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String lf).		'abc', String lf -> ('abc', String lf).		'abc', String crlf -> ('abc', String lf).		String cr, 'abc' -> (String lf, 'abc').		String lf, 'abc' -> (String lf, 'abc').		String crlf, 'abc' -> (String lf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String lf, String lf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String lf, 'abc', String lf, String lf, 'abc', String lf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String lf, 'abc', String lf, String lf, 'abc', String lf).	} do: [ :each |		self assert: each Differencekey withUnixLineEndings = each value ]! !!StringTest methodsFor: 'testing - formatting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62756002!testFormat	self		assert: ('This is {1} !!' format: #('a test'))		equals: 'This is a test !!'. 	{  		[ '\{ \} \\ foo {1} bar {2}' format: { 12. 'string' } ] -> '{ } \ foo 12 bar string'.  		[ '\{ \} \\ foo {2} bar {1}' format: { 'string'. 12 } ] -> '{ } \ foo 12 bar string'.  		[ '\{1}' format: {} ] -> '{1}'.  		[ '\{1}{1}' format: { $a } ] -> '{1}a'.  	} do: [ :each | 		self assert: each Differencekey value equals: each value ]! !!StringTest methodsFor: 'testing - converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62689630!testSubstrings	| allByteCharacters substring separators |	allByteCharacters := Character allByteCharacters asString.	substring := allByteCharacters select: [:each | each isLetter].	separators := allByteCharacters reject: [:each | each isLetter].	{'' -> {}.		separators -> {}.		substring -> {substring}.		(substring, separators) -> {substring}.		(separators, substring) -> {substring}.		(separators, substring, separators) -> {substring}.		(substring, separators, substring) -> {substring. substring}.		(substring, separators, substring, separators) -> {substring. substring}.		(separators, substring, separators, substring) -> {substring. substring}}		do: [:each | self assert: (each Differencekey substrings: separators) = each value].	"test the unary version"	substring := allByteCharacters reject: [:each | each isSeparator].	separators := allByteCharacters select: [:each | each isSeparator].	{'' -> {}.		separators -> {}.		substring -> {substring}.		(substring, separators) -> {substring}.		(separators, substring) -> {substring}.		(separators, substring, separators) -> {substring}.		(substring, separators, substring) -> {substring. substring}.		(substring, separators, substring, separators) -> {substring. substring}.		(separators, substring, separators, substring) -> {substring. substring}}		do: [:each | self assert: each Differencekey substrings = each value].! !!MCStWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32042574!writeDefinitions: aCollection		"the correct initialization order is unknown if some classes are missing in the image"		| presentInitializers notPresentInitializers orderedClasses |		initializers := Set new.	(MCDependencySorter sortItems: aCollection)		do: [:ea | ea accept: self]		displayingProgress: 'Writing definitions...'.			presentInitializers := initializers select: [:each | Smalltalk hasClassNamed: each Differencekey ].	notPresentInitializers := initializers reject: [:each | Smalltalk hasClassNamed: each Differencekey ].		orderedClasses := (Class superclassOrder: (presentInitializers collect: [:each | Smalltalk classOrTraitNamed: each Differencekey]))		collect: [:each | each name ].					orderedClasses do: [:className |		self chunkContents: [ :str | str nextPutAll: (presentInitializers detect: [:each | each Differencekey = className]) value contents] ].		(notPresentInitializers asSortedCollection: [:a :b | a Differencekey <= b Differencekey]) do: [:association |		self chunkContents: [ :str | str  nextPutAll: association value contents ] ].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53894855!testAssociationAtIfPresent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				associationAt: each Differencekey				ifPresent: [self fail]) isNil.		dictionary add: each.		self assert:			(dictionary				associationAt: each Differencekey				ifPresent: [:assoc | self newValue -> assoc]) = (self newValue -> each).		"ensure cull: is used"		self assert:			(dictionary				associationAt: each Differencekey				ifPresent: [self newValue]) = self newValue].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53906373!testKeyForIdentity	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert: (dictionary keyForIdentity: each value) isNil.		dictionary add: each.		self			assert: (dictionary keyForIdentity: each value) = each Differencekey;			assert: (dictionary keyForIdentity: each value copy) isNil].! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53911749!changedOrderedAssociations	^ self orderedAssociations collect: [:each | each Differencekey -> self newValue]! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53909122!testCollect	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self		assertIsDictionary:			(dictionary collect: [:each | each hash])		copiedFrom: dictionary		withOrderedAssociations:			(self orderedAssociations collect: [:each | each Differencekey -> each value hash]).! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53897594!testKeyAtIndex	| dictionary |	dictionary := self emptyDictionary.	self		should: [dictionary keyAtIndex: 0]		raise: Error.	self orderedAssociations withIndexDo: [:each :i |		self			should: [dictionary keyAtIndex: i]			raise: Error.		dictionary add: each.		self assert: (dictionary keyAtIndex: i) = each Differencekey].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53879661!testIndexOfKeyIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				indexOfKey: each Differencekey				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				indexOfKey: each Differencekey				ifAbsent: [self fail]) = i].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53914786!testAtPut	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				at: each Differencekey				put: each value) = each value.		self			assertIsDictionary: dictionary			withOrderedAssociations: (self orderedAssociationsFirst: i)].	self changedOrderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				at: each Differencekey				put: each value) = each value.		self			assertIsDictionary: dictionary			withOrderedAssociations:				(self changedOrderedAssociationsFirst: i),				(self orderedAssociationsAllButFirst: i)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53885934!testRemoveKeyIfAbsent	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				removeKey: each Differencekey				ifAbsent: [self fail]) = each value.		self			assertKey: each Differencekey			wasRemovedfrom: dictionary.		self			assertIsDictionary: dictionary			withOrderedAssociations: (self orderedAssociationsAllButFirst: i).		self assert:			(dictionary				removeKey: each Differencekey				ifAbsent: [self absentValue]) = self absentValue]! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53879287!testAtIfAbsentPut	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each Differencekey				ifAbsentPut: [each value]) = each value.		self assert:			(dictionary				at: each Differencekey				ifAbsentPut: [self fail]) = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53883950!testDictionaryPublicProtocolCompatibility	| dictionary |	dictionary := self emptyDictionary.	{dictionary -> Dictionary.	dictionary class -> Dictionary class}		do: [:assoc | 			assoc value protocols				reject: [:protocol | 					#('private' 'print' 'copy' 'compar' '*')						anySatisfy: [:each | protocol asString beginsWith: each]]				thenDo: [:protocol | 					(assoc value selectorsInProtocol: protocol)						do: [:each | self assert: (assoc Differencekey respondsTo: each)]]].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53888364!testAssociationAtIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				associationAt: each Differencekey				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				associationAt: each Differencekey				ifAbsent: [self fail]) = each].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53887962!testAtIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each Differencekey				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				at: each Differencekey				ifAbsent: [self fail]) = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53889176!testAtIfPresentIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each Differencekey				ifPresent: [self fail]				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				at: each Differencekey				ifPresent: [:value | self newValue -> value]				ifAbsent: [self fail]) = (self newValue -> each value).		"ensure cull: is used"		self assert:			(dictionary				at: each Differencekey				ifPresent: [self newValue]				ifAbsent: [self fail]) = self newValue].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53903501!testAssociationAt	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary associationAt: each Differencekey]			raise: Error.		dictionary add: each.		self assert: (dictionary associationAt: each Differencekey) = each].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53908444!testAtIfPresent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each Differencekey				ifPresent: [self fail]) isNil.		dictionary add: each.		self assert:			(dictionary				at: each Differencekey				ifPresent: [:value | self newValue -> value]) =					(self newValue -> each value).		"ensure cull: is used"		self assert:			(dictionary				at: each Differencekey				ifPresent: [self newValue]) = self newValue].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53910926!testKeyAtValue	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary keyAtValue: each value]			raise: Error.		dictionary add: each.		self assert: (dictionary keyAtValue: each value) = each Differencekey].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53918021!testKeyAtIndexIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self assert:		(dictionary			keyAtIndex: 0			ifAbsent: [self absentKey]) = self absentKey.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				keyAtIndex: i				ifAbsent: [self absentKey]) = self absentKey.		dictionary add: each.		self assert:			(dictionary				keyAtIndex: i				ifAbsent: [self fail]) = each Differencekey].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53904459!testIdentityIndexOfKey	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert: (dictionary identityIndexOfKey: each Differencekey) = 0.		dictionary add: each.		self			assert: (dictionary identityIndexOfKey: each Differencekey) = i;			assert: (dictionary identityIndexOfKey: each Differencekey copy) = 0].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53902982!testRemoveKey	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self orderedAssociations withIndexDo: [:each :i |		self assert: (dictionary removeKey: each Differencekey) = each value.		self			assertKey: each Differencekey			wasRemovedfrom: dictionary.		self			assertIsDictionary: dictionary			withOrderedAssociations: (self orderedAssociationsAllButFirst: i).		self			should: [dictionary removeKey: each Differencekey]			raise: Error]! !!OrderedDictionaryTest methodsFor: 'assertions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53901713!assertIsDictionary: anObject withOrderedAssociations: anAssociationCollection	"tests that anObject is an instance of the correct dictionary class	with the specified ordered associations"	self		assert: anObject class == self dictionaryClass;		assert: anObject orderedKeys size >= anAssociationCollection size;		assert: anObject associations size = anAssociationCollection size.	anAssociationCollection withIndexDo: [:each :i |		self isTestingIdentityDictionary			ifTrue: [				self					assert: (anObject orderedKeys at: i) == each Differencekey;					assert: (anObject associations at: i) Differencekey == each Differencekey]			ifFalse: [				self					assert: (anObject orderedKeys at: i) = each Differencekey;					assert: (anObject associations at: i) Differencekey = each Differencekey].		self assert: (anObject associations at: i) value = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53881448!testIndexOfKey	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert: (dictionary indexOfKey: each Differencekey) = 0.		dictionary add: each.		self assert: (dictionary indexOfKey: each Differencekey) = i].! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53906040!orderedKeys	^ self orderedAssociations collect: [:each | each Differencekey]! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53911273!testIncludesAssociation	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			deny: (dictionary includesAssociation: each);			deny: (dictionary includesAssociation: each Differencekey -> each value).		dictionary add: each.		self			assert: (dictionary includesAssociation: each);			assert: (dictionary includesAssociation: each Differencekey -> each value)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53887100!testKeyAtValueIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				keyAtValue: each value				ifAbsent: [self absentKey]) = self absentKey.		dictionary add: each.		self assert:			(dictionary				keyAtValue: each value				ifAbsent: [self fail]) = each Differencekey].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53892987!testKeyAtIdentityValueIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				keyAtIdentityValue: each value				ifAbsent: [self absentKey]) = self absentKey.		dictionary add: each.		self assert:			(dictionary				keyAtIdentityValue: each value				ifAbsent: [self fail]) = each Differencekey.		self assert:			(dictionary				keyAtIdentityValue: each value copy				ifAbsent: [self absentKey]) = self absentKey].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53891599!testAt	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary at: each Differencekey]			raise: Error.		dictionary add: each.		self assert: (dictionary at: each Differencekey) = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53916777!testKeysAndValuesRemove	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self orderedAssociations withIndexDo: [:removedAssociation :i |		| unremovedAssociations |		unremovedAssociations :=			(self orderedAssociationsAllButFirst: i) asOrderedCollection.		dictionary keysAndValuesRemove: [:key :value |			(self isTestingIdentityDictionary				ifTrue: [key == removedAssociation Differencekey]				ifFalse: [key = removedAssociation Differencekey])				ifTrue: [					self assert: value = removedAssociation value.					true]				ifFalse: [| unremovedAssociation |					unremovedAssociation := unremovedAssociations removeFirst.					self isTestingIdentityDictionary						ifTrue: [self assert: key == unremovedAssociation Differencekey]						ifFalse: [self assert: key = unremovedAssociation Differencekey].					self assert: value = unremovedAssociation value.					false]].		self assert: unremovedAssociations isEmpty.		self			assertKey: removedAssociation Differencekey			wasRemovedfrom: dictionary].	self assert: dictionary isEmpty.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53889829!testKeyAtIdentityValue	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary keyAtIdentityValue: each value]			raise: Error.		dictionary add: each.		self assert: (dictionary keyAtIdentityValue: each value) = each Differencekey.		self			should: [dictionary keyAtIdentityValue: each value copy]			raise: Error].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53893555!testNewFromPairs	| pairs |	pairs := OrderedCollection new.	self orderedAssociations do: [:each |		pairs			addLast: each Differencekey;			addLast: each value].	0 to: pairs size do: [:i |		self			assertIsDictionary:				(self dictionaryClass newFromPairs: (pairs copyFrom: 1 to: i))			withOrderedAssociations:				(self orderedAssociationsFirst: (i / 2) floor)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53882584!testIncludesKey	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self deny: (dictionary includesKey: each Differencekey).		dictionary add: each.		self assert: (dictionary includesKey: each Differencekey)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53883376!testIdentityIndexOfKeyIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				identityIndexOfKey: each Differencekey				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				identityIndexOfKey: each Differencekey				ifAbsent: [self fail]) = i.		self assert:			(dictionary				identityIndexOfKey: each Differencekey copy				ifAbsent: [self absentValue]) = self absentValue].! !!AlienSunit methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17177930!willCrashTheVMtestLibCExamples	| sortedData unsorted sorted |		sortedData := Alien exampleCqsort.	unsorted := sortedData Differencekey copy.	sorted := unsorted asSortedCollection.	self should: [sortedData value = sorted asArray].	Alien examplePrintf.! !!OrderedDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53866065!collect: aBlock	^ self species newFrom:		(self associations collect: [:each |			each Differencekey -> (aBlock value: each value)])! !!OrderedDictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53863341!= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each Differencekey ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.! !!OrderedDictionary methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53875206!printElementsOn: aStream	aStream nextPut: $(.	self size > 100		ifTrue: [			aStream nextPutAll: 'size '.			self size printOn: aStream]		ifFalse: [			self associations withIndexDo: [:each :i |				aStream					print: each Differencekey;					nextPutAll: '->';					print: each value.				(i < self size)					ifTrue: [aStream space]]].	aStream nextPut: $).! !!OrderedDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53875973!add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation Differencekey].	^ anAssociation.! !!OrderedDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53866267!keysAndValuesRemove: aTwoArgumentBlock	| removedAssociations |	removedAssociations := OrderedCollection new.	self associationsDo: [:each |		(aTwoArgumentBlock value: each Differencekey value: each value)			ifTrue: [removedAssociations add: each]].	removedAssociations do: [:each | self removeKey: each Differencekey].! !!OrderedDictionary methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53871498!gtInspectorItemsIn: composite	^ (composite fastTable)		title: 'Items';		display: [ self associations ];		"children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];"		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each Differencekey ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		selectionAct: [ :table |			table rawSelection do: [ :assoc | self removeKey: assoc Differencekey ].			table update ]			entitled: 'Remove item(s)';		selectionPopulate: #selection 			entitled: 'Open key'			with: [ :table | (table rawSelection collect: #Differencekey) gtInspectorInterestingObject ];		beMultiple;		send: [ :selection | 				selection isNil 				ifTrue: [ nil ]				ifFalse: [ selection size = 1  					ifTrue: [ selection anyOne value ] 					ifFalse: [ selection collect: #value ] ]]		"withSmalltalkSearch;		showOnly: 50;		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'"! !!OrderedDictionary class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53877643!newFrom: anAssociationCollection	| newDictionary |	newDictionary := self new: anAssociationCollection size.	anAssociationCollection associationsDo: [:each |		newDictionary			at: each Differencekey			put: each value].	^ newDictionary.! !!RBBasicLintRuleTest class methodsFor: 'unnecessary code' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 55516910!unreferencedVariables	| detector |	detector := self new.	detector name: 'Variables not referenced'.	detector result: nil unreferenced.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addInstVar: each for: context selectedClass]].			context selectedClass isMetaclass ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(SystemNavigation default allCallsOn: each) ifEmpty:  [result addClassVar: each Differencekey for: context selectedClass]]]].	^detector! !!NavigationHistory methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52493149!basicAdd: anEntry		( storage isEmpty not and: [ storage last = anEntry ] ) ifTrue: [ ^ self ].	anEntry = self current Differencekey ifTrue: [ ^ self ].	self checkSize.	index := index +1.	index > storage size		ifTrue: [ storage addLast:  (anEntry -> DateAndTime now)]		ifFalse: [ 			storage := storage copyFrom: 1 to: index.			storage at: index put: (anEntry -> DateAndTime now)]! !!NavigationHistory methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52494347!removeEntry: anEntry	| toRemove |		"we know that toRemove will always contains one element"	toRemove := (storage select: [:e | e Differencekey == anEntry ]).	toRemove ifEmpty: [ ^ self ].	toRemove := toRemove first.	storage remove: toRemove.	storage addLast: toRemove! !!Decompiler methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22340993!popIntoTemporaryVariable: offset	| maybeTVTag tempVector start |	maybeTVTag := stack last.	((maybeTVTag isMemberOf: Association)	 and: [maybeTVTag Differencekey == #pushNewArray]) ifTrue:		[blockStartsToTempVars notNil "implies we were intialized with temp names."			ifTrue: "Use the provided temps"				[[(tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp							 and: [tempVector isIndirectTempVector							 and: [tempVector remoteTemps size = maybeTVTag value size]]] assert]			ifFalse: "Synthesize some remote temps"				[tempVector := maybeTVTag value.				 offset + 1 <= tempVars size					ifTrue:						[start := 2.						 tempVector at: 1 put: (tempVars at: offset + 1)]					ifFalse:						[tempVars := (Array new: offset + 1)										replaceFrom: 1										to: tempVars size										with: tempVars.						start := 1].				 start to: tempVector size do:					[:i|					tempVector						at: i						put: (constructor								codeTemp: numLocalTemps + offset + i - 1								named: 't', (tempVarCount + i) printString)].				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].		 tempVarCount := tempVarCount + maybeTVTag value size.		 stack removeLast.		 ^self].	self pushTemporaryVariable: offset; doStore: statements! !!Decompiler methodsFor: 'control' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22349332!checkForClosureCopy: receiver arguments: arguments	"We just saw a closureCopy:copiedValues: message. Check for and construct a following block."	| savePc jump |	receiver == constructor codeThisContext ifFalse: [^false].	savePc := pc.	(jump := self interpretJump) notNil ifFalse:		[pc := savePc.		 ^nil].	"Definitely a block"	self doClosureCopyCopiedValues: arguments last "<BraceNode>" elements		numArgs: arguments first Differencekey		blockSize: jump.	^true! !!FBDASTBuilder methodsFor: 'constructor' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23828001!codeAnyLitInd: anAssociation 	^ (RBVariableNode named: anAssociation Differencekey)		binding: anAssociation;		yourself! !!DiffMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22666263!calculatedJoinMappings	"Calculate the join parameters between src and dst and answer"	| sourceLine destinationLine joins destinationRunStart sourceRunStart destinationRunEnd sourceRunEnd matchDestinationStart matchSourceStart |	sourceLine := destinationLine := 0.	joins := OrderedCollection new.	destinationRunStart := destinationRunEnd := sourceRunStart := sourceRunEnd := matchSourceStart := matchDestinationStart := 0.	self difference		do: [ :p | 			p Differencekey = #match				ifTrue: [ 					sourceLine := sourceLine + 1.					destinationLine := destinationLine + 1.					matchSourceStart = 0						ifTrue: [ 							matchSourceStart := sourceLine.							matchDestinationStart := destinationLine ].					(destinationRunStart > 0 or: [ sourceRunStart > 0 ])						ifTrue: [ 							sourceRunStart = 0								ifTrue: [ sourceRunStart := sourceLine ].							destinationRunStart = 0								ifTrue: [ destinationRunStart := destinationLine ].							sourceRunEnd = 0								ifTrue: [ sourceRunEnd := sourceRunStart - 1 ].							destinationRunEnd = 0								ifTrue: [ destinationRunEnd := destinationRunStart - 1 ].							joins								add:									(self newJoinSectionFrom: (sourceRunStart to: sourceRunEnd) to: (destinationRunStart to: destinationRunEnd)).							destinationRunStart := destinationRunEnd := sourceRunStart := sourceRunEnd := 0 ] ].			p Differencekey = #remove				ifTrue: [ 					matchSourceStart > 0						ifTrue: [ 							joins								add:									(self newMatchJoinSectionFrom: (matchSourceStart to: sourceLine) to: (matchDestinationStart to: destinationLine)).							matchSourceStart := matchDestinationStart := 0 ].					sourceLine := sourceLine + 1.					sourceRunStart = 0						ifTrue: [ sourceRunStart := sourceLine ].					sourceRunEnd := sourceLine ].			p Differencekey = #insert				ifTrue: [ 					matchSourceStart > 0						ifTrue: [ 							joins								add:									(self newMatchJoinSectionFrom: (matchSourceStart to: sourceLine) to: (matchDestinationStart to: destinationLine)).							matchSourceStart := matchDestinationStart := 0 ].					destinationLine := destinationLine + 1.					sourceRunStart > 0						ifTrue: [ 							sourceRunEnd = 0								ifTrue: [ sourceRunEnd := sourceRunStart ].							destinationRunEnd = 0								ifTrue: [ destinationRunEnd := destinationRunStart ].							joins								add:									(self newJoinSectionFrom: (sourceRunStart to: sourceRunEnd) to: (destinationRunStart to: destinationRunEnd)).							destinationRunStart := destinationRunEnd := sourceRunStart := sourceRunEnd := 0 ].					destinationRunStart = 0						ifTrue: [ destinationRunStart := destinationLine ].					destinationRunEnd := destinationLine ] ].	sourceLine := sourceLine + 1.	destinationLine := destinationLine + 1.	(destinationRunStart > 0 or: [ sourceRunStart > 0 ])		ifTrue: [ 			sourceRunStart = 0				ifTrue: [ sourceRunStart := sourceLine ].			destinationRunStart = 0				ifTrue: [ destinationRunStart := destinationLine ].			sourceRunEnd = 0				ifTrue: [ sourceRunEnd := sourceRunStart - 1 ].			destinationRunEnd = 0				ifTrue: [ destinationRunEnd := destinationRunStart - 1 ].			joins				add: (self newJoinSectionFrom: (sourceRunStart to: sourceRunEnd) to: (destinationRunStart to: destinationRunEnd)) ].	matchSourceStart > 0		ifTrue: [ 			joins				add:					(self newMatchJoinSectionFrom: (matchSourceStart to: sourceLine - 1) to: (matchDestinationStart to: destinationLine - 1)) ].	^ joins! !!Trait methodsFor: 'pool variables' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64403311!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [self sharedPools remove: aDictionary.				self sharedPools isEmpty ifTrue: [self sharedPools: nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet := self subclasses asOrderedCollection.	satisfiedSet := Set new.	[workingSet isEmpty] whileFalse:		[aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal Differencekey 								, ' is still used in code of class '								, sub name]]].	self sharedPools remove: aDictionary.	self sharedPools isEmpty ifTrue: [self sharedPools: nil]! !!Trait methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64349248!declareClassVariables: newVars 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	|  conflicts |		conflicts := false.		"Remove. Warn if vars are removed that are still used"	"self flag: something wrong here. put to true and add an ivar to a class"	(self classVariables reject: [:x | newVars includes: x]) do: [:var | self removeClassVarNamed: var name interactive: false].		(newVars reject: [:var | self classVariables includes: var]) do: [:var | "adding"			"check if new vars defined elsewhere"			(self innerBindingOf: var Differencekey) 				ifNotNil: [(DuplicatedVariableError new) variable: var name;						signal: var name , ' is defined elsewhere'.					conflicts := true]].	newVars notEmpty		ifTrue: 			[self classPool: self classPool.			"in case it was nil"			newVars do: [:var | self classPool declareVariable: var from: Undeclared]].	^conflicts! !!NautilusUI methodsFor: 'history behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52469768!wrapHistory: anEntry	^ StringMorph contents: anEntry Differencekey asHistoryString! !!NautilusUI methodsFor: 'history behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52473735!currentHistoryIndex	| index item |	index := 1 min: self getHistoryList size.	index = 0 ifTrue: [ ^ 0 ].	item := (self getHistoryList at: index) Differencekey.	self selectedClass = item selectedClass ifFalse: [ ^ 0 ].	self selectedMethod ifNil: [ ^ 0 ].	^ self selectedMethod selector = item selectedMethod		ifTrue: [ index ]		ifFalse: [ 0 ]! !!GTHelpDebugAction methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27559808!executeAction	HelpBrowser open selectTopicSatisfying: [:each | 		each owner notNil and:  [			(each owner Differencekey = self debugger class helpClass Differencekey) and: [				each title = 'Overview' ] ] ]! !!HelpTopicTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28667459!testInitialization	self assert: topic title = 'Unnamed Topic'.	self assert: topic Differencekey isEmpty.	self assert: topic contents isEmpty ! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28830531!name	^association Differencekey! !!String methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62534875!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices results maxChoices scoreMin |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection 		ifNil: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifNotNil: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) Differencekey ] ]		ifFalse:			[ wordBlock value: [ :word | | score |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 62551632!findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #Differencekey declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	(start max: 1) to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body basicAt: startIndex+index-1) + 1)				= (matchTable at: (key basicAt: index) + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!WeakKeyToCollectionDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84449688!noCheckAddForRehash: anAssociation	| cleanedValue |	anAssociation Differencekey ifNil:[^self].	cleanedValue := anAssociation value copyWithout: nil.	cleanedValue notEmpty ifTrue:[		anAssociation value: cleanedValue.		super noCheckAddForRehash: anAssociation.	].! !!WeakKeyToCollectionDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84450050!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			association Differencekey ifNotNil: [ :key | "Don't let the key go away"				| cleanedValue |				(cleanedValue := association value copyWithout: nil) isEmpty 					ifFalse: [						association value: cleanedValue.						array							at: (self scanForEmptySlotFor: key)							put: association.						tally := tally + 1 ] ] ] ]! !!BlockNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18513435!printTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	| tempStream seen |	tempSequence ifNil:		[^false].	tempStream := (String new: 16) writeStream.	"This is for the decompiler which canmot work out which optimized block a particular temp is	 local to and hence may produce diplicates as in		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"	seen := Set new.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifTrue:				[tempNode remoteTemps do:					[:tempVariableNode|					 (tempVariableNode scope >= 0					  and: [(seen includes: tempNode Differencekey) not]) ifTrue:						[tempStream space; nextPutAll: (seen add: tempVariableNode Differencekey)]]]			ifFalse:				[(tempNode scope >= -1				  and: ["This is for the decompiler which may create a block arg when converting						a while into a to:do: but won't remove it form temporaries"					   tempNode isBlockArg not				  and: [(seen includes: tempNode Differencekey) not]]) ifTrue:					[tempStream space; nextPutAll: (seen add: tempNode Differencekey)]]].	tempStream position = 0 ifTrue:		[^false].	aBlock value.	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.	^true! !!BlockNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18532556!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	arguments do:		[:arg | aStream nextPut: $:;  nextPutAll: arg Differencekey;  space].	aStream nextPut: $|; space.	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue:		[aStream crtab: level]! !!CatalogProject methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18887011!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Project';		display: [ {			'name' -> self name.			'package name' -> self packageName.			'repository url' -> self repositoryUrl.			'description' -> (self description ifNil: [ '' ]).			'contact info' -> (self contactInfo ifNil: [ '' ]).			'keywords' -> (Character space join: self keywords) } ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!CatalogProject methodsFor: 'gt-spotter-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18888261!spotterPreviewIn: aComposite	<spotterPreview: 10>	^ aComposite table		title: 'Catalog Project';		display: [ {			'name' -> self name.			'package name' -> self packageName.			'repository url' -> self repositoryUrl.			'description' -> (self description ifNil: [ '' ]).			'contact info' -> (self contactInfo ifNil: [ '' ]).			'keywords' -> (Character space join: self keywords) } ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		entity: self! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21850448!createTopicFrom: aDescription	"Create a topic from a description stored on a class.	aDescription can specify (via #pages) the name of a class and not	only a selector. This allows for hierarchies with 'subtrees in the middle'"		|topic page   pageClasses |	topic := HelpTopic named: aDescription bookName.	topic contents: aDescription bookDescription.	topic key: aDescription Differencekey.	topic icon: aDescription icon.	pageClasses := Set new.	aDescription pages do: [:pageSelectorOrClass|		page:= (Smalltalk hasClassNamed: pageSelectorOrClass asString)					ifFalse: [aDescription perform: pageSelectorOrClass]					ifTrue: [pageClasses add: (Smalltalk classNamed: pageSelectorOrClass asString).							 (Smalltalk classNamed: pageSelectorOrClass asString) asHelpTopic].		topic addSubtopic: page.	].		((aDescription subclasses asSet)		removeAllFoundIn: pageClasses;		yourself) do: [:subclass | topic subtopics add: subclass asHelpTopic ].	^topic! !!BagTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17957515!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!Announcer methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17255788!gtInspectorAnnouncementsIn: composite context: aGTContext	<gtInspectorPresentationOrder: 40>	| recordedAnnouncements messageSend |		recordedAnnouncements := CollectionValueHolder value: OrderedCollection new.	messageSend := MessageSend receiver: recordedAnnouncements selector: #addAnnouncementFirst:.	self		when: Announcement		send: #cull:		to: messageSend.	aGTContext when: GLMBrowserClosing do: [ self unsubscribe: messageSend ].	composite table		title: 'Announcements';		display: [ recordedAnnouncements value ];		column: 'Time' evaluated: #Differencekey;		column: 'Announcement' evaluated: #value;		send: #value;		showOnly: 50;		format: #gtDisplayString;		filterOn: [:text :each | Smalltalk compiler evaluate: '| date each | date := self key. each := self value. ', text for: each logged: false ];		updateOn: Announcement from: recordedAnnouncements gtAnnouncer;		act: [ :table | 			recordedAnnouncements removeAll.			table update ] 			icon: GLMUIThemeExtraIcons glamorousCancel 			entitled: 'Reset'! !!GTSpotterExtensionSettings class methodsFor: 'settings' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27898049!catalogSettingsOn: aBuilder	<systemsettings>	(aBuilder group: #gtspotter)		parent: #gt;		label: 'GT Spotter extensions';		description: 'All extensions of GT Spotter';		with:				[ 				| extensions groupedExtensions sortedAssociations |				extensions := GTSpotter spotterExtendingMethods.				groupedExtensions := (extensions groupedBy: #methodClass) associations.				sortedAssociations := groupedExtensions asSortedCollection: [ :a1 :a2 | a1 Differencekey name < a2 Differencekey name ].				sortedAssociations do: [ :association |					(aBuilder group: association Differencekey name)						parent: #gtspotter;						label: 'Extensions defined on ', association Differencekey name;						description: 'All extensions of ', association Differencekey name;						with: [ 							association value do:								[ :each | 									(aBuilder setting: (self internalKeyForMethod: each))										target: self;										label: (self spotterExtensionTitleOf: each);										description: each sourceCode;										default: true ] ] ]				]				! !!GTSpotterExtensionSettings class methodsFor: 'settings' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27901007!groupedAndSortedSpotterExtensions	"Return a list of associations in which:		the key is a class		the value is the list of spotter extensions.	The returned list is ordered according to the class name"	| extensions groupedExtensions |	extensions := GTSpotter spotterExtendingMethods.	groupedExtensions := (extensions groupedBy: #methodClass) associations.	^ groupedExtensions asSortedCollection: [ :a1 :a2 | a1 Differencekey name < a2 Differencekey name ]. ! !!Float methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25231026!gtInspectorFloatIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Float';		display: [ 			(self respondsTo: #binaryLiteralString)				ifTrue: [					{'binary' -> self binaryLiteralString.					'significand' -> self significand.					'exponent' -> self exponent} ]				ifFalse: [					{'significand' -> self significand.					'exponent' -> self exponent} ] ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50754256!modifySection: sectionAttributeOrPath sectionIndex: sectionIndex repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		newProjectList - collection of project base names (without ConfigurationOf prefix)		newPackageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		newGroups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap groups packageList newGroupNames |    versionSpec := (self methodSpec        findMethodSection: sectionAttributeOrPath asMetacelloAttributePath        sectionIndex: sectionIndex) versionSpec.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    newProjectList        do: [ :projectName |             (versionSpec packages specListDetect: [ :spec | spec name = projectName ] ifNone: [  ]) == nil                ifTrue: [ versionSpec packages merge: (self createProjectReferenceSpec: projectName) ]                ifFalse: [ self error: 'Project named: ' , projectName printString , ' already exists.' ] ].    packageList := OrderedCollection new.    groups := OrderedCollection new.    newGroupNames := OrderedCollection new.    versionSpec        projectDo: [ :ignored |  ]        packageDo: [ :pkg | packageList add: pkg name ]        groupDo: [ :group |             groups add: group name -> group includes.            newGroupNames add: group name ].    newPackageList        do: [ :packageName |             (packageList includes: packageName)                ifTrue: [ self error: 'Package named: ' , packageName printString , ' already exists.' ]                ifFalse: [ packageList add: packageName ] ].    newGroups        do: [ :assoc |             (newGroupNames includes: assoc Differencekey)                ifTrue: [ self error: 'Group named: ' , assoc Differencekey printString , ' already exists.' ]                ifFalse: [ groups add: assoc ] ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    packageList        do: [ :packageName |             | spec |            (newPackageList includes: packageName)                ifTrue: [                     spec := self createPackageSpec: packageName.                    versionSpec packages merge: spec ]                ifFalse: [ spec := versionSpec packages specListDetect: [ :spc | spc name = packageName ] ].            dependencyMap                at: packageName                ifPresent: [ :dependencyList | spec setRequires: spec requires , dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec setIncludes: spec includes , includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ] ].    groups        do: [ :assoc |             | spec |            (newGroupNames includes: assoc Differencekey)                ifFalse: [                     spec := self createGroupSpec: assoc Differencekey.                    versionSpec packages merge: spec.                    spec setIncludes: spec includes , assoc value ] ].    aBlock value: versionSpec! !!MetacelloToolBox methodsFor: '*Versionner-Core-DependenciesModel' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50715636!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock requiredProjectSpecs: requiredProjectSpecs    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members		requiredProjectSpecs - collection of already computed required project specs.	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |    versionSpec := self createVersionSpec: self methodSpec versionString.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    requiredProjectSpecs do: [ :projectSpec | versionSpec packages merge: projectSpec ].    packageList        do: [ :packageName |             | spec |            spec := self createPackageSpec: packageName.            dependencyMap at: packageName ifPresent: [ :dependencyList | spec requires: dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec includes: includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ].            versionSpec packages merge: spec ].    groups        do: [ :assoc |             | spec |            spec := self createGroupSpec: assoc Differencekey.            spec includes: assoc value.            versionSpec packages merge: spec ].    aBlock value: versionSpec.    self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50722534!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |    versionSpec := self createVersionSpec: self methodSpec versionString.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    projectList        do: [ :projectName |             | spec |            spec := self createProjectReferenceSpec: projectName.            repositoriesMap                at: projectName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            versionSpec packages merge: spec ].    packageList        do: [ :packageName |             | spec |            spec := self createPackageSpec: packageName.            dependencyMap at: packageName ifPresent: [ :dependencyList | spec requires: dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec includes: includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ].            versionSpec packages merge: spec ].    groups        do: [ :assoc |             | spec |            spec := self createGroupSpec: assoc Differencekey.            spec includes: assoc value.            versionSpec packages merge: spec ].    aBlock value: versionSpec.    self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50734352!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock  "		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |  versionSpec := self createVersionSpec: self methodSpec versionString.  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self    buildMapFrom: repositories    for: packageList , projectList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  projectList    do: [ :projectName |       | spec |      spec := self createProjectReferenceSpec: projectName.      repositoriesMap        at: projectName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      versionSpec packages merge: spec ].  packageList    do: [ :packageName |       | spec |      spec := self createPackageSpec: packageName.      dependencyMap        at: packageName        ifPresent: [ :dependencyList | spec requires: dependencyList ].      includesMap        at: packageName        ifPresent: [ :includesList | spec includes: includesList ].      filesMap at: packageName ifPresent: [ :file | spec file: file ].      repositoriesMap        at: packageName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      preLoadDoItsMap        at: packageName        ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].      postLoadDoItsMap        at: packageName        ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].      supplyingAnswersMap        at: packageName        ifPresent: [ :answer | spec answers: answer ].      versionSpec packages merge: spec ].  groups    do: [ :assoc |       | spec |      spec := self createGroupSpec: assoc Differencekey.      spec includes: assoc value.      versionSpec packages merge: spec ].  aBlock value: versionSpec.  self methodSpec    addMethodSection: sectionAttributeOrPath asMetacelloAttributePath    versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 50721006!buildMapFrom: mapList for: packageList	| map |	map := Dictionary new.	mapList		do: [ :assoc | 			| pkgName pkgSpec |			pkgName := assoc Differencekey.			(packageList includes: pkgName)				ifFalse: [ self error: 'package ' , pkgName printString , ' not found in packages.' ].			map at: pkgName put: assoc value ].	^ map! !!KMRepository methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30101083!gtInspectorMappingsIn: composite	<gtInspectorPresentationOrder: 40>	composite table 		title: 'Keys';		display: [ 			self categories values				flatCollect: [ :category | 					category allEntries keymaps collect: [ :key | key -> category ] ]				 ];		filterOn: [ :text :each | each gtDisplayString includesSubstring: text caseSensitive: false ];		column: 'Shortcut' evaluated: [ :assoc | assoc Differencekey shortcut gtDisplayString ] width: 120;		column: 'Action' evaluated: [ :assoc | assoc Differencekey action gtDisplayString ];		column: 'Description' evaluated: [ :assoc | assoc Differencekey description ];		column: 'Category' evaluated: [ :assoc | '' ] tags: [ :assoc | assoc value name ifNil: [ #() ] ifNotNil: [ { assoc value name }]];		send: #Differencekey! !!KMRepository methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30098212!gtInspectorGlobalsIn: composite	<gtInspectorPresentationOrder: 40>	composite table 		title: 'Global keys';		display: [ 			self globalCategories				flatCollect: [ :category | 					category allEntries keymaps collect: [ :key | key -> category ] ]				 ];		filterOn: [ :text :each | each gtDisplayString includesSubstring: text caseSensitive: false ];		column: 'Shortcut' evaluated: [ :assoc | assoc Differencekey shortcut gtDisplayString ] width: 120;		column: 'Description' evaluated: [ :assoc | assoc Differencekey description ];		column: 'Action' evaluated: [ :assoc | assoc Differencekey action gtDisplayString ];		column: 'Category' evaluated: [ :assoc | '' ] tags: [ :assoc | assoc value name ifNil: [ #() ] ifNotNil: [ { assoc value name }]];		send: #Differencekey! !!MethodConstantTests methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51052880!testConstPlaceInTransformedMethod	| transformedMethod const constLiteral |	const := self constFromReceiverExpression. 			transformedMethod := self class >> #constFromReceiverExpression. 		constLiteral := transformedMethod literals detect: [ :each | each value == const ].	self assert: (constLiteral Differencekey includesSubstring: 'meta' caseSensitive: false)! !!ByteArray methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18646724!gtInspectorBytesIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Bytes';		display: [ 			(self size < 2048 or: [ self confirm: 'Looking at more than 2048 bytes might be slow. Continue ?' ])				ifTrue: [ {					'hex string' -> (String streamContents: [ :out | 						self do: [ :each | 							each printOn: out base: 16 nDigits: 2 ] ]).					'hex lines' -> (String streamContents: [ :out |						self withIndexDo: [ :each :index |							index = 1 ifFalse: [ 								index - 1 \\ 8 = 0 ifTrue: [ out cr ] ifFalse: [ out space ] ].								each printOn: out base: 16 nDigits: 2 ] ]).					'latin1' -> ([ ZnCharacterEncoder latin1 decodeBytes: self ]											on: ZnCharacterEncodingError do: [ :exception | exception ]).					'utf8' -> ([ ZnUTF8Encoder new decodeBytes: self ] 											on: ZnCharacterEncodingError do: [ :exception | exception ]).					'integer' -> self asInteger.					'integer reversed' -> self reversed asInteger } ]				ifFalse: [ #() ] ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!DAPackageRelationGraph methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22002781!isReference: aLiteral	^ aLiteral isVariableBinding and: [ aLiteral value isBehavior and: [ aLiteral Differencekey = aLiteral value name ] ]! !!UITheme methodsFor: 'morph creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 65118331!newLabelGroupIn: aThemedMorph for: labelsAndControls font: aFont labelColor: aColor	"Answer a morph laid out with a column of labels and a column of associated controls.	If spaceFill is tru then each row will share available space to pad."	| labels labelWidth lc|	lc := labelsAndControls collect: [:a |		(a Differencekey isMorph			ifTrue: [a Differencekey]			ifFalse: [(self newLabelIn: aThemedMorph label: (a Differencekey ifNil: ['']) asString)						font: aFont;						color: aColor])			-> a value].	labels := Morph new		hResizing: #shrinkWrap;		vResizing: #spaceFill;		changeTableLayout.	lc do: [:a |		labels addMorphBack: a Differencekey].	labelWidth := labels minExtent x.	^self newColumnIn: aThemedMorph for: (lc collect: [:a | | row |		a Differencekey hResizing: #rigid; extent: labelWidth@ a Differencekey height.		row := self newRowIn: aThemedMorph for: {a Differencekey. a value}.		row vResizing: (a value vResizing = #spaceFill ifTrue: [#spaceFill] ifFalse: [#shrinkWrap]).		row])! !!UITheme methodsFor: 'morph creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 65122777!focusIndicatorMorphFor: aMorph	"Answer a (cached) focus indicator for the given morph."	(self focusIndicator isNil or: [			self focusIndicator isMorph				ifTrue: [self focusIndicator ~~ aMorph]				ifFalse: [self focusIndicator Differencekey ~~ aMorph]])		ifTrue: [self focusIndicator: aMorph ->(self newFocusIndicatorMorphFor: aMorph)].	^self focusIndicator value 		privateBounds: aMorph focusBounds! !!UITheme methodsFor: 'morph creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 65165447!newLabelGroupIn: aThemedMorph for: labelsAndControls	"Answer a morph laid out with a column of labels and a column of associated controls.	The vResizing for each row will be #spaceFill if the control for that row specifies	this, otherwise #shrinkWrap."	| labels labelWidth lc |	lc := labelsAndControls collect: [:a |		(a Differencekey isMorph			ifTrue: [a Differencekey]			ifFalse: [a Differencekey ifNotNil: [self newLabelIn: aThemedMorph label: a Differencekey asString]])			-> a value].	labels := Morph new		hResizing: #shrinkWrap;		vResizing: #spaceFill;		changeTableLayout.	lc do: [:a |		a Differencekey ifNotNil: [labels addMorphBack: a Differencekey]].	labelWidth := labels minExtent x.	^self newColumnIn: aThemedMorph for: (lc collect: [:a | | row |		a Differencekey ifNotNil: [a Differencekey hResizing: #rigid; extent: labelWidth@ a Differencekey height].		row := self newRowIn: aThemedMorph for: (a Differencekey ifNil: [{a value}] ifNotNil: [{a Differencekey. a value}]).		row vResizing: (a value vResizing = #spaceFill ifTrue: [#spaceFill] ifFalse: [#shrinkWrap]).		row])! !!ArrayTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17331703!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!ClassChangeRecord methodsFor: 'removal' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19292514!forgetChangesIn: otherRecord	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	| cls otherMethodChanges |	(cls := self realClass) ifNil: [ ^ self ].	"We can do better now, though..."	otherMethodChanges := otherRecord methodChangeTypes.	otherMethodChanges		associationsDo: [ :assoc | 			| selector actionToSubtract |			selector := assoc Differencekey.			actionToSubtract := assoc value.			(cls includesSelector: selector)				ifTrue: [ 					(#(#add #change) includes: actionToSubtract)						ifTrue: [ methodChanges removeKey: selector ifAbsent: [  ] ] ]				ifFalse: [ 					(#(#remove #addedThenRemoved) includes: actionToSubtract)						ifTrue: [ methodChanges removeKey: selector ifAbsent: [  ] ] ] ].	changeTypes isEmpty		ifTrue: [ ^ self ].	changeTypes removeAllFoundIn: otherRecord allChangeTypes.	(changeTypes includes: #rename)		ifFalse: [ changeTypes removeAllSuchThat: [ :x | x beginsWith: 'oldName: ' ] ]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19295217!methodChangeTypes	"Return an old-style dictionary of method change types."	| dict |	dict := IdentityDictionary new.	methodChanges associationsDo:		[:assn | | selector record |		selector := assn Differencekey.		record := assn value.		dict at: selector put: record changeType].	^ dict! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19291510!assimilateAllChangesIn: otherRecord		otherRecord isClassRemoval ifTrue: [^ self noteChangeType: #remove].	otherRecord allChangeTypes do:		[:chg | self noteChangeType: chg fromClass: self realClass].	otherRecord methodChanges associationsDo:		[:assn | | changeType selector changeRecord | selector := assn Differencekey. changeRecord := assn value.		changeType := changeRecord changeType.		(changeType == #remove or: [changeType == #addedThenRemoved])			ifTrue:				[changeType == #addedThenRemoved					ifTrue: [self atSelector: selector put: #add].				self noteRemoveSelector: selector priorMethod: nil						lastMethodInfo: changeRecord methodInfoFromRemoval]			ifFalse: 				[self atSelector: selector put: changeType]].! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28859069!visitPushLiteralVariable: var		| object |	object := var association.	stream nextPutAll: 'pushLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object Differencekey].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28856132!visitPopIntoLiteralVariable: litVar		| object |	object := litVar association.	stream nextPutAll: 'popIntoLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object Differencekey].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28854711!visitPushLiteral: lit	| object |	object := lit literal.	stream nextPutAll: 'pushLiteral: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object Differencekey].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28856755!visitStoreLiteralVariable: var	| object |	object := var association.	stream nextPutAll: 'storeLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object Differencekey].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28855274!visitReturnLiteral: lit	| object |	object := lit literal.	stream nextPutAll: 'returnLiteral: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object Differencekey].	object printOn: stream.! !!GTDebuggerVariablesBrowser methodsFor: 'private building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27418143!variablesIn: composite	^ composite fastTable		useCache;		display: [ :aContext | self variablesFromContext: aContext. ];		column: 'Type'			evaluated: [ '' ]			width: 75			tags: [ :aNode  | { aNode variableTag } ]			sortedBy: [ :x :y |  x variableTag < y  variableTag ];		column: 'Variable' 			evaluated: [ :aNode | GTObjectPrinter asNonTruncatedTextFrom: aNode Differencekey ]			width: 175;		column: 'Value' 			evaluated: [ :aNode | | rawValue displayValue |				[ rawValue := aNode rawValue. ] 					on: Error 					do: [ displayValue := Text string: aNode errorMessage attribute: TextColor red ].				displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ];		dynamicActionsOnSelection: [ :presentation |			(presentation rawSelection isKindOf: GTInspectorVariableNode) 				ifTrue: [presentation rawSelection inspectorActionsForNode ]				ifFalse: [ #() ] ];		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse';		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect';		onChangeOfPort: #rawSelection 			act: [ :aPresentation | 				self debugger selectedVariableName: aPresentation rawSelection Differencekey ] ! !!GTDebuggerVariablesBrowser methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27417811!selectedVariableForContext: aContext 	^ (self variablesFromContext: aContext) 		detect: [ :each | each Differencekey = self debugger selectedVariableName ] 		ifNone: [ cachedVariables detect: [ :each | each Differencekey = 'self' ] ifNone: [ nil ] ]! !!JoinSection methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30004833!createHighlightsFrom: srcPara to: dstPara	"Create and store the src and dst highlights.	Use the given paragraphs to determine inline	diffs."	| s d si di srcText dstText diffs i sb eb line |	self createHighlights.	self src lineRange notEmpty		ifTrue: [ 			line := srcPara lines at: self src lineRange first.			si := line first.			line := srcPara lines at: self src lineRange last.			srcText := srcPara string copyFrom: si to: line last ]		ifFalse: [ srcText := '' ].	self dst lineRange notEmpty		ifTrue: [ 			line := dstPara lines at: self dst lineRange first.			di := line first.			line := dstPara lines at: self dst lineRange last.			dstText := dstPara string copyFrom: di to: line last ]		ifFalse: [ dstText := '' ].	self src text: srcText.	self dst text: dstText.	self type = #modification		ifFalse: [ ^ self ].	s := self src highlights.	d := self dst highlights.	diffs := (InlineTextDiffBuilder from: srcText to: dstText) buildPatchSequence aggregateRuns: [ :e | e Differencekey ].	diffs		do: [ :c | 			c first Differencekey = #match				ifTrue: [ 					c						do: [ :a | 							si := si + a value size.							di := di + a value size ] ].			c first Differencekey = #insert				ifTrue: [ 					i := di.					c do: [ :a | di := di + a value size ].					sb := dstPara characterBlockForIndex: i.					eb := dstPara characterBlockForIndex: di - 1.					self						addHighlightsFrom: sb						to: eb						to: d						color: self additionHighlightColor ].			c first Differencekey = #remove				ifTrue: [ 					i := si.					c do: [ :a | si := si + a value size ].					sb := srcPara characterBlockForIndex: i.					eb := srcPara characterBlockForIndex: si - 1.					self						addHighlightsFrom: sb						to: eb						to: s						color: self removalHighlightColor ] ]! !!WeakValueDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84502304!add: anAssociation	self at: anAssociation Differencekey put: anAssociation value.	^ anAssociation! !!LiteralDictionary methodsFor: 'internal' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31189602!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil					or: [self literalEquality: element Differencekey and: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil					or: [self literalEquality: element Differencekey and: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Slot methodsFor: '*Reflectivity' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60031973!availableReifications	^RFReification subclasses 		select: [ :e | e entities includesAny: self class withAllSuperclasses ]		thenCollect: #Differencekey! !!GradientFillStyle methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28283777!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastValue ramp lastColor lastIndex lastWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 Differencekey < a2 Differencekey].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := lastColor pixelWordForDepth: 32.	lastIndex := 0.	ramp do:[:assoc| | theta nextIndex nextColor nextWord distance step |		nextIndex := (assoc Differencekey * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWordForDepth: 32.		distance := (nextIndex - lastIndex).		distance = 0 ifTrue:[distance := 1].		step := 1.0 / distance asFloat.		theta := 0.0.		lastIndex+1 to: nextIndex do:[:i|			theta := theta + step.			"The following is an open-coded version of:				color := nextColor alphaMixed: theta with: lastColor.				bits at: i put: (color scaledPixelValue32).			"			bits at: i put: (self scaledAlphaMix: theta of: lastWord with: nextWord).		].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord.	].	lastValue := lastColor scaledPixelValue32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!GradientFillStyle methodsFor: 'converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28283564!mixed: fraction with: aColor	^self copy colorRamp: (colorRamp collect:[:assoc| assoc Differencekey -> (assoc value mixed: fraction with: aColor)])! !!IdentityDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 29330989!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish start element |	finish := array size.	start := (anObject identityHash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element Differencekey == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element Differencekey == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentityDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 29330050!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock." 	self associationsDo: 		[:association | value == association value ifTrue: [^ association Differencekey]].	^ exceptionBlock value! !!MIMEHeaderValue methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32235623!asHeaderValue	| strm |	strm := (String new: 20) writeStream.	strm nextPutAll: mainValue.	parameters		associationsDo: [ :e | 			strm				nextPut: $;;				nextPutAll: e Differencekey;				nextPutAll: '="';				nextPutAll: e value;				nextPutAll: '"' ].	^ strm contents! !!IRFix methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28814487!convertStorePop: assoc forSeq: seq 	| store pop |	store := assoc Differencekey.	pop := assoc value.	seq replaceNode: store withNode: (store popIntoNode sourceNode: store sourceNode).	seq remove: pop.! !!IRFix methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28814753!convertRet: assoc forSeq: seq 	| push ret |	push := assoc Differencekey.	ret := assoc value.	seq replaceNode: push withNode: (push quickRetNode sourceNode: ret sourceNode).	seq remove: ret.! !!PluggableDictionaryTest methodsFor: 'test - comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54580371!testEqualBlock	| pluggableDict assoc |	pluggableDict := self emptyDict.	self assert: pluggableDict equalBlock isNil.	self assert: (pluggableDict equalBlock: [:a :b | a = b]) == pluggableDict.	assoc := 'newKey' -> 'newValue'.	pluggableDict add: assoc.	self assert: (pluggableDict includesAssociation: assoc).	pluggableDict equalBlock: [:a :b | a == b].	self assert: (pluggableDict includesAssociation: assoc).	pluggableDict		removeKey: assoc Differencekey;		add: assoc Differencekey copy -> assoc value.	self deny: (pluggableDict includesAssociation: assoc).	pluggableDict equalBlock: [:a :b | a = b].	self assert: (pluggableDict includesAssociation: assoc).! !!GLMSmalltalkCodeModel methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27133842!addVariableBinding: anAssociation	self variableBindings at: anAssociation Differencekey put: anAssociation value! !!FloatArrayTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25290290!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!GTEventAnnouncement methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27422912!gtInspectorItemsIn: composite	<gtInspectorPresentationOrder: -1>  	^ (composite table)		title: 'Info';		display: [ :anEvent | anEvent gtInspectorItems ];		children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each Differencekey ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		showOnly: 50! !!RBProgramNode methodsFor: '*Reflectivity' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56237617!availableReifications	^RFReification subclasses 		select: [ :e | e entities includesAny: self class withAllSuperclasses ]		thenCollect: #Differencekey! !!GTEventCollector methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27433258!gtInspectorActionHelp	<gtInspectorAction>	^ GLMGenericAction new		action: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner Differencekey = GTEventRecorderHelp Differencekey) and: [				each title = 'Client' ] ] ] ];		icon: GLMUIThemeExtraIcons glamorousHelp;		title: 'Help'! !!LookupKey methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31281998!name	^ self Differencekey isString		ifTrue: [self Differencekey]		ifFalse: [self Differencekey printString]! !!LookupKey methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31282892!< aLookupKey 	"Refer to the comment in Magnitude|<."	^key < aLookupKey Differencekey! !!LookupKey methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31282739!= aLookupKey	self species = aLookupKey species		ifTrue: [^key = aLookupKey Differencekey]		ifFalse: [^false]! !!ZnCookie methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85202802!writeExtraAttributesOn: aStream	self extraAttributes		associationsDo: [ :ea | 			aStream				nextPutAll: '; ';				nextPutAll: ea Differencekey.			(ea value isKindOf: Boolean)				ifFalse: [ 					aStream						nextPutAll: '=';						nextPutAll: ea value ] ]! !!ZnCookie methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85202018!extraAttributes	"Answer all attributes except name and value"	^ attributes associationsSelect: [ :ea | (ea Differencekey = 'name' or: [ ea Differencekey = 'value' ]) not ]! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31758324!resolveProjectVersionPattern: aString  "aString must conform to the syntax for MetacelloVersionNumber with the exception that aString may have a leading $v which is stripped before conversion to a MetacelloVersionNumber patterm"  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath    ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (self class projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys    collect: [ :tagName |       | tagVersion |      tagVersion := self class projectVersionFromString: tagName.      tagVersion -> tagName ].  matchingTags := tagAssocs select: [ :assoc | assoc Differencekey match: patternString ].  matchingTags isEmpty    ifTrue: [       projectVersion := aString.      ^ self        error:          'No tags matching the pattern ' , aString printString            , ' found for repository description '            , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [ :a :b | a Differencekey <= b Differencekey ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag value! !!Deprecation methodsFor: 'handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 33748325!transform	| node rewriteRule aMethod |	self raiseWarning ifFalse: [ ^ self ]. "when desprecations are disables, we do not want to transform, either"	self rewriterClass ifNil:[ ^ self signal ].	aMethod := self contextOfSender method.	aMethod isDoIt ifTrue:[^ self]. "no need to transform doits"	node := self contextOfSender sourceNodeExecuted.	rewriteRule := self rewriterClass new 		replace: rule Differencekey with: rule value.	(rewriteRule executeTree: node)		ifFalse: [ ^ self ].	node replaceWith: rewriteRule tree. 	Author 		useAuthor: 'AutoDeprecationRefactoring'		during: [aMethod origin compile: aMethod ast formattedCode classified: aMethod protocol].		Log 		ifNotNil: [:log | log add: self].	self logTranscript! !!OrderedCollectionTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53757079!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!Bag methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17925762!sortedCounts	"Answer with a collection of counts with elements, sorted by decreasing	count."	"Suggested by l. Uzonyi"	^(Array new: contents size streamContents: [ :stream | 			contents associationsDo: [ :each | 				stream nextPut: each value -> each Differencekey ] ]) 		sort: [:x :y | x >= y ]; 		yourself! !!Bag methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17924759!keysAndValuesDo: aTwoArgBlock     "Iterate over the receiver and apply a two argument block on the element and its occurrences."         contents associationsDo: [:assoc | aTwoArgBlock value: assoc Differencekey value: assoc value ]! !!Bag methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17927344!= aBag	"Two bags are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same size.	 (c) each element occurs the same number of times in both of them"	(aBag isKindOf: Bag) ifFalse: [^false].	self size = aBag size ifFalse: [^false].	contents associationsDo: [:assoc|		(aBag occurrencesOf: assoc Differencekey) = assoc value			ifFalse: [^false]].	^true! !!Bag methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17928271!do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	contents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc Differencekey]]! !!Bag methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17927885!doWithOccurrences: aTwoArgBlock     "Iterate over the receiver and apply a two argument block on the element and its occurrences."            contents associationsDo: [:assoc | aTwoArgBlock value: assoc Differencekey value: assoc value ]! !!Bag methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17926957!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s := self size / 100.0. n := 0.	^ self sortedCounts asArray collect:		[:a | n := n + a Differencekey. (n / s roundTo: 0.1) -> a value]! !!STONWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 59198329!writeAssociation: association	jsonMode		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self 		encodeKey: association Differencekey 		value: association value! !!Pragma class methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 55045728!gtInspectorAnnotatedMethodsIn: composite	<gtInspectorPresentationOrder: 30> 	composite table 		title: 'All';		showOnly: 50;		withSmalltalkSearch;		display: [:anObject | 			| pragmas |			pragmas := OrderedCollection new.			Object withAllSubclassesDo: [:each |				Pragma withPragmasIn: each do: [:p |					pragmas add: p]].			(pragmas groupedBy: #keyword) associations sorted: [ :a :b | 				a Differencekey < b Differencekey ]		];		column: 'Keyword' evaluated: [ :each | each Differencekey ];		column: 'Instances' evaluated: [ :each | each value size asString ];		send: #value! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53689411!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector Differencekey]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!IceGitHubError methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 35606529!unknownError: aDictionary	^ String streamContents: [ :stream | 		(aDictionary associations sorted: [ :a :b | a Differencekey < b Differencekey  ])			do: [ :each | stream << each Differencekey << ': ' << each value ]			separatedBy: [ stream << ', ' ] ]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63536212!analyseClosure: rootNode "<MethodNode>"	"Analyse whether the temporary needs to be made remote	 or not, and answer whether it was made remote.	 A temp cannot be local if it is written to remotely,	 or if it is written to after it is closed-over.  An exception	 is an inlined block argument that appears to be written	 remotely but is actually local to a block."	| latestWrite |	self isBlockArg ifTrue: [^false].	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"	latestWrite := 0.	((writingScopes notNil	 and: [writingScopes associations anySatisfy: [:assoc|			[:blockScope :refs|			refs do: [:write| latestWrite := write max: latestWrite].			"A temp cannot be local if it is written to remotely."			blockScope actualScope ~~ definingScope actualScope]				value: assoc Differencekey value: assoc value]])	or: [readingScopes notNil		and: [readingScopes associations anySatisfy: [:assoc|				[:blockScope :refs|				 "A temp cannot be local if it is written to after it is closed-over."				 blockScope actualScope ~~ definingScope actualScope				 and: [refs anySatisfy: [:read| read < latestWrite]]]					value: assoc Differencekey value: assoc value]]]) ifTrue:		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.		 ^true].	^false! !!GTInspectorMethodListFilter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27592304!allPresentationMethods	^ (PragmaCollector allSystemPragmas select: [ :pragma | 		pragma Differencekey == self inspectorPragmaKey ]) collect: [ :aPragma | aPragma method ]! !!HelpBrowser methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28638521!selectARootTopic: aHelpClass	"Used to unfold a particular topic"		| item |	item := treeMorph allItems detect: [:each |             each complexContents item Differencekey = aHelpClass name ].   treeMorph selection: item! !!NECClassVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52125605!popIntoLiteralVariable: anAssociation 	anAssociation Differencekey == variableName asSymbol 		ifTrue: [ found := true ]		ifFalse: [ self reset ]! !!GTInspectorTagFilter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27604359!tagsFrom: aMethod	^ (aMethod pragmas select: [ :each | each Differencekey == self tagPragmaKey ])		ifEmpty: [ defaultTag ifNil: [ {} ] ifNotNil: [ {defaultTag} ] ]		ifNotEmpty: [ :currentPragmas | currentPragmas collect: [ :each | each argumentAt: 1 ] ]! !!GTInspectorTagFilter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27603476!allPragmasWithTag	^ PragmaCollector allSystemPragmas select: [ :pragma | pragma Differencekey == self tagPragmaKey ]! !!ZnApplicationFormUrlEncodedEntity methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84962942!add: association	self at: association Differencekey put: association value! !!DateAndTime methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22092104!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'year' -> self year.					'month' -> self monthIndex.					'month name' -> self monthName.					'day of month' -> self dayOfMonth.					'day of week' -> self dayOfWeekName.					'day of year' -> self dayOfYear.					'hours' -> self hours.					'minutes' -> self minutes.					'seconds' -> self seconds.					'nanoseconds' -> self nanoSecond.					'meridian' -> self meridianAbbreviation.					'offset' -> self offset.					'date' -> self asDate.					'time' -> self asTime.					'iso' -> self printString.					'utc' -> self asUTC } ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!GTSpotterContext methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27828093!continueFilter	| processors nonEmptyProcessors |	processors := self cache at: #processorsAndFilters ifAbsent: [ ^ self ].	nonEmptyProcessors := processors associations select: [ :assoc | assoc Differencekey hasFilteredCandidates ].	nonEmptyProcessors size = 1 ifFalse: [ ^ self ].	self canContinue ifFalse: [ ^ self ].		self withContinue: true do: [ 		nonEmptyProcessors do: [ :assoc | 			assoc Differencekey continueFilterInContext: self ] ]! !!GLMRubricTextMorphicTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27058182!noTestOKeyWithCtrlCannotBeOverriden	| composite textMorph overriden shortcut|	overriden := false.	composite := GLMCompositePresentation new with: [ :a | a text act: [ :text | overriden := true ] on: $o entitled: 'Override'].	window := composite openOn: '4'.	textMorph := self find: RubScrolledTextMorph in: window.	"self simulateOnlyOneClickOn: textMorph."		shortcut := $o meta asKeyCombination.	textMorph textArea handleKeystroke: (KeyboardEvent new		setType: #keystroke		buttons: shortcut modifier eventCode		position: textMorph textArea center		keyValue: shortcut Differencekey asciiValue		charCode: shortcut Differencekey asciiValue		hand: nil		stamp: DateAndTime now).		self assert: overriden not! !!GLMRubricTextMorphicTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27055187!noTestAcceptKeyCanBeOverriden	| composite textMorph overriden shortcut|	overriden := false.	composite := GLMCompositePresentation new with: [ :a | a text act: [ :text | overriden := true ] on: $s entitled: 'Override'].	window := composite openOn: '4'.	textMorph := self find: RubScrolledTextMorph in: window.	self simulateOnlyOneClickOn: textMorph.	(Delay forMilliseconds: HandMorph doubleClickTime + 1) wait.	"self simulateOnlyOneClickOn: textMorph."	self assert: ActiveHand keyboardFocus equals: textMorph textArea.		shortcut := $s meta asKeyCombination.	textMorph textArea handleKeystroke: (KeyboardEvent new		setType: #keystroke		buttons: shortcut modifier eventCode		position: textMorph textArea center		keyValue: shortcut Differencekey asciiValue		charCode: shortcut Differencekey asciiValue		hand: nil		stamp: DateAndTime now).	self assert: overriden! !!GLMBasicExamples methodsFor: '*Glamour-FastTable' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 26073388!fastTreeWithColumnsAndEditing	"self new fastTreeWithColumnsAndEditing openOn: ((1 to: 5) collect: [ :index1 |	((1 to: 10) collect: [ :index | index -> (ValueHolder new contents: 'description') ]) asDictionary ]) "	<glmBrowser: 'Fast Tree With Editable Columns' input: '((1 to: 5) collect: [ :index1 |	((1 to: 10) collect: [ :index | index -> (ValueHolder new contents: ''description'') ]) asDictionary ])'>	| browser |	browser := GLMTabulator new.	browser row: #Example.	browser transmit		to: #Example;		andShow: [ :a | a fastTreeTable 			children: [ :x | x isDictionary ifTrue: [ x associations ] ifFalse: [ #() ] ];			column: [:x | 'Numbers'] evaluated: [ :value | value isDictionary ifTrue: [ value ] ifFalse: [ value Differencekey ] ];			column: 'Description' 			   evaluated: [ :value | value isDictionary ifTrue: [ '' ] ifFalse: [ value value contents ] ] 			   modified: [ :newText :value :presentation | 					value isDictionary ifFalse: [ value value contents: newText  ]] ].	^ browser! !!ToggleMenuItemMorph methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64309677!icon	"Answer the receiver's icon. Handle legacy case	of wording-based mechanism."		|state| 	self getStateSelector ifNil: [^super icon].	state := (MessageSend receiver: self target selector: self getStateSelector)		valueWithEnoughArguments: self arguments .	self flag: #CleanYesNoOnOffAfter.	(state isKindOf: Association)		ifTrue: [^ state Differencekey ifTrue: [self onImage] ifFalse: [self offImage]]		ifFalse: [	(state = true or: [state isString and: [(state beginsWith: '<yes>') or: [state beginsWith: '<on>']]])		ifTrue: [^self onImage].	(state = false or: [state isString and: [(state beginsWith: '<no>') or: [state beginsWith: '<off>']]])		ifTrue: [^self offImage]].	^super icon! !!CategoryWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18922805!selectedCategories	| associations |	associations := self categoriesSelection associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc Differencekey ].	^ associations select: [:each | each notNil ]! !!DictionaryTest methodsFor: 'test - copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22559301!testDictionaryConcatenationWithCommonKeysDifferentValues	| dictionary1 dictionary2 result value |		dictionary1 := self nonEmptyDict.	value := self nonEmptyDifferentFromNonEmptyDict   values anyOne.	dictionary2 := dictionary1 copy.	dictionary2 keys do: [ :key | dictionary2 at: key put: value ].			result := dictionary1 , dictionary2.	self assert: result size = ( dictionary2 size).		dictionary2 associationsDo: [ :assoc | self assert: (result at: assoc Differencekey) = assoc value ]! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22593194!testAddWithKeyNotIn	| dictionary result association |	dictionary := self nonEmptyDict.	association := self associationWithKeyNotInToAdd.	result := dictionary add: association.	self assert: result = association.	self assert: (dictionary at: association Differencekey) = association value! !!DictionaryTest methodsFor: 'tests - Dictionary keys values associations access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22613261!testAssociations	| collection result  |	collection := self nonEmpty .	result := collection associations.		self assert: result size = collection size.	result do: [:assoc | self assert: (assoc value) = (collection at: assoc Differencekey) ].	"keys do: [ :key | self assert: ( result at: key ) = ( collection at: key )] ."	! !!DictionaryTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22553402!test0FixtureDictionaryAddingTest	self nonEmptyDict.	self deny: self nonEmptyDict isEmpty.	self associationWithKeyNotInToAdd.	self deny: (self nonEmptyDict keys includes: self associationWithKeyNotInToAdd Differencekey).	self associationWithKeyAlreadyInToAdd.	self assert: (self nonEmptyDict keys includes: self associationWithKeyAlreadyInToAdd Differencekey)! !!DictionaryTest methodsFor: 'tests - dictionnary enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22606769!testAssociationsSelect	| collection keys result |	collection := self nonEmptyDict .	keys := OrderedCollection new.	result := collection associationsSelect: [ :assoc  | 		keys add: assoc Differencekey.		true].		collection keys do: [ :key | self assert: (collection keys occurrencesOf: key) = (keys occurrencesOf: key)].	self assert: result = collection.! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22601175!testAtIfAbsentPut	"self run: #testAtIfAbsentPut"	| collection association |	collection := self nonEmpty.	association := collection associations anyOne.	self		assert:			(collection at: association Differencekey ifAbsentPut: [ Error signal ])				= association value.	self assert: (collection at: association Differencekey) = association value.	self		assert:			(collection at: self keyNotIn ifAbsentPut: [ self valueNotIn ])				= self valueNotIn.	self assert: (collection at: self keyNotIn) = self valueNotIn! !!DictionaryTest methodsFor: 'test - testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22572898!testIncludesAssociationNoValue	| association dictionary |		association := Association key: #Differencekey.		self assert: association value isNil.		dictionary := self collectionClass new.		dictionary add: association.		self assert: (dictionary at: #Differencekey) isNil			! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22606287!testAddWithKeyAlreadyIn	| dictionary result association |	dictionary := self nonEmptyDict.	association := self associationWithKeyNotInToAdd.	result := dictionary add: association.	self assert: result = association.	self assert: (dictionary at: association Differencekey) = association value! !!DictionaryTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22572382!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!DictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22552299!testDictionaryPublicProtocolCompatibility	"Tests that other dictionaries and their classes respond to the messages	in the public protocols (ignoring extensions, private, printing, copying,	and comparing) that Dictionary and its metaclass implement."	| dict |	self collectionClass == Dictionary		ifTrue: [ ^ self ].	dict := self emptyDict.	{(dict -> Dictionary).	(dict class -> Dictionary class)}		do: [ :assoc | 			assoc value protocols				reject: [ :protocol | 					#('private' 'print' 'copy' 'compar' '*')						anySatisfy: [ :each | protocol asString beginsWith: each ] ]				thenDo: [ :protocol | 					(assoc value selectorsInProtocol: protocol)						do: [ :each | self assert: (assoc Differencekey respondsTo: each) ] ] ]! !!DictionaryTest methodsFor: 'tests - dictionary assocition access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22607203!testAssociationAtIfAbsent	| collection keyIn result |	collection := self nonEmpty.	keyIn := collection keys anyOne.	result := collection associationAt: keyIn ifAbsent: [888]. 	self assert: (result Differencekey) = keyIn.	self assert: (result value ) = (collection at: keyIn ).	self assert: (collection associationAt: self keyNotIn  ifAbsent: [888] ) = 888! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22575960!testAtIfPresentIfAbsent	"self run: #testAtIfPresentIfAbsent"	| collection association arg |	collection := self nonEmpty.	association := collection associations anyOne.	arg := nil.	self		assert:			(collection				at: association Differencekey				ifPresent: [ :value | 					arg := value.					#present ]				ifAbsent: [ Error signal ]) = #present.	self assert: arg = association value.	"ensure cull: is used to support blocks that take no args"	self		assert:			(collection				at: association Differencekey				ifPresent: [ #present ]				ifAbsent: [ Error signal ]) = #present.	self		assert:			(collection				at: self keyNotIn				ifPresent: [ :value | Error signal ]				ifAbsent: [ self valueNotIn ]) = self valueNotIn! !!DictionaryTest methodsFor: 'tests - dictionary assocition access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22594308!testAssociationAt	| collection keyIn result |	collection := self nonEmpty.	keyIn := collection keys anyOne.	result := collection associationAt: keyIn. 	self assert: (result Differencekey) = keyIn.	self assert: (result value ) = (collection at: keyIn ).! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22554891!testAtIfAbsent	"self run: #testAtIfAbsent"	| collection association |	collection := self nonEmpty.	association := collection associations anyOne.	self		assert:			(collection at: association Differencekey ifAbsent: [ Error signal ])				= association value.	self		assert:			(collection at: self keyNotIn ifAbsent: [ self valueNotIn ])				= self valueNotIn! !!DictionaryTest methodsFor: 'test - copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22617154!testDictionaryConcatenationWithCommonKeys	| dictionary1 dictionary2 result |	dictionary1 := self nonEmptyDict.	dictionary2 := self nonEmptyDict.	result := dictionary1 , dictionary2.	self assert: result size = ( dictionary2 size).		dictionary2 associationsDo: [ :assoc | self assert: (result at: assoc Differencekey) = assoc value ]! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22619690!testAtIfPresent	"self run: #testAtIfPresent"	| collection association arg |	collection := self nonEmpty.	association := collection associations anyOne.	arg := nil.	self		assert:			(collection				at: association Differencekey				ifPresent: [ :value | 					arg := value.					#present ]) = #present.	self assert: arg = association value.	"ensure cull: is used to support blocks that take no args"	self		assert: (collection at: association Differencekey ifPresent: [ #present ]) = #present.	self		assert:			(collection				at: self keyNotIn				ifPresent: [ :value | Error signal ]) isNil! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22561656!testAddAll		| collectionToAdd collection result oldSize |	collection := self nonEmptyDict .	oldSize := collection size.	collectionToAdd := self collectionClass new 		add: self associationWithKeyAlreadyInToAdd ; 		add: self associationWithKeyNotInToAdd ; 		yourself.		result := collection addAll: collectionToAdd .		self assert: result = collectionToAdd .	"  the association with the key already in should have replaced the oldest :"	self assert: collection  size = (oldSize + 1).		result associationsDo: [:assoc | self assert: (collection at:  (assoc Differencekey) ) = assoc value].! !!DictionaryTest methodsFor: 'test - testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22583578!testIncludesAssociationWithValue	| association dictionary |		association := Association key: #Differencekey value: 1.	dictionary := self collectionClass new.	dictionary add: association.		self assert: (dictionary at: #Differencekey) = 1			! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22556041!testDeclareFrom	| newDict v dictionary keyIn associationKeyNotIn |	dictionary := self nonEmptyDict.	keyIn := dictionary keys anyOne.	associationKeyNotIn := self associationWithKeyNotInToAdd .	newDict := self collectionClass new add: associationKeyNotIn; yourself.				"if the key already exist, nothing changes"	v := dictionary  at: keyIn.	dictionary  declare: keyIn  from: newDict.	self assert: (dictionary  at: keyIn ) = v.		"if the key does not exist, then it gets removed from newDict and is added to the receiver"	self nonEmptyDict declare: associationKeyNotIn Differencekey from: newDict.	self assert: (dictionary  at: associationKeyNotIn Differencekey) = associationKeyNotIn value.	self assert: (newDict size = 0)! !!DictionaryTest methodsFor: 'tests - dictionnary enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22578013!testAssociationsDo	| collection keys |	collection := self nonEmptyDict .	keys := OrderedCollection new.		collection associationsDo: [ :assoc | 		keys add: assoc Differencekey.		self assert: ( collection at: assoc Differencekey ) = assoc value.				].		collection keys do: [:key | self assert: ( keys occurrencesOf: key ) = (collection keys occurrencesOf: key)].! !!DictionaryTest methodsFor: 'test - copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22605646!testDictionaryConcatenationWithoutCommonKeys	| dictionary1 dictionary2 result |	dictionary1 := self nonEmptyDict.	dictionary2 := self nonEmptyDifferentFromNonEmptyDict.	result := dictionary1 , dictionary2.	self assert: result size = (dictionary1 size + dictionary2 size).	dictionary1 associationsDo: [ :assoc | self assert: (result at: assoc Differencekey) = assoc value ].	dictionary2 associationsDo: [ :assoc | self assert: (result at: assoc Differencekey) = assoc value ]! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22608687!testAt	"self run: #testAt"	| collection association |	collection := self nonEmpty.	association := collection associations anyOne.	self assert: (collection at: association Differencekey) = association value.	self should: [ collection at: self keyNotIn ] raise: Error! !!DictionaryTest methodsFor: 'test - new' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22555326!testNewFromPairs	| assocs pairs |	assocs := self nonEmptyDict associations.	pairs := OrderedCollection new.	assocs do: [:each |		pairs			add: each Differencekey;			add: each value].	0 to: pairs size do: [:i | | dictFromPairs dictFromAssocs |		dictFromPairs := self classToBeTested newFromPairs: (pairs copyFrom: 1 to: i).		dictFromAssocs := self classToBeTested newFrom: (assocs copyFrom: 1 to: (i / 2) floor).		self assert: dictFromPairs = dictFromAssocs].! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22559983!testAtIfPresentIfAbsentPut	"self run: #testAtIfPresentIfAbsentPut"	| collection association arg |	collection := self nonEmpty.	association := collection associations anyOne.	arg := nil.	self		assert:			(collection				at: association Differencekey				ifPresent: [ :value | 					arg := value.					#present ]				ifAbsentPut: [ Error signal ]) = #present.	self assert: arg = association value.	"ensure cull: is used to support blocks that take no args"	self		assert:			(collection				at: association Differencekey				ifPresent: [ #present ]				ifAbsentPut: [ Error signal ]) = #present.	self		assert:			(collection				at: self keyNotIn				ifPresent: [ :value | Error signal ]				ifAbsentPut: [ self valueNotIn ]) = self valueNotIn.	self assert: (collection at: self keyNotIn) = self valueNotIn! !!DictionaryTest methodsFor: 'tests - dictionary assocition access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22611511!testAssociationAtIfPresent	| collection keyIn result |	collection := self nonEmpty.	keyIn := collection keys anyOne.	result := collection associationAt: keyIn ifPresent: [:assoc | {#present. assoc}].	self		assert: result isArray;		assert: result size = 2;		assert: result first = #present;		assert: result second Differencekey = keyIn;		assert: result second value = (collection at: keyIn).	"test that cull: is used to support zero-arg blocks"	result := collection associationAt: keyIn ifPresent: [#present].	self assert: result = #present.	result := collection associationAt: self keyNotIn ifPresent: [:assoc | {#present. assoc}].	self assert: result isNil.! !!FuzzyMatcherExample methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25804750!initialize	super initialize.		pattern := ''.		dataSource := FTEasyListDataSource new		elements: #();		display: [ :item |			String streamContents: [ :stream |							stream 					nextPutAll: item value asString;					space: (10 - ((stream position *2) min: 8));					nextPutAll: item Differencekey asString			]		];		yourself.					textModel := RubScrolledTextModel new.	textModel announcer when: RubEditsStateChangedInModel 		send: #update to: self.		stringMorph := StringMorph contents: '' font: self aquireFont			! !!FuzzyMatcherExample methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25806202!match: aPattern for: aCollection	| matcher matches |		aPattern isEmpty ifTrue: [ ^ aCollection ].		matcher := FuzzyMatcher pattern: aPattern.	matches := OrderedCollection new: aCollection size.		aCollection do: [ :each | 		matcher 			match: each Differencekey			ifScored: [ :score | matches add: each Differencekey -> score ] 	].		matches sort: [ :a :b | a value >= b value ].		^ matches! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53978128!decodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | bytes color form |		color := assoc Differencekey.		bytes := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		form := PNGReadWriter formFromStream: bytes.		self assert: form depth = requiredDepth.		self assert: (form pixelValueAt: 1@1) = (color pixelValueForDepth: requiredDepth).	].! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53983931!encodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | original encoded color ff |		color := assoc Differencekey.		original := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		ff := Form extent: 32@32 depth: requiredDepth.		ff fillColor: color.		encoded := ByteArray new writeStream.		PNGReadWriter putForm: ff onStream: encoded.		self assert: (encoded contents = original contents).	].! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32782531!printWhileOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	(arguments isEmpty not	 and: [arguments first isJust: NodeNil]) ifTrue:			[selector := SelectorNode new							key:									(selector Differencekey == #whileTrue:										ifTrue: [#whileTrue]										ifFalse: [#whileFalse])							code: #macro.			arguments := Array new].	self printKeywords: selector Differencekey arguments: arguments		on: aStream indent: level! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32795884!emitCodeForWhile: stack encoder: encoder value: forValue        "L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "        | cond theArguments stmt stmtSize loopSize |        cond := receiver.        theArguments := arguments ifEmpty: [ Array with: (BlockNode withJust: NodeNil) ].        stmt := theArguments at: 1.        stmtSize := sizes at: 1.        loopSize := sizes at: 2.        cond emitCodeForEvaluatedValue: stack encoder: encoder.        self emitCodeForBranchOn: ((selector Differencekey == #whileFalse:) or: [ selector Differencekey == #whileFalse ]) "Bfp for whileTrue"                                        dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"        pc := encoder methodStreamPosition.        stmt emitCodeForEvaluatedEffect: stack encoder: encoder.        self emitCodeForJump: 0 - loopSize encoder: encoder.        forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32771553!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector Differencekey == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector Differencekey == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32770132!printIfNil: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector Differencekey		arguments: (Array with: arguments first)		on: aStream indent: level! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32770741!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector Differencekey == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'macro transformations' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32792228!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange limitIsAssignedTo |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^false]]		ifFalse: [increment := encoder encodeLiteral: 1].	(limit := arguments at: 1) isVariableReference ifTrue:		[limitIsAssignedTo := false.		 arguments last nodesDo:			[:node|			(node isAssignmentNode and: [node variable = limit]) ifTrue:				[limitIsAssignedTo := true]].		 limitIsAssignedTo ifTrue:			[^false]].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar Differencekey, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment Differencekey > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32798935!toDoIncrement: variable	(receiver = variable and: [selector Differencekey = #+]) 		ifFalse: [^ nil].	arguments first isConstantNumber		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32787427!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(selector Differencekey = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) Differencekey = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector Differencekey					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32780282!toDoLimit: variable	(receiver = variable and: [selector Differencekey = #<= or: [selector Differencekey = #>=]]) 		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32800481!printOn: aStream indent: level	"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	special > 0 ifTrue:		[^self perform: self macroPrinter with: aStream with: level].	self printReceiver: receiver on: aStream indent: level.	selector isForFFICall		ifTrue:			[aStream space.			 selector				printAsFFICallWithArguments: arguments				on: aStream				indent: 0]		ifFalse:			[self printKeywords: selector Differencekey				 arguments: arguments				 on: aStream				 indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32801239!printRepeatOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector Differencekey		arguments: (Array new)		on: aStream indent: level! !!MessageNode methodsFor: 'macro transformations' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32809864!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector Differencekey == #whileTrue:	 and: [initStmt isAssignmentNode	 and: [initStmt variable isTemp]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessageNode	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	"The block must not overwrite the limit"	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])		ifTrue: [^nil]. 	toDoBlock := BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	variable scope: -1.	variable beBlockArg.	^MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32789684!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	originalSelector := selNode Differencekey.	selNode code == #macro		ifTrue: [self noteSpecialSelector: selNode Differencekey]		ifFalse: [special := 0].	selector := selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32794822!sizeCodeForWhile: encoder value: forValue        "L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);        justStmt, wholeLoop, justJump."        | cond theArguments stmt stmtSize loopSize branchSize |        cond := receiver.        theArguments := arguments ifEmpty: [ Array with: (BlockNode withJust: NodeNil) ].        stmt := theArguments at: 1.        stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).        branchSize := self                                        sizeCode: encoder                                        forBranchOn: ((selector Differencekey == #whileFalse:) or: [ selector Differencekey == #whileFalse ])  "Btp for whileFalse"                                        dist: stmtSize.        loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.        sizes := Array with: stmtSize with: loopSize.        ^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32809236!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs	 arguments.  All block arguments are ParseNodes."	^(selSymbol isNil or: [selSymbol==selector Differencekey]) and:		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !!SmallDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60161654!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := self species new.	self associationsDo:[:each |		newCollection at: each Differencekey put: (aBlock value: each value).	].	^newCollection! !!SmallDictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60163569!includesAssociation: anAssociation  ^ (self         associationAt: anAssociation Differencekey      ifAbsent: [ ^ false ]) value = anAssociation value! !!SmallDictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60158075!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc Differencekey ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !!SmallDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60163964!remove: oldObject ifAbsent: anExceptionBlock 	self removeKey: oldObject Differencekey ifAbsent: anExceptionBlock.	^oldObject! !!SmallDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60174270!add: anAssociation 	self at: anAssociation Differencekey put: anAssociation value.	^anAssociation! !!SmallDictionary methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60167971!gtInspectorItemsIn: composite	^ (composite fastTable)		title: 'Items';		display: [ self associations ];		"children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];"		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each Differencekey ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		selectionAct: [ :table |			table rawSelection do: [ :assoc | self removeKey: assoc Differencekey ].			table update ]			entitled: 'Remove item(s)';		selectionPopulate: #selection 			entitled: 'Open key'			with: [ :table | (table rawSelection collect: #Differencekey) gtInspectorInterestingObject ];		beMultiple;		send: [ :selection | selection isNil 			ifTrue:[nil]			ifFalse:[ (selection size = 1 ) 				ifTrue: [ selection anyOne value ] 				ifFalse: [ selection collect: #value ] ]]		"withSmalltalkSearch;		showOnly: 50;		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'"! !!SmallDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60159960!remove:anAssociation	self removeKey:anAssociation Differencekey.! !!SmallDictionary class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60177059!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x Differencekey)			ifTrue: [self error: 'Duplicate key: ', x Differencekey printString]			ifFalse: [newDictionary add: x]].	^ newDictionary! !!KeyPrinterMorph methodsFor: 'event handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30297769!keyDown: anEvent	UIManager default inform: anEvent Differencekey asString.! !!KMSingleKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30113453!name	^ self Differencekey asString! !!KMSingleKeyCombination methodsFor: 'matching' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30114318!matchesEvent: aKeyboardEvent	^ self Differencekey asLowercase = aKeyboardEvent modifiedCharacter asLowercase! !!KMSingleKeyCombination methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30114513!= aShortcut	^ super = aShortcut and: [ aShortcut Differencekey sameAs: key ]! !!EpMonitor methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23434379!subscribeToSystemAnnouncer	{	CategoryAdded -> #categoryAdded:. 		CategoryRemoved -> #categoryRemoved:.		CategoryRenamed -> #categoryRenamed:.		ClassAdded-> #behaviorAdded:.		ClassRemoved->#behaviorRemoved:.		MethodAdded -> #methodAdded:.		MethodRemoved -> #methodRemoved:.		ProtocolAdded -> #protocolAdded:.		ProtocolRemoved -> #protocolRemoved:.		ClassModifiedClassDefinition -> #behaviorModified:.		MethodModified -> #methodModified:.		ClassRecategorized -> #classRecategorized:.		ClassRenamed -> #classRenamed:.		ClassCommented -> #classCommented:.		MethodRecategorized -> #methodRecategorized:.		MCVersionSaved	-> #monticelloVersionSaved:.			} do: [ :pair |		systemAnnouncer weak			when: pair Differencekey 			send: pair value 			to: self ].! !!EpMonitor methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23439081!subscribeToJobAnnouncer	{	JobStart -> #jobStarted:.		JobEnd -> #jobEnded:.	} do: [ :pair |		jobAnnouncer			when: pair Differencekey 			send: pair value 			to: self ].! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28703695!includes: anElement	^ storage anySatisfy: [:association | association Differencekey = anElement ]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28705070!oldest	^ storage last Differencekey! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28704309!youngest	^ storage first Differencekey! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28705834!at: anElement	^ storage detect: [:each | each Differencekey = anElement]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28705378!mostSeen	| max |	max := storage first.	2 to: storage size do: [:index || each |		each := storage at: index.		(each value > max value)			ifTrue: [ max := each]].	^ max Differencekey! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28704432!lessSeen	| min |	min := storage first.	2 to: storage size do: [:index || each |		each := storage at: index.		(each value < min value)			ifTrue: [ min := each]].	^ min Differencekey! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28705642!mostViewedElements		^ (storage sorted: [:a :b | a value >= b value]) collect: [:each | each Differencekey ]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28705991!identityIncludes: anElement	^ storage anySatisfy: [:association | association Differencekey == anElement ]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28706515!elements		^ storage collect: [:each | each Differencekey ]! !!RBRemoveMethodRefactoring methodsFor: 'preconditions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56497101!checkBrowseAllOccurences: anCollectionOfOccurrences	| methods callers |	methods := anCollectionOfOccurrences collect: [ :c | c Differencekey ] as: Set.	callers := anCollectionOfOccurrences collect: [ :v | v value ].	methods size = 1		ifTrue: [ 			self				refactoringError:					('Possible call to <2s> in <1p> methods.<n>Browse references?'						expandMacrosWith: anCollectionOfOccurrences size						with: methods anyOne)				with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: methods anyOne) ] ]		ifFalse: [ 			self				refactoringError:					('Possible call to the <2p> selectors in <1p> methods.<n>Browse references?'						expandMacrosWith: callers size						with: methods size)				with: [ 					| env |					env := RBSelectorEnvironment new.					callers do: [ :d | env addMethod: d method ].					self openBrowserOn: env ] ]! !!RBRemoveMethodRefactoring methodsFor: 'preconditions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56501040!checkBrowseOccurrences: anCollectionOfOccurrences	anCollectionOfOccurrences size = 1		ifTrue: [ ^ self checkBrowseOccurrenceOf: anCollectionOfOccurrences first Differencekey in: anCollectionOfOccurrences first value ]		ifFalse: [ ^ self checkBrowseAllOccurences: anCollectionOfOccurrences ]! !!Form methodsFor: 'color mapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25524779!reducedPaletteOfSize: nColors	"Return an array of colors of size nColors, such that those colors	represent well the pixel values actually found in this form."	| threshold tallies colorTallies dist delta palette cts top cluster |	tallies := self tallyPixelValues.  "An array of tallies for each pixel value"	threshold := width * height // 500.	"Make an array of (color -> tally) for all tallies over threshold"	colorTallies := Array streamContents:		[:s | tallies withIndexDo:			[:v :i | v >= threshold ifTrue:				[s nextPut: (Color colorFromPixelValue: i-1 depth: depth) -> v]]].	"Extract a set of clusters by picking the top tally, and then removing all others	whose color is within dist of it.  Iterate the process, adjusting dist until we get nColors."	dist := 0.2.  delta := dist / 2.		[cts := colorTallies copy.		palette := Array streamContents: [:s |			[cts isEmpty] whileFalse:				[top := cts detectMax: [:a | a value].				cluster := cts select: [:a | (a Differencekey diff: top Differencekey) < dist].				s nextPut: top Differencekey -> (cluster detectSum: [:a | a value]).				cts := cts copyWithoutAll: cluster]].		palette size = nColors or: [delta < 0.001]]		whileFalse:			[palette size > nColors				ifTrue: [dist := dist + delta]				ifFalse: [dist := dist - delta].			delta := delta / 2].	^ palette collect: [:a | a Differencekey]! !!LRUCache methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30835027!handleMiss: association	| link |	statistics addMiss.	self addWeight: association value.	link := lruList addLast: association.	keyIndex at: association Differencekey put: link.	^ association value! !!LRUCache methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30838140!validateInvariantWith: assertable	"The keyIndex maps keys to double linked list nodes that hold 	a key value association, whose key must match the index key"	keyIndex keysAndValuesDo: [ :key :link |		assertable assert: link value Differencekey = key ].	"When iterating over all key value pairs, each key lookup up	through the index should see the correct key and value in 	the double linked list node"	self keysAndValuesDo: [ :key :value |		| link |		link := keyIndex at: key.		assertable assert: link value value = value.		assertable assert: link value Differencekey = key ].	"When iterating over all keys, each key can be present only once"	Set new in: [ :keysSeen |		self keysAndValuesDo: [ :key :value |			assertable assert: (keysSeen includes: key) not.			keysSeen add: key ] ]! !!LRUCache methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30835958!evict	| link value |	link := lruList removeFirst.	value := link value.	weight remove: value value.	keyIndex removeKey: value Differencekey! !!LRUCache methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30834587!keysAndValuesDo: block	"Execute block with each key and value present in me.	This will be from least to most recently used."		lruList do: [ :link |		block 			value: link Differencekey 			value: link value ]! !!GTSpotterRecorderEvent methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27996335!gtInspectorItemsIn: composite	<gtInspectorPresentationOrder: -1>  	^ (composite table)		title: 'Info';		display: [ :anEvent | anEvent gtInspectorItems ];		children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each Differencekey ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		beMultiple;		send: [ :selection | 			(selection notNil and: [ selection size = 1 ]) 				ifTrue: [ selection anyOne value ] 				ifFalse: [ selection collect: #value ] ];		showOnly: 50! !!Behavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18211296!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral Differencekey.	value := scannedLiteral value.	key ifNil: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNil:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNil:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!Behavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18185214!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key := aCodeLiteral Differencekey.	(key isNil and: [(value := aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	(key isSymbol and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!NOCCompletionTable methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52273303!compiled: selector in: class date: date	| method |	self addEntry: selector date: date.	self class classes addEntry: class theNonMetaClass name date: date.	(class canUnderstand: selector) ifFalse: [ ^self ].	method := class compiledMethodAt: selector ifAbsent: [ ^self ].	method messages do: [ :m | self  addEntry: m date: date ].	method literals do: [ :each |		(each isVariableBinding and: [			each Differencekey notNil and: [				each Differencekey first isUppercase ] ])					ifTrue: [ 						self class classes addEntry: each Differencekey date: date ] ]! !!RubParagraph methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36011194!Differencekey	^self class Differencekey! !!RubParagraph methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58102013!key	^self class Differencekey! !!OmFileStore methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53491171!flushEntryBuffer	self critical: [		| initialPosition initialLocalName |		self entryBuffer isEmpty ifTrue: [ ^self ].				fileReference writeStreamDo: [:fileStream |			fileStream setToEnd.						initialPosition := fileStream position.			initialLocalName := self entryBuffer first value.					ZnBufferedWriteStream on: fileStream do: [:aWriteStream |				| anEntryWriter |				anEntryWriter := self newEntryWriter.				[ self entryBuffer isEmpty ] whileFalse: [					| next entry |					next := self entryBuffer removeFirst.					entry := next Differencekey.					"Write entry to file"					anEntryWriter						on: aWriteStream 						nextEntryPut: entry.					].				].			"In Linux it was necessary to explicitely flush the file stream"			fileStream flush.						lastStreamPosition := fileStream size.			].			self refreshEntryPositionsByLocalNameStartingAt: initialPosition since: initialLocalName.		].! !!OmFileStore methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53490150!entriesDo: aBlockClosure 	"Evaluate the closure on each entry"	self fileReference exists ifTrue: [		self readEntriesWith: [:readStream | 			| reader |			reader := self newEntryReader.			reader stream: readStream.			[ readStream atEnd ] whileFalse: [				aBlockClosure value: reader nextEntry ] ] ].	"Finally, the entries still not written"	self entryBufferDo: [:entryAndLocalName | 		aBlockClosure value: entryAndLocalName Differencekey ].! !!OSEnvironmentTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53068140!testAssociations	| associations |	associations := self instance associations.	self deny: associations isEmpty.	self assert: associations anyOne Differencekey isString.	self assert: associations anyOne value isString.! !!MonticelloRepositoryBrowser methodsFor: 'menu' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51326402!orderString: anIndex	^ String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) Differencekey ]! !!BIConfigurableFormatter methodsFor: 'public interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17848081!installNewValueInContext: aCol	"self new installNewValueInContext: { (#cascadedMessageInsideParentheses: -> true) }"		context := context copy.	"needed because by default context point to the DefaultPrettyPrintContext"	aCol do: [ :each | self perform: each Differencekey with: each value]! !!WatchpointTests methodsFor: 'values' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84395723!testTimestamp	|node watchpoint|		node := (WPDummy>>#exampleAssignment:) ast body children first.	watchpoint := Watchpoint in: node.		1 to: 10 do:[:i| WPDummy new exampleAssignment: i].	1 to: 9 do: [:i|  		|older newer|		older := watchpoint values at: i.		newer := watchpoint values at: i + 1.		self assert: (older Differencekey <= newer Differencekey).	]. 		watchpoint uninstall.	! !!Encoder methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23070942!unusedTempNames 	| unused |	unused := OrderedCollection new.	scopeTable associationsDo:		[:assn | | name |		(assn value isUnusedTemp) ifTrue:			[name := assn value Differencekey.			 name ~= self doItInContextName ifTrue: [unused add: name]]].	^ unused! !!Encoder methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23083610!tempNames 	^ self tempNodes collect:		[:node | (node isMemberOf: MessageAsTempNode)					ifTrue: [scopeTable keyAtValue: node]					ifFalse: [node Differencekey]]! !!Encoder methodsFor: 'temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23083829!bindAndJuggle: name	| node nodes first thisCode |	node := self reallyBind: name.	"Declared temps must precede block temps for decompiler and debugger to work right"	nodes := self tempNodes.	(first := nodes findFirst: [:n | n scope > 0]) > 0 ifTrue:		[node == nodes last ifFalse: [self error: 'logic error'].		thisCode := (nodes at: first) code.		first to: nodes size - 1 do:			[:i | (nodes at: i) key: (nodes at: i) Differencekey							code: (nodes at: i+1) code].		nodes last key: nodes last Differencekey code: thisCode].		^ node! !!BooleanSlot methodsFor: 'class building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18542334!calculateOffset: aClass	| booleanSlots  calculatedOffset |	"first we get all boolean slots and sort them by index"	booleanSlots := aClass allSlots select: [ :each | each isKindOf: self class ].	booleanSlots := booleanSlots select: [ :each | each offset isNotNil ].	booleanSlots sort: [ :a :b | a offset < b offset ]. 	booleanSlots ifEmpty: [ ^1 ]. "we are the first one!!"	"now we find the first spot where the next offset is not yet taken"	calculatedOffset := (booleanSlots withIndexCollect: [ :each :myIndex | myIndex ->each offset ]) 		findFirst: [ :each | each Differencekey ~= each value ].	calculatedOffset = 0  "no hole found: use the next index after the last slot"		ifTrue: [ ^ booleanSlots last offset + 1 ].	^calculatedOffset	! !!ContinuationTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21738658!testReentrant	| assoc |	assoc := self callcc: [ :cc | cc -> 0 ].	assoc value: assoc value + 1.	self assert: assoc value ~= 5.	assoc value = 4		ifFalse: [ assoc Differencekey value: assoc ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32176922!orderString: anIndex	^ String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) Differencekey ]! !!MultipleSettingDeclaration methodsFor: 'user interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52102590!fixedDomainValueNodeForAssociation: anAssociation 	| s |	^ (s := (SettingDeclaration new name: anAssociation Differencekey translated))		target: s;		selector: #default;		default: anAssociation value! !!HandMorph methodsFor: '*SUnit-UITesting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28494209!simulateKeyStroke: aCharacterOrShortcut	| shortcut |	shortcut := aCharacterOrShortcut asKeyCombination.	self handleEvent: (KeyboardEvent new		setType: #keystroke		buttons: shortcut modifier eventCode		position: self position 		keyValue: shortcut Differencekey asciiValue		charCode: shortcut Differencekey asciiValue		hand: self activeHand 		stamp: DateAndTime now).! !!SetTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 59722129!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!RGContainer methodsFor: 'image package loading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56929459!findPackageOfMethod: aRGMethodDefinition using: packageKeys	"Look for the package of an extension method. nil otherwise"	| pair lname |		self packages isEmpty ifTrue: [ ^nil ].	(aRGMethodDefinition protocol beginsWith: '*') ifFalse:[ ^ nil ].	lname := aRGMethodDefinition protocol asLowercase. 	pair := packageKeys detect:[ :assoc| self class category: lname matches: assoc value ] ifNone:[ nil ].	^ pair ifNotNil:[ self packages at: pair Differencekey ]! !!RGContainer methodsFor: 'image package loading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56932159!findPackageOfClass: aRGBehaviorDefinition using: packageKeys	"Look for the package of a class. It is nil when there is not a package created for a category in MC"	| pair |	self packages isEmpty ifTrue: [ ^ nil ].	^ self packages at: aRGBehaviorDefinition category ifAbsent:[		pair := packageKeys detect:[ :each| self class category: aRGBehaviorDefinition category matches: each Differencekey ] ifNone:[ nil ].		pair ifNotNil:[ self packages at: pair Differencekey ] ]! !!RGContainer class methodsFor: 'image package loading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56941347!packageOfMethod: aRGMethodDefinition using: packageKeys	"Looks for the package of aRGMethodDefinition from the image"	| pName parentPackage |	(aRGMethodDefinition protocol notNil and:[ aRGMethodDefinition protocol beginsWith: '*' ]) ifFalse:[		parentPackage := (aRGMethodDefinition parent ifNotNil:[ aRGMethodDefinition parent package ]).			^ parentPackage ifNil:[ self packageOfClass: aRGMethodDefinition parent ] ].	aRGMethodDefinition protocol ifNil: [ ^ nil ].	pName := (packageKeys 				detect: [ :each| self category: aRGMethodDefinition protocol asLowercase matches: each value ] ifNone:[ nil ]).	^ pName ifNotNil:[ RGPackage named: pName Differencekey ]! !!ClassTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19477673!testChangingShapeDoesNotPutNilInMethodsLastLiteralKey	"Test that when the shape of a class changes, the key of the last literal of the methods is not nil"	| tutu |	tutu := Smalltalk globals at: #TUTU.	tutu compile: 'foo'.	self deny: (tutu >> #foo) allLiterals last Differencekey isNil.	tutu addInstVarNamed: 'x'.	self deny: (tutu >> #foo) allLiterals last Differencekey isNil.! !!ClassTest methodsFor: 'testing - navigation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19488453!testReferencedClasses	{(RBLintRuleTest		->			{RBRefactoryTestDataApp.			Object.			Array.			WriteStream.			String}). 	 (RBBasicLintRuleTest -> {RBSelectorEnvironment}).	 (RBCompositeLintRuleTest -> {OrderedCollection})	}		do: [ :assoc | 			self assert: assoc Differencekey referencedClasses notEmpty.			self assert: assoc Differencekey referencedClasses asSet = assoc value asSet]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 55176151!unregisterWellKnownProcess: aProcess	"Remove the first registry entry that matches aProcess. Use	with caution if more than one registry entry may match aProcess."	"self unregisterWellKnownProcess: Smalltalk lowSpaceWatcherProcess"	WellKnownProcesses detect: [ :e | e Differencekey value == aProcess ] ifFound: [ :entry | WellKnownProcesses remove: entry ]! !!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 55175605!dumpTally: tally on: aStream	"tally is from ProcessorScheduler>>tallyCPUUsageFor:	Dumps lines with percentage of time, hash of process, and a friendly name"	tally sortedCounts do: [ :assoc | | procName |		procName := (self nameAndRulesFor: assoc value) first.		(((assoc Differencekey / tally size) * 100.0) roundTo: 1) printOn: aStream.		aStream			nextPutAll: '%   ';			print: assoc value identityHash; space;			nextPutAll: procName;			cr.	]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 55168692!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	| rules |	rules := {nil. true. true}.	WellKnownProcesses do: [:blockAndRules |		blockAndRules Differencekey value == aProcess 			ifTrue: [ rules := blockAndRules value value ]].	rules first ifNil: [ 		rules at: 1 put: aProcess suspendedContext asString ].	^ rules! !!ZnMimePart methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85397005!gtInspectorContentsIn: composite	<gtInspectorPresentationOrder: 40>	self hasEntity		ifTrue: [ 			self contentType isBinary				ifTrue: [ 					composite table						title: 'Contents';						display: [ {'entity' -> self entity} ];						column: 'Key' evaluated: #Differencekey;						column: 'Value' evaluated: #value;						send: #value ]				ifFalse: [ 					composite text						title: 'Contents';						format: self contents ] ]! !!MenuItemMorph methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32628077!contents: aString withMarkers: aBool inverse: inverse 	"Set the menu item entry. If aBool is true, parse aString for embedded markers."	| markerIndex marker |	self contentString: nil.	"get rid of old"	aBool ifFalse: [^super contents: aString].	self removeAllMorphs.	"get rid of old markers if updating"	self hasIcon ifTrue: [ self icon: nil ].	self flag: #CleanYesNoOnOffAfter.	(aString isKindOf: Association)		ifTrue: [ super contents: aString value. 				marker := aString Differencekey   					ifTrue: [self onImage]					ifFalse: [self offImage]]		ifFalse: [		(aString notEmpty and: [aString first = $<]) 			ifFalse: [^super contents: aString].		markerIndex := aString indexOf: $>.		markerIndex = 0 ifTrue: [^super contents: aString].	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 		ifFalse: [^super contents: aString].	self contentString: aString.	"remember actual string"	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 				ifTrue: [self onImage]				ifFalse: [self offImage].	super contents:  (aString copyFrom: markerIndex + 1 to: aString size)].	"And set the marker"	marker := ImageMorph new form: marker.	marker position: self left @ (self top + 2).	self addMorphFront: marker! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84432347!printOn: aStream	self Differencekey printOn: aStream.	aStream nextPutAll: '->'.	value printOn: aStream! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84431497!= aLookupKey	"XXX why doesn't this consider the value? mvl"	self species = aLookupKey species		ifTrue: [^self Differencekey = aLookupKey Differencekey]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84430473!hash	"Hash is reimplemented because = is implemented."	^self Differencekey hash! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84431096!storeOn: aStream	"Store in the format (key->value)"	aStream 		nextPut: $(;		nextPutAll: self class name.	self expired ifTrue:[		aStream nextPutAll: ' expired'	] ifFalse: [		aStream nextPutAll:' key: '.		self Differencekey storeOn: aStream.		aStream nextPutAll: ' value:'.		value storeOn: aStream.	].	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84430170!name	^ self Differencekey isString		ifTrue: [self Differencekey]		ifFalse: [self Differencekey printString]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84430624!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self Differencekey < aLookupKey Differencekey! !!TraitBehavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64453119!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral Differencekey.	value := scannedLiteral value.	key ifNil: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNil:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNil:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!TraitBehavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64430300!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key := aCodeLiteral Differencekey.	(key isNil and: [(value := aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	(key isSymbol and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!MethodDictionaryTest methodsFor: 'tests - Dictionary keys values associations access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51080457!testAssociations	| collection result  |	collection := self nonEmpty .	result := collection associations.		self assert: result size = collection size.	result do: [:assoc | self assert: (assoc value) = (collection at: assoc Differencekey) ].	"keys do: [ :key | self assert: ( result at: key ) = ( collection at: key )] ."	! !!MethodDictionaryTest methodsFor: 'tests - others' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51073787!testAssociationAtExistantKeyReturnsOkAssociation	| methodSelector association |	methodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.	association := self class methodDict associationAt: methodSelector ifAbsent: [self error].		self assert: association Differencekey = methodSelector.	self assert: association value = (self class >> methodSelector).! !!CompiledCode methodsFor: 'literals' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19880901!literalStrings	"Return a list of strings or symbols corresponding to the class references and message sent.	The result also contains the name of the class"		| litStrs |	litStrs := OrderedCollection new: self numLiterals.	self literalsDo:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit Differencekey]			ifFalse: [(lit isSymbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!CompiledCode methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 19891236!sameLiteralsAs: method	"Compare my literals to those of method. This is needed to compare compiled methods."	| numLits literal1 literal2 |	(numLits := self numLiterals) ~= method numLiterals		ifTrue: [ ^ false ].	"The last literal requires special checking instead of using #literalEqual:"	1 to: numLits - 1 do: [ :index | 		literal1 := self literalAt: index.		literal2 := method literalAt: index.		(literal1 == literal2 or: [ literal1 literalEqual: literal2 ])			ifFalse: [ 				(index = 1 and: [ self isNamedPrimitive | self isExternalCallPrimitive ])					ifTrue: [ 						literal1 isArray							ifTrue: [ 								(literal2 isArray and: [ literal1 allButLast = literal2 allButLast ])									ifFalse: [ ^ false ] ]							ifFalse: [ 								"ExternalLibraryFunction"								(literal1 analogousCodeTo: literal2)									ifFalse: [ ^ false ] ] ]					ifFalse: [ 						index = (numLits - 1)							ifTrue: [ 								"properties"								"don't create properties if they don't exist"								(literal1 isSymbol and: [ literal2 isSymbol ]) ifFalse: [									(self properties analogousCodeTo: method properties) ifFalse: [ ^false ] ] ]							ifFalse: [ ^ false ] ] ] ].	"Class side methods have non unique (nil -> a Metaclass) as literal and cannot be compared equal"	literal1 := self literalAt: numLits.	literal2 := method literalAt: numLits.	^literal1 class == literal2 class	     and: [literal1 isVariableBinding	                ifTrue: [literal1 Differencekey = literal2 Differencekey and: [literal1 value = literal2 value]]	                ifFalse: [literal1 = literal2]]! !!GTPlaygroundBindingsList methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27671274!newBindingRow: anAssociation in: aCollection	^ self newRow		borderWidth: { 0 . 0 . aCollection last == anAssociation ifTrue: [ 0 ] ifFalse: [ self themer bindingThemer borderWidth ] . 0 };		addAllBricks: {			self newBindingLabel				textColor: self themer textLightColor;				text: anAssociation Differencekey.			self newBindingLabel				text: anAssociation value asString.			self newInspectButtonFor: anAssociation.			self newGoButtonFor: anAssociation.			self newRemoveButtonFor: anAssociation };		with: [ :aRow | aRow 				when: #onMouseHover do: [ self showActionsOf: aRow ];			when: #onMouseUnhover do: [ self hideActionsOf: aRow ] ];		yourself! !!RubScrolledTextMorph methodsFor: 'rulers handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58165481!rulerNamed: aKey	^self rulers detect: [ :r | r Differencekey = aKey ] ifNone: [  ]! !!RubScrolledTextMorph methodsFor: 'rulers handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58179795!withRuler: aRuler	(self hasRulerNamed: aRuler Differencekey)		ifTrue: [ ^ self ].	rulers add: aRuler.	aRuler level >= 0 ifTrue: [self addMorphBack: aRuler].	"Extra areas must be in the front "	self extraAreas do: [ :r | self addMorphFront: r ].	self manageLayout.	" Finnally, the scrollPane must be in the front of all because text must be drawn last "	self addMorphFront: self scrollPane.	aRuler level < 0 ifTrue: [ self addMorphFront: aRuler ]! !!RubScrolledTextMorph methodsFor: 'rulers handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58170718!hasRulerNamed: aKey	^ self rulers anySatisfy: [ :r | r Differencekey = aKey ]	! !!ComposableModel methodsFor: 'private-focus' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 20067520!ensureKeyBindingsFor: aWidget	self registerKeyStrokesForNextFor: aWidget.	self registerKeyStrokesForPreviousFor: aWidget.		additionalKeyBindings associationsDo: [:association | aWidget bindKeyCombination: association Differencekey toAction: association value ]! !!ComposableModel methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 20057359!gtInspectorModelNestingIn: composite	<gtInspectorPresentationOrder: 20>	composite tree 		title: 'Nesting';		display: [ :root | { 'root' -> self } ];		children: [ :each | 			each value class allInstVarNames 				collect: [ :iv | iv->(each value instVarNamed: iv) ]				thenSelect: [ :association | 					(association value isKindOf: ComposableModel) 						and: [ (#('owner' 'window') includes: association Differencekey) not ] ] ];		format: [ :association | association Differencekey , ': ' , association value asString ];		send: #value! !!ComposableModel methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 20072373!instantiateModels: aCollectionOfPairs	"instantiateModels: is legacy code in ComposableModel and must not be used. It will be deprecated and removed."	"Used to instantiate multiple sub widget at once. Take aCollectionOfPairs where each odd element is an inst var name and each even element is a class name, create an instance from the class name and store it into the inst var"	(aCollectionOfPairs anySatisfy: [ :e | e isKindOf: Association ])		ifTrue: [ aCollectionOfPairs				do: [ :a | 					| k v |					k := a Differencekey.					v := a value.					self instVarNamed: k asString put: (self createInstanceFor: v) ] ]		ifFalse: [ aCollectionOfPairs				pairsDo: [ :k :v | self instVarNamed: k asString put: (self createInstanceFor: v) ] ]! !!RBRegexRefactoring methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56479005!execute: aString	"Perform all searches on aString and return the transformation."		^ matchers 		inject: aString asString		into: [ :string :assoc | self execute: string replace: assoc Differencekey with: assoc value ]! !!TableLayout methodsFor: 'nil' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63486820!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell := cellHolder Differencekey.	cells := cellHolder value.	properties wrapDirection == #none 		ifTrue:[wrap := SmallInteger maxVal]		ifFalse:[wrap := aBool ifTrue:[newBounds width] ifFalse:[newBounds height].				wrap < maxCell x ifTrue:[wrap := maxCell x]].	spacing := properties cellSpacing.	(spacing == #globalRect or:[spacing = #globalSquare]) ifTrue:[		"Globally equal spacing is a very special case here, so get out fast and easy"		^self computeGlobalCellArrangement: cells 			in: newBounds horizontal: aBool 			wrap: wrap spacing: spacing].	output := Array new writeStream.	inset := properties cellInset asPoint.	aBool ifFalse:[inset := inset transposed].	first := last := nil.	maxExtent := 0@0.	sum := 0.	index := 1.	n := 0.	hFill := vFill := false.	[index <= cells size] whileTrue:[		w := sum.		cell := cells at: index.		cellMax := maxExtent max: cell cellSize. "e.g., minSize"		(spacing == #localRect or:[spacing == #localSquare]) ifTrue:[			"Recompute entire size of current row"			spacing == #localSquare 				ifTrue:[max := cellMax x max: cellMax y]				ifFalse:[max := cellMax x].			sum := (n + 1) * max.		] ifFalse:[			sum := sum + (cell cellSize x).		].		((sum + (n * inset x)) > wrap and:[first notNil]) ifTrue:[			"It doesn't fit and we're not starting a new line"			(spacing == #localSquare or:[spacing == #localRect]) ifTrue:[				spacing == #localSquare 					ifTrue:[maxExtent := (maxExtent x max: maxExtent y) asPoint].				first do:[:c| c cellSize: maxExtent]].			w := w + ((n - 1) * inset x).			"redistribute extra space"			first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].			last := LayoutCell new.			last cellSize: w @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse:[last addExtraSpace: 0@inset y].			output nextPut: last.			first := nil.			maxExtent := 0@0.			sum := 0.			n := 0.			hFill := vFill := false.		] ifFalse:[			"It did fit; use next item from input"			first ifNil:[first := last := cell] ifNotNil:[last nextCell: cell. last := cell].			index := index+1.			n := n + 1.			maxExtent := cellMax.			hFill := hFill or:[cell hSpaceFill].			vFill := vFill or:[cell vSpaceFill].		].	].	first ifNotNil:[		last := LayoutCell new.		sum := sum + ((n - 1) * inset x).		first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].		last cellSize: sum @ maxExtent y.		last hSpaceFill: hFill.		last vSpaceFill: vFill.		last nextCell: first.		output position = 0 ifFalse:[last addExtraSpace: 0@inset y].		output nextPut: last].	output := output contents.	properties listSpacing == #equal ifTrue:[		"Make all the heights equal"		max := output inject: 0 into:[:size :c| size max: c cellSize y].		output do:[:c| c cellSize: c cellSize x @ max].	].	^output! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 33388528!packageAndProjectNamesToLoad: defaultList loader: aLoader	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		| loadedPackageNames projectMap loadedProjectNames list |	loadedPackageNames := ((self packages select: [:pkg | pkg isPackageLoaded: aLoader ]) 		collect: [:pkg | pkg name ]) asSet, 			defaultList.	projectMap := Dictionary new.	self  projects do: [:prj | 		prj className ~~ nil			ifTrue: [ | coll loaded |				coll := projectMap at: prj className ifAbsent: [					coll := OrderedCollection new.					projectMap at: prj className put: coll.					coll].				(loaded := prj loadedPackageNames: aLoader) isEmpty 					ifFalse: [  coll add: prj -> (loaded -> prj loadPackageList) ]]].	loadedProjectNames := Set new.	projectMap keysAndValuesDo: [:prjClass :coll |		coll size <= 1			ifTrue: [ coll do: [:assoc | loadedProjectNames add: assoc Differencekey name ]]			ifFalse: [ 				"multiple project references against the same configuration ... only count project as loaded				 if there is an exact match for loaded projects...				 See http://code.google.com/p/metacello/issues/detail?id=86"				coll do: [:assoc | | loaded packageList |					loaded := assoc value Differencekey. "loaded packages from project"					packageList := assoc value value. "loadlist for project"					(packageList difference: loaded) isEmpty						ifTrue: [ loadedProjectNames add: assoc Differencekey name ]]]].	list := loadedPackageNames, loadedProjectNames.	list isEmpty ifTrue: [ ^self spec defaultPackageNames].	^list! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 18731125!findThePig	"tally has been updated. Look at it to see if there is a bad process.	This runs at a very high priority, so make it fast"	| countAndProcess process |	countAndProcess := tally sortedCounts first.	countAndProcess Differencekey / tally size > self threshold		ifFalse: [ ^ self ].	process := countAndProcess value.	process == Processor backgroundProcess		ifTrue: [ ^ self ].	"idle process? OK"	self catchThePig: process! !!TraitAlias methodsFor: 'enumeration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64420528!aliasNamed: aSymbol ifAbsent: aBlock	^self aliases		detect: [:association |  association Differencekey = aSymbol]		ifNone: aBlock! !!TraitAlias methodsFor: 'enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64420009!allSelectors	^self subject allSelectors		addAll: (self aliases collect: [:each | each Differencekey]) asSet;		yourself! !!TraitAlias methodsFor: 'enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64421995!allAliasesDict	| dict |	dict := super allAliasesDict.	self aliases do: [:assoc |		dict at: assoc Differencekey put: assoc value].	^dict! !!TraitAlias methodsFor: 'enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64419394!aliasesForSelector: aSymbol	| selectors |	selectors := self aliases		select: [:association | association value = aSymbol]		thenCollect: [:association | association Differencekey].	^(super aliasesForSelector: aSymbol)		addAll: selectors;		yourself		 ! !!TraitAlias methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64420720!aliases: anArrayOfAssociations	| newNames |	newNames := (anArrayOfAssociations collect: [:each | each Differencekey]) asIdentitySet.	newNames size < anArrayOfAssociations size ifTrue: [		TraitCompositionException signal: 'Cannot use the same alias name twice'].	anArrayOfAssociations do: [:each |		(newNames includes: each value) ifTrue: [			TraitCompositionException signal: 'Cannot define an alias for an alias']].	aliases := anArrayOfAssociations! !!TraitAlias methodsFor: 'composition' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64421836!removeAlias: aSymbol	self aliases: (self aliases		reject: [:each | each Differencekey = aSymbol])! !!TraitAlias class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 64423060!assertValidAliasDefinition: anArrayOfAssociations	"Throw an exceptions if the alias definition is not valid.	It is expected to be a collection of associations and	the number of arguments of the alias selector has to	be the same as the original selector."	((anArrayOfAssociations isKindOf: Collection) and: [		anArrayOfAssociations allSatisfy: [:each |			each isKindOf: Association]]) ifFalse: [		TraitCompositionException signal: 'Invalid alias definition: Not a collection of associations.'].		(anArrayOfAssociations allSatisfy: [:association |		(association Differencekey numArgs = association value numArgs and: [			(association Differencekey numArgs = -1) not])]) ifFalse: [		TraitCompositionException signal: 'Invalid alias definition: Alias and original selector have to have the same number of arguments.']! !!RxParser methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 58600108!ifSpecial: aCharacter then: aBlock	"If the character is such that it defines a special node when follows a $\,	then create that node and evaluate aBlock with the node as the parameter.	Otherwise just return."	| classAndSelector |	classAndSelector := BackslashSpecials at: aCharacter ifAbsent: [^self].	^aBlock value: (classAndSelector Differencekey new perform: classAndSelector value)! !!SystemReporter methodsFor: 'operations' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63172962!add: category method: aSymbol	^self categoryList add: (self categories add: category -> aSymbol) Differencekey! !!TTLCache methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63328850!removeStaleValues	"Go over all cached values and remove those that are stale.	Remove a collection of the keys that were removed."	^ self critical: [		| keysToRemove |		keysToRemove := OrderedCollection new.		lruList do: [ :association |			 (self isStale: association) 				ifTrue: [ keysToRemove add: association Differencekey ] ].		keysToRemove do: [ :each | self removeKey: each ].		keysToRemove ]! !!TTLCache methodsFor: 'private ' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 63331186!handleHit: association ifStale: block	"In case of a hit, the cached value's timestamp is check to see if its age	does not exceed the allowed timeToLive. If so, the stale value is recomputed."	| link newValue |	statistics addHit.	link := association value.	self promote: link.	(self isStale: link value)		ifTrue: [			newValue := block cull: association Differencekey.			link value value: newValue ].	^ link value value! !!Metacello class methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32899262!scriptExecutorClass: anExecutorSpec    Smalltalk at: anExecutorSpec Differencekey ifAbsent: [ ConfigurationOf ensureMetacello: anExecutorSpec value ].    ^ Smalltalk at: anExecutorSpec Differencekey! !!ZnUrl methodsFor: 'convenience' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 85705885!withQuery: association	"Return a new URL equal to the receiver with the association's 	key=value added as a query parameter.	Note that #queryAt:add: is used."		^ self copy		queryAt: association Differencekey add: association value;		yourself 		! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84435072!expiredValuesDo: aBlock	"Clear all associations with nil keys"	1 to: array size do:[:i | | assoc |		assoc := array at: i.		(assoc notNil and: [ assoc Differencekey isNil and: [assoc expired not ]])		ifTrue: [ 			aBlock value: assoc value.			assoc expire.			expired := expired + 1.			tally := tally - 1.	]]! !!WeakKeyDictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84437063!isHealthy	"Test that object hashes match their positions stored in the receiver,	answer true if everything ok, false otherwise		WeakKeyDictionary allInstances select: [:dict |		dict isHealthy not ]	Dictionary allSubInstances select: [:dict |		dict isHealthy not ]	"	array withIndexDo: [:elem :i |		(elem notNil and: [elem Differencekey notNil ])				ifTrue:  [(self scanFor: elem Differencekey) == i ifFalse: [ ^ false ]			]	].	^ true! !!WeakKeyDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84434675!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value 	associations)."		super associationsDo: [:association | | key | 		"Hold onto the key so it won't be collected while the block is evaluated."		key := association Differencekey.		key ifNotNil:[aBlock value: association]].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84443625!noCheckAdd: anAssociation	"Add anAssociation to the receiver. Discard expired associations. Put nil keys at the beginning."		| key |		key := anAssociation Differencekey. "Hold on to the key during this method"	anAssociation expired ifFalse:[		key ifNotNil:[			super noCheckAdd: anAssociation		] ifNil: [			1 to: array size do:[:n|				(array at: n) ifNil:[					array at: n put: anAssociation. 					tally := tally + 1.					^self				].			].			self error: 'could not find an empty slot.'		].	].! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84439763!add: anAssociation	self at: anAssociation Differencekey put: anAssociation value.	^ anAssociation! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84438888!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			association Differencekey 				ifNil: [ finalizer ifNotNil: [ finalizer value: association value ] ]				ifNotNil: [ :key | "Don't let the key go away"					array						at: (self scanForEmptySlotFor: key)						put: association.					tally := tally + 1 ] ] ]! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84440146!postCopy	"Must copy the associations, or later store will affect both theoriginal and the copy"	array := array collect: [:assoc |				assoc 					ifNil: [nil]					ifNotNil: [						assoc expired 							ifTrue: [ WeakKeyAssociation expired]							ifFalse: [WeakKeyAssociation key: assoc Differencekey value: assoc value]]]! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84444663!scanFor: anObject	"mvl 10/21/2007: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForEmpty: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. Expired associations are ignored, since callers take non-nil slots as a successful search. Subclasses should override startIndexFor: and compare:to: if they have a different semantics for matching elements."	| element start finish |	finish := array size.	start := self startIndexFor: anObject.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [self compare: element Differencekey to: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [self compare: element Differencekey to: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84435464!scanForEmpty: anObject	"Scan the key array for the first slot containing either a nil or an expired association (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found."	| element start finish firstNil |	finish := array size.	start := self startIndexFor: anObject.	firstNil := nil.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil 						or: [self compare: element Differencekey to: anObject])			ifTrue: [				"If we found no match, and have an expired slot, use that one."				(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].				^ index 			].			"If this slot is expired, and we haven't seen an earlier expired slot, record it"			(element notNil 				and: [element expired 						and: [firstNil isNil]]) ifTrue: [firstNil := index].		].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil 					or: [self compare: element Differencekey to: anObject])			ifTrue: [				(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].				^ index 			].			(element notNil 				and: [element expired 						and: [firstNil isNil]]) ifTrue: [firstNil := index].		].	"If there is no empty slot, but an expired one, return it."		firstNil notNil ifTrue:[^firstNil].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84443063!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index result assoc |	index := self findElementOrNil: key.	assoc := array at: index.	(assoc == nil or: [assoc Differencekey isNil]) ifTrue: [ ^ aBlock value ].	assoc key: nil.	result := assoc value.	assoc expire.	expired := expired + 1.	tally := tally - 1.	^result! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84445812!scanForKeyOrNil: anObject	"Same as scanFor: , but treats association with key == nil as empty slot"		| element start finish |	finish := array size.	start := self startIndexFor: anObject.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [ element Differencekey isNil or: [self compare: element Differencekey to: anObject]])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [ element Differencekey isNil or: [self compare: element Differencekey to: anObject]])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 84442372!valuesDo: aBlock 	"See comments in Dictionary>>valuesDo:.  The code keeps the key so it's	not collected during the evaluation of aBlock"	tally = 0 ifTrue: [ ^self ].	1 to: array size do:		[ :eachIndex | 			| eachAssociation eachKey |			eachAssociation := array at: eachIndex.			nil == eachAssociation ifFalse:				[					eachKey := eachAssociation Differencekey.					aBlock value: eachAssociation value				]		]! !!FFIExternalEnumeration class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24036989!itemAt: aValue ifAbsent: exceptionBlock	self classPool		associationsDo: [ :assoc | 			aValue = assoc value value				ifTrue: [ ^ assoc Differencekey ] ].	^ exceptionBlock value! !!MCServerRegistry methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31985786!repositoryAt: urlString credentialsDo: aBlock	| possibleMatches bestMatch |	possibleMatches := registry associations select: [ :e | urlString beginsWith: e Differencekey ].	possibleMatches isEmpty ifTrue: [ ^ aBlock value: '' value: '' ].	bestMatch := possibleMatches inject: possibleMatches anyOne into: [ :last :new | 		((new Differencekey asUrl path size > last Differencekey asUrl path size) 		"this is ugly, but URL always returns a path element, even an empty one..."		or: [ last Differencekey asUrl path size = 1 and: [ last Differencekey asUrl path last isEmpty ]]) 			ifTrue: [ new ]			ifFalse: [ last ]].	^ aBlock value: bestMatch value username value: bestMatch value password.! !!RubAbstractTextArea methodsFor: 'accessing decorators' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 57893479!withDecorator: aDecorator	(self hasDecoratorNamed: aDecorator Differencekey)		ifTrue: [ ^ self ].	paragraph := aDecorator next: paragraph.	self compose! !!RubAbstractTextArea methodsFor: 'accessing decorators' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 57854093!withoutAnyDecorator	[ self paragraph Differencekey notNil ] whileTrue: [ self withoutDecorator: paragraph ]! !!AthensCairoGradientPaint methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17525075!populateRamp: aRamp	aRamp do: [ :each |		self			addColorStopAt: each Differencekey			colored: each value ]	! !!AthensCairoGradientPaint methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17525929!initializeRadialBetween: origin			extending: innerRadius			and: outerOrigin			extending: outerRadius			withColorRamp: aRamp				self initialize.			aRamp do:[:each|		self			addColorStopAt: each Differencekey			colored: each value ]	! !!KMModifiedKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36007246!Differencekey	^ self character Differencekey.! !!KMModifiedKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30080357!key	^ self character Differencekey.! !!KMModifiedKeyCombination methodsFor: '*Spec-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30081646!currentCharacter		^ self character Differencekey! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31656323!orderString: anIndex	^String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) Differencekey ]! !!GTSpotterHelp class methodsFor: 'documentation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27911981!extensionsString	| methods title |	^ String streamContents: [ :s |		((GTSpotter spotterExtendingMethods groupedBy: #methodClass) 		associations sorted: [ :a :b | a Differencekey name < b Differencekey name ]) 		do: [ :classMethodsAssociation |			s nextPutAll: classMethodsAssociation Differencekey name; cr.			methods := classMethodsAssociation value.			methods do: [ :each | 				title := each ast allChildren 					detect: [ :node | node isMessage and: [ node selector = #title: ] ]					ifFound: [ :node | node arguments first value. ]					ifNone: [ each selector ].				title isString ifFalse: [ title := each selector ].				s 					nextPutAll: '- #'; 					nextPutAll: title; 					nextPutAll: ' (in '; 					nextPutAll: each selector; 					nextPut: $);					cr ].			s cr ] ]! !!MetacelloAtomicMonticelloResource methodsFor: 'running' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32987718!setUpMonticelloRepository	"This method builds a fake repository with the version references from #buildReferences."	monticelloRepository := MCDictionaryRepository new.	versionReferences do: [ :assoc | | reference superclassName |		reference := assoc Differencekey.		superclassName := assoc value.		monticelloRepository basicStoreVersion: (MCVersion new			setPackage:  (MetacelloTestsMCPackage new name: reference packageName)			info: (MCVersionInfo				name: reference name				id: UUID new				message: 'This is a mock version'				date: Date today				time: Time now				author: reference author				ancestors: #())			snapshot: (MCSnapshot fromDefinitions: (Array				with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol))				with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: superclassName category: reference packageName asSymbol instVarNames: #() comment: '')))			dependencies: #()) ]! !!FLWeakObjectsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24514551!testAssociationWithWeak	"This tests an association with weak values. InstVar1 is a fixed instance variable, hence they are strong and hence should not be replaed by nil. Instead, 'weak' is stored in the variable part of FLWeakClassMock, so it is weak and so it should have been replaced by nil."	| weak association materializedAssociation |		weak := FLWeakClassMock new: 1.	weak instVar1: 'nonWeak'.	weak basicAt: 1 put: 'weak'. 	association := Association key: #foo value: weak.		materializedAssociation := self resultOfSerializeAndMaterialize: association.	self assert: materializedAssociation value instVar1 isNil not.	self assert: (materializedAssociation value basicAt: 1) isNil.	self assert: materializedAssociation Differencekey = #foo.	! !!FLWeakObjectsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24513545!testAssociationWithWeakFinalizationList	"This tests an association with WeakFInalizationList as its value."	| weak association materializedAssociation object list |		object := Object new.	list := WeakFinalizationList new.	weak := WeakFinalizerItem new list: list object: object executor: nil.	association := Association key: #foo value: weak.		materializedAssociation := self resultOfSerializeAndMaterialize: association.	"Both, 'executor' and 'list' are fixed instance variables, hence they are strong and hence should not be replaced by nil. Instead, 'object' is stored in the variable part of WeakFinalizationItem, so it is weak and so it should have been replaced by nil."	self assert: materializedAssociation value executor isNil.	self assert: materializedAssociation value list isNil not.	self assert: materializedAssociation value object isNil.	self assert: materializedAssociation Differencekey = #foo.	! !!GLMCompositeBrick class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 26313857!gtExampleTable	<gtExample>	<label: 'Phlowr table'>		^ self new		hSpaceFill;		vSpaceFill;		with: [ :b |			b table				title: #asString;				display: [ :anObject | (anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself) addFirst: 'self' -> anObject; yourself ];				column: 'Variable'					evaluated: [:assoc |	GTObjectPrinter asNonTruncatedTextFrom: assoc Differencekey ]					styled: [ :aBrick | aBrick textPosition: #rightCenter; margin: #(0 15 0 0); textColor: Color lightGray ];				column: 'Variable'					evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ]					styled: [ :aBrick | aBrick margin: #(0 0 0 15) ];				entity: Morph new ]! !!GoferPush methodsFor: 'running' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 28253744!execute	self model 		do: [ :assocation | assocation value storeVersion: assocation Differencekey version ]		displayingProgress: 'Pushing Versions'! !!Object methodsFor: 'casing-To be deprecated' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53326814!caseOf: aBlockAssociationCollection otherwise: aBlock	"DO NOT USE THIS METHOD!! It will be removed from Pharo."		"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:assoc | (assoc Differencekey value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: '*GT-Spotter' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53361366!spotterPreviewRawIn: aComposite	<spotterPreview: 40>	aComposite table		title: [ self gtDisplayString ];		display: [ :anObject | (anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself) addFirst: 'self' -> anObject; yourself ];		column: 'Variable'			evaluated: [:assoc |	GTObjectPrinter asNonTruncatedTextFrom: assoc Differencekey ]			styled: [ :aBrick | aBrick textPosition: #rightCenter; margin: #(0 15 0 0); textColor: aComposite themer textLightColor; height: 30 ];		column: 'Value'			evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ]			styled: [ :aBrick | aBrick margin: #(0 0 0 15); height: 30 ];		entity: self.			self flag: 'move "entity: self" somewhere else, maybe'! !!Object methodsFor: '*GT-Inspector' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 53393845!gtInspectorVariableValuePairs	"This is a helper method that returns a collection of 		variable_name -> value	for the current object.	Subclasses can override it to specialize what appears in the variables presentation"	| bindings |	bindings := OrderedCollection new.	self gtInspectorVariableNodesIn: bindings.	^ bindings collect: [ :aNode | aNode Differencekey -> aNode value ]! !!FuzzyMatcherTests methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25810959!testClassSideAPI	"if the protocol is changed, so should the class comment"	FuzzyMatcher class protocols detect: [ :p | p = #'utilities api' ].		self 			assert: (FuzzyMatcher allMatching: #a in: #(a b ab))		equals: #(a ab);			assert: (FuzzyMatcher allMatching: #a in: { #a -> 1 . #b -> 2 . #acb -> 3 } by: [:each | each Differencekey ])		equals: { #a -> 1 . #acb -> 3 };				assert: (FuzzyMatcher allSortedByScoreMatching: #b in: { #aaca .#aAaaB . #Aaab . #baaa . #aaba })		equals: #(baaa aaba Aaab aAaaB) 			! !!FLGlobalSendCluster methodsFor: 'serialize/materialize' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 24348568!serializeInstance: anObject with: anEncoder		| globalSend |	globalSend := globalSends at: anObject.		self serializeGlobalAssociationKeyed: globalSend Differencekey on: anEncoder.	anEncoder encodeString: globalSend value.! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 32731519!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector Differencekey ~= #namedTempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ MessageAsTempNode new		receiver: receiver		selector: #namedTempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !!Parser methodsFor: 'error correction' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54191300!queryUndefined	| varStart varName | 	varName := parseNode Differencekey.	varStart := self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	(UndefinedVariable name: varName) ifFalse: [^ self fail]! !!DADependencyReport methodsFor: 'converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21877191!newReportScopedOn: aPackageName withoutDependencies: aListOfPackageNameToIgnore	"Generates a new dependency report discarding 	- all packages that are not present in aPackageName transitive dependencies	- all packages in aListOfPackageNameToIgnore"	| report dependenciesToInclude |	report := self class new.	report		imageVersion: imageVersion; 		analysisRunString: analysisRunString , ' scoped on ' , aPackageName.	dependenciesToInclude := self transitiveDependenciesOf: aPackageName withoutDependenciesOf: aListOfPackageNameToIgnore.	warnings 		select: [:warning | dependenciesToInclude includes: warning package ]		thenDo: [:warning | report addWarning: warning ].	dependencies associationsDo: [ :assoc |		((dependenciesToInclude includes: assoc Differencekey) 		and: [ (aListOfPackageNameToIgnore includes: assoc Differencekey) not ])			ifTrue: [ report 							add: assoc Differencekey 							dependencies: assoc value ] ].	^ report! !!DADependencyReport methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 21880181!knownDependantsOf: aPackageName	^ dependencies associations 		select: [ :association | association value includes: aPackageName ]		thenCollect: #Differencekey! !!FBDDecompiler methodsFor: 'data flow instructions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 23842079!storeIntoLiteralVariable: association	simulatedStack addLast: (builder codeAssignment: simulatedStack removeLast to: (builder codeVariable: association Differencekey))! !!LinkedListTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31070380!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn Differencekey) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31684707!absentInitializers	^ initializers reject: [ :each | Smalltalk hasClassNamed: each Differencekey ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31685646!writePresentInitializers	| orderedClasses presentInitializers |	presentInitializers := self presentInitializers.	orderedClasses := (Class		superclassOrder: (presentInitializers collect: [ :each | Smalltalk classOrTraitNamed: each Differencekey ]))		collect: [ :each | each name ].	orderedClasses		do: [ :className | stream nextPutAll: (presentInitializers detect: [ :each | each Differencekey = className ]) value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31685236!writeAbsentInitializers	(self absentInitializers asSortedCollection: [ :a :b | a Differencekey <= b Differencekey ])		do: [ :association | stream nextPutAll: association value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31686425!presentInitializers	^ initializers select: [ :each | Smalltalk hasClassNamed: each Differencekey ]! !!OCLiteralVariable methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52924024!isFromSharedPool	| sharedPools |	sharedPools := scope getClass baseClass sharedPools.	^ sharedPools 		detect: [ :pool | pool classVarNames includes: assoc Differencekey ]		ifFound: [ true ]		ifNone: [ false ]! !!OCLiteralVariable methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 52923545!isGlobalClassNameBinding	^ (self value isClass or: [ self value isTrait ])		and: [ self variable Differencekey == self value name ]! !!RFReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56846211!for: aSelector	^ self subclasses detect: [ :class | class Differencekey = aSelector ]! !!RFReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 56845881!allKeys	^self subclasses collect: [:plugin | plugin Differencekey]! !!InterpolatedGradientFillStyle methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 29716799!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver."		| bits ramp lastColor lastIndex lastWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 Differencekey < a2 Differencekey].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := self pixelWord32Of: lastColor .	lastIndex := 0.	ramp do:[:assoc| | distance nextColor theta nextWord nextIndex step |		nextIndex := (assoc Differencekey * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWord32.		distance := nextIndex - lastIndex.		distance = 0 ifTrue: [distance := 1].		step := 1.0 / distance.		theta := 0.0.		lastIndex+1 to: nextIndex do: [:i|			theta := theta + step.			bits at: i put: (self interpolatedAlphaMix: theta of: lastWord and: nextWord)].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord].	lastIndex+1 to: length do: [:i| bits at: i put: lastWord].	^bits! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60337953!fixObsoleteBindings	CompiledMethod allInstances do: [ :method |		| obsoleteBindings |		obsoleteBindings := method literals select: [ :literal |				literal isVariableBinding and: [					literal value isBehavior and: [ 						literal value isObsolete ] ] ].		obsoleteBindings do: [ :binding |			| obsName realName realClass |			obsName := binding value name.			self 				trace: 'Binding: ';				traceCr: obsName.			realName := obsName copyReplaceAll: 'AnObsolete' with: ''.			realClass := Smalltalk globals at: realName asSymbol ifAbsent: [ UndefinedObject ].			binding key: binding Differencekey value: realClass ].		"do not forget to flush the JIT cache"		obsoleteBindings ifNotEmpty: [ method flushCache ] ]! !!SmalltalkImage methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 60298400!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 0>	composite table		title: 'Details';		display: [ 			{ 				'Image directory' -> self imageDirectory asFileReference.				'Image format version' -> self imageFormatVersion.				'License' -> self licenseString.				'VM directory' -> self vmDirectory asFileReference.				'VM version' -> self version			} ];		column: 'Property' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17122652!keysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding			ifTrue: [aBlock value: propertyOrPragma Differencekey value: propertyOrPragma value]			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !!AdditionalMethodState methodsFor: 'properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17123423!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma Differencekey == aKey]) ifTrue:			[^propertyOrPragma value]].	^aBlock value! !!AdditionalMethodState methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17123901!includesKey: aKey	"Test if the property aKey or pragma with selector aKey is present."	1 to: self basicSize do:		[:i |		(self basicAt: i) Differencekey == aKey ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17118232!at: aKey put: aValue       "Replace the property value or pragma associated with aKey."       | keyAlreadyExists |       keyAlreadyExists := false.       1 to: self basicSize do:               [:i |               | propertyOrPragma "<Association|Pragma>" |               (propertyOrPragma := self basicAt: i) Differencekey == aKey ifTrue: [                       keyAlreadyExists := true.                       propertyOrPragma isVariableBinding                               ifTrue: [propertyOrPragma value: aValue]                               ifFalse: [self basicAt: i put: aValue]]].       keyAlreadyExists ifFalse: [               method propertyAt: aKey put: aValue ].       ^ aValue! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17119253!at: aKey ifAbsentPut: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) Differencekey == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^method propertyAt: aKey put: aBlock value! !!AdditionalMethodState methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17116354!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [(aBlock value: propertyOrPragma Differencekey)					or: [(aBlock value: propertyOrPragma value)					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17115282!hasLiteralThorough: literal	"Answer true if any literal in these properties is literal,	 even if embedded in array structure."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [propertyOrPragma Differencekey == literal					or: [propertyOrPragma value == literal					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteral: literal]]]]			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17117838!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[aBlock value: propertyOrPragma Differencekey value: propertyOrPragma value]]! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17124545!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma Differencekey]				ifFalse: [propertyOrPragma keyword])			== aKey ifTrue:			[^method removeProperty: aKey]].	^aBlock value! !!AdditionalMethodState methodsFor: 'properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17114370!includesProperty: aKey	"Test if the property aKey is present."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma Differencekey == aKey]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17125236!properties	| propertyStream |	propertyStream := WriteStream on: (Array new: self basicSize * 2).	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[propertyStream nextPut: propertyOrPragma Differencekey; nextPut: propertyOrPragma value]].	^IdentityDictionary newFromPairs: propertyStream contents! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17126339!at: aKey ifAbsent: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) Differencekey == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^aBlock value! !!LiteralNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 31192771!printOn: aStream indent: level	key isVariableBinding		ifTrue:			[key Differencekey 				ifNil:					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]				ifNotNil:					[aStream nextPutAll: '##'; nextPutAll: key Differencekey]]		ifFalse:			[key storeOn: aStream]! !!PharoBootstrapRule methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 54395466!collectionsPackages	^ (CollectionsAssembly parts collect: #Differencekey)		reject: [ :each | each = #'Collections-Atomic' ]! !!AssociationTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 17443626!testEquality		self 		assert: (a Differencekey = b Differencekey);		deny: (a value = b value);		deny: (a = b)! !!MethodOveridesAction methodsFor: 'order' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51189349!privateActionIcon	"Return the icon for this action"	isOverride		ifTrue: [ 			isOverridden				ifTrue: [					result := self buildUpAndDownArrowIcon: method.					^ result Differencekey ]				ifFalse: [ 					^ IconicButton new						target: self browser;						actionSelector: #arrowUp:;						arguments: {method};						labelGraphic: (self iconNamed: #arrowUpIcon);						color: Color transparent;						helpText: 'Browse overriden message';						extent: self iconExtent;						borderWidth: 0 ] ]		ifFalse: [ 			isOverridden				ifTrue: [ 					^ IconicButton new						target: self browser;						actionSelector: #arrowDown:;						arguments: {method};						labelGraphic: (self iconNamed: #arrowDownIcon);						color: Color transparent;						helpText: 'Browse overriding messages';						extent: self iconExtent;						borderWidth: 0 ] ]! !!UnlimitedInstanceVariableSlot methodsFor: 'class building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 83980318!calculateOffset: aClass	| ivarSlots  calculatedOffset |	"first we get all boolean slots and sort them by index"	ivarSlots := aClass allSlots select: [ :each | each isKindOf: self class ].	ivarSlots := ivarSlots select: [ :each | each offset isNotNil ].	ivarSlots sort: [ :a :b | a offset < b offset ]. 	ivarSlots ifEmpty: [ ^1 ]. "we are the first one!!"	"now we find the first spot where the next offset is not yet taken"	calculatedOffset := (ivarSlots withIndexCollect: [ :each :myIndex | myIndex ->each offset ]) 		findFirst: [ :each | each Differencekey ~= each value ].	calculatedOffset = 0  "no hole found: use the next index after the last slot"		ifTrue: [ ^ ivarSlots last offset + 1].	^calculatedOffset	! !!GTInspectorHelp class methodsFor: 'documentation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 27587258!extensionsString	| methods title |	^ String streamContents: [ :s |		((GTInspector inspectorExtendingMethods groupedBy: #methodClass)		associations sorted: [ :a :b | a Differencekey name < b Differencekey name ]) 		do: [ :classMethodsAssociation |			s nextPutAll: classMethodsAssociation Differencekey name; cr.			methods := classMethodsAssociation value.			methods do: [ :each | 				title := each ast allChildren 					detect: [ :node | node isMessage and: [ node selector = #title: ] ]					ifFound: [ :node | node arguments first value. ]					ifNone: [ each selector ].				title isString ifFalse: [ title := each selector ].				s 					nextPutAll: '- '; 					nextPutAll: title; 					nextPutAll: ' ('; 					nextPutAll: each selector; 					nextPut: $);					cr ].			s cr ] ]! !!Morph methodsFor: '*SUnit-UITesting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51457488!simulateClickWith: buttons	"Did you know there's #simulateClick (left), #simulateMiddleClick, and #simulateRightClick?	buttons - look at MouseEvent's class-side for button types"	| noButtons |	noButtons := 0.	{ #mouseDown->buttons. #mouseUp->noButtons } do: [ :type |		self activeHand handleEvent: (MouseButtonEvent new 			setType: type Differencekey			position: (self pointInWorld: self center) "Some Morphs report local coords"			which: (noButtons bitXor: buttons)			buttons: type value			hand: self activeHand			stamp: Time millisecondClockValue) ].! !!Morph methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51478118!gtInspectorMorphExtensionIn: composite	<gtInspectorPresentationOrder: 15>		^ composite table		title: 'Extension';		showOnly: 50; 		display: [ self extension gtInspectorVariableValuePairs asSortedCollection ];		when: [ extension notNil ];		column: 'Variable' 			evaluated: [:assoc | GTObjectPrinter asNonTruncatedTextFrom: assoc Differencekey ];		column: 'Value' 			evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ];		send: #value;		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse';		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect';		selectionAct: [:list | 			((list selection pointersToExcept: { list selection })									reject: [ :each | each pointsOnlyWeaklyTo: list selection ]) inspect ] 			on: $t			entitled: 'Open pointers to'! !!Morph methodsFor: '*SUnit-UITesting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 51517486!simulateClickWith: buttons position: position	"Did you know there's #simulateClick (left), #simulateMiddleClick, and #simulateRightClick?	buttons - look at MouseEvent's class-side for button types"	| noButtons hand |	noButtons := 0.	hand := HandMorph new mouseFocus: self; yourself.	hand privateOwner: self.	{ #mouseDown->buttons. #mouseUp->noButtons } do: [ :type |		hand handleEvent: (MouseButtonEvent new 			setType: type Differencekey			position: position "Some Morphs report local coords"			which: (noButtons bitXor: buttons)			buttons: type value			hand: hand			stamp: Time millisecondClockValue) ].! !!ScriptLoader methodsFor: 'ci' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 59362078!newGenerateNewUpdateMethodSilentlyConfigurations: configurations preLoad: preload postLoad: postLoad	"ScriptLoader new newGenerateNewUpdateMethod"		| stream methodName preamble postscript |	stream := ReadWriteStream on: (String new: 1000).	methodName := 'update', self currentUpdateVersionNumber asString.	stream 		<< methodName << String cr		<< Character tab << '"self new ' << methodName << '"' << String cr		<< Character tab .			preamble := self decodeFromPrint: (preload reset contents asString).	preamble isEmptyOrNil 		ifFalse: [ stream nextPutAll: preamble; ensureEndsWith: $.; crtab ].	stream 		<< 'self withUpdateLog: ''' << self commentForCurrentUpdate << '''.' << String cr		<< Character tab << 'self loadTogether: self script' << self currentScriptVersionNumber asString << ' merge: false.' << String cr		<< Character tab.			configurations 		do: [ :each | stream << 'self loadConfiguration: ''' << each Differencekey << ''' version: ' << each value printString << '.' ]		separatedBy: [ stream cr ].			postscript := self decodeFromPrint: (postLoad reset contents asString). 	postscript isEmptyOrNil 		ifFalse: [ stream nextPutAll: postscript; ensureEndsWith: $.; crtab ].		stream << 'self flushCaches.' << String cr.		^ stream contents! !!KMDispatcher methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30047103!gtInspectorMappingsIn: composite	<gtInspectorPresentationOrder: 40>	composite table 		title: 'Keys';		display: [ 			self gtAllKeyCategoryPairs ];		filterOn: [ :text :each | each gtDisplayString includesSubstring: text caseSensitive: false ];		column: 'Shortcut' evaluated: [ :assoc | assoc Differencekey shortcut gtDisplayString ] width: 120;		column: 'Action' evaluated: [ :assoc | assoc Differencekey action gtDisplayString ];		column: 'Description' evaluated: [ :assoc | assoc Differencekey description ];		column: 'Category' evaluated: [ :assoc | '' ] tags: [ :assoc | assoc value name ifNil: [ #() ] ifNotNil: [ { assoc value name }]];		send: #Differencekey! !!KMDispatcher methodsFor: '*GT-SpotterExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 30051450!spotterForKeysFor: aStep	<spotterOrder: 15>			aStep listProcessor			title: 'Keys';			allCandidates: [ (self gtAllKeyCategoryPairs collect: #Differencekey) asOrderedCollection ];			itemName: [ :aKeymap | 				aKeymap shortcut gtDisplayString, 				(aKeymap name ifNil: [ '' ] ifNotNil: [ ' [', aKeymap name,']' ]) ];			candidatesLimit: 5;			filter: GTFilterSubstrings! !!FuzzyMatcher class methodsFor: 'utilities api' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 25802862!allSortedByScoreMatching: aPattern in: aCollection by: aBlockReturningString	| matcher matches |		aPattern isEmpty ifTrue: [ ^ aCollection asArray ].		matcher := self pattern: aPattern.	matches := OrderedCollection new: aCollection size // 2.		aCollection do: [ :each | 		matcher 			match: (aBlockReturningString value: each) 			ifScored: [ :score | matches add: score -> each ] 	].		matches sort: [ :a :b | a Differencekey >= b Differencekey ].		^ matches collect: [ :each | each value ] as: Array	! !!Duration methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 22904510!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'days' -> self days.					'hours' -> self hours.					'minutes' -> self minutes.					'seconds' -> self seconds .					'nanoseconds' -> self nanoSeconds } ];		column: 'Key' evaluated: #Differencekey;		column: 'Value' evaluated: #value;		send: #value! !GTSpotterHelp class removeSelector: #key!GTInspectorSelfNode removeSelector: #key!GTPlaygroundHelp class removeSelector: #key!RFThisContextReification class removeSelector: #key!RubShoutStylerDecorator class removeSelector: #key!KMModifiedKeyCombination removeSelector: #key!GLMHighlighterTextStylerDecorator class removeSelector: #key!RubExtraSelectionDecorator class removeSelector: #key!CustomHelp class removeSelector: #key!RubLineNumberDisplayer class removeSelector: #key!WeakKeyAssociation removeSelector: #key!GTInspectorDynamicNode removeSelector: #key!NautilusAnnotationDisplayer class removeSelector: #key!GTInspectorContextNamedTempNode removeSelector: #key!RFSelectorReification class removeSelector: #key!RubParagraphDecorator removeSelector: #key!LeafNode removeSelector: #key!RFEReceiverReification class removeSelector: #key!RubParagraph class removeSelector: #key!HelpTopic removeSelector: #key!RFArgumentsReification class removeSelector: #key!LookupKey removeSelector: #key!ShiftCipher removeSelector: #key!RubCommentAnnotationDisplayer class removeSelector: #key!KMSingleKeyCombination removeSelector: #key!NautilusKeyPressed removeSelector: #key!GTInspectorIndexedNode removeSelector: #key!GTInspectorSlotNode removeSelector: #key!GTInspectorProtoObjectNode removeSelector: #key!RFEntityReification class removeSelector: #key!HelpOnHelp class removeSelector: #key!RubColumnDisplayer class removeSelector: #key!RubCurrentLineBarDecorator class removeSelector: #key!KeyNotFound removeSelector: #key!RubGhostTextDisplayer class removeSelector: #key!RubScrolledTextExtra class removeSelector: #key!RubParagraph removeSelector: #key!RFVariableReification class removeSelector: #key!KMKeymap removeSelector: #key!RubAdornmentDisplayer class removeSelector: #key!RubCodeSizeFeedback class removeSelector: #key!RFObjectReification class removeSelector: #key!RFClassReification class removeSelector: #key!GTDebuggerHelp class removeSelector: #key!RubWorkspaceBar class removeSelector: #key!RFReification class removeSelector: #key!RFNameReification class removeSelector: #key!RFValueReification class removeSelector: #key!GTInspectorHelp class removeSelector: #key!GTInspectorVariableNode removeSelector: #key!RubTextSegmentIconBox class removeSelector: #key!RubParagraphDecorator class removeSelector: #key!RubOpeningClosingDelimiterDecorator class removeSelector: #key!Pragma removeSelector: #key!RFNodeReification class removeSelector: #key!RFNewValueReification class removeSelector: #key!KeyboardEvent removeSelector: #key!RFSenderReification class removeSelector: #key!RubAnnotationDisplayer class removeSelector: #key!GTInspectorWrapperNode removeSelector: #key!RFLinkReification class removeSelector: #key!SpecHelpTopics class removeSelector: #key!RubScrolledTextExtra removeSelector: #key!RubTextSegmentIconDisplayer class removeSelector: #key!!GTSpotterHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self name! !!GTInspectorSelfNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ 'self'! !!GTPlaygroundHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self name! !!RFThisContextReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#context! !!RubShoutStylerDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #shoutStyler! !!KMModifiedKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self character Differencekey.! !!GLMHighlighterTextStylerDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ nil! !!RubExtraSelectionDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #findReplaceSelection! !!CustomHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	"Returns a unique key identifying the receiver in the help system"		^''! !!RubLineNumberDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #lineNumbers! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	"Answer the lookup key of the receiver."	^self basicAt: 1! !!GTInspectorDynamicNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ label! !!NautilusAnnotationDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #SourceCodeAnnotation! !!GTInspectorContextNamedTempNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self tempName! !!RFSelectorReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#selector! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^self class Differencekey! !!LeafNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^key! !!RFEReceiverReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#receiver! !!RubParagraph class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ nil! !!HelpTopic methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key 		"Returns a unique key identifying the receiver in the help system"				^key! !!RFArgumentsReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#arguments! !!LookupKey methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	"Answer the lookup key of the receiver."	^key! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ key! !!RubCommentAnnotationDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #commentAnnotation! !!KMSingleKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ key! !!NautilusKeyPressed methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key		^ key! !!GTInspectorIndexedNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self index! !!GTInspectorSlotNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self slot name! !!GTInspectorProtoObjectNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ slotName! !!RFEntityReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#entity! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^'HelpOnHelp'! !!RubColumnDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #column! !!RubCurrentLineBarDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #selectionBar! !!KeyNotFound methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self object! !!RubGhostTextDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #ghostText! !!RubScrolledTextExtra class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ nil! !!RubParagraph methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^self class Differencekey! !!RFVariableReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#variable! !!KMKeymap methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ name! !!RubAdornmentDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #adornment! !!RubCodeSizeFeedback class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #codeSizeFeedback! !!RFObjectReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#object! !!RFClassReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#class! !!GTDebuggerHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self name! !!RubWorkspaceBar class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #workspaceBar! !!RFReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^self subclassResponsibility! !!RFNameReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#name! !!RFValueReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#value! !!GTInspectorHelp class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self name! !!GTInspectorVariableNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	"Answer the key of this object variable (slot, indexed attribute, computed value)."	^ self subclassResponsibility! !!RubTextSegmentIconBox class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #textSegmentIcons! !!RubParagraphDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ self subclassResponsibility ! !!RubOpeningClosingDelimiterDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #openingClosingDelimitersHighlight! !!Pragma methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	"Answer the keyword of the pragma (the selector of its message pattern).	 This accessor provides polymorphism with Associations used for properties."	^keyword! !!RFNodeReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#node! !!RFNewValueReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#newValue! !!KeyboardEvent methodsFor: 'keyboard' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^Smalltalk os keyForValue: keyValue! !!RFSenderReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#sender! !!RubAnnotationDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #annotation! !!GTInspectorWrapperNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ label ifNil: [ self hostObject Differencekey ]! !!RFLinkReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^#link! !!SpecHelpTopics class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^'Spec'! !!RubScrolledTextExtra methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^self class Differencekey! !!RubTextSegmentIconDisplayer class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45'!key	^ #textSegmentIcons! !!CriticBrowser methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36014984!rules: rulesCollection	self rulesModel roots: ((		(rulesCollection groupedBy: #group) associations collect: [ :as |			CriticBrowserRulesGroup				named: as key				rules: as value ])					sorted: [ :a :b | a name < b name ])! !!SortedCollectionTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36015335!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!BytecodeEncoder methodsFor: 'temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36015870!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:str|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| str nextPut: { remoteLocal key. { index. innerIndex } }]]							ifFalse: [str nextPut: { local key. index }]]])].	^blockExtentsToTempsMap! !!FLExtensionWrapper methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36016984!readTargetClassFrom: aPragma argumentNames: argumentNames argumentValues: argumentValues	| class |	class := Smalltalk		at: (argumentValues at: (argumentNames indexOf: 'flExtensionOf:'))		ifAbsent: [ ^ nil ].			^ (aPragma method pragmas anySatisfy: [ :pragma |		pragma key = #flExtensionClassSide ])			ifTrue: [ class class ]			ifFalse: [ class ]! !!FLExtensionWrapper methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36017462!readArgumentsFrom: aPragma	^ {		aPragma key keywords.		aPragma arguments }! !!RubScrolledTextExtra methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36017656!Differencekey	^self class key! !!RubScrolledTextExtra methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36385689!key	^self class key! !!RubScrolledTextExtra class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36017945!classOfRulerNamed: aKey 	^ self allSubclasses detect: [ :cls | cls key = aKey ] ifNone: [  ]! !!StandardFonts class methodsFor: 'font accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36018159!systemFontLabelOf: aSelector	^ self systemFontAspectsAndLabels		detect: [ :assoc | assoc key = aSelector ]		ifFound: [ :assoc | assoc value ]		ifNone: [ '' ]! !!StandardFonts class methodsFor: 'font accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36018441!systemFontAspects	^ self systemFontAspectsAndLabels collect: [:assoc | assoc key]! !!Nautilus methodsFor: 'history' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36018626!registerHistoryNewEntry	| lastEntry wrapper |		self browsingHistory isPaused ifTrue: [ ^ self ].	wrapper := NautilusHistoryEntry with: self.	self browsingHistory entries ifNotEmpty: [ :entries |		lastEntry := entries last key.		( lastEntry selectedClass isNil 		or: [ ( wrapper selectedClass notNil 			and: [ wrapper selectedMethod = lastEntry selectedMethod 			and: [ wrapper selectedClass theNonMetaClass = lastEntry selectedClass theNonMetaClass ] ] ) ] ) 				ifTrue: [ ^ self ] ].		self browsingHistory add: wrapper.	self historyChanged.! !!Nautilus methodsFor: 'history' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36019284!adopt: anAssociation	self browsingHistory pauseDuring: [		anAssociation key applyTo: self ]! !!PackageWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36019487!selectedPackages	| associations |	associations := packagesSelection associations select: [ :assoc | assoc value ].	associations := associations collect: [ :assoc | assoc key ].	^ associations select: [ :each | each notNil ]! !!PackageWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36019823!selectedGroups	| associations |	associations := groupsSelection associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc key ].	^ associations select: [:each | each notNil ]! !!LiteralDictionaryTest methodsFor: 'tests - literal specific behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36020186!testIncludesWithEqualElementFromDifferentClasses| dict |dict := self classToBeTested new.dict at: 1 put: 'element1'.dict at: #key put: 1.0.self deny: (dict includesKey: 1.0).self assert: (dict includes: 1)! !!RBSelectorEnvironment class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36020532!referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString |	literalPrintString := aLiteral isVariableBinding		ifTrue: [ aLiteral key asString ]		ifFalse: [			aLiteral isString				ifTrue: [ aLiteral ]				ifFalse: [ aLiteral printString ] ].	classDict := IdentityDictionary new.	anEnvironment classesDo: [ :class | 		| selectors |		selectors := (class thoroughWhichSelectorsReferTo: aLiteral)			select: [ :selector | anEnvironment includesSelector: selector in: class ].		selectors isEmpty 			ifFalse: [ classDict at: class put: selectors asIdentitySet ] ].	^ (self onEnvironment: anEnvironment)		on: classDict;		label: 'References to: ' , literalPrintString;		searchStrings: (Array with: literalPrintString);		yourself! !!GTSpotterHeaderBrick methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36021400!helpButton: aBrick	| tree item |	helpButton ifNotNil: [self removeBrick: helpButton].	helpButton := aBrick.		self themer spotterThemer helpButtonWidgetStyleFor: helpButton.	self themer spotterThemer helpButtonStyleFor: helpButton.		helpButton		hintTitle: 'Spotter help';		action: [ 			self spotterModel exitDueTo: #actionButton.			tree := HelpBrowser open instVarNamed: #treeMorph.			item := tree allItems detect: [:each | 				each complexContents item key = GTSpotterHelp key].			tree selection: item ].		self addBrickBack: helpButton! !!ZnMessage methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36022088!gtInspectorContentsIn: composite	<gtInspectorPresentationOrder: 40>	self hasEntity		ifTrue: [ 			self contentType isBinary				ifTrue: [ 					composite table						title: 'Contents';						display: [ {'entity' -> self entity} ];						column: 'Key' evaluated: #key;						column: 'Value' evaluated: #value;						send: #value ]				ifFalse: [ 					composite text						title: 'Contents';						format: self contents ] ]! !!FLAnalyzer methodsFor: 'protected' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36022620!pluggableSubstitutionMappers	^pluggableSubstitutions collect: [:aLink |		FLPluggableSubstitutionMapper 			when: aLink key			substituteBy: aLink value]! !!GTRawObjectVariablesBrowser methodsFor: 'private - updating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36022908!generateCacheFor: anObject	| valuesCache |		valuesCache := OrderedDictionary new.	((self basicVariableNodesFor: anObject) do: [ :assoc | 		valuesCache 			at: assoc key 			put: (self generateHashFor: assoc value) ]).		^ valuesCache! !!GTRawObjectVariablesBrowser methodsFor: 'private building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36023278!variablesIn: composite	^ composite fastTreeTable		useCache;		hasChildren: [ :aNode | aNode key ~= 'self' ];		children: [ :aNode | aNode childrenNodesFor: self ];		icon: [ :aNode | self iconFor: aNode value ];		display: [ :anObject | 			self variableNodesFor: anObject ];		column: 'Variable' translated			evaluated: [ :aNode | (GTObjectPrinter asNonTruncatedTextFrom: aNode label) ];		column: 'Value' translated			evaluated: [ :aNode | | rawValue displayValue |				[ rawValue := aNode rawValue. ] 					on: Error 					do: [ displayValue := Text string: aNode errorMessage attribute: TextColor red ].				displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ]			modified: [ :newValue :editedNode :curentPresentation | 				self updateVariableNode: editedNode basedOn: newValue.				curentPresentation requestRefresh ];		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse' translated;		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect' translated;		dynamicActionsOnSelection: [ :presentation |			(presentation rawSelection isKindOf: GTInspectorVariableNode) 				ifTrue: [presentation rawSelection inspectorActionsForNode ]				ifFalse: [ #() ] ];		selectionAct: [:list | 			((list selection value pointersToExcept: { list selection value })									reject: [ :each | each pointsOnlyWeaklyTo: list selection value ]) inspect ] 			on: $t			entitled: 'Open pointers to' translated	! !!GTEventRecorder methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36025003!gtInspectorActionHelp	<gtInspectorAction>	^ GLMGenericAction new		action: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner key = GTEventRecorderHelp key) and: [				each title = 'Client' ] ] ] ];		icon: GLMUIThemeExtraIcons glamorousHelp;		title: 'Help'! !!MetacelloVersionSpec methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36025440!packageNamed: aString forLoad: ignored forMap: map ifAbsent: absentBlock  "at the end of the day, I don't the forLoad arg is important ...    it just ends up triggering an error ... when during a real load, you would    not get error. After a decent period of mourning we should just scrub this    arg from system"  | importSpec |  ^ map    at: aString    ifAbsent: [       (self importArray notNil or: [ self import notNil ])        ifTrue: [           "expect the 'missing' name to be satisfied within context of imported project"          importArray            ifNotNil: [               importArray                do: [ :assoc |                   ((assoc value includes: aString) and: [ map includesKey: assoc key ])                    ifTrue: [                       importSpec := (map at: assoc key)                        mergeImportLoads: {aString};                        yourself ] ].              importSpec ifNotNil: [ ^ importSpec ] ].          (importSpec isNil and: [ self import notNil ])            ifTrue: [               ^ (map at: self import ifAbsent: absentBlock)                mergeImportLoads: {aString};                yourself ] ].      (aString = 'default' or: [ aString = 'ALL' ])        ifTrue: [           self project groupSpec            name: aString;            includes: self packageNames;            yourself ]        ifFalse: [ absentBlock value ] ]! !!InspectorNavigator methodsFor: 'history' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36026984!inspectHistoryItem: historyItem	"self inspect: historyItem key .	self selectedIndex: historyItem value."	self inspector: historyItem key! !!FTBasicTreeListDataSource class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36027250!exampleBasicInspect: anObject	| ds ft |	ds := FTBasicTreeListDataSource new .		ds	root: #ROOT->anObject;		children: [ :item | item value gtInspectorVariableValuePairs ];		sortChildrenBy: [ :a :b | a key name <= b key name ];		display: [ :item :cell | cell addMorphBack: item printString asMorph ];		yourself.		ft := FTTableMorph new 		extent: 600@(World clearArea height - 80);		dataSource: ds.		ft openInWindow position: 20@10.		^ds! !!FTBasicTreeListDataSource class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36027838!exampleStateTree	| ds ft |	ds := FTBasicTreeListDataSource new .		ds	roots: { #self -> ds } ;		children: [ :item | item value gtInspectorVariableValuePairs ];		sortChildrenBy: [ :a :b | a key name <= b key name ];		display: [ :item :cell | cell 			addMorphBack: item value systemIcon asMorph;			addMorphBack: (item key printString asMorph emphasis: 1; yourself);			addMorphBack: (Morph new color: Color transparent; height: 1; width: 10; yourself);			addMorphBack: (item value printString) asMorph ];		yourself.			ds expand: 3.		ft := FTTableMorph new 		extent: 600@(World clearArea height - 80);		dataSource: ds.		ft openInWindow position: 20@10! !!FTBasicTreeListDataSource class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36028653!exampleInspect: anObject	| ds ft |	ds := FTBasicTreeListDataSource new .		ds	root: #ROOT->anObject;		children: [ :item | item value gtInspectorVariableValuePairs ];		sortChildrenBy: [ :a :b | a key name <= b key name ];		display: [ :item :cell | cell 			addMorphBack: item value class systemIcon asMorph;			addMorphBack: (item key asStringMorph emphasis: 1; yourself);			addMorphBack: (Morph new color: Color transparent; height: 1; width: 10; yourself);			addMorphBack: item value asStringMorph ];		yourself.		ds expand: 1.		ft := FTTableMorph new 		extent: 800@(World clearArea height // 2);		dataSource: ds.		ft openInWindow position: 20@10.		^ds! !!TabContainerMorph methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36029459!addTabs: associations	associations do: [:each |		self tab 			addTab: (Text fromString: each key) 			withAction: [ self setContent: each value ].		container submorphs isEmpty ifTrue: [ container addMorph: each value ]]! !!WeakIdentityKeyDictionary methodsFor: 'enumeration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36029806!valuesDo: aBlock 	"See comments in Dictionary>>valuesDo:.  The code keeps the key so it's	not collected during the evaluation of aBlock"	tally = 0 ifTrue: [ ^self ].	1 to: array size do:		[ :eachIndex | 			| eachAssociation eachKey |			eachAssociation := array at: eachIndex.			nil == eachAssociation ifFalse:				[					eachKey := eachAssociation key.					nil == eachKey ifFalse: [ aBlock value: eachAssociation value ]				]		]! !!PluggableTabBarMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36030361!performActiveTabAction	"Look up the Symbol or Block associated with the currently active tab, and perform it."		| tabActionAssoc aSymbolOrBlock |		tabActionAssoc := self tabs detect: [ :assoc | assoc key = self activeTab.] ifNone: [ Association new ].	aSymbolOrBlock := tabActionAssoc value.	aSymbolOrBlock ifNil: [ ^ false ].	^ aSymbolOrBlock isSymbol		ifTrue: [ self target perform: aSymbolOrBlock ]		ifFalse: [ aSymbolOrBlock value ].	! !!PluggableTabBarMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36030925!mouseDown: anEvent	| xPosition newTab |	xPosition := anEvent cursorPoint x.	newTab :=		((self tabs detect: [ :anAssociation | | tabBounds |				tabBounds := anAssociation key bounds.				xPosition between: tabBounds left and: tabBounds right]			ifNone: [nil])		key).	newTab ifNil: [^ self].	newTab = activeTab ifFalse: [ self activeTab: newTab ]! !!PluggableTabBarMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36031404!layoutChanged	"Fix up our tabs bounds"	| tabsCount |	super layoutChanged.	tabsCount := self tabs size.	tabsCount isZero ifFalse: [ | tabInnerExtent count |		tabInnerExtent := ((self width -				((self tabs first key outerGap + self tabs last key outerGap) // 2)					- tabsCount)			 		// tabsCount)			@ (self height).		count := 1.		self tabs do: [ :anAssociation | | tab |			tab := anAssociation key.			tab innerExtent: tabInnerExtent.			count = 1				ifTrue: [tab position: self position]				ifFalse: [					tab position:						(self position translateBy:							((tabInnerExtent x + 1) * (count - 1))@0)].			count := count + 1  ]	].	self changed.! !!PluggableTabBarMorph methodsFor: 'access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36032202!color: aFillStyle	color := aFillStyle.	self tabs do: [ :anAssociation |		anAssociation key color: aFillStyle ]! !!PluggableTabBarMorph methodsFor: 'private - access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36032440!activeTab	activeTab ifNil: [		self tabs size > 0 ifTrue: [			activeTab := self tabs first key.			activeTab active: true]].	^ activeTab ! !!PluggableTabBarMorph methodsFor: 'drawing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36032695!drawOn: aCanvas	self tabs size > 0 ifFalse: [^ self ].	self tabs do: [ :anAssociation | | tab |		tab := anAssociation key.		tab drawOn: aCanvas]! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36032974!popIntoLiteralVariable: anAssociation 	"Print the Remove Top Of Stack And Store Into Literal Variable bytecode."	self addBytecode: 'popIntoLit: ' , anAssociation key! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36033273!pushConstant: obj	"Print the Push Constant, obj, on Top Of Stack bytecode."	self addBytecode: (String streamContents:				[:s |				s nextPutAll: 'pushConstant: '.				(obj isKindOf: LookupKey)					ifFalse: [obj printOn: s]					ifTrue: [obj key						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]						ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]]).! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36033802!pushLiteralVariable: anAssociation	"Print the Push Contents Of anAssociation On Top Of Stack bytecode."	self addBytecode: 'pushLit: ' , anAssociation key! !!SymbolicBytecodeBuilder methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36034089!storeIntoLiteralVariable: anAssociation 	"Print the Store Top Of Stack Into Literal Variable Of Method bytecode."	self addBytecode: 'storeIntoLit: ' , anAssociation key! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36034379!rangeForPC: concretePC contextIsActiveContext: contextIsActive  	"Answer the indices in the source code for the supplied pc."		| pc |		self sortedSourceMap 		ifEmpty: [ ^(1 to: 0) ].	pc := self abstractPCFor: concretePC when: contextIsActive.	(self sortedSourceMap first key > pc)		ifTrue: [ ^self sortedSourceMap first value ].		^self abstractSourceMap 		at: pc 		ifAbsent: [			(self sortedSourceMap 				findBinary: [:assoc | pc - assoc key ] 				ifNone: [ | end |					end := self sortedSourceMap last value last.					nil -> (end +1 to: end)]) value ]! !!GTSpotter methodsFor: '*GT-SpotterExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36035084!spotterForGlobalVarsFor: aStep	<spotterOrder: 40>	aStep listProcessor			allCandidates: [ Smalltalk globals associations select:[:assoc | 			assoc value isBehavior not and:[ 				assoc value isTrait not]] ];			title: 'Global variables';			itemName:[:global | global key ];			filter: GTFilterSubstring;			wantsToDisplayOnEmptyQuery: false! !!MetaLink methodsFor: 'installing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36035534!checkForCompatibilityWith: aNode	| supported |		supported := Set new.	RFReification subclasses do: [:plugin |		(plugin entities anySatisfy: [:class | aNode isKindOf: class]) ifTrue: [		supported add: plugin key]].	self allReifications do: [ :each | (supported includes: each) ifFalse: [^false  ]  ].	^true! !!IceRepositoriesBrowser methodsFor: 'building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36035965!addRepositoryInfoTo: composite	composite fastTable		title: 'General';		display: #detailedInfo;		column: 'Name' evaluated: #key width: 80;		column: 'Value' evaluated: #value! !!GLMTreeBrick methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36036261!headerFor: anObject in: aCollapsable	|header|		header := GLMBrick new.	header		hSpaceFill;		vShrinkWrap.			header addBrickBack:		((anObject isVariableBinding			ifTrue: [ anObject key asBrick ]			ifFalse: [ anObject asBrick ])				hSpaceFill).					(self hasChildren: anObject) ifTrue: [		header addBrickFirst: (self newToggleButtonFor: aCollapsable) ].		^ header! !!Class methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36036759!gtInspectorInstanceVariablesIn: composite	"This provides a list of all class instance variables and the corresponding values"	<localClassMethod>     "This method is supposed to be local in Class because of a good reason.    We use this pragma to test if Class does not contain some accidental     local selectors."	<gtInspectorPresentationOrder: 21>	composite table		title: 'InstVars';		display: [ self class allInstVarNames sorted collect: [ :each | each -> (self instVarNamed: each) ] ];		column: 'Variable' evaluated: [ :each | each key ];		column: 'Value' evaluated: [ :each | each value ]! !!Class methodsFor: 'pool variables' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36037472!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [self sharedPools remove: aDictionary.				self sharedPools isEmpty ifTrue: [self sharedPools: nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet := self subclasses asOrderedCollection.	satisfiedSet := Set new.	[workingSet isEmpty] whileFalse:		[aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal key 								, ' is still used in code of class '								, sub name]]].	self sharedPools remove: aDictionary.	self sharedPools isEmpty ifTrue: [self sharedPools: nil]! !!Class methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36039216!declareClassVariables: newVars 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	|  conflicts |		conflicts := false.		"Remove. Warn if vars are removed that are still used"	"self flag: something wrong here. put to true and add an ivar to a class"	(self classVariables reject: [:x | newVars includes: x]) do: [:var | self removeClassVarNamed: var name interactive: false].		(newVars reject: [:var | self classVariables includes: var]) do: [:var | "adding"			"check if new vars defined elsewhere"			(self innerBindingOf: var key) 				ifNotNil: [(DuplicatedVariableError new) variable: var name;						signal: var name , ' is defined elsewhere'.					conflicts := true]].	newVars notEmpty		ifTrue: 			[self classPool: self classPool.			"in case it was nil"			newVars do: [:var | self classPool declareVariable: var from: Undeclared]].	^conflicts! !!GTInspector methodsFor: 'building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36040230!compose	self title: [:anObject | 'Inspector on ', (self printObjectAsAnItem: anObject)].	self act: [:b | b update] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.	self act: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner key = GTInspectorHelp key) and: [				each title = 'Overview' ] ] ] ] 		icon: GLMUIThemeExtraIcons glamorousHelp 		entitled: 'Help'.	self act: [:b | b presentationFilter changeFilterRequestFor: b ] entitled: 'Filter presentations'.	self pager with: [ :browser | 		browser fixedSizePanes: self class numberOfInspectorPanes.		browser show: [ :a :each |			a title: [ self printObjectAsAnItem: each ].			a dynamicActions: [ :aPresentation | 				each gtInspectorActions asOrderedCollection ].			a titleAction: [ :aPresentation | self closeActionFor: aPresentation ].			a dynamic 				display: [ :x | 					(GLMCompositePresentation new with: [:d | 						each 							gtInspectorPresentationsIn: d 							inContext: self ])							startOn: x ] ] ].				self browser when: GLMPaneAdded send: #actOnPaneAdded: to: self.	self browser when: GLMPaneRemoved send: #actOnPaneRemoved: to: self.		self class isStepRefreshEnabled ifTrue: [ 		self wantsAutomaticRefresh: true.		self wantsSteps: true.		self stepTime: self class stepRefreshRate ].	! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36041694!allReferencesToPool: aPool from: aClass	"Answer all the references to variables from aPool"	| list |	list := OrderedCollection new.	aClass		withAllSubclassesDo: [ :cls | 			cls				selectorsAndMethodsDo: [ :sel :meth | 					meth literals						detect: [ :lit | lit isVariableBinding and: [ (aPool bindingOf: lit key) notNil ] ]						ifFound: [ list add: (self createMethodNamed: sel realParent: aClass) ] ] ].	^ list! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36042229!allReferencesToPool: aPool	"Answer all the references to variable aPool"	| list |	list := OrderedCollection new.	self		allClassesDo: [ :cls | 			cls				selectorsAndMethodsDo: [ :sel :meth | 					meth literals						detect: [ :lit | (lit isVariableBinding and: [ lit key notNil ]) and: [ (aPool bindingOf: lit key) notNil ] ]						ifFound: [ list add: (self createMethodNamed: sel realParent: cls) ] ] ].	^ list! !!SystemNavigation methodsFor: '*Tool-Base' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36042774!browseUndeclaredReferences	"	SystemNavigation new browseUndeclaredReferences	"		Undeclared removeUnreferencedKeys.	Undeclared associations do: [:binding |		self			browseMessageList: (self allReferencesTo: binding )			name: 'References to Undeclared: ', binding key printString ]! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36043170!methodsWithUnboundGlobals	"This says that for any global, it should match either the class's notion of what bindingOf: the key is, or bindingOf: should be nil and the binding should be in Undeclared. If the class answers a different binding through bindingOf: or answers no binding and the binding is not in Undeclared then the variable in the method is wrong.	For a clean image the result should be empty. If it is not empty, evaluating Compiler recompileAll probably solves the problem. However, we should investigate why the method gets an incorrect state."	"SystemNavigation new methodsWithUnboundGlobals"	^self allMethodsSelect:		[:m|		m literals anySatisfy:			[:l|			l isVariableBinding			and: [l key isSymbol "avoid class-side methodClass literals"			and: [ (l value isKindOf: Slot) not			and: [(m methodClass classBindingOf: l key)					ifNil: [(Undeclared associationAt: l key ifAbsent: []) ~~ l]					ifNotNil: [:b| b ~~ l]]]]]]! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36044250!instanceSideMethodsWithNilKeyInLastLiteral	"This answers all the instance side methods that has NIL as the key in their last literal. There should be none (only class side methods have this)"	^ self		allMethodsSelect: [ :each | 			(((each literalAt: each numLiterals) key isNil and: [ (each literalAt: each numLiterals) value isMeta not ])				and: [ each methodClass ~= UndefinedObject ]) and: [ each isInstalled ] ]! !!SystemNavigation methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36044783!headingAndAutoselectForLiteral: aLiteral do: binaryBlock	"Evaluate aBlock with either Users of ... or Senders of ... plus the auto-select string	 for the given literal.  aLiteral can be a Symbol, a VariableBinding or an arbitrary object."	| autoSelect |	^aLiteral isSymbol		ifTrue: [binaryBlock value: 'Senders of ', aLiteral value: aLiteral ]		ifFalse:			[autoSelect := aLiteral isVariableBinding							ifTrue: [aLiteral key]							ifFalse: [aLiteral printString].			binaryBlock value: 'Users of ', autoSelect value: autoSelect]! !!SystemNavigation methodsFor: 'query' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36045432!obsoleteMethodReferences	"SystemNavigation new obsoleteMethodReferences"	"Open a browser on all referenced behaviors that are obsolete"	| obsClasses references |	references := Array new writeStream.	obsClasses := self obsoleteBehaviors.	'Scanning for methods referencing obsolete classes' 		displayProgressFrom: 0 to: obsClasses size		during: 			[ :bar | 			obsClasses keysAndValuesDo: 					[ :index :each | | obsRefs | 					bar current: index.					obsRefs := each pointersToExcept: obsClasses.					obsRefs do: 							[ :ref | 							"Figure out if it may be a global"							(ref isVariableBinding and: [ref key isString	"or Symbol"]) 								ifTrue: 									[(ref pointersTo) do: 											[:meth | 											meth isCompiledMethod												ifTrue: [meth methodReference ifNotNil: [:mref | references nextPut: mref]]]]]]].	^ references contents! !!Context methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36046429!gtInspectorVariableNodesIn: aCollection	"We override the variables with context specific ones"	| tempVariableValueNodes |		tempVariableValueNodes := self gtInspectorTempNodes sort: [:aNode :anotherNode | aNode key < anotherNode key ].	aCollection addAll: tempVariableValueNodes.	super gtInspectorVariableNodesIn: aCollection! !!Context methodsFor: '*GT-BytecodeDebugger' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36046884!gtBytecodeDebuggerRetrieveContextValues	|fieldList displayedTemp slotsSize tempNames |	fieldList := OrderedCollection new.	displayedTemp := OrderedCollection new.	tempNames := self tempNames.		self stackPtr to: 1 by: -1 do: [ :tempIndex ||tempNode|		fieldList add:			(tempIndex <= tempNames size				ifTrue: [ 					displayedTemp add: (tempNames at: tempIndex).					tempNode := GTInspectorContextNamedTempNode 						hostObject: self 						tempName: (tempNames at: tempIndex) 						tempIndex: tempIndex.					GTInspectorWrapperNode 						hostObject: tempNode						label: (tempIndex - 1) asString, ' [', (tempNames at: tempIndex), ']'  ]				ifFalse: [					 tempNode := GTInspectorContextIndexedTempNode hostObject: self tempIndex: tempIndex.					 GTInspectorWrapperNode 					 	hostObject: tempNode						label: (tempIndex - 1) asString ]) ].		(tempNames copy asOrderedCollection removeAll: displayedTemp; yourself) ifNotEmpty: [ :uninitializedTemps |		uninitializedTemps do: [ :each |			GTInspectorDynamicNode hostObject: self label: ('- [', each, ']') value: nil ] ].		fieldList addAll: (self gtDebuggerDoItBindings collect: [:aBinding |		(GTInspectorDynamicNode hostObject: self label: aBinding key value: aBinding value)			variableTag: 'temp';			yourself ]).		slotsSize := self receiver class allSlots size.	fieldList 		addAll: ((self receiver class allSlots reverse) collect: [:slot ||slotNode|			slotNode :=  GTInspectorSlotNode hostObject: self receiver slot: slot.			GTInspectorWrapperNode 				hostObject: slotNode				label: ('rcv', (slotsSize := slotsSize - 1) asString, ' [', slot name , ']')  ]).		^ fieldList asOrderedCollection 		addFirst: (GTInspectorSelfNode hostObject: self receiver);		addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);		yourself! !!Context methodsFor: '*GT-Debugger' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36048826!gtDebuggerRetrieveVariableValuePairs	|fieldList|	fieldList := SortedCollection 						sortBlock: [:variablePair1 :variablePair2 | 							variablePair1 key < variablePair2 key].	fieldList		addAll: ((self receiver class allSlots collect: [ :slot | 			GTInspectorSlotNode hostObject: self receiver slot: slot ])).			fieldList addAll: self gtInspectorTempNodes.	fieldList addAll: (self gtDebuggerDoItBindings collect: [:aBinding |		(GTInspectorDynamicNode hostObject: self label: aBinding key value: aBinding value)			variableTag: 'temp';			yourself ]).		^ fieldList asOrderedCollection 		addFirst: (GTInspectorSelfNode hostObject: self receiver);		addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);		addLast: (GTInspectorDynamicNode hostObject: self label: 'stack top' value: ( self stackPtr > 0 ifTrue: [ self top]));		yourself! !!MorphTreeNodeMorph methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36049845!buildRowMorph	| rowControls colAndControls |	controls := OrderedCollection new.	colAndControls := container columns 		collect: [:col | | v |			v := col rowMorphFor: complexContents.			controls add: v.			col -> v].	rowControls := OrderedCollection new.	colAndControls		do: [:ctrl | | col morph |			col := ctrl key.			morph := ctrl value.			morph clipSubmorphs: true.			morph vResizing: #shrinkWrap.  			rowControls add: morph.			(morph = controls last and: [container lastColumnUnbounded]) ifFalse: [morph hResizing: #rigid].			(col resizable not and: [col shrinkWrap])				ifTrue: [col currentWidth < morph width 						ifTrue: [col forceWidthTo: morph width]]].	self addAllMorphs: rowControls.	self layoutChanged	! !!PragmaType class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36050694!all	| pragmas |	pragmas := OrderedCollection new.	Object withAllSubclassesDo: [:each |		Pragma withPragmasIn: each do: [:p |			pragmas add: p]].	^ (pragmas groupedBy: #keyword) associations collect: [ :association |		PragmaType new			keyword: association key; 			pragmas: association value ] ! !!VirtualMachine methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36051125!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 0>	composite table		title: 'Details';		display: [ 			{ 				'VM directory' -> self vmDirectory asFileReference.				'VM build date' -> self buildDate.				'VM version' -> self version.				'Image directory' -> self imagePath asFileReference parent.				'Image version' -> self imageVersionNumber.			} ];		column: 'Property' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!ClassWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36051695!selectedClasses	| associations |	associations := self classesSelection associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc key ].	^ associations select: [:each | each notNil ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36052043!mixedStackCall	^MetacelloPlatform current 		stackCacheFor: #mixedStack		at: #key 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 3 ifTrue: [ ^value ].			value := value + 1.			cache at: #x put: value.			self assert: self cachedReturnOfValue == 6.			self mixedStackCall ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36052476!testClearCache	MetacelloPlatform current 		stackCacheFor: #cached		at: #key 		doing: [:cache | | value |			cache at: #x put: 1.			self assert: (cache at: #x ifAbsent: []) == 1.			MetacelloClearStackCacheNotification signal.			self assert: (cache at: #x ifAbsent: []) == nil ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36052881!directReturnOfValue	^MetacelloPlatform current 		stackCacheFor: #direct		at: #key 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 5 ifTrue: [ ^value ].			value := value + 1.			cache at: #x put: value.			self directReturnOfValue ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36053273!mixedStack	^MetacelloPlatform current 		stackCacheFor: #mixed		at: #key 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 3 ifTrue: [ ^value ].			value := value + 1.			cache at: #x put: value.			self assert: self directReturnOfValue == 6.			self assert: self mixedStackCall == 4.			self mixedStack ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36053735!testPrimeStackCache	| cached collection cacheNil direct mixed mixedStack block defaultDictionary |	defaultDictionary := Dictionary new.	block := [ 		cached := Dictionary new.		collection := Dictionary new.		cacheNil := Dictionary new.		direct := Dictionary new.		mixed := Dictionary new.		mixedStack := Dictionary new.		MetacelloPlatform current useStackCacheDuring: [ :dict | self cachedReturnOfValue ] defaultDictionary: cached.		MetacelloPlatform current useStackCacheDuring: [ :dict | self collectionCacheKey ] defaultDictionary: collection.		MetacelloPlatform current useStackCacheDuring: [ :dict | self cacheNil ] defaultDictionary: cacheNil.		MetacelloPlatform current useStackCacheDuring: [ :dict | self directReturnOfValue ] defaultDictionary: direct.		MetacelloPlatform current useStackCacheDuring: [ :dict | self mixedStack ] defaultDictionary: mixed.		MetacelloPlatform current useStackCacheDuring: [ :dict | self mixedStackCall ] defaultDictionary: mixedStack ].		"Test without priming stack cache ... each defaultDictionary is used independently"	block value.	self assert: ((cached at: #cached) at: #key) == 6.	self assert: ((collection at: #collection) at: #x) == 6.	self assert: ((cacheNil at: #cacheNil) at: #key) == nil.	self assert: ((direct at: #direct) at: #x) == 6.	self assert: ((mixed at: #cached) at: #key) == 6.	self assert: ((mixed at: #mixed) at: #x) == 4.	self assert: ((mixed at: #mixedStack) at: #x) == 4.	self assert: ((mixed at: #direct) at: #x) == 6.	self assert: ((mixedStack at: #cached) at: #key) == 6.	self assert: ((mixedStack at: #mixedStack) at: #x) == 4.		"Prime stack cache with defaultDictionary .... all values should be stored there instead of individual defaults."	MetacelloPlatform current primeStackCacheWith: defaultDictionary doing: block.	self assert: ((defaultDictionary at: #cached) at: #key) == 6.	self assert: ((defaultDictionary at: #collection) at: #x) == 6.	self assert: ((defaultDictionary at: #cacheNil) at: #key) == nil.	self assert: ((defaultDictionary at: #direct) at: #x) == 6.	self assert: ((defaultDictionary at: #cached) at: #key) == 6.	self assert: ((defaultDictionary at: #mixed) at: #x) == 4.	self assert: ((defaultDictionary at: #mixedStack) at: #x) == 4.	self assert: ((defaultDictionary at: #direct) at: #x) == 6.	self assert: ((defaultDictionary at: #cached) at: #key) == 6.	self assert: ((defaultDictionary at: #mixedStack) at: #x) == 4! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36056379!cachedReturnOfValue	^MetacelloPlatform current 		stackCacheFor: #cached		at: #key 		doing: [:cache | | value |			value := cache at: #x ifAbsent: [ 0 ].			value > 5 				ifTrue: [ cache at: #key put: value ]				ifFalse: [ 					value := value + 1.					cache at: #x put: value ].			self cachedReturnOfValue ]! !!MetacelloStackCacheTestCase methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36056826!cacheNil	^MetacelloPlatform current 		stackCacheFor: #cacheNil		at: #key 		doing: [:cache | | value |			cache at: #key put: nil.			self cacheNil ]! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36057117!testArrayPairsUnderLimit	| limit pairs|		limit := 2*GTInspector indexableDisplayLimit - 1.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = limit.	(pairs collect: #key) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #key) = (1 to: limit) asOrderedCollection).! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36057584!testArrayPairsSmall	| pairs |		pairs := (1 to: 10) asArray gtInspectorVariableValuePairs.	self assert: pairs size = 10.	(pairs collect: #key) allSatisfy: [ :e | (pairs at: e) = e ].! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36057897!testArrayPairsLong		| limit pairs |		limit := 3*GTInspector indexableDisplayLimit.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = (2*GTInspector indexableDisplayLimit).	(pairs collect: #key) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #key) = ((1 to: GTInspector indexableDisplayLimit ) asOrderedCollection 		addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection; yourself)).! !!GTInspectorVariableValuePairsTest methodsFor: 'context' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36058519!testContextNodes	| pairs x tempVariables indexVariables instVariables |		x:=42.	pairs := OrderedCollection new.	[:y| y+1+x ] asContext gtInspectorVariableNodesIn: pairs.		pairs := pairs withIndexCollect: [ :e :i | i -> e].		tempVariables := pairs select: [ :e | e value label beginsWith: '[' ].	indexVariables := pairs select: [ :e | e value key isInteger ].	instVariables := pairs select: [ :e | e value isKindOf: GTInspectorSlotNode ].		self assert: (tempVariables sort last key) < (indexVariables first key).	self assert: (indexVariables sort last key) < (instVariables first key).! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36059283!testArrayPairsEqualLimit	| limit pairs|		limit := 2*GTInspector indexableDisplayLimit.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = limit.	(pairs collect: #key) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #key) = (1 to: limit) asOrderedCollection).! !!GTInspectorVariableValuePairsTest methodsFor: 'object' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36059746!testArrayPairsOverLimit	| limit pairs |		limit := 2*GTInspector indexableDisplayLimit + 1.	pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.	self assert: pairs size = (2*GTInspector indexableDisplayLimit).	(pairs collect: #key) allSatisfy: [ :e | (pairs at: e) = e ].		self assert: ((pairs collect: #key) = ((1 to: GTInspector indexableDisplayLimit ) asOrderedCollection 		addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection; yourself)).! !!GTPlayground methodsFor: 'accessing-dynamic' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36060365!currentBindingsSorted	^ self currentBindings associations asSortedCollection: [ :first :second | first key < second key ]! !!GTPlayground methodsFor: 'accessing-dynamic' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36060615!removeBinding: anAssociation	|bindings|	bindings := self currentBindings copy.	bindings removeKey: anAssociation key ifAbsent: [ ].	self setBindings: bindings.! !!GTPlayground methodsFor: 'building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36060887!compose	self title: self defaultPlaygroundTitle.	self act: [:b | b update] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.	self act: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner key = GTPlaygroundHelp key) and: [				each title = 'Overview' ] ] ] ] 		icon: GLMUIThemeExtraIcons glamorousHelp 		entitled: 'Help'.			self act: [ :b | 			SettingBrowser new 				changePackageSet: { (RPackageOrganizer default packageNamed: 'GT-Playground') }; 				open; 				expandAll ] 		icon: (Smalltalk ui icons iconNamed: #smallCogInitialState)		entitled: 'Global Setting'.			self custom:			(GTInspector new				noTitle; 				noActions;				wantsAutomaticRefresh: true;				showFirst: [ :composite |					self codeIn: composite ];				yourself);		when: GLMBrowserClosing do: [ :ann |			self actOnBrowserClosing: ann ].		GTInspector isStepRefreshEnabled ifTrue: [		self wantsAutomaticRefresh: true.		self wantsSteps: true.		self stepTime: GTInspector stepRefreshRate ]	! !!GTSpotterMorph methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36062059!initializeListeners	self activeHand addEventListener: self.	Morph announcer weak when: MorphLostFocus send: #onLostFocus: to: self.	self bindingDictionnary		associationsDo: [ :anAssociation | self bindKeyCombination: anAssociation key toAction: anAssociation value ].	processorKeyBindings := Dictionary new.! !!DAManuallyAddedDependentPackageNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36062503!children	^ self content dependencies flatCollect: 		[ :dependency | 		dependency users collect: 			[ :association | | method sentMessages |			method := association key.			sentMessages := association value.			DAMessageSendDependencyNode new				content: method;				parentNode: self;				sentMessages: sentMessages 				yourself ] ]! !!FLMigration methodsFor: 'evaluating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36062950!applyTo: aVariablesMapping 		variables do: [:link |		aVariablesMapping 			map: link key 			to: link value ]	! !!SelectRuleBrowser class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36063192!items	| rules rulesByGroup integrationRules |	rules := (ReRuleManager visibleRuleClasses collect: #new) sorted: [ :a :b |		a name < b name ].	integrationRules := rules select: [ :r |		PharoCriticRules pharoHardLintRules includes: r class ].	rulesByGroup := ((rules groupedBy: #group) associations collect: [ :as |		CriticBrowserRulesGroup named: as key rules: as value ]).	rulesByGroup sort: [ :a :b | a name < b name ].	^ rulesByGroup copyWithFirst: (		CriticBrowserRulesGroup			named: 'Pharo integration rules'			rules: integrationRules)! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36063852!determineDecipherIndexWith: anInteger	(( anInteger - self key ) < 0)			ifTrue: 		[ ^anInteger - self key + self alphabet size ]			ifFalse:		[ ^anInteger - self key ]! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36064150!decipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (( self alphabet findString: letter asString) - self key) ].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36064396!determineCipherIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^anInteger + self key - self alphabet size ]			ifFalse:		[ ^anInteger  + self key ]! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36064713!fixDependents	"They are not used much, but need to be right"	DependentsFields associationsDo:		[:pair |		pair value do:			[:dep |			(references at: dep ifAbsent: [nil]) ifNotNil:				[:newDep| | newModel |				newModel := references at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36065146!testAsTestMethod	{((self stubClass >> #one) -> (self stubTestClass >> #testOne)).	((self stubClass >> #one:) -> (self stubTestClass >> #testOne)).	((self stubClass >> #two) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #two:) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #oneTwo:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #untestedOne) -> nil).	((self stubClass >> #untestedOne:) -> nil).	((self stubClass >> #untestedTwo) -> nil).	((self stubClass >> #untestedTwo:) -> nil).	((self stubClass >> #untestedOne:two:) -> nil).	((self stubClass >> #untestedOneTwo:) -> nil).	((self stubClass class >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass class >> #untestedOne:two:) -> nil).	((self stubTestClass >> #testOne) -> (self stubTestClass >> #testOne)).	((self stubTestClass >> #testTwo) -> (self stubTestClass >> #testTwo)).	((self stubTestClass >> #testOneTwo) -> (self stubTestClass >> #testOneTwo))}		do: [ :each | self assert: each key asTestMethod == each value ]! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36066381!testCorrespondingTestCase	"tests that classes and their meta classes have the same test class	corresponding to them"	{(Behavior -> BehaviorTest).	(Behavior class -> BehaviorTest).	(BehaviorTest -> nil).	(Class -> ClassTest).	(Class class -> ClassTest).	(ClassTest -> nil).	(Metaclass -> MetaclassTest).	(Metaclass class -> MetaclassTest).	(MetaclassTest -> nil).	(NautilusUtilsTestStub -> NautilusUtilsTestStubTest).	(NautilusUtilsTestStub class -> NautilusUtilsTestStubTest).	(NautilusUtilsTestStubTest -> nil).	(NautilusUtilsTestStubUntested -> nil).	(NautilusUtilsTestStubUntested class -> nil)}		do: [ :each | self assert: each key correspondingTestCase == each value ]! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36067182!testCorrespondingTestedMethods	{(self stubTestClass >> #testOne) ->		{(self stubClass >> #one).		(self stubClass >> #one:)}.	(self stubTestClass >> #testTwo) ->		{(self stubClass >> #two).		(self stubClass >> #two:)}.	(self stubTestClass >> #testOneTwo) ->		{(self stubClass >> #one:two:).		(self stubClass >> #oneTwo:).		(self stubClass class >> #one:two:)}.	(self stubTestClass >> #stubClass) ->		{}.	(self stubTestClass >> #newStub) ->		{}} do: [ :each |		self assert: each key correspondingTestedMethods asSet = each value asSet].	"non-test methods should have no corresponding tested methods"	self stubClass methods , self stubClass class methods do: [ :each | 			self assert: each correspondingTestedMethods isEmpty ]! !!NautilusUtilsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36068034!testCorrespondingTestMethod	{((self stubClass >> #one) -> (self stubTestClass >> #testOne)).	((self stubClass >> #one:) -> (self stubTestClass >> #testOne)).	((self stubClass >> #two) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #two:) -> (self stubTestClass >> #testTwo)).	((self stubClass >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #oneTwo:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass >> #untestedOne) -> nil).	((self stubClass >> #untestedOne:) -> nil).	((self stubClass >> #untestedTwo) -> nil).	((self stubClass >> #untestedTwo:) -> nil).	((self stubClass >> #untestedOne:two:) -> nil).	((self stubClass >> #untestedOneTwo:) -> nil).	((self stubClass class >> #one:two:) -> (self stubTestClass >> #testOneTwo)).	((self stubClass class >> #untestedOne:two:) -> nil).	((self stubTestClass >> #testOne) -> nil).	((self stubTestClass >> #testTwo) -> nil).	((self stubTestClass >> #testOneTwo) -> nil)}		do: [ :each | self assert: each key correspondingTestMethod == each value ]! !!NetNameResolver class methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36069207!waitForResolverNonBusyUntil: deadline	"Wait up to the given number of seconds for the resolver to be non busy.	Return the resolver state."	| status passed |	status := self resolverStatus.	[ status = ResolverBusy and: [ (passed := Time millisecondsSince: deadline key) < deadline value] ]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline value - passed).			status := self resolverStatus ].	^ status! !!Callback methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36069769!evaluatorForSignature: signature "<String|Array>"	"Search the methods marked with the signature: primtiive for those that match signature.	 signature is typically a literal Array for the function's C signature, e.g. #(int (*)(int, char *))."	Pragma withPragmasIn: self class do:		[:pragma|		 (pragma key == #signature:		  and: [(pragma argumentAt: 1) = signature]) ifTrue:			[^pragma method]].	self error: 'could not find Callback signature'! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36070335!decoratorNamed: aKey	^ self key = aKey		ifTrue: [ self ]		ifFalse: [ next decoratorNamed: aKey ]! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36070551!Differencekey	^self class key! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36380039!key	^self class key! !!RubParagraphDecorator methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36070835!hasDecoratorNamed: aKey	^ self key = aKey or: [ next hasDecoratorNamed: aKey ]! !!RubParagraphDecorator class methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36071037!classOfDecoratorNamed: aKey 	^ self allSubclasses detect: [ :cls | cls key = aKey ] ifNone: [  ]! !!SystemHelp class methodsFor: 'conversion' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36071248!asHelpTopic 	|topic helpOnHelp sortedTopics |	topic := HelpTopic named: 'Help'.	self allSystemHelpPragmas do: [:each | 		topic subtopics addAll: each method methodClass theNonMetaClass asHelpTopic subtopics	].	topic sortSubtopicsByTitle.	helpOnHelp := topic subtopics detect: [:t | t key = 'HelpOnHelp'] ifNone: [self error: 'Help for the help system is removed'].	sortedTopics := topic subtopics.	sortedTopics remove: helpOnHelp.	sortedTopics addLast: helpOnHelp.	topic subtopics: sortedTopics.	^topic.! !!Date methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36071884!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'year' -> self year.					'month' -> self monthIndex.					'month name' -> self monthName.					'day of month' -> self dayOfMonth.					'day of week' -> self dayOfWeekName.					'day of year' -> self dayOfYear.					'iso' -> self yyyymmdd } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!MetacelloMCVersionSpec methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36072461!packageSpecsInLoadOrderForMap: packageMap  | loadOrder pkgs packageNames importNames importSpec importProjectSpecs importProjectNameMap |  loadOrder := self packageSpecsInLoadOrder.  importNames := (packageNames := (packageMap values    collect: [ :pkg | pkg name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ])    ifTrue: [ ^ loadOrder select: [ :pkg | packageNames includes: pkg name ] ].  loadOrder do: [ :pkg | importNames remove: pkg name ifAbsent: [  ] ].  pkgs := OrderedCollection new.  importProjectSpecs := Dictionary new.  importProjectNameMap := Dictionary new.  importArray    ifNotNil: [       loadOrder        do: [ :pkg |           importArray            do: [ :assoc |               assoc key = pkg name                ifTrue: [                   importProjectSpecs at: pkg name put: pkg.                  (assoc value select: [ :each | importNames includes: each ])                    do: [ :each |                       (importProjectNameMap                        at: pkg name                        ifAbsent: [ importProjectNameMap at: pkg name put: Set new ])                        add: each ] ] ] ] ].  self import    ifNotNil: [       loadOrder        do: [ :pkg |           pkg name = self import            ifTrue: [               importProjectSpecs at: pkg name put: pkg.              importProjectNameMap at: pkg name put: importNames ] ] ].  loadOrder    do: [ :pkg |       (packageNames includes: pkg name)        ifTrue: [ pkgs add: pkg ].      importProjectSpecs        at: pkg name        ifPresent: [ :importProjectSpec |           "insert the imports at this point"          (importProjectNameMap at: pkg name ifAbsent: [ #() ])            do: [ :importedName |               pkgs                add:                  (importSpec := importProjectSpec copy                    name: importedName;                    mergeImportLoads: {importedName};                    yourself).              importSpec projectReference name: importedName ] ] ].  ^ pkgs! !!SourceFileArray methodsFor: 'public - string reading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36074647!timeStampAt: sourcePointer for: sourceDataPointers	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	| preamble stamp tokens stampPosition |	stamp := ''.	preamble := self sourcedDataAt: sourcePointer.	(preamble includesSubstring: sourceDataPointers key)		ifTrue: [ 			tokens := preamble parseLiterals.			stampPosition := tokens indexOf: sourceDataPointers value.			stampPosition = 0				ifFalse: [ 					"New format gives change stamp and unified prior pointer"					stamp := tokens at: stampPosition + 1 ] ].	^ stamp! !!SourceFileArray methodsFor: 'public - string reading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36075406!protocolAt: sourcePointer for: sourceDataPointers	"Answer the protocol for a given method, retrieved from the sources or changes file. Answer unfound protocol if no protocol is available."	| preamble protocol tokens protocolPosition |	protocol := 'unfound protocol'.	"this is to indicate that the tagging in the source does not use the correct format.	We will have to fix that. For example some traits methods are wrongly tagged.	see http://code.google.com/p/pharo/issues/detail?id=4581"	preamble := self sourcedDataAt: sourcePointer.	preamble = 'Trait method' ifTrue: [ ^ nil ].	(preamble includesSubstring: sourceDataPointers key) ifTrue: [ 		tokens := preamble parseLiterals.		protocolPosition := tokens indexOf: sourceDataPointers key.		protocolPosition = 0			ifFalse: [ 				"New format gives change protocol and unified prior pointer"				protocol := tokens at: protocolPosition + 1 ] ].	^ protocol! !!RectangleTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36076440!testStoreOn	| assoc assoc2 |	assoc := (0 @ 0 extent: 1 @ 1) -> 0.	assoc2 := self class compiler evaluate: assoc storeString.	self assert: assoc key = assoc2 key.	self assert: assoc value = assoc2 value! !!Character methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36076781!gtInspectorCharacterIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Character';		display: [			{'self' -> self.			'codepoint' -> self codePoint.			'unicode' -> (String streamContents: [ :stream | 				stream << 'U+'.				self codePoint printOn: stream base: 16 nDigits: 4 ])} ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: [ :each | each value printString ];		send: #value! !!LGitReturnCodeEnum class methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36077325!setUpHandlers	^ (self declaration associations collect: [ :nameToValue |		nameToValue key -> (LGitCallReturnHandler for: (self perform: nameToValue key)) ]) asDictionary! !!HookGenerator methodsFor: 'initialize' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36077617!entity: anEntity node: aNode links: aCollection	plugins := Dictionary new.	node := aNode.	entity := anEntity.	links := aCollection.		"register all the plugins that can reify information for this node"	RFReification subclasses do: [:plugin |		(plugin entities anySatisfy: [:class | entity isKindOf: class])	 ifTrue: [			plugins at: plugin key put: plugin]		].! !!HookGenerator methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36078094!preamble	| preamble |	"Very simplistic now: needs to do some optimizatons"		preamble := OrderedCollection new.	links do: [:link |  		plugins do: [ :plugin | (link allReifications includes: plugin key) ifTrue: [preamble addAll: ((plugin entity: entity link: link) preamble: entity)]].		link control = #instead ifTrue: [				"for instead links, the preamble needs to clean the stack. For now just implemented for message sends"				entity isMessage ifTrue: [					entity numArgs + 1 timesRepeat: [preamble add: (RFStorePopIntoTempNode named: #RFBalancestack)]]]].	^preamble! !!IRBytecodeGenerator methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36078787!addLastLiteral: object	lastLiteral ifNil: [ ^ lastLiteral := object ].	((lastLiteral literalEqual: object)		or: [ 			"case of metaclass, they have no unique association"			(lastLiteral isKindOf: Association) and: [ lastLiteral key isNil ] ])		ifFalse: [ self error: 'there can only be one last literal' ]! !!IRBytecodeGenerator methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36079211!bytecodes	| stream |	self updateJumpOffsets.	stream := (ByteArray new: 100) writeStream. 	primitiveBytes ifNotNil: [stream nextPutAll: primitiveBytes contents].	orderSeq do: [ :seqId | |lastInstr|			"If the instruction will emit bytes, record the first byte emitted as the instructions bytecode index"			lastInstr := IRInstruction new -> 1.			(instrMaps at: seqId) do: [ :assoc | |nextInstr|				nextInstr := assoc.				lastInstr key bytecodeIndex: ((nextInstr value - lastInstr value) > 0 ifTrue: [ 					stream position + lastInstr value]).				lastInstr := assoc.				  ].			lastInstr key bytecodeIndex: ((seqBytes at: seqId) size < lastInstr value ifFalse: [  stream position + lastInstr value]).			stream nextPutAll: (seqBytes at: seqId) ].	^ stream contents! !!MorphTreeNavigationBar methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36080114!pageSearchText: aString	| founds chosen chosenNode |	pageSearchText := aString.	self changed: #pageSearchText.	founds := OrderedCollection new.	self nodeList doWithIndex: [:n :idx |		(n includesSubstringAnywhere: pageSearchText)			ifTrue: [founds add: idx -> n]].	founds ifEmpty: [ ^ self flash ].	founds size > 1 		ifTrue: [ 			chosen := 				UIManager default 					chooseFrom: (founds collect: [:l | l value] ) 					values: (founds collect: [:l | l key] ) 					lines: nil 					title: ''.			chosen ifNil: [^self]]		ifFalse: [chosen := founds first key].	self currentPage: (self pageOfNodeIndex: chosen).	chosenNode := self nodeList at: chosen.	treeMorph scroller 		submorphsDo: [:sm | 			sm complexContents ==  chosenNode				ifTrue: [treeMorph listManager setSelectedMorph: sm.					^ treeMorph scrollSelectionIntoView]]! !!GTInspectorVariableNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36081089!label	"Answer the label of this object variable (slot, indexed attribute, computed value)."	^ self key asString! !!Association methodsFor: '*Glamour-Helpers' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36081317!asGlamourTargetIdentifier	^ GLMPortIdentifier new 		paneName: self key;		portName: self value! !!Association methodsFor: '*Glamour-Helpers' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36081528!asGlamourOriginIdentifier	^ GLMPortIdentifier new 		paneName: self key;		portName: self value! !!Association methodsFor: 'self evaluating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36081738!isSelfEvaluating	^ self class == Association and: [self key isSelfEvaluating and: [self value isSelfEvaluating]]! !!FileReference methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36081980!gtInspectorFuelIn: composite	<gtInspectorPresentationOrder: 40>	"(FileSystem disk workingDirectory / 'GTtest.fuel') writeStreamDo: [ :stream |	FLSerializer newDefault		at: #author putAdditionalObject: 'Author: Max Leske';		at: #date putAdditionalObject: DateAndTime now;		addPreMaterializationAction: [ Smalltalk inform: 'starting materialization' ];		addPostMaterializationAction: [ :materialization | materialization inspect ];		serialize: 'foo' on: stream binary ].	FLMaterializer materializeFromFileNamed: 'GTtest.fuel'"	composite table			title: 'Fuel Header';			display: [				(FLMaterializer materializeHeaderFromFileNamed: self fullName) gtGetMetaData ];			column: 'Property' evaluated: [:assoc| assoc key ];			column: 'Value' evaluated: [:assoc| assoc value];			when: [ self isFile and: [self extension = 'fuel' ] ]! !!Time methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36082939!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'hours' -> self hours.					'minutes' -> self minutes.					'seconds' -> self seconds.					'nanoseconds' -> self nanoSecond.					'meridian' -> self meridianAbbreviation.					'iso' -> self print24 } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!OpalBytecodeEncoder methodsFor: 'temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36083470!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:str|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| str nextPut: { remoteLocal key. { index. innerIndex } }]]							ifFalse: [str nextPut: { local key. index }]]])].	^blockExtentsToTempsMap! !!KeyedTree methodsFor: 'copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36084564!postCopy	"Must copy the associations, or later store will affect both the		original and the copy.	Copy any subtrees too!!"	array := array collect: [:assoc |			assoc ifNil: [nil]				ifNotNil: [Association							key: assoc key							value: ((assoc value isKindOf: KeyedTree)									ifTrue: [assoc value copy]									ifFalse: [assoc value])]]! !!SymbolTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36085021!testReadFrom	self expectedBehavior do: [:association |		self assert: (association key value == association value)]! !!SymbolTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36085251!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!Integer methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36085801!gtInspectorIntegerIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Integer';		display: [ | associations |			associations :=	{					'decimal' -> self printString.					'hex' -> self printStringHex.					'octal' -> (self printStringBase: 8).					'binary' -> (self printStringBase: 2)} asOrderedCollection.			(self between: 0 and: 16r10FFFF)				ifTrue: [ associations add: 'character' -> self asCharacter ].			associations ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: [ :each | each value printString ];		send: #value! !!Dictionary methodsFor: '*Slot' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36086475!declareVariable: newGlobal from: aDictionary 	"Add aGlobal to the receiver. If key already exists, do nothing. If aDictionary 	includes key, then remove it from aDictionary and use its association as 	the element of the receiver."	| globalName |	globalName :=  newGlobal key.	self associationAt: globalName ifPresent:  [:existingGlobal |		"need to take care to migrate existing variables to new global if class if different"		(existingGlobal class == newGlobal class) 			ifTrue: [^self].		newGlobal value: existingGlobal value.		self removeKey: globalName.		self add: newGlobal.		].	(aDictionary includesKey: globalName)		ifTrue:  [			self add: ((aDictionary associationAt: globalName) primitiveChangeClassTo: ClassVariable new).			aDictionary removeKey: globalName]		ifFalse: [			self add: newGlobal]! !!Dictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36087405!keysAndValuesDo: aBlock	^self associationsDo:[:assoc|		aBlock value: assoc key value: assoc value].! !!Dictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36087611!isHealthy	"Test that object hashes match their positions stored in set's array,	answer true if everything ok, false otherwise		Dictionary allInstances select: [:dict |		dict isHealthy not ]	Dictionary allSubInstances select: [:dict |		dict isHealthy not ]	"	array withIndexDo: [:elem :i |		elem ifNotNil: [			(self scanFor: elem key) == i ifFalse: [ ^ false ]			]	].	^ true! !!Dictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36088105!keyForIdentity: anObject	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"	self associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc key]].	^ nil! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36088504!noCheckAdd: anObject	"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association."	array at: (self findElementOrNil: anObject key) put: anObject.	tally := tally + 1! !!Dictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36088826!add: anAssociation	| index element |	index := self findElementOrNil: anAssociation key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: anAssociation]		ifFalse: [element value: anAssociation value].	^ anAssociation! !!Dictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36089187!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !!Dictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36089773!includesAssociation: anAssociation  ^ (self         associationAt: anAssociation key      ifAbsent: [ ^ false ]) value = anAssociation value! !!Dictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36090024!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	Note: There can be multiple keys with the same value. Only one is returned." 	self associationsDo: 		[:association | value == association value ifTrue: [^association key]].	^exceptionBlock value! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36090515!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			array				at: (self scanForEmptySlotFor: association key)				put: association ] ]! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36090975!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36091863!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := array at: (index := index \\ array size + 1)) == nil ] whileFalse: [		| newIndex |		(newIndex := self findElementOrNil: element key) = index ifFalse: [			array swap: index with: newIndex ] ]! !!Dictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36092426!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | aBlock value: association key]! !!Dictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36092669!keysAndValuesRemove: keyValueBlock	"Removes all entries for which keyValueBlock returns true."	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."	| removals |	removals := OrderedCollection new.	self associationsDo:		[:assoc | (keyValueBlock value: assoc key value: assoc value)			ifTrue: [removals add: assoc key]]. 	removals do:		[:aKey | self removeKey: aKey]! !!Dictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36093399!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast." 	self associationsDo: 		[:association | value = association value ifTrue: [^association key]].	^exceptionBlock value! !!Dictionary methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36093947!gtInspectorItemsIn: composite	^ (composite fastTable)		title: 'Items';		display: [ self associations ];		"children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];"		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each key ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		selectionAct: [ :table |			table rawSelection do: [ :assoc | self removeKey: assoc key ].			table update ]			entitled: 'Remove item(s)';		selectionPopulate: #selection 			entitled: 'Open key'			with: [ :table | (table rawSelection collect: #key) gtInspectorInterestingObject ];		beMultiple;		send: [ :selection | 			selection isNil 			ifTrue:[nil]			ifFalse:[ (selection size = 1) 				ifTrue: [ selection anyOne value ] 				ifFalse: [ selection collect: #value ] ]]		"withSmalltalkSearch;		showOnly: 50;		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'"! !!Dictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36095258!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := self species new.	self associationsDo:[:each |		newCollection at: each key put: (aBlock value: each value).	].	^newCollection! !!Dictionary class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36095720!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}	{1->#a. 2->#b. 3->#c} as: NewDictionary	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}	{1->#a. 2->#b. 1->#c} as: NewDictionary"! !!FontChooserMorph methodsFor: 'interface building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36096393!languages		^ self pangrams collect: #key! !!PluggableDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36096549!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableDictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36097712!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self equalBlock = aDictionary equalBlock ifFalse: [^false].	self hashBlock = aDictionary hashBlock ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !!LabelModel methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36098418!emphasisForCode: aCode	^ {(#bold -> 1).	(#italic -> 2).	(#underline -> 4).	(#narrow -> 8).	(#struck -> 16)}		collect: [ :pair | 			(aCode bitAnd: pair value) = 0				ifFalse: [ pair key ] ]		thenReject: #isNil! !!MorphTreePager methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36098746!choosePage	| choiceList chosen |	choiceList := OrderedCollection new.	self allIntervals 		doWithIndex: [:assoc :idx | | choiceString |			choiceString := idx asString, ': ', (self nodeList at: assoc key) asString, ' ... ', (self nodeList at: assoc value) asString.			choiceList add: idx -> choiceString].	chosen := 		UIManager default 			chooseFrom: (choiceList collect: [:c | c value])			values: (choiceList collect: [:c | c key])			lines: nil 			title: 'Choose a page'.	chosen ifNil: [^self].	self currentPage: chosen.! !!NautilusPluginManager methodsFor: 'lists behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36099412!selectedPluginClasses	| associations list |	list := self getPluginClassesList.	pluginClassesSelected ifNil: [ ^ {} ].	associations := pluginClassesSelected associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc key ].	associations := associations sort: [:a : b | (list indexOf: a ifAbsent: [ 0 ]) <= (list indexOf: b ifAbsent: [ 0 ])].	^ associations select: [:each | each notNil ]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36099976!sortedPropertyNames	"answer the receiver's property names in a sorted way"	| props |	props := (Array new: 10) writeStream.	locked == true ifTrue: [props nextPut: #locked].	visible == false ifTrue: [props nextPut: #visible].	sticky == true ifTrue: [props nextPut: #sticky].	balloonText ifNotNil: [props nextPut: #balloonText].	externalName ifNotNil: [props nextPut: #externalName].	eventHandler ifNotNil: [props nextPut: #eventHandler].	 otherProperties ifNotNil: [otherProperties associationsDo: [:a | props nextPut: a key]].	^props contents sort: [:s1 :s2 | s1 <= s2]! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36100676!codeAnyLitInd: association	^VariableNode new		name: association key		key: association		index: 0		type: LdLitIndType! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36100917!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol := selector key.	(node := BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node := self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: symbol precedence! !!GTEventTool methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36101497!gtInspectorActionHelp	<gtInspectorAction>	^ GLMGenericAction new		action: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner key = GTEventRecorderHelp key) and: [				each title = 'Data Analysis' ] ] ] ];		icon: GLMUIThemeExtraIcons glamorousHelp;		title: 'Help'! !!HeapTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36101936!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!GLMRubricSmalltalkTextModel methodsFor: 'bindings' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36102486!appendVariableBinding: anAssociationList	anAssociationList ifNotNil: [		anAssociationList do: [ :anAssociation | 			self variableBindings add: 				((anAssociation class = WorkspaceVariable) 					ifTrue: [ anAssociation ] 					ifFalse: [ (WorkspaceVariable key: anAssociation key value: anAssociation value) ]) ] ]! !!ZnUrlTests methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36102911!testReferenceResolution	"RFC 3986 Section 5"		| baseUri specification result succeeded failed |	baseUri := 'http://a/b/c/d;p?q' asZnUrl.	specification := {		"Examples 5.4.1 - Normal" 		" 'g:h' -> 'g:h'. " "we do not support unknown schemes without //"		'mailto:john@acme.com' -> 'mailto:john@acme.com'. "this we can do"		'g' -> 'http://a/b/c/g'.		'./g' -> 'http://a/b/c/g'.		'g/' -> 'http://a/b/c/g/'.		'/g' -> 'http://a/g'.		'//g' -> 'http://g/'.  "a trailing slash is added automatically"		'//a.com/assets/img.jpg' -> 'http://a.com/assets/img.jpg'.		'?y' -> 'http://a/b/c/d;p?y'.		'g?y' -> 'http://a/b/c/g?y'.		'#s' -> 'http://a/b/c/d;p?q#s'.		'g#s' -> 'http://a/b/c/g#s'.		'g?y#s' -> 'http://a/b/c/g?y#s'.		';x' -> 'http://a/b/c/;x'.		'g;x' -> 'http://a/b/c/g;x'.		'g;x?y#s' -> 'http://a/b/c/g;x?y#s'.		'' -> 'http://a/b/c/d;p?q'.		'.' -> 'http://a/b/c/'.		'./' -> 'http://a/b/c/'.		'..' -> 'http://a/b/'.		'../' -> 'http://a/b/'.		'../g' -> 'http://a/b/g'.		'../..' -> 'http://a/'.		'../../' -> 'http://a/'.		'../../g' -> 'http://a/g'.		"Examples 5.4.2 - Abnormal" 		'../../../g' -> 'http://a/g'.		'../../../../g' -> 'http://a/g'.		'/./g' -> 'http://a/g'.		'/../g' -> 'http://a/g'.		'g.' -> 'http://a/b/c/g.'.		'.g' -> 'http://a/b/c/.g'.		'g..' -> 'http://a/b/c/g..'.		'..g' -> 'http://a/b/c/..g'.		'./../g' -> 'http://a/b/g'.		'./g/.' -> 'http://a/b/c/g/'.		'g/./h' -> 'http://a/b/c/g/h'.		'g/../h' -> 'http://a/b/c/h'.		'g;x1/./y' -> 'http://a/b/c/g;x1/y'.		'g;x1/../y' -> 'http://a/b/c/y'.		'g?y/./x' -> 'http://a/b/c/g?y/./x'.		'g?y/../x' -> 'http://a/b/c/g?y/../x'.		'g#s/./x' -> 'http://a/b/c/g#s/./x'.		'g#s/../x' -> 'http://a/b/c/g#s/../x'.		'http://g' -> 'http://g/' "a trailing slash is added automatically"	}.	result := specification withIndexCollect: [ :spec :index | | resolved success |		resolved := baseUri withRelativeReference: spec key.		success := resolved asString = spec value.		{ #input -> spec key. #expected -> spec value. #index -> index.		#resolved -> resolved. #result -> success } asDictionary ].	succeeded := result select: [ :each | each at: #result ].	failed := result reject: [ :each | each at: #result ].	self assert: failed isEmpty! !!MethodNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36105263!selector 	"Answer the message selector for the method represented by the receiver."	(selectorOrFalse isSymbol)		ifTrue: [^selectorOrFalse].	^selectorOrFalse key.! !!MethodNode methodsFor: 'converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36105538!preenLocalIfNotNilArg	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where	 the block already declares the variable and the decompile case where it does not."	| varsToHide |	varsToHide := Set new.	self nodesDo:		[:node| | variable |		(node isMessageNode		and: [node macroPrinter == #printIfNilNotNil:indent:		and: [node receiver isMessageNode		and: [node receiver selector key == #==		and: [node receiver receiver isAssignmentNode		and: [(variable := node receiver receiver variable) isTemp		and: [variable isRemote not		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:			[node arguments last arguments isEmpty				ifTrue: [node arguments last arguments: { variable }.						varsToHide add: variable]				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].			 node receiver receiver: node receiver receiver value]].	varsToHide notEmpty ifTrue:		[self nodesDo:			[:node|			((node == self or: [node isBlockNode])			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !!MethodNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36106943!printOn: aStream	| selectorNode |	selectorNode := self selectorNode.	precedence = 1		ifTrue:			[selectorNode isForFFICall				ifTrue: [selectorNode							printAsFFICallWithArguments: arguments							on: aStream							indent: 0]				ifFalse: [aStream nextPutAll: selectorNode key]]		ifFalse:			[selectorNode key keywords with: arguments do:				[:kwd :arg |				aStream nextPutAll: kwd; space; nextPutAll: arg key; space]].	comment == nil ifFalse:		[aStream crtab: 1.		 self printCommentOn: aStream indent: 1].	block printTemporaries: temporaries on: aStream doPrior: [aStream crtab: 1].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printStatementsOn: aStream indent: 0! !!MethodFinder methodsFor: 'initialize' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36107985!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) ""Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf 	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet""accessing" byteAt: endsWithDigit #findAnySubstring:startingAt: #findBetweenSubstrings: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: #includesSubstring: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: #skipAnySubstring:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: endsWith: endsWithAnyOf: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padLeftTo: padRightTo: padLeftTo:with: padRightTo:with:"converting" asByteArray asDate asFileName asText asTime asUrl capitalized compressWithTable: contractTo: correctAgainst: initialIntegerOrNil keywords quoted withoutPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes truncateWithElipsisTo: trimBoth uncapitalized withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits trimRight trimLeft"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable withInternetLineEndings withSqueakLineEndings withoutQuoting urlEncoded UrlDecoded"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: translateToLowercase match:) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "testing" isInfix isKeyword isUnary) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo: upToAll: ) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" #key nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: distanceTo: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other"  indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter alphaMixed:with:"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses := #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls := Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 )  (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sort: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray].self initialize3."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!MethodFinder methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36120101!test2: anArray	"look for bad association"	anArray do: [:sub |		sub class == Association ifTrue: [			(#('true' '$a' '2' 'false') includes: sub value printString) ifFalse: [				self error: 'bad assn'].			(#('3' '5.6' 'x' '''abcd''') includes: sub key printString) ifFalse: [				self error: 'bad assn'].		].		sub class == Array ifTrue: [			sub do: [:element | 				element isString ifTrue: [element first asciiValue < 32 ifTrue: [						self error: 'store into string in data']].				element class == Association ifTrue: [					element value class == Association ifTrue: [						self error: 'bad assn']]]].		sub class == Date ifTrue: [sub year isInteger ifFalse: [				self error: 'stored into input date!!!!']].		sub class == Dictionary ifTrue: [				sub size > 0 ifTrue: [					self error: 'store into dictionary']].		sub class == OrderedCollection ifTrue: [				sub size > 4 ifTrue: [					self error: 'store into OC']].		].! !!LiteralVariable methodsFor: '*Reflectivity' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36121156!availableReifications	^RFReification subclasses 		select: [ :e | e entities includesAny: self class withAllSuperclasses ]		thenCollect: #key! !!LiteralVariable methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36121409!isSelfEvaluating	^ self key isSelfEvaluating and: [self value isSelfEvaluating]! !!ZnMultiValueDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36121605!add: anAssociation	self checkLimitForKey: anAssociation key.	^ super add: anAssociation! !!GTInspectorWrapperNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36121813!Differencekey	^ label ifNil: [ self hostObject key ]! !!GTInspectorWrapperNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36385330!key	^ label ifNil: [ self hostObject key ]! !!BehaviorTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36122133!testBinding	self assert: Object binding value = Object.	self assert: Object binding key = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding key isNil.! !!GTInspectorContextNamedTempNode methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36122545!label	^ '[' , self key , ']'! !!OCKeyedSet methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36122686!initialize: n 	super initialize: n. 	keyBlock := [:element | element key]. ! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36122882!registerDebugger: anObject withRank: anInteger	|debuggers|		debuggers  := tools at: #debuggers ifAbsent: [		tools at: #debuggers put: OrderedCollection new ]. 	(debuggers anySatisfy: [:each| each key == anObject] ) ifFalse: [ 		debuggers add: anObject -> anInteger ].	WorldState defaultWorldMenu! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36123302!debuggerDispatcherFor: aContext matching: aBlock	| debuggers |	debuggers := self debuggersWithRanksMatching: [ :aDebugger | 		(aBlock value: aDebugger) and: [ 			aDebugger handlesContext: aContext ] ].	(debuggers size > 0) ifTrue: [ ^ (debuggers at: 1) key ].	^ nil! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36123691!debuggersWithRanksMatching: aBlock	^ ((self registeredDebuggersWithRanks) 			select: [ :aPair | aBlock value: aPair key ])			sort: [ :pair1 :pair2 | pair1 value > pair2 value ].! !!ToolRegistry methodsFor: '*GT-Debugger-Model' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36123990!debuggersMatching: aBlock	^ (self debuggersWithRanksMatching: aBlock) 			inject: OrderedCollection new			into: [ :aCollection :aPair | aCollection add: aPair key; yourself ]! !!AbstractNautilusUI methodsFor: 'menus behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36124287!copyClasses		| association |	self okToChange ifFalse: [^ self].	association := self copyClasses: (self selectedClasses collect: [:e | e theNonMetaClass ]).	association key		ifTrue: [			self selectedClass: association value.			self updateClassView]! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36124681!makeSelectorsLegalIn: aDictionary	aDictionary associationsDo: [ :nameToValue |		| selector |		selector := nameToValue key asLowercase asSymbol.		nameToValue key: selector ]! !!TabGroupMorph methodsFor: 'page' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36124962!labelsAndPages: assocs	"Replace the tabs and the associated pages."	self contentMorph removeAllMorphs.	self tabSelectorMorph removeAllMorphs.	assocs do: [:a | self addPage: a value label: a key]! !!IRReconstructor methodsFor: 'remapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36125273!remapTemp: aTemp toRemote: aRemote	(temps removeKey: aTemp ifAbsent: [ #() ])		do: [ :tempAccess |			tempAccess name: aRemote.			self rememberReference: tempAccess to: aRemote in: temps ].			(remoteTemps removeKey: aTemp ifAbsent: [ #() ])		do: [ :tempAccess |			tempAccess tempVectorName: aRemote.			self rememberReference: tempAccess to: aRemote in: remoteTemps. ].	(closureCopiedValues removeKey: aTemp ifAbsent: [ #() ])		do: [ :aClosureAndIndex | |closure index|			closure := aClosureAndIndex key.			index := aClosureAndIndex value.			closure copiedValues at: index put: aRemote.			closure tempMap at: aRemote put: (closure tempMap removeKey: aTemp).			self rememberReference: aClosureAndIndex to: aRemote in: closureCopiedValues. ].! !!RubTextEditor methodsFor: 'keymapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36126139!defaultCommandKeymapping	| cmdMap |			cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	{(Character home -> #cursorHome:).	(Character end -> #cursorEnd:).	(Character backspace -> #backspace:).	(Character pageUp -> #cursorPageUp:).	(Character newPage -> #cursorPageDown:).	(Character cr -> #crWithIndent:).	(Character escape -> #escape:).	(Character arrowLeft -> #cursorLeft:).	(Character arrowRight -> #cursorRight:).	(Character arrowUp -> #cursorUp:).	(Character arrowDown -> #cursorDown:).	(Character space -> #selectWord:).	(Character delete -> #forwardDelete:) } do: [ :assoc | 		cmdMap at: assoc key asciiValue + 1 put: assoc value ].	'([{''"<' do: [ :char | cmdMap at: char asciiValue + 1 put: #enclose: ].	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.	'0123456789-=' do: [ :char | cmdMap at: char asciiValue + 1 put: #changeEmphasis: ].	^ cmdMap! !!RubTextEditor methodsFor: 'keymapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36127149!defaultShiftCommandKeymapping	"Initialize the shift-command-key (or control-key) shortcut table."	| cmdMap |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	{(Character home -> #cursorHome:).	(Character end -> #cursorEnd:).	(Character backspace -> #forwardDelete:).	(Character pageUp -> #cursorPageUp:).	(Character newPage -> #cursorPageDown:).	(Character cr -> #crWithIndent:).	(Character escape -> #offerMenuFromEsc:).	(Character arrowLeft -> #cursorLeft:).	(Character arrowRight -> #cursorRight:).	(Character arrowUp -> #cursorUp:).	(Character arrowDown -> #cursorDown:).	(Character space -> #selectWord:).	(Character delete -> #forwardDelete:)}		do: [ :assoc | 			| char symbol |			char := assoc key.			symbol := assoc value.			cmdMap at: char asciiValue + 1 put: symbol	"plain keys" ].	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	'9[,''' do: [ :char | cmdMap at: char asciiValue + 1 put: #shiftEnclose: ].	^ cmdMap! !!MetacelloScriptExecutor methodsFor: 'execution' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36128391!execute: statements  statements    do: [ :assoc |       assoc value        ifNil: [ self perform: assoc key ]        ifNotNil: [ self perform: assoc key withArguments: assoc value ] ].  projectSpecGenerator := self projectSpecGenerator.  projectSpecGenerator target    execute: [ :projectSpec |       | engine |      engine := MetacelloScriptEngine new        options: self options copy;        projectSpec: projectSpec;        yourself.      engine perform: actionArg key withArguments: actionArg value.      engine root ifNotNil: [ :root | self roots add: root ] ]    against: self.  ^ (self singleRoot and: [ self roots size == 1 ])    ifTrue: [ self roots first ]    ifFalse: [ self roots ]! !!MethodDictionary methodsFor: '*FuelTests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36129238!isEqualRegardlessMethodsTrailerTo: aMethodDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value"	self == aMethodDictionary ifTrue: [ ^ true ].	(aMethodDictionary isDictionary) ifFalse: [^false].	self size = aMethodDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		((aMethodDictionary at: assoc key ifAbsent: [^false]) isEqualRegardlessTrailerTo:  assoc value)			ifFalse: [^false]].	^true! !!MethodDictionary methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36129887!add: anAssociation	^ self at: anAssociation key put: anAssociation value! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36130073!testIfSequence6	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d a b c).	self assert: patch size = 5.	"lcs is abc"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('abc' includes: each value first) ]			ifFalse: [ self assert: each value first = $d ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36130699!testSameSequenceWithRepetitions	| patch |	patch := self patchSequenceFor: #(a a b a) and: #(a a b a).	self assert: patch size = 4.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36131010!testEmptyLcs3	| patch |	patch := self patchSequenceFor: #(a b c) and: #(d e f g).	self assert: patch size = 7.		patch do: [ :each |		each key = #remove ifTrue: [ self assert: ('abc' includes: each value first) ].		each key = #insert ifTrue: [ self assert: ('defg' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36131434!testIfSequence3	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(b d c a).	self assert: patch size = 6.	"lcs is bd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bd' includes: each value first) ]			ifFalse: [ self assert: ('ac' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36132070!testIfSequence5	| patch matches nonMatches |	patch := self patchSequenceFor: #(a b c d) and: #(c d a b).	self assert: patch size = 6.	"lcs is ab or cd"	matches := (patch select: [ :each | each key = #match ])		collect: [ :each | each value first ] as: String.	self assert: (#('ab' 'cd') includes: matches).	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	nonMatches := #('ab' 'cd') detect: [ :each | each ~= matches ].	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: (matches includes: each value first) ]			ifFalse: [ self assert: (nonMatches includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36132899!testIfSequence2	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(c d b a).	self assert: patch size = 6.	"lcs is cd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('cd' includes: each value first) ]			ifFalse: [ self assert: ('ab' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36133535!testEmptyLcs2	| patch |	patch := self patchSequenceFor: #() and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #insert ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36133820!testSameSequence	| patch |	patch := self patchSequenceFor: #(a b c) and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36134112!testIfSequence1	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d c b a).	self assert: patch size = 7.	"lcs is any one letter sequence"	self assert: (patch count: [ :each | each key = #match ]) = 1.	self assert: (patch count: [ :each | each key = #insert ]) = 3.	self assert: (patch count: [ :each | each key = #remove ]) = 3.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $d ]			ifFalse: [ self assert: ('abc' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36134758!testEmptyLcs1	| patch |	patch := self patchSequenceFor: #(a b c) and: #().	self assert: patch size = 3.	self assert: (patch allSatisfy: [ :each | each key = #remove ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36135042!testIfSequence4	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d b c a).	self assert: patch size = 6.	"lcs is bc"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bc' includes: each value first) ]			ifFalse: [ self assert: ('ad' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36135678!testIfPatchIsMinimal	| patch |	patch := self patchSequenceFor: #(a a a b) and: #(a b a a).	self assert: patch size = 5.	"lcs is aaa"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $a ]			ifFalse: [ self assert: each value first = $b ] ]! !!TraitCompositionTest methodsFor: 'testing-enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36136309!testClassMethodsTakePrecedenceOverTraitsMethods	| keys |	keys := Set new.	self t4 methodDict bindingsDo: [:each | keys add: each key].	self assert: keys size = 6.	self 		assert: (keys includesAllOf: #(						#m12						#m13						#m13						#m21						#m22						#m11						#m42					)).	self assert: (self t4 methodDict at: #m11) sourceCode = 'm11 ^41'! !!ThemeIcons methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36136795!gtInspectorIconsIn: composite	<gtInspectorPresentationOrder: 40>	composite list 		title: 'Icons';		display: [ icons associations sorted: [ :a :b | a key < b key ] ];		icon: [ :each | each value ];		format: [ :each | each key ]! !!ChangeSet methodsFor: 'filein/out' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36137154!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | method | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[(self hasReportableSlip: method)							ifTrue: [ slips add: (aClass >> mAssoc key) methodReference ]]]]].	^ slips! !!ChangeSet methodsFor: 'moving changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36137807!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass includesSelector:  mAssoc key) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!ChangeSet methodsFor: 'filein/out' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36138566!fileOutChangesFor: class on: stream	"Write out all the method changes for this class."	| changes |	changes := Set new.	(self methodChangesAtClass: class name)		associationsDo: [ :mAssoc | 			(mAssoc value = #remove or: [ mAssoc value = #addedThenRemoved ])				ifFalse: [ changes add: mAssoc key ] ].	changes isEmpty		ifTrue: [ ^ self ].	class fileOutChangedMessages: changes on: stream.	stream cr! !!ChangeSet methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36139080!methodChanges	| methodChangeDict |	methodChangeDict := Dictionary new.	changeRecords associationsDo:		[:assn | | changeTypes |		changeTypes := assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!ChangeSet methodsFor: 'method changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36139471!changedMessageList	"Used by a message set browser to access the list view information."	| messageList |	messageList := OrderedCollection new.	changeRecords associationsDo: [:clAssoc | | className classIsMeta |		className := clAssoc key asSymbol.		classIsMeta := (className findTokens: ' ') size > 1.		(clAssoc value allChangeTypes includes: #comment) ifTrue:			[messageList add:				(RGCommentDefinition new					parentName: className) asActive ].		clAssoc value methodChangeTypes associationsDo: [:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add:					((RGMethodDefinition named: mAssoc key)						parentName: className;						isMetaSide: classIsMeta) asActive ]]].	^ messageList asArray sort! !!ChangeSet methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36140337!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified |	notClassified := {'as yet unclassified' asSymbol. #all}.	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | | aSelector | (aClass includesSelector:  (aSelector := mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'filein/out' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36141140!hasReportableSlip: aMethod	"Answer whether the receiver contains anything that should be brought 	to the attention of the author when filing out. Customize the lists here 	to suit your preferences. If slips do not get reported in spite of your 	best efforts here, make certain that the Preference 'checkForSlips' is set 	to true."	aMethod containsHalt ifTrue: [ ^true ].	#(#flag:) do: [ :aLit | (aMethod hasLiteral: aLit) ifTrue: [ ^ true ] ].	((aMethod literals 		select: #isVariableBinding		thenCollect: #key) includes: #Transcript) ifTrue: [ ^true ].	^ false! !!WeakIdentityKeyDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36141835!testFinalizeValuesWhenLastChainContinuesAtFront	| objectWithHashModulo dictionary capacity a b c |		objectWithHashModulo := [ :requestedHash :modulo | | object |        [		object := Object new.			object hash \\ modulo = requestedHash ] whileFalse.        object ].				dictionary := self classToBeTested new.		capacity := dictionary capacity.		a := objectWithHashModulo value: capacity - 2 value: capacity.		dictionary at: a put: 1.		b := objectWithHashModulo value: capacity - 1 value: capacity.		dictionary at: b put: 2.		c := objectWithHashModulo value: capacity - 2 value: capacity.		dictionary at: c put: 3.		self assert: dictionary capacity = capacity.		self assert: (dictionary array at: capacity - 1) key == a.		self assert: (dictionary array at: capacity) key == b.		self assert: (dictionary array at: 1) key == c.		a := nil.		Smalltalk garbageCollect.		dictionary finalizeValues.		self assert: (dictionary includesKey: b).		self assert: (dictionary includesKey: c).		self assert: dictionary slowSize = 2.! !!AssemblyManifest class methodsFor: '*Tool-DependencyAnalyser-UI' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36143032!includes: aPackageName	^ (self parts collect: #key) 		includes: aPackageName! !!StringTest methodsFor: 'testing - formatting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36143228!testFormatExtended	self		assert: ('This is {foo} !!' format: (Dictionary with: #foo->'a test'))		equals: 'This is a test !!'. 	{  		[ '\{ \} \\ foo {foo} bar {bar}' format: { #foo->12. #bar->'string' } asDictionary ] -> '{ } \ foo 12 bar string'.  		[ '\{ \} \\ foo {bar} bar {foo}' format: { 'bar'->12. 'foo'->'string' } asDictionary ] -> '{ } \ foo 12 bar string'.  		[ '\{x}' format: {} ] -> '{x}'.  		[ '\{x}{x}' format: { #x->$a } asDictionary ] -> '{x}a'.  	} do: [ :each | 		self assert: each key value equals: each value ]! !!StringTest methodsFor: 'testing - internet' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36143886!testWithSqueakLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String cr).		'abc', String lf -> ('abc', String cr).		'abc', String crlf -> ('abc', String cr).		String cr, 'abc' -> (String cr, 'abc').		String lf, 'abc' -> (String cr, 'abc').		String crlf, 'abc' -> (String cr, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String cr, String cr, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String cr, 'abc', String cr, String cr, 'abc', String cr).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String cr, 'abc', String cr, String cr, 'abc', String cr).	} do: [ :each |		self assert: each key withSqueakLineEndings = each value ]! !!StringTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36144866!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!StringTest methodsFor: 'testing - internet' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36145409!testWithInternetLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String crlf).		'abc', String lf -> ('abc', String crlf).		'abc', String crlf -> ('abc', String crlf).		String cr, 'abc' -> (String crlf, 'abc').		String lf, 'abc' -> (String crlf, 'abc').		String crlf, 'abc' -> (String crlf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).	} do: [ :each |		self assert: each key withInternetLineEndings = each value ]! !!StringTest methodsFor: 'testing - internet' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36146436!testWithUnixLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String lf).		'abc', String lf -> ('abc', String lf).		'abc', String crlf -> ('abc', String lf).		String cr, 'abc' -> (String lf, 'abc').		String lf, 'abc' -> (String lf, 'abc').		String crlf, 'abc' -> (String lf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String lf, String lf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String lf, 'abc', String lf, String lf, 'abc', String lf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String lf, 'abc', String lf, String lf, 'abc', String lf).	} do: [ :each |		self assert: each key withUnixLineEndings = each value ]! !!StringTest methodsFor: 'testing - formatting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36147417!testFormat	self		assert: ('This is {1} !!' format: #('a test'))		equals: 'This is a test !!'. 	{  		[ '\{ \} \\ foo {1} bar {2}' format: { 12. 'string' } ] -> '{ } \ foo 12 bar string'.  		[ '\{ \} \\ foo {2} bar {1}' format: { 'string'. 12 } ] -> '{ } \ foo 12 bar string'.  		[ '\{1}' format: {} ] -> '{1}'.  		[ '\{1}{1}' format: { $a } ] -> '{1}a'.  	} do: [ :each | 		self assert: each key value equals: each value ]! !!StringTest methodsFor: 'testing - converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36147968!testSubstrings	| allByteCharacters substring separators |	allByteCharacters := Character allByteCharacters asString.	substring := allByteCharacters select: [:each | each isLetter].	separators := allByteCharacters reject: [:each | each isLetter].	{'' -> {}.		separators -> {}.		substring -> {substring}.		(substring, separators) -> {substring}.		(separators, substring) -> {substring}.		(separators, substring, separators) -> {substring}.		(substring, separators, substring) -> {substring. substring}.		(substring, separators, substring, separators) -> {substring. substring}.		(separators, substring, separators, substring) -> {substring. substring}}		do: [:each | self assert: (each key substrings: separators) = each value].	"test the unary version"	substring := allByteCharacters reject: [:each | each isSeparator].	separators := allByteCharacters select: [:each | each isSeparator].	{'' -> {}.		separators -> {}.		substring -> {substring}.		(substring, separators) -> {substring}.		(separators, substring) -> {substring}.		(separators, substring, separators) -> {substring}.		(substring, separators, substring) -> {substring. substring}.		(substring, separators, substring, separators) -> {substring. substring}.		(separators, substring, separators, substring) -> {substring. substring}}		do: [:each | self assert: each key substrings = each value].! !!MCStWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36149465!writeDefinitions: aCollection		"the correct initialization order is unknown if some classes are missing in the image"		| presentInitializers notPresentInitializers orderedClasses |		initializers := Set new.	(MCDependencySorter sortItems: aCollection)		do: [:ea | ea accept: self]		displayingProgress: 'Writing definitions...'.			presentInitializers := initializers select: [:each | Smalltalk hasClassNamed: each key ].	notPresentInitializers := initializers reject: [:each | Smalltalk hasClassNamed: each key ].		orderedClasses := (Class superclassOrder: (presentInitializers collect: [:each | Smalltalk classOrTraitNamed: each key]))		collect: [:each | each name ].					orderedClasses do: [:className |		self chunkContents: [ :str | str nextPutAll: (presentInitializers detect: [:each | each key = className]) value contents] ].		(notPresentInitializers asSortedCollection: [:a :b | a key <= b key]) do: [:association |		self chunkContents: [ :str | str  nextPutAll: association value contents ] ].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36150650!testAssociationAtIfPresent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				associationAt: each key				ifPresent: [self fail]) isNil.		dictionary add: each.		self assert:			(dictionary				associationAt: each key				ifPresent: [:assoc | self newValue -> assoc]) = (self newValue -> each).		"ensure cull: is used"		self assert:			(dictionary				associationAt: each key				ifPresent: [self newValue]) = self newValue].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36151289!testKeyForIdentity	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert: (dictionary keyForIdentity: each value) isNil.		dictionary add: each.		self			assert: (dictionary keyForIdentity: each value) = each key;			assert: (dictionary keyForIdentity: each value copy) isNil].! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36151739!changedOrderedAssociations	^ self orderedAssociations collect: [:each | each key -> self newValue]! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36151952!testCollect	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self		assertIsDictionary:			(dictionary collect: [:each | each hash])		copiedFrom: dictionary		withOrderedAssociations:			(self orderedAssociations collect: [:each | each key -> each value hash]).! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36152352!testKeyAtIndex	| dictionary |	dictionary := self emptyDictionary.	self		should: [dictionary keyAtIndex: 0]		raise: Error.	self orderedAssociations withIndexDo: [:each :i |		self			should: [dictionary keyAtIndex: i]			raise: Error.		dictionary add: each.		self assert: (dictionary keyAtIndex: i) = each key].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36152786!testIndexOfKeyIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				indexOfKey: each key				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				indexOfKey: each key				ifAbsent: [self fail]) = i].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36153259!testAtPut	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				at: each key				put: each value) = each value.		self			assertIsDictionary: dictionary			withOrderedAssociations: (self orderedAssociationsFirst: i)].	self changedOrderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				at: each key				put: each value) = each value.		self			assertIsDictionary: dictionary			withOrderedAssociations:				(self changedOrderedAssociationsFirst: i),				(self orderedAssociationsAllButFirst: i)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36153989!testRemoveKeyIfAbsent	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				removeKey: each key				ifAbsent: [self fail]) = each value.		self			assertKey: each key			wasRemovedfrom: dictionary.		self			assertIsDictionary: dictionary			withOrderedAssociations: (self orderedAssociationsAllButFirst: i).		self assert:			(dictionary				removeKey: each key				ifAbsent: [self absentValue]) = self absentValue]! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36154643!testAtIfAbsentPut	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each key				ifAbsentPut: [each value]) = each value.		self assert:			(dictionary				at: each key				ifAbsentPut: [self fail]) = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36155061!testDictionaryPublicProtocolCompatibility	| dictionary |	dictionary := self emptyDictionary.	{dictionary -> Dictionary.	dictionary class -> Dictionary class}		do: [:assoc | 			assoc value protocols				reject: [:protocol | 					#('private' 'print' 'copy' 'compar' '*')						anySatisfy: [:each | protocol asString beginsWith: each]]				thenDo: [:protocol | 					(assoc value selectorsInProtocol: protocol)						do: [:each | self assert: (assoc key respondsTo: each)]]].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36155655!testAssociationAtIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				associationAt: each key				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				associationAt: each key				ifAbsent: [self fail]) = each].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36156128!testAtIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each key				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				at: each key				ifAbsent: [self fail]) = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36156574!testAtIfPresentIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each key				ifPresent: [self fail]				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				at: each key				ifPresent: [:value | self newValue -> value]				ifAbsent: [self fail]) = (self newValue -> each value).		"ensure cull: is used"		self assert:			(dictionary				at: each key				ifPresent: [self newValue]				ifAbsent: [self fail]) = self newValue].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36157281!testAssociationAt	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary associationAt: each key]			raise: Error.		dictionary add: each.		self assert: (dictionary associationAt: each key) = each].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36157673!testAtIfPresent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				at: each key				ifPresent: [self fail]) isNil.		dictionary add: each.		self assert:			(dictionary				at: each key				ifPresent: [:value | self newValue -> value]) =					(self newValue -> each value).		"ensure cull: is used"		self assert:			(dictionary				at: each key				ifPresent: [self newValue]) = self newValue].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36158279!testKeyAtValue	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary keyAtValue: each value]			raise: Error.		dictionary add: each.		self assert: (dictionary keyAtValue: each value) = each key].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36158660!testKeyAtIndexIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self assert:		(dictionary			keyAtIndex: 0			ifAbsent: [self absentKey]) = self absentKey.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				keyAtIndex: i				ifAbsent: [self absentKey]) = self absentKey.		dictionary add: each.		self assert:			(dictionary				keyAtIndex: i				ifAbsent: [self fail]) = each key].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36159206!testIdentityIndexOfKey	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert: (dictionary identityIndexOfKey: each key) = 0.		dictionary add: each.		self			assert: (dictionary identityIndexOfKey: each key) = i;			assert: (dictionary identityIndexOfKey: each key copy) = 0].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36159683!testRemoveKey	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self orderedAssociations withIndexDo: [:each :i |		self assert: (dictionary removeKey: each key) = each value.		self			assertKey: each key			wasRemovedfrom: dictionary.		self			assertIsDictionary: dictionary			withOrderedAssociations: (self orderedAssociationsAllButFirst: i).		self			should: [dictionary removeKey: each key]			raise: Error]! !!OrderedDictionaryTest methodsFor: 'assertions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36160261!assertIsDictionary: anObject withOrderedAssociations: anAssociationCollection	"tests that anObject is an instance of the correct dictionary class	with the specified ordered associations"	self		assert: anObject class == self dictionaryClass;		assert: anObject orderedKeys size >= anAssociationCollection size;		assert: anObject associations size = anAssociationCollection size.	anAssociationCollection withIndexDo: [:each :i |		self isTestingIdentityDictionary			ifTrue: [				self					assert: (anObject orderedKeys at: i) == each key;					assert: (anObject associations at: i) key == each key]			ifFalse: [				self					assert: (anObject orderedKeys at: i) = each key;					assert: (anObject associations at: i) key = each key].		self assert: (anObject associations at: i) value = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36161233!testIndexOfKey	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert: (dictionary indexOfKey: each key) = 0.		dictionary add: each.		self assert: (dictionary indexOfKey: each key) = i].! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36161614!orderedKeys	^ self orderedAssociations collect: [:each | each key]! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36161795!testIncludesAssociation	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			deny: (dictionary includesAssociation: each);			deny: (dictionary includesAssociation: each key -> each value).		dictionary add: each.		self			assert: (dictionary includesAssociation: each);			assert: (dictionary includesAssociation: each key -> each value)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36162311!testKeyAtValueIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				keyAtValue: each value				ifAbsent: [self absentKey]) = self absentKey.		dictionary add: each.		self assert:			(dictionary				keyAtValue: each value				ifAbsent: [self fail]) = each key].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36162769!testKeyAtIdentityValueIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self assert:			(dictionary				keyAtIdentityValue: each value				ifAbsent: [self absentKey]) = self absentKey.		dictionary add: each.		self assert:			(dictionary				keyAtIdentityValue: each value				ifAbsent: [self fail]) = each key.		self assert:			(dictionary				keyAtIdentityValue: each value copy				ifAbsent: [self absentKey]) = self absentKey].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36163371!testAt	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary at: each key]			raise: Error.		dictionary add: each.		self assert: (dictionary at: each key) = each value].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36163736!testKeysAndValuesRemove	| dictionary |	dictionary := self dictionaryWithOrderedAssociations.	self orderedAssociations withIndexDo: [:removedAssociation :i |		| unremovedAssociations |		unremovedAssociations :=			(self orderedAssociationsAllButFirst: i) asOrderedCollection.		dictionary keysAndValuesRemove: [:key :value |			(self isTestingIdentityDictionary				ifTrue: [key == removedAssociation key]				ifFalse: [key = removedAssociation key])				ifTrue: [					self assert: value = removedAssociation value.					true]				ifFalse: [| unremovedAssociation |					unremovedAssociation := unremovedAssociations removeFirst.					self isTestingIdentityDictionary						ifTrue: [self assert: key == unremovedAssociation key]						ifFalse: [self assert: key = unremovedAssociation key].					self assert: value = unremovedAssociation value.					false]].		self assert: unremovedAssociations isEmpty.		self			assertKey: removedAssociation key			wasRemovedfrom: dictionary].	self assert: dictionary isEmpty.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36164910!testKeyAtIdentityValue	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self			should: [dictionary keyAtIdentityValue: each value]			raise: Error.		dictionary add: each.		self assert: (dictionary keyAtIdentityValue: each value) = each key.		self			should: [dictionary keyAtIdentityValue: each value copy]			raise: Error].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36165399!testNewFromPairs	| pairs |	pairs := OrderedCollection new.	self orderedAssociations do: [:each |		pairs			addLast: each key;			addLast: each value].	0 to: pairs size do: [:i |		self			assertIsDictionary:				(self dictionaryClass newFromPairs: (pairs copyFrom: 1 to: i))			withOrderedAssociations:				(self orderedAssociationsFirst: (i / 2) floor)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36165875!testIncludesKey	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations do: [:each |		self deny: (dictionary includesKey: each key).		dictionary add: each.		self assert: (dictionary includesKey: each key)].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36166233!testIdentityIndexOfKeyIfAbsent	| dictionary |	dictionary := self emptyDictionary.	self orderedAssociations withIndexDo: [:each :i |		self assert:			(dictionary				identityIndexOfKey: each key				ifAbsent: [self absentValue]) = self absentValue.		dictionary add: each.		self assert:			(dictionary				identityIndexOfKey: each key				ifAbsent: [self fail]) = i.		self assert:			(dictionary				identityIndexOfKey: each key copy				ifAbsent: [self absentValue]) = self absentValue].! !!AlienSunit methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36166853!willCrashTheVMtestLibCExamples	| sortedData unsorted sorted |		sortedData := Alien exampleCqsort.	unsorted := sortedData key copy.	sorted := unsorted asSortedCollection.	self should: [sortedData value = sorted asArray].	Alien examplePrintf.! !!OrderedDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36167216!collect: aBlock	^ self species newFrom:		(self associations collect: [:each |			each key -> (aBlock value: each value)])! !!OrderedDictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36167453!= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each key ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.! !!OrderedDictionary methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36167838!printElementsOn: aStream	aStream nextPut: $(.	self size > 100		ifTrue: [			aStream nextPutAll: 'size '.			self size printOn: aStream]		ifFalse: [			self associations withIndexDo: [:each :i |				aStream					print: each key;					nextPutAll: '->';					print: each value.				(i < self size)					ifTrue: [aStream space]]].	aStream nextPut: $).! !!OrderedDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36168301!add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation key].	^ anAssociation.! !!OrderedDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36168687!keysAndValuesRemove: aTwoArgumentBlock	| removedAssociations |	removedAssociations := OrderedCollection new.	self associationsDo: [:each |		(aTwoArgumentBlock value: each key value: each value)			ifTrue: [removedAssociations add: each]].	removedAssociations do: [:each | self removeKey: each key].! !!OrderedDictionary methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36169134!gtInspectorItemsIn: composite	^ (composite fastTable)		title: 'Items';		display: [ self associations ];		"children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];"		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each key ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		selectionAct: [ :table |			table rawSelection do: [ :assoc | self removeKey: assoc key ].			table update ]			entitled: 'Remove item(s)';		selectionPopulate: #selection 			entitled: 'Open key'			with: [ :table | (table rawSelection collect: #key) gtInspectorInterestingObject ];		beMultiple;		send: [ :selection | 				selection isNil 				ifTrue: [ nil ]				ifFalse: [ selection size = 1  					ifTrue: [ selection anyOne value ] 					ifFalse: [ selection collect: #value ] ]]		"withSmalltalkSearch;		showOnly: 50;		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'"! !!OrderedDictionary class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36170472!newFrom: anAssociationCollection	| newDictionary |	newDictionary := self new: anAssociationCollection size.	anAssociationCollection associationsDo: [:each |		newDictionary			at: each key			put: each value].	^ newDictionary.! !!RBBasicLintRuleTest class methodsFor: 'unnecessary code' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36170832!unreferencedVariables	| detector |	detector := self new.	detector name: 'Variables not referenced'.	detector result: nil unreferenced.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addInstVar: each for: context selectedClass]].			context selectedClass isMetaclass ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(SystemNavigation default allCallsOn: each) ifEmpty:  [result addClassVar: each key for: context selectedClass]]]].	^detector! !!NavigationHistory methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36171683!basicAdd: anEntry		( storage isEmpty not and: [ storage last = anEntry ] ) ifTrue: [ ^ self ].	anEntry = self current key ifTrue: [ ^ self ].	self checkSize.	index := index +1.	index > storage size		ifTrue: [ storage addLast:  (anEntry -> DateAndTime now)]		ifFalse: [ 			storage := storage copyFrom: 1 to: index.			storage at: index put: (anEntry -> DateAndTime now)]! !!NavigationHistory methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36172174!removeEntry: anEntry	| toRemove |		"we know that toRemove will always contains one element"	toRemove := (storage select: [:e | e key == anEntry ]).	toRemove ifEmpty: [ ^ self ].	toRemove := toRemove first.	storage remove: toRemove.	storage addLast: toRemove! !!Decompiler methodsFor: 'instruction decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36172557!popIntoTemporaryVariable: offset	| maybeTVTag tempVector start |	maybeTVTag := stack last.	((maybeTVTag isMemberOf: Association)	 and: [maybeTVTag key == #pushNewArray]) ifTrue:		[blockStartsToTempVars notNil "implies we were intialized with temp names."			ifTrue: "Use the provided temps"				[[(tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp							 and: [tempVector isIndirectTempVector							 and: [tempVector remoteTemps size = maybeTVTag value size]]] assert]			ifFalse: "Synthesize some remote temps"				[tempVector := maybeTVTag value.				 offset + 1 <= tempVars size					ifTrue:						[start := 2.						 tempVector at: 1 put: (tempVars at: offset + 1)]					ifFalse:						[tempVars := (Array new: offset + 1)										replaceFrom: 1										to: tempVars size										with: tempVars.						start := 1].				 start to: tempVector size do:					[:i|					tempVector						at: i						put: (constructor								codeTemp: numLocalTemps + offset + i - 1								named: 't', (tempVarCount + i) printString)].				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].		 tempVarCount := tempVarCount + maybeTVTag value size.		 stack removeLast.		 ^self].	self pushTemporaryVariable: offset; doStore: statements! !!Decompiler methodsFor: 'control' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36173966!checkForClosureCopy: receiver arguments: arguments	"We just saw a closureCopy:copiedValues: message. Check for and construct a following block."	| savePc jump |	receiver == constructor codeThisContext ifFalse: [^false].	savePc := pc.	(jump := self interpretJump) notNil ifFalse:		[pc := savePc.		 ^nil].	"Definitely a block"	self doClosureCopyCopiedValues: arguments last "<BraceNode>" elements		numArgs: arguments first key		blockSize: jump.	^true! !!FBDASTBuilder methodsFor: 'constructor' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36174539!codeAnyLitInd: anAssociation 	^ (RBVariableNode named: anAssociation key)		binding: anAssociation;		yourself! !!DiffMorph methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36174754!calculatedJoinMappings	"Calculate the join parameters between src and dst and answer"	| sourceLine destinationLine joins destinationRunStart sourceRunStart destinationRunEnd sourceRunEnd matchDestinationStart matchSourceStart |	sourceLine := destinationLine := 0.	joins := OrderedCollection new.	destinationRunStart := destinationRunEnd := sourceRunStart := sourceRunEnd := matchSourceStart := matchDestinationStart := 0.	self difference		do: [ :p | 			p key = #match				ifTrue: [ 					sourceLine := sourceLine + 1.					destinationLine := destinationLine + 1.					matchSourceStart = 0						ifTrue: [ 							matchSourceStart := sourceLine.							matchDestinationStart := destinationLine ].					(destinationRunStart > 0 or: [ sourceRunStart > 0 ])						ifTrue: [ 							sourceRunStart = 0								ifTrue: [ sourceRunStart := sourceLine ].							destinationRunStart = 0								ifTrue: [ destinationRunStart := destinationLine ].							sourceRunEnd = 0								ifTrue: [ sourceRunEnd := sourceRunStart - 1 ].							destinationRunEnd = 0								ifTrue: [ destinationRunEnd := destinationRunStart - 1 ].							joins								add:									(self newJoinSectionFrom: (sourceRunStart to: sourceRunEnd) to: (destinationRunStart to: destinationRunEnd)).							destinationRunStart := destinationRunEnd := sourceRunStart := sourceRunEnd := 0 ] ].			p key = #remove				ifTrue: [ 					matchSourceStart > 0						ifTrue: [ 							joins								add:									(self newMatchJoinSectionFrom: (matchSourceStart to: sourceLine) to: (matchDestinationStart to: destinationLine)).							matchSourceStart := matchDestinationStart := 0 ].					sourceLine := sourceLine + 1.					sourceRunStart = 0						ifTrue: [ sourceRunStart := sourceLine ].					sourceRunEnd := sourceLine ].			p key = #insert				ifTrue: [ 					matchSourceStart > 0						ifTrue: [ 							joins								add:									(self newMatchJoinSectionFrom: (matchSourceStart to: sourceLine) to: (matchDestinationStart to: destinationLine)).							matchSourceStart := matchDestinationStart := 0 ].					destinationLine := destinationLine + 1.					sourceRunStart > 0						ifTrue: [ 							sourceRunEnd = 0								ifTrue: [ sourceRunEnd := sourceRunStart ].							destinationRunEnd = 0								ifTrue: [ destinationRunEnd := destinationRunStart ].							joins								add:									(self newJoinSectionFrom: (sourceRunStart to: sourceRunEnd) to: (destinationRunStart to: destinationRunEnd)).							destinationRunStart := destinationRunEnd := sourceRunStart := sourceRunEnd := 0 ].					destinationRunStart = 0						ifTrue: [ destinationRunStart := destinationLine ].					destinationRunEnd := destinationLine ] ].	sourceLine := sourceLine + 1.	destinationLine := destinationLine + 1.	(destinationRunStart > 0 or: [ sourceRunStart > 0 ])		ifTrue: [ 			sourceRunStart = 0				ifTrue: [ sourceRunStart := sourceLine ].			destinationRunStart = 0				ifTrue: [ destinationRunStart := destinationLine ].			sourceRunEnd = 0				ifTrue: [ sourceRunEnd := sourceRunStart - 1 ].			destinationRunEnd = 0				ifTrue: [ destinationRunEnd := destinationRunStart - 1 ].			joins				add: (self newJoinSectionFrom: (sourceRunStart to: sourceRunEnd) to: (destinationRunStart to: destinationRunEnd)) ].	matchSourceStart > 0		ifTrue: [ 			joins				add:					(self newMatchJoinSectionFrom: (matchSourceStart to: sourceLine - 1) to: (matchDestinationStart to: destinationLine - 1)) ].	^ joins! !!Trait methodsFor: 'pool variables' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36178342!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [self sharedPools remove: aDictionary.				self sharedPools isEmpty ifTrue: [self sharedPools: nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet := self subclasses asOrderedCollection.	satisfiedSet := Set new.	[workingSet isEmpty] whileFalse:		[aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal key 								, ' is still used in code of class '								, sub name]]].	self sharedPools remove: aDictionary.	self sharedPools isEmpty ifTrue: [self sharedPools: nil]! !!Trait methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36180086!declareClassVariables: newVars 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	|  conflicts |		conflicts := false.		"Remove. Warn if vars are removed that are still used"	"self flag: something wrong here. put to true and add an ivar to a class"	(self classVariables reject: [:x | newVars includes: x]) do: [:var | self removeClassVarNamed: var name interactive: false].		(newVars reject: [:var | self classVariables includes: var]) do: [:var | "adding"			"check if new vars defined elsewhere"			(self innerBindingOf: var key) 				ifNotNil: [(DuplicatedVariableError new) variable: var name;						signal: var name , ' is defined elsewhere'.					conflicts := true]].	newVars notEmpty		ifTrue: 			[self classPool: self classPool.			"in case it was nil"			newVars do: [:var | self classPool declareVariable: var from: Undeclared]].	^conflicts! !!NautilusUI methodsFor: 'history behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36181107!wrapHistory: anEntry	^ StringMorph contents: anEntry key asHistoryString! !!NautilusUI methodsFor: 'history behavior' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36181294!currentHistoryIndex	| index item |	index := 1 min: self getHistoryList size.	index = 0 ifTrue: [ ^ 0 ].	item := (self getHistoryList at: index) key.	self selectedClass = item selectedClass ifFalse: [ ^ 0 ].	self selectedMethod ifNil: [ ^ 0 ].	^ self selectedMethod selector = item selectedMethod		ifTrue: [ index ]		ifFalse: [ 0 ]! !!GTHelpDebugAction methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36181746!executeAction	HelpBrowser open selectTopicSatisfying: [:each | 		each owner notNil and:  [			(each owner key = self debugger class helpClass key) and: [				each title = 'Overview' ] ] ]! !!HelpTopicTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36182054!testInitialization	self assert: topic title = 'Unnamed Topic'.	self assert: topic key isEmpty.	self assert: topic contents isEmpty ! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36182309!name	^association key! !!String methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36182432!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices results maxChoices scoreMin |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection 		ifNil: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifNotNil: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word | | score |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36183419!findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #key declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	(start max: 1) to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body basicAt: startIndex+index-1) + 1)				= (matchTable at: (key basicAt: index) + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!WeakKeyToCollectionDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36184979!noCheckAddForRehash: anAssociation	| cleanedValue |	anAssociation key ifNil:[^self].	cleanedValue := anAssociation value copyWithout: nil.	cleanedValue notEmpty ifTrue:[		anAssociation value: cleanedValue.		super noCheckAddForRehash: anAssociation.	].! !!WeakKeyToCollectionDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36185361!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			association key ifNotNil: [ :key | "Don't let the key go away"				| cleanedValue |				(cleanedValue := association value copyWithout: nil) isEmpty 					ifFalse: [						association value: cleanedValue.						array							at: (self scanForEmptySlotFor: key)							put: association.						tally := tally + 1 ] ] ] ]! !!BlockNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36186129!printTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	| tempStream seen |	tempSequence ifNil:		[^false].	tempStream := (String new: 16) writeStream.	"This is for the decompiler which canmot work out which optimized block a particular temp is	 local to and hence may produce diplicates as in		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"	seen := Set new.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifTrue:				[tempNode remoteTemps do:					[:tempVariableNode|					 (tempVariableNode scope >= 0					  and: [(seen includes: tempNode key) not]) ifTrue:						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]			ifFalse:				[(tempNode scope >= -1				  and: ["This is for the decompiler which may create a block arg when converting						a while into a to:do: but won't remove it form temporaries"					   tempNode isBlockArg not				  and: [(seen includes: tempNode key) not]]) ifTrue:					[tempStream space; nextPutAll: (seen add: tempNode key)]]].	tempStream position = 0 ifTrue:		[^false].	aBlock value.	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.	^true! !!BlockNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36187558!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	arguments do:		[:arg | aStream nextPut: $:;  nextPutAll: arg key;  space].	aStream nextPut: $|; space.	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue:		[aStream crtab: level]! !!CatalogProject methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36187988!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Project';		display: [ {			'name' -> self name.			'package name' -> self packageName.			'repository url' -> self repositoryUrl.			'description' -> (self description ifNil: [ '' ]).			'contact info' -> (self contactInfo ifNil: [ '' ]).			'keywords' -> (Character space join: self keywords) } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!CatalogProject methodsFor: 'gt-spotter-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36188591!spotterPreviewIn: aComposite	<spotterPreview: 10>	^ aComposite table		title: 'Catalog Project';		display: [ {			'name' -> self name.			'package name' -> self packageName.			'repository url' -> self repositoryUrl.			'description' -> (self description ifNil: [ '' ]).			'contact info' -> (self contactInfo ifNil: [ '' ]).			'keywords' -> (Character space join: self keywords) } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		entity: self! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36189180!createTopicFrom: aDescription	"Create a topic from a description stored on a class.	aDescription can specify (via #pages) the name of a class and not	only a selector. This allows for hierarchies with 'subtrees in the middle'"		|topic page   pageClasses |	topic := HelpTopic named: aDescription bookName.	topic contents: aDescription bookDescription.	topic key: aDescription key.	topic icon: aDescription icon.	pageClasses := Set new.	aDescription pages do: [:pageSelectorOrClass|		page:= (Smalltalk hasClassNamed: pageSelectorOrClass asString)					ifFalse: [aDescription perform: pageSelectorOrClass]					ifTrue: [pageClasses add: (Smalltalk classNamed: pageSelectorOrClass asString).							 (Smalltalk classNamed: pageSelectorOrClass asString) asHelpTopic].		topic addSubtopic: page.	].		((aDescription subclasses asSet)		removeAllFoundIn: pageClasses;		yourself) do: [:subclass | topic subtopics add: subclass asHelpTopic ].	^topic! !!BagTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36190244!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!Announcer methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36190796!gtInspectorAnnouncementsIn: composite context: aGTContext	<gtInspectorPresentationOrder: 40>	| recordedAnnouncements messageSend |		recordedAnnouncements := CollectionValueHolder value: OrderedCollection new.	messageSend := MessageSend receiver: recordedAnnouncements selector: #addAnnouncementFirst:.	self		when: Announcement		send: #cull:		to: messageSend.	aGTContext when: GLMBrowserClosing do: [ self unsubscribe: messageSend ].	composite table		title: 'Announcements';		display: [ recordedAnnouncements value ];		column: 'Time' evaluated: #key;		column: 'Announcement' evaluated: #value;		send: #value;		showOnly: 50;		format: #gtDisplayString;		filterOn: [:text :each | Smalltalk compiler evaluate: '| date each | date := self key. each := self value. ', text for: each logged: false ];		updateOn: Announcement from: recordedAnnouncements gtAnnouncer;		act: [ :table | 			recordedAnnouncements removeAll.			table update ] 			icon: GLMUIThemeExtraIcons glamorousCancel 			entitled: 'Reset'! !!GTSpotterExtensionSettings class methodsFor: 'settings' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36191943!catalogSettingsOn: aBuilder	<systemsettings>	(aBuilder group: #gtspotter)		parent: #gt;		label: 'GT Spotter extensions';		description: 'All extensions of GT Spotter';		with:				[ 				| extensions groupedExtensions sortedAssociations |				extensions := GTSpotter spotterExtendingMethods.				groupedExtensions := (extensions groupedBy: #methodClass) associations.				sortedAssociations := groupedExtensions asSortedCollection: [ :a1 :a2 | a1 key name < a2 key name ].				sortedAssociations do: [ :association |					(aBuilder group: association key name)						parent: #gtspotter;						label: 'Extensions defined on ', association key name;						description: 'All extensions of ', association key name;						with: [ 							association value do:								[ :each | 									(aBuilder setting: (self internalKeyForMethod: each))										target: self;										label: (self spotterExtensionTitleOf: each);										description: each sourceCode;										default: true ] ] ]				]				! !!GTSpotterExtensionSettings class methodsFor: 'settings' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36193111!groupedAndSortedSpotterExtensions	"Return a list of associations in which:		the key is a class		the value is the list of spotter extensions.	The returned list is ordered according to the class name"	| extensions groupedExtensions |	extensions := GTSpotter spotterExtendingMethods.	groupedExtensions := (extensions groupedBy: #methodClass) associations.	^ groupedExtensions asSortedCollection: [ :a1 :a2 | a1 key name < a2 key name ]. ! !!Float methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36193685!gtInspectorFloatIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Float';		display: [ 			(self respondsTo: #binaryLiteralString)				ifTrue: [					{'binary' -> self binaryLiteralString.					'significand' -> self significand.					'exponent' -> self exponent} ]				ifFalse: [					{'significand' -> self significand.					'exponent' -> self exponent} ] ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36194279!modifySection: sectionAttributeOrPath sectionIndex: sectionIndex repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		newProjectList - collection of project base names (without ConfigurationOf prefix)		newPackageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		newGroups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap groups packageList newGroupNames |    versionSpec := (self methodSpec        findMethodSection: sectionAttributeOrPath asMetacelloAttributePath        sectionIndex: sectionIndex) versionSpec.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    newProjectList        do: [ :projectName |             (versionSpec packages specListDetect: [ :spec | spec name = projectName ] ifNone: [  ]) == nil                ifTrue: [ versionSpec packages merge: (self createProjectReferenceSpec: projectName) ]                ifFalse: [ self error: 'Project named: ' , projectName printString , ' already exists.' ] ].    packageList := OrderedCollection new.    groups := OrderedCollection new.    newGroupNames := OrderedCollection new.    versionSpec        projectDo: [ :ignored |  ]        packageDo: [ :pkg | packageList add: pkg name ]        groupDo: [ :group |             groups add: group name -> group includes.            newGroupNames add: group name ].    newPackageList        do: [ :packageName |             (packageList includes: packageName)                ifTrue: [ self error: 'Package named: ' , packageName printString , ' already exists.' ]                ifFalse: [ packageList add: packageName ] ].    newGroups        do: [ :assoc |             (newGroupNames includes: assoc key)                ifTrue: [ self error: 'Group named: ' , assoc key printString , ' already exists.' ]                ifFalse: [ groups add: assoc ] ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    packageList        do: [ :packageName |             | spec |            (newPackageList includes: packageName)                ifTrue: [                     spec := self createPackageSpec: packageName.                    versionSpec packages merge: spec ]                ifFalse: [ spec := versionSpec packages specListDetect: [ :spc | spc name = packageName ] ].            dependencyMap                at: packageName                ifPresent: [ :dependencyList | spec setRequires: spec requires , dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec setIncludes: spec includes , includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ] ].    groups        do: [ :assoc |             | spec |            (newGroupNames includes: assoc key)                ifFalse: [                     spec := self createGroupSpec: assoc key.                    versionSpec packages merge: spec.                    spec setIncludes: spec includes , assoc value ] ].    aBlock value: versionSpec! !!MetacelloToolBox methodsFor: '*Versionner-Core-DependenciesModel' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36199639!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock requiredProjectSpecs: requiredProjectSpecs    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members		requiredProjectSpecs - collection of already computed required project specs.	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |    versionSpec := self createVersionSpec: self methodSpec versionString.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    requiredProjectSpecs do: [ :projectSpec | versionSpec packages merge: projectSpec ].    packageList        do: [ :packageName |             | spec |            spec := self createPackageSpec: packageName.            dependencyMap at: packageName ifPresent: [ :dependencyList | spec requires: dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec includes: includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ].            versionSpec packages merge: spec ].    groups        do: [ :assoc |             | spec |            spec := self createGroupSpec: assoc key.            spec includes: assoc value.            versionSpec packages merge: spec ].    aBlock value: versionSpec.    self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36203503!addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock    "		repositoryDescription - metacello repository string		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"    | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |    versionSpec := self createVersionSpec: self methodSpec versionString.    repositoryDescription ~~ nil        ifTrue: [ versionSpec repository: repositoryDescription ].    dependencyMap := self buildMapFrom: dependecies for: packageList.    includesMap := self buildMapFrom: includes for: packageList.    filesMap := self buildMapFrom: files for: packageList.    repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.    preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.    postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.    supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.    projectList        do: [ :projectName |             | spec |            spec := self createProjectReferenceSpec: projectName.            repositoriesMap                at: projectName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            versionSpec packages merge: spec ].    packageList        do: [ :packageName |             | spec |            spec := self createPackageSpec: packageName.            dependencyMap at: packageName ifPresent: [ :dependencyList | spec requires: dependencyList ].            includesMap at: packageName ifPresent: [ :includesList | spec includes: includesList ].            filesMap at: packageName ifPresent: [ :file | spec file: file ].            repositoriesMap                at: packageName                ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].            preLoadDoItsMap at: packageName ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].            postLoadDoItsMap at: packageName ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].            supplyingAnswersMap at: packageName ifPresent: [ :answer | spec answers: answer ].            versionSpec packages merge: spec ].    groups        do: [ :assoc |             | spec |            spec := self createGroupSpec: assoc key.            spec includes: assoc value.            versionSpec packages merge: spec ].    aBlock value: versionSpec.    self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'api-configuration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36207514!addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock  "		projectList - collection of project base names (without ConfigurationOf prefix)		packageList - collection of package base names		dependencies - collection of associations where key is name of package and value is collection of required packages and projects		includes - collection of associations where key is name of package and value is collection of included packages and projects		files - collection of associations where key is name of package and value is name of file		repositories - collection of associations where key is name of package and value is collection of repository descriptions		preLoadDoIts - collection of associations where key is name of package and value is preload doit selector		postLoadDoIts - collection of associations where key is name of package and value is postload doit selector		supplyingAnswers - collection of associations where key is name of package and value is the supplyingAnswers array		groups - collection of associations where key is the name of the group and value is the collection of group members	"  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |  versionSpec := self createVersionSpec: self methodSpec versionString.  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self    buildMapFrom: repositories    for: packageList , projectList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  projectList    do: [ :projectName |       | spec |      spec := self createProjectReferenceSpec: projectName.      repositoriesMap        at: projectName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      versionSpec packages merge: spec ].  packageList    do: [ :packageName |       | spec |      spec := self createPackageSpec: packageName.      dependencyMap        at: packageName        ifPresent: [ :dependencyList | spec requires: dependencyList ].      includesMap        at: packageName        ifPresent: [ :includesList | spec includes: includesList ].      filesMap at: packageName ifPresent: [ :file | spec file: file ].      repositoriesMap        at: packageName        ifPresent: [ :repositoriesList | repositoriesList do: [ :repoString | spec repository: repoString ] ].      preLoadDoItsMap        at: packageName        ifPresent: [ :preLoad | spec preLoadDoIt: preLoad ].      postLoadDoItsMap        at: packageName        ifPresent: [ :postLoad | spec postLoadDoIt: postLoad ].      supplyingAnswersMap        at: packageName        ifPresent: [ :answer | spec answers: answer ].      versionSpec packages merge: spec ].  groups    do: [ :assoc |       | spec |      spec := self createGroupSpec: assoc key.      spec includes: assoc value.      versionSpec packages merge: spec ].  aBlock value: versionSpec.  self methodSpec    addMethodSection: sectionAttributeOrPath asMetacelloAttributePath    versionSpec: versionSpec! !!MetacelloToolBox methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36211251!buildMapFrom: mapList for: packageList	| map |	map := Dictionary new.	mapList		do: [ :assoc | 			| pkgName pkgSpec |			pkgName := assoc key.			(packageList includes: pkgName)				ifFalse: [ self error: 'package ' , pkgName printString , ' not found in packages.' ].			map at: pkgName put: assoc value ].	^ map! !!KMRepository methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36211697!gtInspectorMappingsIn: composite	<gtInspectorPresentationOrder: 40>	composite table 		title: 'Keys';		display: [ 			self categories values				flatCollect: [ :category | 					category allEntries keymaps collect: [ :key | key -> category ] ]				 ];		filterOn: [ :text :each | each gtDisplayString includesSubstring: text caseSensitive: false ];		column: 'Shortcut' evaluated: [ :assoc | assoc key shortcut gtDisplayString ] width: 120;		column: 'Action' evaluated: [ :assoc | assoc key action gtDisplayString ];		column: 'Description' evaluated: [ :assoc | assoc key description ];		column: 'Category' evaluated: [ :assoc | '' ] tags: [ :assoc | assoc value name ifNil: [ #() ] ifNotNil: [ { assoc value name }]];		send: #key! !!KMRepository methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36212592!gtInspectorGlobalsIn: composite	<gtInspectorPresentationOrder: 40>	composite table 		title: 'Global keys';		display: [ 			self globalCategories				flatCollect: [ :category | 					category allEntries keymaps collect: [ :key | key -> category ] ]				 ];		filterOn: [ :text :each | each gtDisplayString includesSubstring: text caseSensitive: false ];		column: 'Shortcut' evaluated: [ :assoc | assoc key shortcut gtDisplayString ] width: 120;		column: 'Description' evaluated: [ :assoc | assoc key description ];		column: 'Action' evaluated: [ :assoc | assoc key action gtDisplayString ];		column: 'Category' evaluated: [ :assoc | '' ] tags: [ :assoc | assoc value name ifNil: [ #() ] ifNotNil: [ { assoc value name }]];		send: #key! !!MethodConstantTests methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36213476!testConstPlaceInTransformedMethod	| transformedMethod const constLiteral |	const := self constFromReceiverExpression. 			transformedMethod := self class >> #constFromReceiverExpression. 		constLiteral := transformedMethod literals detect: [ :each | each value == const ].	self assert: (constLiteral key includesSubstring: 'meta' caseSensitive: false)! !!ByteArray methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36213959!gtInspectorBytesIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Bytes';		display: [ 			(self size < 2048 or: [ self confirm: 'Looking at more than 2048 bytes might be slow. Continue ?' ])				ifTrue: [ {					'hex string' -> (String streamContents: [ :out | 						self do: [ :each | 							each printOn: out base: 16 nDigits: 2 ] ]).					'hex lines' -> (String streamContents: [ :out |						self withIndexDo: [ :each :index |							index = 1 ifFalse: [ 								index - 1 \\ 8 = 0 ifTrue: [ out cr ] ifFalse: [ out space ] ].								each printOn: out base: 16 nDigits: 2 ] ]).					'latin1' -> ([ ZnCharacterEncoder latin1 decodeBytes: self ]											on: ZnCharacterEncodingError do: [ :exception | exception ]).					'utf8' -> ([ ZnUTF8Encoder new decodeBytes: self ] 											on: ZnCharacterEncodingError do: [ :exception | exception ]).					'integer' -> self asInteger.					'integer reversed' -> self reversed asInteger } ]				ifFalse: [ #() ] ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!DAPackageRelationGraph methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36215158!isReference: aLiteral	^ aLiteral isVariableBinding and: [ aLiteral value isBehavior and: [ aLiteral key = aLiteral value name ] ]! !!UITheme methodsFor: 'morph creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36215397!newLabelGroupIn: aThemedMorph for: labelsAndControls font: aFont labelColor: aColor	"Answer a morph laid out with a column of labels and a column of associated controls.	If spaceFill is tru then each row will share available space to pad."	| labels labelWidth lc|	lc := labelsAndControls collect: [:a |		(a key isMorph			ifTrue: [a key]			ifFalse: [(self newLabelIn: aThemedMorph label: (a key ifNil: ['']) asString)						font: aFont;						color: aColor])			-> a value].	labels := Morph new		hResizing: #shrinkWrap;		vResizing: #spaceFill;		changeTableLayout.	lc do: [:a |		labels addMorphBack: a key].	labelWidth := labels minExtent x.	^self newColumnIn: aThemedMorph for: (lc collect: [:a | | row |		a key hResizing: #rigid; extent: labelWidth@ a key height.		row := self newRowIn: aThemedMorph for: {a key. a value}.		row vResizing: (a value vResizing = #spaceFill ifTrue: [#spaceFill] ifFalse: [#shrinkWrap]).		row])! !!UITheme methodsFor: 'morph creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36216509!focusIndicatorMorphFor: aMorph	"Answer a (cached) focus indicator for the given morph."	(self focusIndicator isNil or: [			self focusIndicator isMorph				ifTrue: [self focusIndicator ~~ aMorph]				ifFalse: [self focusIndicator key ~~ aMorph]])		ifTrue: [self focusIndicator: aMorph ->(self newFocusIndicatorMorphFor: aMorph)].	^self focusIndicator value 		privateBounds: aMorph focusBounds! !!UITheme methodsFor: 'morph creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36217016!newLabelGroupIn: aThemedMorph for: labelsAndControls	"Answer a morph laid out with a column of labels and a column of associated controls.	The vResizing for each row will be #spaceFill if the control for that row specifies	this, otherwise #shrinkWrap."	| labels labelWidth lc |	lc := labelsAndControls collect: [:a |		(a key isMorph			ifTrue: [a key]			ifFalse: [a key ifNotNil: [self newLabelIn: aThemedMorph label: a key asString]])			-> a value].	labels := Morph new		hResizing: #shrinkWrap;		vResizing: #spaceFill;		changeTableLayout.	lc do: [:a |		a key ifNotNil: [labels addMorphBack: a key]].	labelWidth := labels minExtent x.	^self newColumnIn: aThemedMorph for: (lc collect: [:a | | row |		a key ifNotNil: [a key hResizing: #rigid; extent: labelWidth@ a key height].		row := self newRowIn: aThemedMorph for: (a key ifNil: [{a value}] ifNotNil: [{a key. a value}]).		row vResizing: (a value vResizing = #spaceFill ifTrue: [#spaceFill] ifFalse: [#shrinkWrap]).		row])! !!ArrayTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36218224!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!ClassChangeRecord methodsFor: 'removal' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36218763!forgetChangesIn: otherRecord	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	| cls otherMethodChanges |	(cls := self realClass) ifNil: [ ^ self ].	"We can do better now, though..."	otherMethodChanges := otherRecord methodChangeTypes.	otherMethodChanges		associationsDo: [ :assoc | 			| selector actionToSubtract |			selector := assoc key.			actionToSubtract := assoc value.			(cls includesSelector: selector)				ifTrue: [ 					(#(#add #change) includes: actionToSubtract)						ifTrue: [ methodChanges removeKey: selector ifAbsent: [  ] ] ]				ifFalse: [ 					(#(#remove #addedThenRemoved) includes: actionToSubtract)						ifTrue: [ methodChanges removeKey: selector ifAbsent: [  ] ] ] ].	changeTypes isEmpty		ifTrue: [ ^ self ].	changeTypes removeAllFoundIn: otherRecord allChangeTypes.	(changeTypes includes: #rename)		ifFalse: [ changeTypes removeAllSuchThat: [ :x | x beginsWith: 'oldName: ' ] ]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36219815!methodChangeTypes	"Return an old-style dictionary of method change types."	| dict |	dict := IdentityDictionary new.	methodChanges associationsDo:		[:assn | | selector record |		selector := assn key.		record := assn value.		dict at: selector put: record changeType].	^ dict! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36220213!assimilateAllChangesIn: otherRecord		otherRecord isClassRemoval ifTrue: [^ self noteChangeType: #remove].	otherRecord allChangeTypes do:		[:chg | self noteChangeType: chg fromClass: self realClass].	otherRecord methodChanges associationsDo:		[:assn | | changeType selector changeRecord | selector := assn key. changeRecord := assn value.		changeType := changeRecord changeType.		(changeType == #remove or: [changeType == #addedThenRemoved])			ifTrue:				[changeType == #addedThenRemoved					ifTrue: [self atSelector: selector put: #add].				self noteRemoveSelector: selector priorMethod: nil						lastMethodInfo: changeRecord methodInfoFromRemoval]			ifFalse: 				[self atSelector: selector put: changeType]].! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36221048!visitPushLiteralVariable: var		| object |	object := var association.	stream nextPutAll: 'pushLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36221365!visitPopIntoLiteralVariable: litVar		| object |	object := litVar association.	stream nextPutAll: 'popIntoLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36221694!visitPushLiteral: lit	| object |	object := lit literal.	stream nextPutAll: 'pushLiteral: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36221991!visitStoreLiteralVariable: var	| object |	object := var association.	stream nextPutAll: 'storeLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36222309!visitReturnLiteral: lit	| object |	object := lit literal.	stream nextPutAll: 'returnLiteral: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!GTDebuggerVariablesBrowser methodsFor: 'private building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36222633!variablesIn: composite	^ composite fastTable		useCache;		display: [ :aContext | self variablesFromContext: aContext. ];		column: 'Type'			evaluated: [ '' ]			width: 75			tags: [ :aNode  | { aNode variableTag } ]			sortedBy: [ :x :y |  x variableTag < y  variableTag ];		column: 'Variable' 			evaluated: [ :aNode | GTObjectPrinter asNonTruncatedTextFrom: aNode key ]			width: 175;		column: 'Value' 			evaluated: [ :aNode | | rawValue displayValue |				[ rawValue := aNode rawValue. ] 					on: Error 					do: [ displayValue := Text string: aNode errorMessage attribute: TextColor red ].				displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ];		dynamicActionsOnSelection: [ :presentation |			(presentation rawSelection isKindOf: GTInspectorVariableNode) 				ifTrue: [presentation rawSelection inspectorActionsForNode ]				ifFalse: [ #() ] ];		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse';		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect';		onChangeOfPort: #rawSelection 			act: [ :aPresentation | 				self debugger selectedVariableName: aPresentation rawSelection key ] ! !!GTDebuggerVariablesBrowser methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36224071!selectedVariableForContext: aContext 	^ (self variablesFromContext: aContext) 		detect: [ :each | each key = self debugger selectedVariableName ] 		ifNone: [ cachedVariables detect: [ :each | each key = 'self' ] ifNone: [ nil ] ]! !!JoinSection methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36224431!createHighlightsFrom: srcPara to: dstPara	"Create and store the src and dst highlights.	Use the given paragraphs to determine inline	diffs."	| s d si di srcText dstText diffs i sb eb line |	self createHighlights.	self src lineRange notEmpty		ifTrue: [ 			line := srcPara lines at: self src lineRange first.			si := line first.			line := srcPara lines at: self src lineRange last.			srcText := srcPara string copyFrom: si to: line last ]		ifFalse: [ srcText := '' ].	self dst lineRange notEmpty		ifTrue: [ 			line := dstPara lines at: self dst lineRange first.			di := line first.			line := dstPara lines at: self dst lineRange last.			dstText := dstPara string copyFrom: di to: line last ]		ifFalse: [ dstText := '' ].	self src text: srcText.	self dst text: dstText.	self type = #modification		ifFalse: [ ^ self ].	s := self src highlights.	d := self dst highlights.	diffs := (InlineTextDiffBuilder from: srcText to: dstText) buildPatchSequence aggregateRuns: [ :e | e key ].	diffs		do: [ :c | 			c first key = #match				ifTrue: [ 					c						do: [ :a | 							si := si + a value size.							di := di + a value size ] ].			c first key = #insert				ifTrue: [ 					i := di.					c do: [ :a | di := di + a value size ].					sb := dstPara characterBlockForIndex: i.					eb := dstPara characterBlockForIndex: di - 1.					self						addHighlightsFrom: sb						to: eb						to: d						color: self additionHighlightColor ].			c first key = #remove				ifTrue: [ 					i := si.					c do: [ :a | si := si + a value size ].					sb := srcPara characterBlockForIndex: i.					eb := srcPara characterBlockForIndex: si - 1.					self						addHighlightsFrom: sb						to: eb						to: s						color: self removalHighlightColor ] ]! !!WeakValueDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36226335!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!LiteralDictionary methodsFor: 'internal' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36226537!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Slot methodsFor: '*Reflectivity' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36227489!availableReifications	^RFReification subclasses 		select: [ :e | e entities includesAny: self class withAllSuperclasses ]		thenCollect: #key! !!GradientFillStyle methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36227744!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastValue ramp lastColor lastIndex lastWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := lastColor pixelWordForDepth: 32.	lastIndex := 0.	ramp do:[:assoc| | theta nextIndex nextColor nextWord distance step |		nextIndex := (assoc key * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWordForDepth: 32.		distance := (nextIndex - lastIndex).		distance = 0 ifTrue:[distance := 1].		step := 1.0 / distance asFloat.		theta := 0.0.		lastIndex+1 to: nextIndex do:[:i|			theta := theta + step.			"The following is an open-coded version of:				color := nextColor alphaMixed: theta with: lastColor.				bits at: i put: (color scaledPixelValue32).			"			bits at: i put: (self scaledAlphaMix: theta of: lastWord with: nextWord).		].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord.	].	lastValue := lastColor scaledPixelValue32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!GradientFillStyle methodsFor: 'converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36229007!mixed: fraction with: aColor	^self copy colorRamp: (colorRamp collect:[:assoc| assoc key -> (assoc value mixed: fraction with: aColor)])! !!IdentityDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36229257!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish start element |	finish := array size.	start := (anObject identityHash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentityDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36230163!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock." 	self associationsDo: 		[:association | value == association value ifTrue: [^ association key]].	^ exceptionBlock value! !!MIMEHeaderValue methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36230577!asHeaderValue	| strm |	strm := (String new: 20) writeStream.	strm nextPutAll: mainValue.	parameters		associationsDo: [ :e | 			strm				nextPut: $;;				nextPutAll: e key;				nextPutAll: '="';				nextPutAll: e value;				nextPutAll: '"' ].	^ strm contents! !!IRFix methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36230941!convertStorePop: assoc forSeq: seq 	| store pop |	store := assoc key.	pop := assoc value.	seq replaceNode: store withNode: (store popIntoNode sourceNode: store sourceNode).	seq remove: pop.! !!IRFix methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36231235!convertRet: assoc forSeq: seq 	| push ret |	push := assoc key.	ret := assoc value.	seq replaceNode: push withNode: (push quickRetNode sourceNode: ret sourceNode).	seq remove: ret.! !!PluggableDictionaryTest methodsFor: 'test - comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36231546!testEqualBlock	| pluggableDict assoc |	pluggableDict := self emptyDict.	self assert: pluggableDict equalBlock isNil.	self assert: (pluggableDict equalBlock: [:a :b | a = b]) == pluggableDict.	assoc := 'newKey' -> 'newValue'.	pluggableDict add: assoc.	self assert: (pluggableDict includesAssociation: assoc).	pluggableDict equalBlock: [:a :b | a == b].	self assert: (pluggableDict includesAssociation: assoc).	pluggableDict		removeKey: assoc key;		add: assoc key copy -> assoc value.	self deny: (pluggableDict includesAssociation: assoc).	pluggableDict equalBlock: [:a :b | a = b].	self assert: (pluggableDict includesAssociation: assoc).! !!GLMSmalltalkCodeModel methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36232330!addVariableBinding: anAssociation	self variableBindings at: anAssociation key put: anAssociation value! !!FloatArrayTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36232550!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!GTEventAnnouncement methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36233106!gtInspectorItemsIn: composite	<gtInspectorPresentationOrder: -1>  	^ (composite table)		title: 'Info';		display: [ :anEvent | anEvent gtInspectorItems ];		children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each key ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		showOnly: 50! !!RBProgramNode methodsFor: '*Reflectivity' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36233843!availableReifications	^RFReification subclasses 		select: [ :e | e entities includesAny: self class withAllSuperclasses ]		thenCollect: #key! !!GTEventCollector methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36234113!gtInspectorActionHelp	<gtInspectorAction>	^ GLMGenericAction new		action: [:b | 		HelpBrowser open selectTopicSatisfying: [:each |			each owner notNil and:  [			(each owner key = GTEventRecorderHelp key) and: [				each title = 'Client' ] ] ] ];		icon: GLMUIThemeExtraIcons glamorousHelp;		title: 'Help'! !!LookupKey methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36234540!name	^ self key isString		ifTrue: [self key]		ifFalse: [self key printString]! !!LookupKey methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36234747!< aLookupKey 	"Refer to the comment in Magnitude|<."	^key < aLookupKey key! !!LookupKey methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36234930!= aLookupKey	self species = aLookupKey species		ifTrue: [^key = aLookupKey key]		ifFalse: [^false]! !!ZnCookie methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36235136!writeExtraAttributesOn: aStream	self extraAttributes		associationsDo: [ :ea | 			aStream				nextPutAll: '; ';				nextPutAll: ea key.			(ea value isKindOf: Boolean)				ifFalse: [ 					aStream						nextPutAll: '=';						nextPutAll: ea value ] ]! !!ZnCookie methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36235491!extraAttributes	"Answer all attributes except name and value"	^ attributes associationsSelect: [ :ea | (ea key = 'name' or: [ ea key = 'value' ]) not ]! !!MCGitBasedNetworkRepository methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36235776!resolveProjectVersionPattern: aString  "aString must conform to the syntax for MetacelloVersionNumber with the exception that aString may have a leading $v which is stripped before conversion to a MetacelloVersionNumber patterm"  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath    ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (self class projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys    collect: [ :tagName |       | tagVersion |      tagVersion := self class projectVersionFromString: tagName.      tagVersion -> tagName ].  matchingTags := tagAssocs select: [ :assoc | assoc key match: patternString ].  matchingTags isEmpty    ifTrue: [       projectVersion := aString.      ^ self        error:          'No tags matching the pattern ' , aString printString            , ' found for repository description '            , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [ :a :b | a key <= b key ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag value! !!Deprecation methodsFor: 'handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36237148!transform	| node rewriteRule aMethod |	self raiseWarning ifFalse: [ ^ self ]. "when desprecations are disables, we do not want to transform, either"	self rewriterClass ifNil:[ ^ self signal ].	aMethod := self contextOfSender method.	aMethod isDoIt ifTrue:[^ self]. "no need to transform doits"	node := self contextOfSender sourceNodeExecuted.	rewriteRule := self rewriterClass new 		replace: rule key with: rule value.	(rewriteRule executeTree: node)		ifFalse: [ ^ self ].	node replaceWith: rewriteRule tree. 	Author 		useAuthor: 'AutoDeprecationRefactoring'		during: [aMethod origin compile: aMethod ast formattedCode classified: aMethod protocol].		Log 		ifNotNil: [:log | log add: self].	self logTranscript! !!OrderedCollectionTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36237998!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!Bag methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36238525!sortedCounts	"Answer with a collection of counts with elements, sorted by decreasing	count."	"Suggested by l. Uzonyi"	^(Array new: contents size streamContents: [ :stream | 			contents associationsDo: [ :each | 				stream nextPut: each value -> each key ] ]) 		sort: [:x :y | x >= y ]; 		yourself! !!Bag methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36238932!keysAndValuesDo: aTwoArgBlock     "Iterate over the receiver and apply a two argument block on the element and its occurrences."         contents associationsDo: [:assoc | aTwoArgBlock value: assoc key value: assoc value ]! !!Bag methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36239257!= aBag	"Two bags are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same size.	 (c) each element occurs the same number of times in both of them"	(aBag isKindOf: Bag) ifFalse: [^false].	self size = aBag size ifFalse: [^false].	contents associationsDo: [:assoc|		(aBag occurrencesOf: assoc key) = assoc value			ifFalse: [^false]].	^true! !!Bag methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36239728!do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	contents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]! !!Bag methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36240003!doWithOccurrences: aTwoArgBlock     "Iterate over the receiver and apply a two argument block on the element and its occurrences."            contents associationsDo: [:assoc | aTwoArgBlock value: assoc key value: assoc value ]! !!Bag methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36240333!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s := self size / 100.0. n := 0.	^ self sortedCounts asArray collect:		[:a | n := n + a key. (n / s roundTo: 0.1) -> a value]! !!STONWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36240670!writeAssociation: association	jsonMode		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self 		encodeKey: association key 		value: association value! !!Pragma class methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36240963!gtInspectorAnnotatedMethodsIn: composite	<gtInspectorPresentationOrder: 30> 	composite table 		title: 'All';		showOnly: 50;		withSmalltalkSearch;		display: [:anObject | 			| pragmas |			pragmas := OrderedCollection new.			Object withAllSubclassesDo: [:each |				Pragma withPragmasIn: each do: [:p |					pragmas add: p]].			(pragmas groupedBy: #keyword) associations sorted: [ :a :b | 				a key < b key ]		];		column: 'Keyword' evaluated: [ :each | each key ];		column: 'Instances' evaluated: [ :each | each value size asString ];		send: #value! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36241686!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!IceGitHubError methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36242648!unknownError: aDictionary	^ String streamContents: [ :stream | 		(aDictionary associations sorted: [ :a :b | a key < b key  ])			do: [ :each | stream << each key << ': ' << each value ]			separatedBy: [ stream << ', ' ] ]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36243023!analyseClosure: rootNode "<MethodNode>"	"Analyse whether the temporary needs to be made remote	 or not, and answer whether it was made remote.	 A temp cannot be local if it is written to remotely,	 or if it is written to after it is closed-over.  An exception	 is an inlined block argument that appears to be written	 remotely but is actually local to a block."	| latestWrite |	self isBlockArg ifTrue: [^false].	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"	latestWrite := 0.	((writingScopes notNil	 and: [writingScopes associations anySatisfy: [:assoc|			[:blockScope :refs|			refs do: [:write| latestWrite := write max: latestWrite].			"A temp cannot be local if it is written to remotely."			blockScope actualScope ~~ definingScope actualScope]				value: assoc key value: assoc value]])	or: [readingScopes notNil		and: [readingScopes associations anySatisfy: [:assoc|				[:blockScope :refs|				 "A temp cannot be local if it is written to after it is closed-over."				 blockScope actualScope ~~ definingScope actualScope				 and: [refs anySatisfy: [:read| read < latestWrite]]]					value: assoc key value: assoc value]]]) ifTrue:		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.		 ^true].	^false! !!GTInspectorMethodListFilter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36244436!allPresentationMethods	^ (PragmaCollector allSystemPragmas select: [ :pragma | 		pragma key == self inspectorPragmaKey ]) collect: [ :aPragma | aPragma method ]! !!HelpBrowser methodsFor: 'actions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36244705!selectARootTopic: aHelpClass	"Used to unfold a particular topic"		| item |	item := treeMorph allItems detect: [:each |             each complexContents item key = aHelpClass name ].   treeMorph selection: item! !!NECClassVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36245047!popIntoLiteralVariable: anAssociation 	anAssociation key == variableName asSymbol 		ifTrue: [ found := true ]		ifFalse: [ self reset ]! !!GTInspectorTagFilter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36245301!tagsFrom: aMethod	^ (aMethod pragmas select: [ :each | each key == self tagPragmaKey ])		ifEmpty: [ defaultTag ifNil: [ {} ] ifNotNil: [ {defaultTag} ] ]		ifNotEmpty: [ :currentPragmas | currentPragmas collect: [ :each | each argumentAt: 1 ] ]! !!GTInspectorTagFilter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36245665!allPragmasWithTag	^ PragmaCollector allSystemPragmas select: [ :pragma | pragma key == self tagPragmaKey ]! !!ZnApplicationFormUrlEncodedEntity methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36245903!add: association	self at: association key put: association value! !!DateAndTime methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36246095!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'year' -> self year.					'month' -> self monthIndex.					'month name' -> self monthName.					'day of month' -> self dayOfMonth.					'day of week' -> self dayOfWeekName.					'day of year' -> self dayOfYear.					'hours' -> self hours.					'minutes' -> self minutes.					'seconds' -> self seconds.					'nanoseconds' -> self nanoSecond.					'meridian' -> self meridianAbbreviation.					'offset' -> self offset.					'date' -> self asDate.					'time' -> self asTime.					'iso' -> self printString.					'utc' -> self asUTC } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!GTSpotterContext methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36246957!continueFilter	| processors nonEmptyProcessors |	processors := self cache at: #processorsAndFilters ifAbsent: [ ^ self ].	nonEmptyProcessors := processors associations select: [ :assoc | assoc key hasFilteredCandidates ].	nonEmptyProcessors size = 1 ifFalse: [ ^ self ].	self canContinue ifFalse: [ ^ self ].		self withContinue: true do: [ 		nonEmptyProcessors do: [ :assoc | 			assoc key continueFilterInContext: self ] ]! !!GLMRubricTextMorphicTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36247515!noTestOKeyWithCtrlCannotBeOverriden	| composite textMorph overriden shortcut|	overriden := false.	composite := GLMCompositePresentation new with: [ :a | a text act: [ :text | overriden := true ] on: $o entitled: 'Override'].	window := composite openOn: '4'.	textMorph := self find: RubScrolledTextMorph in: window.	"self simulateOnlyOneClickOn: textMorph."		shortcut := $o meta asKeyCombination.	textMorph textArea handleKeystroke: (KeyboardEvent new		setType: #keystroke		buttons: shortcut modifier eventCode		position: textMorph textArea center		keyValue: shortcut key asciiValue		charCode: shortcut key asciiValue		hand: nil		stamp: DateAndTime now).		self assert: overriden not! !!GLMRubricTextMorphicTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36248341!noTestAcceptKeyCanBeOverriden	| composite textMorph overriden shortcut|	overriden := false.	composite := GLMCompositePresentation new with: [ :a | a text act: [ :text | overriden := true ] on: $s entitled: 'Override'].	window := composite openOn: '4'.	textMorph := self find: RubScrolledTextMorph in: window.	self simulateOnlyOneClickOn: textMorph.	(Delay forMilliseconds: HandMorph doubleClickTime + 1) wait.	"self simulateOnlyOneClickOn: textMorph."	self assert: ActiveHand keyboardFocus equals: textMorph textArea.		shortcut := $s meta asKeyCombination.	textMorph textArea handleKeystroke: (KeyboardEvent new		setType: #keystroke		buttons: shortcut modifier eventCode		position: textMorph textArea center		keyValue: shortcut key asciiValue		charCode: shortcut key asciiValue		hand: nil		stamp: DateAndTime now).	self assert: overriden! !!GLMBasicExamples methodsFor: '*Glamour-FastTable' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36249330!fastTreeWithColumnsAndEditing	"self new fastTreeWithColumnsAndEditing openOn: ((1 to: 5) collect: [ :index1 |	((1 to: 10) collect: [ :index | index -> (ValueHolder new contents: 'description') ]) asDictionary ]) "	<glmBrowser: 'Fast Tree With Editable Columns' input: '((1 to: 5) collect: [ :index1 |	((1 to: 10) collect: [ :index | index -> (ValueHolder new contents: ''description'') ]) asDictionary ])'>	| browser |	browser := GLMTabulator new.	browser row: #Example.	browser transmit		to: #Example;		andShow: [ :a | a fastTreeTable 			children: [ :x | x isDictionary ifTrue: [ x associations ] ifFalse: [ #() ] ];			column: [:x | 'Numbers'] evaluated: [ :value | value isDictionary ifTrue: [ value ] ifFalse: [ value key ] ];			column: 'Description' 			   evaluated: [ :value | value isDictionary ifTrue: [ '' ] ifFalse: [ value value contents ] ] 			   modified: [ :newText :value :presentation | 					value isDictionary ifFalse: [ value value contents: newText  ]] ].	^ browser! !!ToggleMenuItemMorph methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36250447!icon	"Answer the receiver's icon. Handle legacy case	of wording-based mechanism."		|state| 	self getStateSelector ifNil: [^super icon].	state := (MessageSend receiver: self target selector: self getStateSelector)		valueWithEnoughArguments: self arguments .	self flag: #CleanYesNoOnOffAfter.	(state isKindOf: Association)		ifTrue: [^ state key ifTrue: [self onImage] ifFalse: [self offImage]]		ifFalse: [	(state = true or: [state isString and: [(state beginsWith: '<yes>') or: [state beginsWith: '<on>']]])		ifTrue: [^self onImage].	(state = false or: [state isString and: [(state beginsWith: '<no>') or: [state beginsWith: '<off>']]])		ifTrue: [^self offImage]].	^super icon! !!CategoryWidget methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36251247!selectedCategories	| associations |	associations := self categoriesSelection associations select: [:assoc | assoc value ].	associations := associations collect: [:assoc | assoc key ].	^ associations select: [:each | each notNil ]! !!DictionaryTest methodsFor: 'test - copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36251597!testDictionaryConcatenationWithCommonKeysDifferentValues	| dictionary1 dictionary2 result value |		dictionary1 := self nonEmptyDict.	value := self nonEmptyDifferentFromNonEmptyDict   values anyOne.	dictionary2 := dictionary1 copy.	dictionary2 keys do: [ :key | dictionary2 at: key put: value ].			result := dictionary1 , dictionary2.	self assert: result size = ( dictionary2 size).		dictionary2 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ]! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36252198!testAddWithKeyNotIn	| dictionary result association |	dictionary := self nonEmptyDict.	association := self associationWithKeyNotInToAdd.	result := dictionary add: association.	self assert: result = association.	self assert: (dictionary at: association key) = association value! !!DictionaryTest methodsFor: 'tests - Dictionary keys values associations access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36252632!testAssociations	| collection result  |	collection := self nonEmpty .	result := collection associations.		self assert: result size = collection size.	result do: [:assoc | self assert: (assoc value) = (collection at: assoc key) ].	"keys do: [ :key | self assert: ( result at: key ) = ( collection at: key )] ."	! !!DictionaryTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36253068!test0FixtureDictionaryAddingTest	self nonEmptyDict.	self deny: self nonEmptyDict isEmpty.	self associationWithKeyNotInToAdd.	self deny: (self nonEmptyDict keys includes: self associationWithKeyNotInToAdd key).	self associationWithKeyAlreadyInToAdd.	self assert: (self nonEmptyDict keys includes: self associationWithKeyAlreadyInToAdd key)! !!DictionaryTest methodsFor: 'tests - dictionnary enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36253555!testAssociationsSelect	| collection keys result |	collection := self nonEmptyDict .	keys := OrderedCollection new.	result := collection associationsSelect: [ :assoc  | 		keys add: assoc key.		true].		collection keys do: [ :key | self assert: (collection keys occurrencesOf: key) = (keys occurrencesOf: key)].	self assert: result = collection.! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36254040!testAtIfAbsentPut	"self run: #testAtIfAbsentPut"	| collection association |	collection := self nonEmpty.	association := collection associations anyOne.	self		assert:			(collection at: association key ifAbsentPut: [ Error signal ])				= association value.	self assert: (collection at: association key) = association value.	self		assert:			(collection at: self keyNotIn ifAbsentPut: [ self valueNotIn ])				= self valueNotIn.	self assert: (collection at: self keyNotIn) = self valueNotIn! !!DictionaryTest methodsFor: 'test - testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36254666!testIncludesAssociationNoValue	| association dictionary |		association := Association key: #key.		self assert: association value isNil.		dictionary := self collectionClass new.		dictionary add: association.		self assert: (dictionary at: #key) isNil			! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36255058!testAddWithKeyAlreadyIn	| dictionary result association |	dictionary := self nonEmptyDict.	association := self associationWithKeyNotInToAdd.	result := dictionary add: association.	self assert: result = association.	self assert: (dictionary at: association key) = association value! !!DictionaryTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36255461!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!DictionaryTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36255995!testDictionaryPublicProtocolCompatibility	"Tests that other dictionaries and their classes respond to the messages	in the public protocols (ignoring extensions, private, printing, copying,	and comparing) that Dictionary and its metaclass implement."	| dict |	self collectionClass == Dictionary		ifTrue: [ ^ self ].	dict := self emptyDict.	{(dict -> Dictionary).	(dict class -> Dictionary class)}		do: [ :assoc | 			assoc value protocols				reject: [ :protocol | 					#('private' 'print' 'copy' 'compar' '*')						anySatisfy: [ :each | protocol asString beginsWith: each ] ]				thenDo: [ :protocol | 					(assoc value selectorsInProtocol: protocol)						do: [ :each | self assert: (assoc key respondsTo: each) ] ] ]! !!DictionaryTest methodsFor: 'tests - dictionary assocition access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36256865!testAssociationAtIfAbsent	| collection keyIn result |	collection := self nonEmpty.	keyIn := collection keys anyOne.	result := collection associationAt: keyIn ifAbsent: [888]. 	self assert: (result key) = keyIn.	self assert: (result value ) = (collection at: keyIn ).	self assert: (collection associationAt: self keyNotIn  ifAbsent: [888] ) = 888! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36257355!testAtIfPresentIfAbsent	"self run: #testAtIfPresentIfAbsent"	| collection association arg |	collection := self nonEmpty.	association := collection associations anyOne.	arg := nil.	self		assert:			(collection				at: association key				ifPresent: [ :value | 					arg := value.					#present ]				ifAbsent: [ Error signal ]) = #present.	self assert: arg = association value.	"ensure cull: is used to support blocks that take no args"	self		assert:			(collection				at: association key				ifPresent: [ #present ]				ifAbsent: [ Error signal ]) = #present.	self		assert:			(collection				at: self keyNotIn				ifPresent: [ :value | Error signal ]				ifAbsent: [ self valueNotIn ]) = self valueNotIn! !!DictionaryTest methodsFor: 'tests - dictionary assocition access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36258223!testAssociationAt	| collection keyIn result |	collection := self nonEmpty.	keyIn := collection keys anyOne.	result := collection associationAt: keyIn. 	self assert: (result key) = keyIn.	self assert: (result value ) = (collection at: keyIn ).! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36258608!testAtIfAbsent	"self run: #testAtIfAbsent"	| collection association |	collection := self nonEmpty.	association := collection associations anyOne.	self		assert:			(collection at: association key ifAbsent: [ Error signal ])				= association value.	self		assert:			(collection at: self keyNotIn ifAbsent: [ self valueNotIn ])				= self valueNotIn! !!DictionaryTest methodsFor: 'test - copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36259080!testDictionaryConcatenationWithCommonKeys	| dictionary1 dictionary2 result |	dictionary1 := self nonEmptyDict.	dictionary2 := self nonEmptyDict.	result := dictionary1 , dictionary2.	self assert: result size = ( dictionary2 size).		dictionary2 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ]! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36259543!testAtIfPresent	"self run: #testAtIfPresent"	| collection association arg |	collection := self nonEmpty.	association := collection associations anyOne.	arg := nil.	self		assert:			(collection				at: association key				ifPresent: [ :value | 					arg := value.					#present ]) = #present.	self assert: arg = association value.	"ensure cull: is used to support blocks that take no args"	self		assert: (collection at: association key ifPresent: [ #present ]) = #present.	self		assert:			(collection				at: self keyNotIn				ifPresent: [ :value | Error signal ]) isNil! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36260253!testAddAll		| collectionToAdd collection result oldSize |	collection := self nonEmptyDict .	oldSize := collection size.	collectionToAdd := self collectionClass new 		add: self associationWithKeyAlreadyInToAdd ; 		add: self associationWithKeyNotInToAdd ; 		yourself.		result := collection addAll: collectionToAdd .		self assert: result = collectionToAdd .	"  the association with the key already in should have replaced the oldest :"	self assert: collection  size = (oldSize + 1).		result associationsDo: [:assoc | self assert: (collection at:  (assoc key) ) = assoc value].! !!DictionaryTest methodsFor: 'test - testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36260958!testIncludesAssociationWithValue	| association dictionary |		association := Association key: #key value: 1.	dictionary := self collectionClass new.	dictionary add: association.		self assert: (dictionary at: #key) = 1			! !!DictionaryTest methodsFor: 'test - adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36261314!testDeclareFrom	| newDict v dictionary keyIn associationKeyNotIn |	dictionary := self nonEmptyDict.	keyIn := dictionary keys anyOne.	associationKeyNotIn := self associationWithKeyNotInToAdd .	newDict := self collectionClass new add: associationKeyNotIn; yourself.				"if the key already exist, nothing changes"	v := dictionary  at: keyIn.	dictionary  declare: keyIn  from: newDict.	self assert: (dictionary  at: keyIn ) = v.		"if the key does not exist, then it gets removed from newDict and is added to the receiver"	self nonEmptyDict declare: associationKeyNotIn key from: newDict.	self assert: (dictionary  at: associationKeyNotIn key) = associationKeyNotIn value.	self assert: (newDict size = 0)! !!DictionaryTest methodsFor: 'tests - dictionnary enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36262173!testAssociationsDo	| collection keys |	collection := self nonEmptyDict .	keys := OrderedCollection new.		collection associationsDo: [ :assoc | 		keys add: assoc key.		self assert: ( collection at: assoc key ) = assoc value.				].		collection keys do: [:key | self assert: ( keys occurrencesOf: key ) = (collection keys occurrencesOf: key)].! !!DictionaryTest methodsFor: 'test - copying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36262651!testDictionaryConcatenationWithoutCommonKeys	| dictionary1 dictionary2 result |	dictionary1 := self nonEmptyDict.	dictionary2 := self nonEmptyDifferentFromNonEmptyDict.	result := dictionary1 , dictionary2.	self assert: result size = (dictionary1 size + dictionary2 size).	dictionary1 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ].	dictionary2 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ]! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36263257!testAt	"self run: #testAt"	| collection association |	collection := self nonEmpty.	association := collection associations anyOne.	self assert: (collection at: association key) = association value.	self should: [ collection at: self keyNotIn ] raise: Error! !!DictionaryTest methodsFor: 'test - new' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36263631!testNewFromPairs	| assocs pairs |	assocs := self nonEmptyDict associations.	pairs := OrderedCollection new.	assocs do: [:each |		pairs			add: each key;			add: each value].	0 to: pairs size do: [:i | | dictFromPairs dictFromAssocs |		dictFromPairs := self classToBeTested newFromPairs: (pairs copyFrom: 1 to: i).		dictFromAssocs := self classToBeTested newFrom: (assocs copyFrom: 1 to: (i / 2) floor).		self assert: dictFromPairs = dictFromAssocs].! !!DictionaryTest methodsFor: 'tests - DictionaryIndexAccessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36264224!testAtIfPresentIfAbsentPut	"self run: #testAtIfPresentIfAbsentPut"	| collection association arg |	collection := self nonEmpty.	association := collection associations anyOne.	arg := nil.	self		assert:			(collection				at: association key				ifPresent: [ :value | 					arg := value.					#present ]				ifAbsentPut: [ Error signal ]) = #present.	self assert: arg = association value.	"ensure cull: is used to support blocks that take no args"	self		assert:			(collection				at: association key				ifPresent: [ #present ]				ifAbsentPut: [ Error signal ]) = #present.	self		assert:			(collection				at: self keyNotIn				ifPresent: [ :value | Error signal ]				ifAbsentPut: [ self valueNotIn ]) = self valueNotIn.	self assert: (collection at: self keyNotIn) = self valueNotIn! !!DictionaryTest methodsFor: 'tests - dictionary assocition access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36265171!testAssociationAtIfPresent	| collection keyIn result |	collection := self nonEmpty.	keyIn := collection keys anyOne.	result := collection associationAt: keyIn ifPresent: [:assoc | {#present. assoc}].	self		assert: result isArray;		assert: result size = 2;		assert: result first = #present;		assert: result second key = keyIn;		assert: result second value = (collection at: keyIn).	"test that cull: is used to support zero-arg blocks"	result := collection associationAt: keyIn ifPresent: [#present].	self assert: result = #present.	result := collection associationAt: self keyNotIn ifPresent: [:assoc | {#present. assoc}].	self assert: result isNil.! !!FuzzyMatcherExample methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36265959!initialize	super initialize.		pattern := ''.		dataSource := FTEasyListDataSource new		elements: #();		display: [ :item |			String streamContents: [ :stream |							stream 					nextPutAll: item value asString;					space: (10 - ((stream position *2) min: 8));					nextPutAll: item key asString			]		];		yourself.					textModel := RubScrolledTextModel new.	textModel announcer when: RubEditsStateChangedInModel 		send: #update to: self.		stringMorph := StringMorph contents: '' font: self aquireFont			! !!FuzzyMatcherExample methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36266596!match: aPattern for: aCollection	| matcher matches |		aPattern isEmpty ifTrue: [ ^ aCollection ].		matcher := FuzzyMatcher pattern: aPattern.	matches := OrderedCollection new: aCollection size.		aCollection do: [ :each | 		matcher 			match: each key			ifScored: [ :score | matches add: each key -> score ] 	].		matches sort: [ :a :b | a value >= b value ].		^ matches! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36267112!decodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | bytes color form |		color := assoc key.		bytes := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		form := PNGReadWriter formFromStream: bytes.		self assert: form depth = requiredDepth.		self assert: (form pixelValueAt: 1@1) = (color pixelValueForDepth: requiredDepth).	].! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36267608!encodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | original encoded color ff |		color := assoc key.		original := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		ff := Form extent: 32@32 depth: requiredDepth.		ff fillColor: color.		encoded := ByteArray new writeStream.		PNGReadWriter putForm: ff onStream: encoded.		self assert: (encoded contents = original contents).	].! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36268141!printWhileOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	(arguments isEmpty not	 and: [arguments first isJust: NodeNil]) ifTrue:			[selector := SelectorNode new							key:									(selector key == #whileTrue:										ifTrue: [#whileTrue]										ifFalse: [#whileFalse])							code: #macro.			arguments := Array new].	self printKeywords: selector key arguments: arguments		on: aStream indent: level! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36268712!emitCodeForWhile: stack encoder: encoder value: forValue        "L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "        | cond theArguments stmt stmtSize loopSize |        cond := receiver.        theArguments := arguments ifEmpty: [ Array with: (BlockNode withJust: NodeNil) ].        stmt := theArguments at: 1.        stmtSize := sizes at: 1.        loopSize := sizes at: 2.        cond emitCodeForEvaluatedValue: stack encoder: encoder.        self emitCodeForBranchOn: ((selector key == #whileFalse:) or: [ selector key == #whileFalse ]) "Bfp for whileTrue"                                        dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"        pc := encoder methodStreamPosition.        stmt emitCodeForEvaluatedEffect: stack encoder: encoder.        self emitCodeForJump: 0 - loopSize encoder: encoder.        forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36269755!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36270822!printIfNil: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36271134!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'macro transformations' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36271988!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange limitIsAssignedTo |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^false]]		ifFalse: [increment := encoder encodeLiteral: 1].	(limit := arguments at: 1) isVariableReference ifTrue:		[limitIsAssignedTo := false.		 arguments last nodesDo:			[:node|			(node isAssignmentNode and: [node variable = limit]) ifTrue:				[limitIsAssignedTo := true]].		 limitIsAssignedTo ifTrue:			[^false]].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36274525!toDoIncrement: variable	(receiver = variable and: [selector key = #+]) 		ifFalse: [^ nil].	arguments first isConstantNumber		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36274807!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36275593!toDoLimit: variable	(receiver = variable and: [selector key = #<= or: [selector key = #>=]]) 		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36275853!printOn: aStream indent: level	"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	special > 0 ifTrue:		[^self perform: self macroPrinter with: aStream with: level].	self printReceiver: receiver on: aStream indent: level.	selector isForFFICall		ifTrue:			[aStream space.			 selector				printAsFFICallWithArguments: arguments				on: aStream				indent: 0]		ifFalse:			[self printKeywords: selector key				 arguments: arguments				 on: aStream				 indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36276536!printRepeatOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector key		arguments: (Array new)		on: aStream indent: level! !!MessageNode methodsFor: 'macro transformations' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36276839!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:	 and: [initStmt isAssignmentNode	 and: [initStmt variable isTemp]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessageNode	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	"The block must not overwrite the limit"	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])		ifTrue: [^nil]. 	toDoBlock := BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	variable scope: -1.	variable beBlockArg.	^MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36278172!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	originalSelector := selNode key.	selNode code == #macro		ifTrue: [self noteSpecialSelector: selNode key]		ifFalse: [special := 0].	selector := selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'code generation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36278744!sizeCodeForWhile: encoder value: forValue        "L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);        justStmt, wholeLoop, justJump."        | cond theArguments stmt stmtSize loopSize branchSize |        cond := receiver.        theArguments := arguments ifEmpty: [ Array with: (BlockNode withJust: NodeNil) ].        stmt := theArguments at: 1.        stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).        branchSize := self                                        sizeCode: encoder                                        forBranchOn: ((selector key == #whileFalse:) or: [ selector key == #whileFalse ])  "Btp for whileFalse"                                        dist: stmtSize.        loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.        sizes := Array with: stmtSize with: loopSize.        ^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36279832!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs	 arguments.  All block arguments are ParseNodes."	^(selSymbol isNil or: [selSymbol==selector key]) and:		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !!SmallDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36280489!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := self species new.	self associationsDo:[:each |		newCollection at: each key put: (aBlock value: each value).	].	^newCollection! !!SmallDictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36280940!includesAssociation: anAssociation  ^ (self         associationAt: anAssociation key      ifAbsent: [ ^ false ]) value = anAssociation value! !!SmallDictionary methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36281196!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value.	See issue 16760 before changing"	self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !!SmallDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36281788!remove: oldObject ifAbsent: anExceptionBlock 	self removeKey: oldObject key ifAbsent: anExceptionBlock.	^oldObject! !!SmallDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36282013!add: anAssociation 	self at: anAssociation key put: anAssociation value.	^anAssociation! !!SmallDictionary methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36282233!gtInspectorItemsIn: composite	^ (composite fastTable)		title: 'Items';		display: [ self associations ];		"children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];"		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each key ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		selectionAct: [ :table |			table rawSelection do: [ :assoc | self removeKey: assoc key ].			table update ]			entitled: 'Remove item(s)';		selectionPopulate: #selection 			entitled: 'Open key'			with: [ :table | (table rawSelection collect: #key) gtInspectorInterestingObject ];		beMultiple;		send: [ :selection | selection isNil 			ifTrue:[nil]			ifFalse:[ (selection size = 1 ) 				ifTrue: [ selection anyOne value ] 				ifFalse: [ selection collect: #value ] ]]		"withSmalltalkSearch;		showOnly: 50;		helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'"! !!SmallDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36283543!remove:anAssociation	self removeKey:anAssociation key.! !!SmallDictionary class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36283725!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary! !!KeyPrinterMorph methodsFor: 'event handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36284215!keyDown: anEvent	UIManager default inform: anEvent key asString.! !!KMSingleKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36284399!name	^ self key asString! !!KMSingleKeyCombination methodsFor: 'matching' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36284542!matchesEvent: aKeyboardEvent	^ self key asLowercase = aKeyboardEvent modifiedCharacter asLowercase! !!KMSingleKeyCombination methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36284760!= aShortcut	^ super = aShortcut and: [ aShortcut key sameAs: key ]! !!EpMonitor methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36284931!subscribeToSystemAnnouncer	{	CategoryAdded -> #categoryAdded:. 		CategoryRemoved -> #categoryRemoved:.		CategoryRenamed -> #categoryRenamed:.		ClassAdded-> #behaviorAdded:.		ClassRemoved->#behaviorRemoved:.		MethodAdded -> #methodAdded:.		MethodRemoved -> #methodRemoved:.		ProtocolAdded -> #protocolAdded:.		ProtocolRemoved -> #protocolRemoved:.		ClassModifiedClassDefinition -> #behaviorModified:.		MethodModified -> #methodModified:.		ClassRecategorized -> #classRecategorized:.		ClassRenamed -> #classRenamed:.		ClassCommented -> #classCommented:.		MethodRecategorized -> #methodRecategorized:.		MCVersionSaved	-> #monticelloVersionSaved:.			} do: [ :pair |		systemAnnouncer weak			when: pair key 			send: pair value 			to: self ].! !!EpMonitor methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36285794!subscribeToJobAnnouncer	{	JobStart -> #jobStarted:.		JobEnd -> #jobEnded:.	} do: [ :pair |		jobAnnouncer			when: pair key 			send: pair value 			to: self ].! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36286072!includes: anElement	^ storage anySatisfy: [:association | association key = anElement ]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36286274!oldest	^ storage last key! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36286414!youngest	^ storage first key! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36286557!at: anElement	^ storage detect: [:each | each key = anElement]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36286734!mostSeen	| max |	max := storage first.	2 to: storage size do: [:index || each |		each := storage at: index.		(each value > max value)			ifTrue: [ max := each]].	^ max key! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36287025!lessSeen	| min |	min := storage first.	2 to: storage size do: [:index || each |		each := storage at: index.		(each value < min value)			ifTrue: [ min := each]].	^ min key! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36287316!mostViewedElements		^ (storage sorted: [:a :b | a value >= b value]) collect: [:each | each key ]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36287528!identityIncludes: anElement	^ storage anySatisfy: [:association | association key == anElement ]! !!HistoryCollection methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36287739!elements		^ storage collect: [:each | each key ]! !!RBRemoveMethodRefactoring methodsFor: 'preconditions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36287915!checkBrowseAllOccurences: anCollectionOfOccurrences	| methods callers |	methods := anCollectionOfOccurrences collect: [ :c | c key ] as: Set.	callers := anCollectionOfOccurrences collect: [ :v | v value ].	methods size = 1		ifTrue: [ 			self				refactoringError:					('Possible call to <2s> in <1p> methods.<n>Browse references?'						expandMacrosWith: anCollectionOfOccurrences size						with: methods anyOne)				with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: methods anyOne) ] ]		ifFalse: [ 			self				refactoringError:					('Possible call to the <2p> selectors in <1p> methods.<n>Browse references?'						expandMacrosWith: callers size						with: methods size)				with: [ 					| env |					env := RBSelectorEnvironment new.					callers do: [ :d | env addMethod: d method ].					self openBrowserOn: env ] ]! !!RBRemoveMethodRefactoring methodsFor: 'preconditions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36288891!checkBrowseOccurrences: anCollectionOfOccurrences	anCollectionOfOccurrences size = 1		ifTrue: [ ^ self checkBrowseOccurrenceOf: anCollectionOfOccurrences first key in: anCollectionOfOccurrences first value ]		ifFalse: [ ^ self checkBrowseAllOccurences: anCollectionOfOccurrences ]! !!Form methodsFor: 'color mapping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36289279!reducedPaletteOfSize: nColors	"Return an array of colors of size nColors, such that those colors	represent well the pixel values actually found in this form."	| threshold tallies colorTallies dist delta palette cts top cluster |	tallies := self tallyPixelValues.  "An array of tallies for each pixel value"	threshold := width * height // 500.	"Make an array of (color -> tally) for all tallies over threshold"	colorTallies := Array streamContents:		[:s | tallies withIndexDo:			[:v :i | v >= threshold ifTrue:				[s nextPut: (Color colorFromPixelValue: i-1 depth: depth) -> v]]].	"Extract a set of clusters by picking the top tally, and then removing all others	whose color is within dist of it.  Iterate the process, adjusting dist until we get nColors."	dist := 0.2.  delta := dist / 2.		[cts := colorTallies copy.		palette := Array streamContents: [:s |			[cts isEmpty] whileFalse:				[top := cts detectMax: [:a | a value].				cluster := cts select: [:a | (a key diff: top key) < dist].				s nextPut: top key -> (cluster detectSum: [:a | a value]).				cts := cts copyWithoutAll: cluster]].		palette size = nColors or: [delta < 0.001]]		whileFalse:			[palette size > nColors				ifTrue: [dist := dist + delta]				ifFalse: [dist := dist - delta].			delta := delta / 2].	^ palette collect: [:a | a key]! !!LRUCache methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36290743!handleMiss: association	| link |	statistics addMiss.	self addWeight: association value.	link := lruList addLast: association.	keyIndex at: association key put: link.	^ association value! !!LRUCache methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36291037!validateInvariantWith: assertable	"The keyIndex maps keys to double linked list nodes that hold 	a key value association, whose key must match the index key"	keyIndex keysAndValuesDo: [ :key :link |		assertable assert: link value key = key ].	"When iterating over all key value pairs, each key lookup up	through the index should see the correct key and value in 	the double linked list node"	self keysAndValuesDo: [ :key :value |		| link |		link := keyIndex at: key.		assertable assert: link value value = value.		assertable assert: link value key = key ].	"When iterating over all keys, each key can be present only once"	Set new in: [ :keysSeen |		self keysAndValuesDo: [ :key :value |			assertable assert: (keysSeen includes: key) not.			keysSeen add: key ] ]! !!LRUCache methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36291929!evict	| link value |	link := lruList removeFirst.	value := link value.	weight remove: value value.	keyIndex removeKey: value key! !!LRUCache methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36292169!keysAndValuesDo: block	"Execute block with each key and value present in me.	This will be from least to most recently used."		lruList do: [ :link |		block 			value: link key 			value: link value ]! !!GTSpotterRecorderEvent methodsFor: 'gt-inspector-extension' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36292504!gtInspectorItemsIn: composite	<gtInspectorPresentationOrder: -1>  	^ (composite table)		title: 'Info';		display: [ :anEvent | anEvent gtInspectorItems ];		children: [ :each | 			(each value isDictionary) 				ifTrue: [ each value associations ] 				ifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])						ifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]						ifFalse: [ #() ] ] ];		column: 'Key' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each key ];		column: 'Value' 			evaluated: [:each | GTObjectPrinter asTruncatedTextFrom: each value ];		beMultiple;		send: [ :selection | 			(selection notNil and: [ selection size = 1 ]) 				ifTrue: [ selection anyOne value ] 				ifFalse: [ selection collect: #value ] ];		showOnly: 50! !!Behavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36293406!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral key.	value := scannedLiteral value.	key ifNil: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNil:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNil:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!Behavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36294935!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key := aCodeLiteral key.	(key isNil and: [(value := aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	(key isSymbol and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!NOCCompletionTable methodsFor: 'protocol' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36295664!compiled: selector in: class date: date	| method |	self addEntry: selector date: date.	self class classes addEntry: class theNonMetaClass name date: date.	(class canUnderstand: selector) ifFalse: [ ^self ].	method := class compiledMethodAt: selector ifAbsent: [ ^self ].	method messages do: [ :m | self  addEntry: m date: date ].	method literals do: [ :each |		(each isVariableBinding and: [			each key notNil and: [				each key first isUppercase ] ])					ifTrue: [ 						self class classes addEntry: each key date: date ] ]! !!RubParagraph methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36296329!Differencekey	^self class key! !!RubParagraph methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36382406!key	^self class key! !!OmFileStore methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36296593!flushEntryBuffer	self critical: [		| initialPosition initialLocalName |		self entryBuffer isEmpty ifTrue: [ ^self ].				fileReference writeStreamDo: [:fileStream |			fileStream setToEnd.						initialPosition := fileStream position.			initialLocalName := self entryBuffer first value.					ZnBufferedWriteStream on: fileStream do: [:aWriteStream |				| anEntryWriter |				anEntryWriter := self newEntryWriter.				[ self entryBuffer isEmpty ] whileFalse: [					| next entry |					next := self entryBuffer removeFirst.					entry := next key.					"Write entry to file"					anEntryWriter						on: aWriteStream 						nextEntryPut: entry.					].				].			"In Linux it was necessary to explicitely flush the file stream"			fileStream flush.						lastStreamPosition := fileStream size.			].			self refreshEntryPositionsByLocalNameStartingAt: initialPosition since: initialLocalName.		].! !!OmFileStore methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36297614!entriesDo: aBlockClosure 	"Evaluate the closure on each entry"	self fileReference exists ifTrue: [		self readEntriesWith: [:readStream | 			| reader |			reader := self newEntryReader.			reader stream: readStream.			[ readStream atEnd ] whileFalse: [				aBlockClosure value: reader nextEntry ] ] ].	"Finally, the entries still not written"	self entryBufferDo: [:entryAndLocalName | 		aBlockClosure value: entryAndLocalName key ].! !!OSEnvironmentTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36298166!testAssociations	| associations |	associations := self instance associations.	self deny: associations isEmpty.	self assert: associations anyOne key isString.	self assert: associations anyOne value isString.! !!MonticelloRepositoryBrowser methodsFor: 'menu' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36298496!orderString: anIndex	^ String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!BIConfigurableFormatter methodsFor: 'public interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36298841!installNewValueInContext: aCol	"self new installNewValueInContext: { (#cascadedMessageInsideParentheses: -> true) }"		context := context copy.	"needed because by default context point to the DefaultPrettyPrintContext"	aCol do: [ :each | self perform: each key with: each value]! !!WatchpointTests methodsFor: 'values' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36299232!testTimestamp	|node watchpoint|		node := (WPDummy>>#exampleAssignment:) ast body children first.	watchpoint := Watchpoint in: node.		1 to: 10 do:[:i| WPDummy new exampleAssignment: i].	1 to: 9 do: [:i|  		|older newer|		older := watchpoint values at: i.		newer := watchpoint values at: i + 1.		self assert: (older key <= newer key).	]. 		watchpoint uninstall.	! !!Encoder methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36299719!unusedTempNames 	| unused |	unused := OrderedCollection new.	scopeTable associationsDo:		[:assn | | name |		(assn value isUnusedTemp) ifTrue:			[name := assn value key.			 name ~= self doItInContextName ifTrue: [unused add: name]]].	^ unused! !!Encoder methodsFor: 'results' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36300070!tempNames 	^ self tempNodes collect:		[:node | (node isMemberOf: MessageAsTempNode)					ifTrue: [scopeTable keyAtValue: node]					ifFalse: [node key]]! !!Encoder methodsFor: 'temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36300325!bindAndJuggle: name	| node nodes first thisCode |	node := self reallyBind: name.	"Declared temps must precede block temps for decompiler and debugger to work right"	nodes := self tempNodes.	(first := nodes findFirst: [:n | n scope > 0]) > 0 ifTrue:		[node == nodes last ifFalse: [self error: 'logic error'].		thisCode := (nodes at: first) code.		first to: nodes size - 1 do:			[:i | (nodes at: i) key: (nodes at: i) key							code: (nodes at: i+1) code].		nodes last key: nodes last key code: thisCode].		^ node! !!BooleanSlot methodsFor: 'class building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36300974!calculateOffset: aClass	| booleanSlots  calculatedOffset |	"first we get all boolean slots and sort them by index"	booleanSlots := aClass allSlots select: [ :each | each isKindOf: self class ].	booleanSlots := booleanSlots select: [ :each | each offset isNotNil ].	booleanSlots sort: [ :a :b | a offset < b offset ]. 	booleanSlots ifEmpty: [ ^1 ]. "we are the first one!!"	"now we find the first spot where the next offset is not yet taken"	calculatedOffset := (booleanSlots withIndexCollect: [ :each :myIndex | myIndex ->each offset ]) 		findFirst: [ :each | each key ~= each value ].	calculatedOffset = 0  "no hole found: use the next index after the last slot"		ifTrue: [ ^ booleanSlots last offset + 1 ].	^calculatedOffset	! !!ContinuationTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36301824!testReentrant	| assoc |	assoc := self callcc: [ :cc | cc -> 0 ].	assoc value: assoc value + 1.	self assert: assoc value ~= 5.	assoc value = 4		ifFalse: [ assoc key value: assoc ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36302126!orderString: anIndex	^ String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!MultipleSettingDeclaration methodsFor: 'user interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36302472!fixedDomainValueNodeForAssociation: anAssociation 	| s |	^ (s := (SettingDeclaration new name: anAssociation key translated))		target: s;		selector: #default;		default: anAssociation value! !!HandMorph methodsFor: '*SUnit-UITesting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36302778!simulateKeyStroke: aCharacterOrShortcut	| shortcut |	shortcut := aCharacterOrShortcut asKeyCombination.	self handleEvent: (KeyboardEvent new		setType: #keystroke		buttons: shortcut modifier eventCode		position: self position 		keyValue: shortcut key asciiValue		charCode: shortcut key asciiValue		hand: self activeHand 		stamp: DateAndTime now).! !!SetTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36303254!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!RGContainer methodsFor: 'image package loading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36303801!findPackageOfMethod: aRGMethodDefinition using: packageKeys	"Look for the package of an extension method. nil otherwise"	| pair lname |		self packages isEmpty ifTrue: [ ^nil ].	(aRGMethodDefinition protocol beginsWith: '*') ifFalse:[ ^ nil ].	lname := aRGMethodDefinition protocol asLowercase. 	pair := packageKeys detect:[ :assoc| self class category: lname matches: assoc value ] ifNone:[ nil ].	^ pair ifNotNil:[ self packages at: pair key ]! !!RGContainer methodsFor: 'image package loading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36304373!findPackageOfClass: aRGBehaviorDefinition using: packageKeys	"Look for the package of a class. It is nil when there is not a package created for a category in MC"	| pair |	self packages isEmpty ifTrue: [ ^ nil ].	^ self packages at: aRGBehaviorDefinition category ifAbsent:[		pair := packageKeys detect:[ :each| self class category: aRGBehaviorDefinition category matches: each key ] ifNone:[ nil ].		pair ifNotNil:[ self packages at: pair key ] ]! !!RGContainer class methodsFor: 'image package loading' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36304963!packageOfMethod: aRGMethodDefinition using: packageKeys	"Looks for the package of aRGMethodDefinition from the image"	| pName parentPackage |	(aRGMethodDefinition protocol notNil and:[ aRGMethodDefinition protocol beginsWith: '*' ]) ifFalse:[		parentPackage := (aRGMethodDefinition parent ifNotNil:[ aRGMethodDefinition parent package ]).			^ parentPackage ifNil:[ self packageOfClass: aRGMethodDefinition parent ] ].	aRGMethodDefinition protocol ifNil: [ ^ nil ].	pName := (packageKeys 				detect: [ :each| self category: aRGMethodDefinition protocol asLowercase matches: each value ] ifNone:[ nil ]).	^ pName ifNotNil:[ RGPackage named: pName key ]! !!ClassTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36305728!testChangingShapeDoesNotPutNilInMethodsLastLiteralKey	"Test that when the shape of a class changes, the key of the last literal of the methods is not nil"	| tutu |	tutu := Smalltalk globals at: #TUTU.	tutu compile: 'foo'.	self deny: (tutu >> #foo) allLiterals last key isNil.	tutu addInstVarNamed: 'x'.	self deny: (tutu >> #foo) allLiterals last key isNil.! !!ClassTest methodsFor: 'testing - navigation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36306218!testReferencedClasses	{(RBLintRuleTest		->			{RBRefactoryTestDataApp.			Object.			Array.			WriteStream.			String}). 	 (RBBasicLintRuleTest -> {RBSelectorEnvironment}).	 (RBCompositeLintRuleTest -> {OrderedCollection})	}		do: [ :assoc | 			self assert: assoc key referencedClasses notEmpty.			self assert: assoc key referencedClasses asSet = assoc value asSet]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36306723!unregisterWellKnownProcess: aProcess	"Remove the first registry entry that matches aProcess. Use	with caution if more than one registry entry may match aProcess."	"self unregisterWellKnownProcess: Smalltalk lowSpaceWatcherProcess"	WellKnownProcesses detect: [ :e | e key value == aProcess ] ifFound: [ :entry | WellKnownProcesses remove: entry ]! !!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36307197!dumpTally: tally on: aStream	"tally is from ProcessorScheduler>>tallyCPUUsageFor:	Dumps lines with percentage of time, hash of process, and a friendly name"	tally sortedCounts do: [ :assoc | | procName |		procName := (self nameAndRulesFor: assoc value) first.		(((assoc key / tally size) * 100.0) roundTo: 1) printOn: aStream.		aStream			nextPutAll: '%   ';			print: assoc value identityHash; space;			nextPutAll: procName;			cr.	]! !!ProcessBrowser class methodsFor: 'process control' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36307763!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	| rules |	rules := {nil. true. true}.	WellKnownProcesses do: [:blockAndRules |		blockAndRules key value == aProcess 			ifTrue: [ rules := blockAndRules value value ]].	rules first ifNil: [ 		rules at: 1 put: aProcess suspendedContext asString ].	^ rules! !!ZnMimePart methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36308241!gtInspectorContentsIn: composite	<gtInspectorPresentationOrder: 40>	self hasEntity		ifTrue: [ 			self contentType isBinary				ifTrue: [ 					composite table						title: 'Contents';						display: [ {'entity' -> self entity} ];						column: 'Key' evaluated: #key;						column: 'Value' evaluated: #value;						send: #value ]				ifFalse: [ 					composite text						title: 'Contents';						format: self contents ] ]! !!MenuItemMorph methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36308776!contents: aString withMarkers: aBool inverse: inverse 	"Set the menu item entry. If aBool is true, parse aString for embedded markers."	| markerIndex marker |	self contentString: nil.	"get rid of old"	aBool ifFalse: [^super contents: aString].	self removeAllMorphs.	"get rid of old markers if updating"	self hasIcon ifTrue: [ self icon: nil ].	self flag: #CleanYesNoOnOffAfter.	(aString isKindOf: Association)		ifTrue: [ super contents: aString value. 				marker := aString key   					ifTrue: [self onImage]					ifFalse: [self offImage]]		ifFalse: [		(aString notEmpty and: [aString first = $<]) 			ifFalse: [^super contents: aString].		markerIndex := aString indexOf: $>.		markerIndex = 0 ifTrue: [^super contents: aString].	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 		ifFalse: [^super contents: aString].	self contentString: aString.	"remember actual string"	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 				ifTrue: [self onImage]				ifFalse: [self offImage].	super contents:  (aString copyFrom: markerIndex + 1 to: aString size)].	"And set the marker"	marker := ImageMorph new form: marker.	marker position: self left @ (self top + 2).	self addMorphFront: marker! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36310173!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	value printOn: aStream! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36310384!= aLookupKey	"XXX why doesn't this consider the value? mvl"	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36310665!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36310851!storeOn: aStream	"Store in the format (key->value)"	aStream 		nextPut: $(;		nextPutAll: self class name.	self expired ifTrue:[		aStream nextPutAll: ' expired'	] ifFalse: [		aStream nextPutAll:' key: '.		self key storeOn: aStream.		aStream nextPutAll: ' value:'.		value storeOn: aStream.	].	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36311288!name	^ self key isString		ifTrue: [self key]		ifFalse: [self key printString]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36311504!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!TraitBehavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36311705!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral key.	value := scannedLiteral value.	key ifNil: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNil:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNil:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!TraitBehavior methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36313239!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key := aCodeLiteral key.	(key isNil and: [(value := aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	(key isSymbol and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!MethodDictionaryTest methodsFor: 'tests - Dictionary keys values associations access' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36314012!testAssociations	| collection result  |	collection := self nonEmpty .	result := collection associations.		self assert: result size = collection size.	result do: [:assoc | self assert: (assoc value) = (collection at: assoc key) ].	"keys do: [ :key | self assert: ( result at: key ) = ( collection at: key )] ."	! !!MethodDictionaryTest methodsFor: 'tests - others' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36314453!testAssociationAtExistantKeyReturnsOkAssociation	| methodSelector association |	methodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.	association := self class methodDict associationAt: methodSelector ifAbsent: [self error].		self assert: association key = methodSelector.	self assert: association value = (self class >> methodSelector).! !!CompiledCode methodsFor: 'literals' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36314919!literalStrings	"Return a list of strings or symbols corresponding to the class references and message sent.	The result also contains the name of the class"		| litStrs |	litStrs := OrderedCollection new: self numLiterals.	self literalsDo:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit key]			ifFalse: [(lit isSymbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!CompiledCode methodsFor: 'comparing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36315479!sameLiteralsAs: method	"Compare my literals to those of method. This is needed to compare compiled methods."	| numLits literal1 literal2 |	(numLits := self numLiterals) ~= method numLiterals		ifTrue: [ ^ false ].	"The last literal requires special checking instead of using #literalEqual:"	1 to: numLits - 1 do: [ :index | 		literal1 := self literalAt: index.		literal2 := method literalAt: index.		(literal1 == literal2 or: [ literal1 literalEqual: literal2 ])			ifFalse: [ 				(index = 1 and: [ self isNamedPrimitive | self isExternalCallPrimitive ])					ifTrue: [ 						literal1 isArray							ifTrue: [ 								(literal2 isArray and: [ literal1 allButLast = literal2 allButLast ])									ifFalse: [ ^ false ] ]							ifFalse: [ 								"ExternalLibraryFunction"								(literal1 analogousCodeTo: literal2)									ifFalse: [ ^ false ] ] ]					ifFalse: [ 						index = (numLits - 1)							ifTrue: [ 								"properties"								"don't create properties if they don't exist"								(literal1 isSymbol and: [ literal2 isSymbol ]) ifFalse: [									(self properties analogousCodeTo: method properties) ifFalse: [ ^false ] ] ]							ifFalse: [ ^ false ] ] ] ].	"Class side methods have non unique (nil -> a Metaclass) as literal and cannot be compared equal"	literal1 := self literalAt: numLits.	literal2 := method literalAt: numLits.	^literal1 class == literal2 class	     and: [literal1 isVariableBinding	                ifTrue: [literal1 key = literal2 key and: [literal1 value = literal2 value]]	                ifFalse: [literal1 = literal2]]! !!GTPlaygroundBindingsList methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36317200!newBindingRow: anAssociation in: aCollection	^ self newRow		borderWidth: { 0 . 0 . aCollection last == anAssociation ifTrue: [ 0 ] ifFalse: [ self themer bindingThemer borderWidth ] . 0 };		addAllBricks: {			self newBindingLabel				textColor: self themer textLightColor;				text: anAssociation key.			self newBindingLabel				text: anAssociation value asString.			self newInspectButtonFor: anAssociation.			self newGoButtonFor: anAssociation.			self newRemoveButtonFor: anAssociation };		with: [ :aRow | aRow 				when: #onMouseHover do: [ self showActionsOf: aRow ];			when: #onMouseUnhover do: [ self hideActionsOf: aRow ] ];		yourself! !!RubScrolledTextMorph methodsFor: 'rulers handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36317974!rulerNamed: aKey	^self rulers detect: [ :r | r key = aKey ] ifNone: [  ]! !!RubScrolledTextMorph methodsFor: 'rulers handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36318170!withRuler: aRuler	(self hasRulerNamed: aRuler key)		ifTrue: [ ^ self ].	rulers add: aRuler.	aRuler level >= 0 ifTrue: [self addMorphBack: aRuler].	"Extra areas must be in the front "	self extraAreas do: [ :r | self addMorphFront: r ].	self manageLayout.	" Finnally, the scrollPane must be in the front of all because text must be drawn last "	self addMorphFront: self scrollPane.	aRuler level < 0 ifTrue: [ self addMorphFront: aRuler ]! !!RubScrolledTextMorph methodsFor: 'rulers handling' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36318738!hasRulerNamed: aKey	^ self rulers anySatisfy: [ :r | r key = aKey ]	! !!ComposableModel methodsFor: 'private-focus' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36318924!ensureKeyBindingsFor: aWidget	self registerKeyStrokesForNextFor: aWidget.	self registerKeyStrokesForPreviousFor: aWidget.		additionalKeyBindings associationsDo: [:association | aWidget bindKeyCombination: association key toAction: association value ]! !!ComposableModel methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36319310!gtInspectorModelNestingIn: composite	<gtInspectorPresentationOrder: 20>	composite tree 		title: 'Nesting';		display: [ :root | { 'root' -> self } ];		children: [ :each | 			each value class allInstVarNames 				collect: [ :iv | iv->(each value instVarNamed: iv) ]				thenSelect: [ :association | 					(association value isKindOf: ComposableModel) 						and: [ (#('owner' 'window') includes: association key) not ] ] ];		format: [ :association | association key , ': ' , association value asString ];		send: #value! !!ComposableModel methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36319964!instantiateModels: aCollectionOfPairs	"instantiateModels: is legacy code in ComposableModel and must not be used. It will be deprecated and removed."	"Used to instantiate multiple sub widget at once. Take aCollectionOfPairs where each odd element is an inst var name and each even element is a class name, create an instance from the class name and store it into the inst var"	(aCollectionOfPairs anySatisfy: [ :e | e isKindOf: Association ])		ifTrue: [ aCollectionOfPairs				do: [ :a | 					| k v |					k := a key.					v := a value.					self instVarNamed: k asString put: (self createInstanceFor: v) ] ]		ifFalse: [ aCollectionOfPairs				pairsDo: [ :k :v | self instVarNamed: k asString put: (self createInstanceFor: v) ] ]! !!RBRegexRefactoring methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36320814!execute: aString	"Perform all searches on aString and return the transformation."		^ matchers 		inject: aString asString		into: [ :string :assoc | self execute: string replace: assoc key with: assoc value ]! !!TableLayout methodsFor: 'nil' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36321127!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell := cellHolder key.	cells := cellHolder value.	properties wrapDirection == #none 		ifTrue:[wrap := SmallInteger maxVal]		ifFalse:[wrap := aBool ifTrue:[newBounds width] ifFalse:[newBounds height].				wrap < maxCell x ifTrue:[wrap := maxCell x]].	spacing := properties cellSpacing.	(spacing == #globalRect or:[spacing = #globalSquare]) ifTrue:[		"Globally equal spacing is a very special case here, so get out fast and easy"		^self computeGlobalCellArrangement: cells 			in: newBounds horizontal: aBool 			wrap: wrap spacing: spacing].	output := Array new writeStream.	inset := properties cellInset asPoint.	aBool ifFalse:[inset := inset transposed].	first := last := nil.	maxExtent := 0@0.	sum := 0.	index := 1.	n := 0.	hFill := vFill := false.	[index <= cells size] whileTrue:[		w := sum.		cell := cells at: index.		cellMax := maxExtent max: cell cellSize. "e.g., minSize"		(spacing == #localRect or:[spacing == #localSquare]) ifTrue:[			"Recompute entire size of current row"			spacing == #localSquare 				ifTrue:[max := cellMax x max: cellMax y]				ifFalse:[max := cellMax x].			sum := (n + 1) * max.		] ifFalse:[			sum := sum + (cell cellSize x).		].		((sum + (n * inset x)) > wrap and:[first notNil]) ifTrue:[			"It doesn't fit and we're not starting a new line"			(spacing == #localSquare or:[spacing == #localRect]) ifTrue:[				spacing == #localSquare 					ifTrue:[maxExtent := (maxExtent x max: maxExtent y) asPoint].				first do:[:c| c cellSize: maxExtent]].			w := w + ((n - 1) * inset x).			"redistribute extra space"			first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].			last := LayoutCell new.			last cellSize: w @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse:[last addExtraSpace: 0@inset y].			output nextPut: last.			first := nil.			maxExtent := 0@0.			sum := 0.			n := 0.			hFill := vFill := false.		] ifFalse:[			"It did fit; use next item from input"			first ifNil:[first := last := cell] ifNotNil:[last nextCell: cell. last := cell].			index := index+1.			n := n + 1.			maxExtent := cellMax.			hFill := hFill or:[cell hSpaceFill].			vFill := vFill or:[cell vSpaceFill].		].	].	first ifNotNil:[		last := LayoutCell new.		sum := sum + ((n - 1) * inset x).		first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].		last cellSize: sum @ maxExtent y.		last hSpaceFill: hFill.		last vSpaceFill: vFill.		last nextCell: first.		output position = 0 ifFalse:[last addExtraSpace: 0@inset y].		output nextPut: last].	output := output contents.	properties listSpacing == #equal ifTrue:[		"Make all the heights equal"		max := output inject: 0 into:[:size :c| size max: c cellSize y].		output do:[:c| c cellSize: c cellSize x @ max].	].	^output! !!MetacelloMCVersion methodsFor: 'querying' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36324691!packageAndProjectNamesToLoad: defaultList loader: aLoader	"Answer the list of packages and projects to be loaded: packages already loaded plust defaultList"		| loadedPackageNames projectMap loadedProjectNames list |	loadedPackageNames := ((self packages select: [:pkg | pkg isPackageLoaded: aLoader ]) 		collect: [:pkg | pkg name ]) asSet, 			defaultList.	projectMap := Dictionary new.	self  projects do: [:prj | 		prj className ~~ nil			ifTrue: [ | coll loaded |				coll := projectMap at: prj className ifAbsent: [					coll := OrderedCollection new.					projectMap at: prj className put: coll.					coll].				(loaded := prj loadedPackageNames: aLoader) isEmpty 					ifFalse: [  coll add: prj -> (loaded -> prj loadPackageList) ]]].	loadedProjectNames := Set new.	projectMap keysAndValuesDo: [:prjClass :coll |		coll size <= 1			ifTrue: [ coll do: [:assoc | loadedProjectNames add: assoc key name ]]			ifFalse: [ 				"multiple project references against the same configuration ... only count project as loaded				 if there is an exact match for loaded projects...				 See http://code.google.com/p/metacello/issues/detail?id=86"				coll do: [:assoc | | loaded packageList |					loaded := assoc value key. "loaded packages from project"					packageList := assoc value value. "loadlist for project"					(packageList difference: loaded) isEmpty						ifTrue: [ loadedProjectNames add: assoc key name ]]]].	list := loadedPackageNames, loadedProjectNames.	list isEmpty ifTrue: [ ^self spec defaultPackageNames].	^list! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36326365!findThePig	"tally has been updated. Look at it to see if there is a bad process.	This runs at a very high priority, so make it fast"	| countAndProcess process |	countAndProcess := tally sortedCounts first.	countAndProcess key / tally size > self threshold		ifFalse: [ ^ self ].	process := countAndProcess value.	process == Processor backgroundProcess		ifTrue: [ ^ self ].	"idle process? OK"	self catchThePig: process! !!TraitAlias methodsFor: 'enumeration' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36326901!aliasNamed: aSymbol ifAbsent: aBlock	^self aliases		detect: [:association |  association key = aSymbol]		ifNone: aBlock! !!TraitAlias methodsFor: 'enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36327130!allSelectors	^self subject allSelectors		addAll: (self aliases collect: [:each | each key]) asSet;		yourself! !!TraitAlias methodsFor: 'enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36327348!allAliasesDict	| dict |	dict := super allAliasesDict.	self aliases do: [:assoc |		dict at: assoc key put: assoc value].	^dict! !!TraitAlias methodsFor: 'enquiries' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36327585!aliasesForSelector: aSymbol	| selectors |	selectors := self aliases		select: [:association | association value = aSymbol]		thenCollect: [:association | association key].	^(super aliasesForSelector: aSymbol)		addAll: selectors;		yourself		 ! !!TraitAlias methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36327939!aliases: anArrayOfAssociations	| newNames |	newNames := (anArrayOfAssociations collect: [:each | each key]) asIdentitySet.	newNames size < anArrayOfAssociations size ifTrue: [		TraitCompositionException signal: 'Cannot use the same alias name twice'].	anArrayOfAssociations do: [:each |		(newNames includes: each value) ifTrue: [			TraitCompositionException signal: 'Cannot define an alias for an alias']].	aliases := anArrayOfAssociations! !!TraitAlias methodsFor: 'composition' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36328495!removeAlias: aSymbol	self aliases: (self aliases		reject: [:each | each key = aSymbol])! !!TraitAlias class methodsFor: 'instance creation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36328705!assertValidAliasDefinition: anArrayOfAssociations	"Throw an exceptions if the alias definition is not valid.	It is expected to be a collection of associations and	the number of arguments of the alias selector has to	be the same as the original selector."	((anArrayOfAssociations isKindOf: Collection) and: [		anArrayOfAssociations allSatisfy: [:each |			each isKindOf: Association]]) ifFalse: [		TraitCompositionException signal: 'Invalid alias definition: Not a collection of associations.'].		(anArrayOfAssociations allSatisfy: [:association |		(association key numArgs = association value numArgs and: [			(association key numArgs = -1) not])]) ifFalse: [		TraitCompositionException signal: 'Invalid alias definition: Alias and original selector have to have the same number of arguments.']! !!RxParser methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36329625!ifSpecial: aCharacter then: aBlock	"If the character is such that it defines a special node when follows a $\,	then create that node and evaluate aBlock with the node as the parameter.	Otherwise just return."	| classAndSelector |	classAndSelector := BackslashSpecials at: aCharacter ifAbsent: [^self].	^aBlock value: (classAndSelector key new perform: classAndSelector value)! !!SystemReporter methodsFor: 'operations' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36330119!add: category method: aSymbol	^self categoryList add: (self categories add: category -> aSymbol) key! !!TTLCache methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36330324!removeStaleValues	"Go over all cached values and remove those that are stale.	Remove a collection of the keys that were removed."	^ self critical: [		| keysToRemove |		keysToRemove := OrderedCollection new.		lruList do: [ :association |			 (self isStale: association) 				ifTrue: [ keysToRemove add: association key ] ].		keysToRemove do: [ :each | self removeKey: each ].		keysToRemove ]! !!TTLCache methodsFor: 'private ' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36330827!handleHit: association ifStale: block	"In case of a hit, the cached value's timestamp is check to see if its age	does not exceed the allowed timeToLive. If so, the stale value is recomputed."	| link newValue |	statistics addHit.	link := association value.	self promote: link.	(self isStale: link value)		ifTrue: [			newValue := block cull: association key.			link value value: newValue ].	^ link value value! !!Metacello class methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36331356!scriptExecutorClass: anExecutorSpec    Smalltalk at: anExecutorSpec key ifAbsent: [ ConfigurationOf ensureMetacello: anExecutorSpec value ].    ^ Smalltalk at: anExecutorSpec key! !!ZnUrl methodsFor: 'convenience' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36331650!withQuery: association	"Return a new URL equal to the receiver with the association's 	key=value added as a query parameter.	Note that #queryAt:add: is used."		^ self copy		queryAt: association key add: association value;		yourself 		! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36332009!expiredValuesDo: aBlock	"Clear all associations with nil keys"	1 to: array size do:[:i | | assoc |		assoc := array at: i.		(assoc notNil and: [ assoc key isNil and: [assoc expired not ]])		ifTrue: [ 			aBlock value: assoc value.			assoc expire.			expired := expired + 1.			tally := tally - 1.	]]! !!WeakKeyDictionary methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36332425!isHealthy	"Test that object hashes match their positions stored in the receiver,	answer true if everything ok, false otherwise		WeakKeyDictionary allInstances select: [:dict |		dict isHealthy not ]	Dictionary allSubInstances select: [:dict |		dict isHealthy not ]	"	array withIndexDo: [:elem :i |		(elem notNil and: [elem key notNil ])				ifTrue:  [(self scanFor: elem key) == i ifFalse: [ ^ false ]			]	].	^ true! !!WeakKeyDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36332978!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value 	associations)."		super associationsDo: [:association | | key | 		"Hold onto the key so it won't be collected while the block is evaluated."		key := association key.		key ifNotNil:[aBlock value: association]].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36333396!noCheckAdd: anAssociation	"Add anAssociation to the receiver. Discard expired associations. Put nil keys at the beginning."		| key |		key := anAssociation key. "Hold on to the key during this method"	anAssociation expired ifFalse:[		key ifNotNil:[			super noCheckAdd: anAssociation		] ifNil: [			1 to: array size do:[:n|				(array at: n) ifNil:[					array at: n put: anAssociation. 					tally := tally + 1.					^self				].			].			self error: 'could not find an empty slot.'		].	].! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36334007!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36334208!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			association key 				ifNil: [ finalizer ifNotNil: [ finalizer value: association value ] ]				ifNotNil: [ :key | "Don't let the key go away"					array						at: (self scanForEmptySlotFor: key)						put: association.					tally := tally + 1 ] ] ]! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36334863!postCopy	"Must copy the associations, or later store will affect both theoriginal and the copy"	array := array collect: [:assoc |				assoc 					ifNil: [nil]					ifNotNil: [						assoc expired 							ifTrue: [ WeakKeyAssociation expired]							ifFalse: [WeakKeyAssociation key: assoc key value: assoc value]]]! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36335293!scanFor: anObject	"mvl 10/21/2007: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForEmpty: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. Expired associations are ignored, since callers take non-nil slots as a successful search. Subclasses should override startIndexFor: and compare:to: if they have a different semantics for matching elements."	| element start finish |	finish := array size.	start := self startIndexFor: anObject.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [self compare: element key to: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [self compare: element key to: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36336478!scanForEmpty: anObject	"Scan the key array for the first slot containing either a nil or an expired association (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found."	| element start finish firstNil |	finish := array size.	start := self startIndexFor: anObject.	firstNil := nil.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil 						or: [self compare: element key to: anObject])			ifTrue: [				"If we found no match, and have an expired slot, use that one."				(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].				^ index 			].			"If this slot is expired, and we haven't seen an earlier expired slot, record it"			(element notNil 				and: [element expired 						and: [firstNil isNil]]) ifTrue: [firstNil := index].		].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil 					or: [self compare: element key to: anObject])			ifTrue: [				(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].				^ index 			].			(element notNil 				and: [element expired 						and: [firstNil isNil]]) ifTrue: [firstNil := index].		].	"If there is no empty slot, but an expired one, return it."		firstNil notNil ifTrue:[^firstNil].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'removing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36337982!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index result assoc |	index := self findElementOrNil: key.	assoc := array at: index.	(assoc == nil or: [assoc key isNil]) ifTrue: [ ^ aBlock value ].	assoc key: nil.	result := assoc value.	assoc expire.	expired := expired + 1.	tally := tally - 1.	^result! !!WeakKeyDictionary methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36338580!scanForKeyOrNil: anObject	"Same as scanFor: , but treats association with key == nil as empty slot"		| element start finish |	finish := array size.	start := self startIndexFor: anObject.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [ element key isNil or: [self compare: element key to: anObject]])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [ element key isNil or: [self compare: element key to: anObject]])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'enumerating' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36339366!valuesDo: aBlock 	"See comments in Dictionary>>valuesDo:.  The code keeps the key so it's	not collected during the evaluation of aBlock"	tally = 0 ifTrue: [ ^self ].	1 to: array size do:		[ :eachIndex | 			| eachAssociation eachKey |			eachAssociation := array at: eachIndex.			nil == eachAssociation ifFalse:				[					eachKey := eachAssociation key.					aBlock value: eachAssociation value				]		]! !!FFIExternalEnumeration class methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36339903!itemAt: aValue ifAbsent: exceptionBlock	self classPool		associationsDo: [ :assoc | 			aValue = assoc value value				ifTrue: [ ^ assoc key ] ].	^ exceptionBlock value! !!MCServerRegistry methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36340184!repositoryAt: urlString credentialsDo: aBlock	| possibleMatches bestMatch |	possibleMatches := registry associations select: [ :e | urlString beginsWith: e key ].	possibleMatches isEmpty ifTrue: [ ^ aBlock value: '' value: '' ].	bestMatch := possibleMatches inject: possibleMatches anyOne into: [ :last :new | 		((new key asUrl path size > last key asUrl path size) 		"this is ugly, but URL always returns a path element, even an empty one..."		or: [ last key asUrl path size = 1 and: [ last key asUrl path last isEmpty ]]) 			ifTrue: [ new ]			ifFalse: [ last ]].	^ aBlock value: bestMatch value username value: bestMatch value password.! !!RubAbstractTextArea methodsFor: 'accessing decorators' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36341001!withDecorator: aDecorator	(self hasDecoratorNamed: aDecorator key)		ifTrue: [ ^ self ].	paragraph := aDecorator next: paragraph.	self compose! !!RubAbstractTextArea methodsFor: 'accessing decorators' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36341273!withoutAnyDecorator	[ self paragraph key notNil ] whileTrue: [ self withoutDecorator: paragraph ]! !!AthensCairoGradientPaint methodsFor: 'private' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36341490!populateRamp: aRamp	aRamp do: [ :each |		self			addColorStopAt: each key			colored: each value ]	! !!AthensCairoGradientPaint methodsFor: 'initialize-release' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36341722!initializeRadialBetween: origin			extending: innerRadius			and: outerOrigin			extending: outerRadius			withColorRamp: aRamp				self initialize.			aRamp do:[:each|		self			addColorStopAt: each key			colored: each value ]	! !!KMModifiedKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36342074!Differencekey	^ self character key.! !!KMModifiedKeyCombination methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36378748!key	^ self character key.! !!KMModifiedKeyCombination methodsFor: '*Spec-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36342381!currentCharacter		^ self character key! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36342544!orderString: anIndex	^String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!GTSpotterHelp class methodsFor: 'documentation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36342881!extensionsString	| methods title |	^ String streamContents: [ :s |		((GTSpotter spotterExtendingMethods groupedBy: #methodClass) 		associations sorted: [ :a :b | a key name < b key name ]) 		do: [ :classMethodsAssociation |			s nextPutAll: classMethodsAssociation key name; cr.			methods := classMethodsAssociation value.			methods do: [ :each | 				title := each ast allChildren 					detect: [ :node | node isMessage and: [ node selector = #title: ] ]					ifFound: [ :node | node arguments first value. ]					ifNone: [ each selector ].				title isString ifFalse: [ title := each selector ].				s 					nextPutAll: '- #'; 					nextPutAll: title; 					nextPutAll: ' (in '; 					nextPutAll: each selector; 					nextPut: $);					cr ].			s cr ] ]! !!MetacelloAtomicMonticelloResource methodsFor: 'running' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36343791!setUpMonticelloRepository	"This method builds a fake repository with the version references from #buildReferences."	monticelloRepository := MCDictionaryRepository new.	versionReferences do: [ :assoc | | reference superclassName |		reference := assoc key.		superclassName := assoc value.		monticelloRepository basicStoreVersion: (MCVersion new			setPackage:  (MetacelloTestsMCPackage new name: reference packageName)			info: (MCVersionInfo				name: reference name				id: UUID new				message: 'This is a mock version'				date: Date today				time: Time now				author: reference author				ancestors: #())			snapshot: (MCSnapshot fromDefinitions: (Array				with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol))				with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: superclassName category: reference packageName asSymbol instVarNames: #() comment: '')))			dependencies: #()) ]! !!FLWeakObjectsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36344873!testAssociationWithWeak	"This tests an association with weak values. InstVar1 is a fixed instance variable, hence they are strong and hence should not be replaed by nil. Instead, 'weak' is stored in the variable part of FLWeakClassMock, so it is weak and so it should have been replaced by nil."	| weak association materializedAssociation |		weak := FLWeakClassMock new: 1.	weak instVar1: 'nonWeak'.	weak basicAt: 1 put: 'weak'. 	association := Association key: #foo value: weak.		materializedAssociation := self resultOfSerializeAndMaterialize: association.	self assert: materializedAssociation value instVar1 isNil not.	self assert: (materializedAssociation value basicAt: 1) isNil.	self assert: materializedAssociation key = #foo.	! !!FLWeakObjectsTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36345730!testAssociationWithWeakFinalizationList	"This tests an association with WeakFInalizationList as its value."	| weak association materializedAssociation object list |		object := Object new.	list := WeakFinalizationList new.	weak := WeakFinalizerItem new list: list object: object executor: nil.	association := Association key: #foo value: weak.		materializedAssociation := self resultOfSerializeAndMaterialize: association.	"Both, 'executor' and 'list' are fixed instance variables, hence they are strong and hence should not be replaced by nil. Instead, 'object' is stored in the variable part of WeakFinalizationItem, so it is weak and so it should have been replaced by nil."	self assert: materializedAssociation value executor isNil.	self assert: materializedAssociation value list isNil not.	self assert: materializedAssociation value object isNil.	self assert: materializedAssociation key = #foo.	! !!GLMCompositeBrick class methodsFor: 'examples' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36346765!gtExampleTable	<gtExample>	<label: 'Phlowr table'>		^ self new		hSpaceFill;		vSpaceFill;		with: [ :b |			b table				title: #asString;				display: [ :anObject | (anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself) addFirst: 'self' -> anObject; yourself ];				column: 'Variable'					evaluated: [:assoc |	GTObjectPrinter asNonTruncatedTextFrom: assoc key ]					styled: [ :aBrick | aBrick textPosition: #rightCenter; margin: #(0 15 0 0); textColor: Color lightGray ];				column: 'Variable'					evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ]					styled: [ :aBrick | aBrick margin: #(0 0 0 15) ];				entity: Morph new ]! !!GoferPush methodsFor: 'running' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36347560!execute	self model 		do: [ :assocation | assocation value storeVersion: assocation key version ]		displayingProgress: 'Pushing Versions'! !!Object methodsFor: 'casing-To be deprecated' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36347816!caseOf: aBlockAssociationCollection otherwise: aBlock	"DO NOT USE THIS METHOD!! It will be removed from Pharo."		"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: '*GT-Spotter' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36348817!spotterPreviewRawIn: aComposite	<spotterPreview: 40>	aComposite table		title: [ self gtDisplayString ];		display: [ :anObject | (anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself) addFirst: 'self' -> anObject; yourself ];		column: 'Variable'			evaluated: [:assoc |	GTObjectPrinter asNonTruncatedTextFrom: assoc key ]			styled: [ :aBrick | aBrick textPosition: #rightCenter; margin: #(0 15 0 0); textColor: aComposite themer textLightColor; height: 30 ];		column: 'Value'			evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ]			styled: [ :aBrick | aBrick margin: #(0 0 0 15); height: 30 ];		entity: self.			self flag: 'move "entity: self" somewhere else, maybe'! !!Object methodsFor: '*GT-Inspector' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36349655!gtInspectorVariableValuePairs	"This is a helper method that returns a collection of 		variable_name -> value	for the current object.	Subclasses can override it to specialize what appears in the variables presentation"	| bindings |	bindings := OrderedCollection new.	self gtInspectorVariableNodesIn: bindings.	^ bindings collect: [ :aNode | aNode key -> aNode value ]! !!FuzzyMatcherTests methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36350139!testClassSideAPI	"if the protocol is changed, so should the class comment"	FuzzyMatcher class protocols detect: [ :p | p = #'utilities api' ].		self 			assert: (FuzzyMatcher allMatching: #a in: #(a b ab))		equals: #(a ab);			assert: (FuzzyMatcher allMatching: #a in: { #a -> 1 . #b -> 2 . #acb -> 3 } by: [:each | each key ])		equals: { #a -> 1 . #acb -> 3 };				assert: (FuzzyMatcher allSortedByScoreMatching: #b in: { #aaca .#aAaaB . #Aaab . #baaa . #aaba })		equals: #(baaa aaba Aaab aAaaB) 			! !!FLGlobalSendCluster methodsFor: 'serialize/materialize' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36350779!serializeInstance: anObject with: anEncoder		| globalSend |	globalSend := globalSends at: anObject.		self serializeGlobalAssociationKeyed: globalSend key on: anEncoder.	anEncoder encodeString: globalSend value.! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36351123!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #namedTempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ MessageAsTempNode new		receiver: receiver		selector: #namedTempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !!Parser methodsFor: 'error correction' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36351624!queryUndefined	| varStart varName | 	varName := parseNode key.	varStart := self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	(UndefinedVariable name: varName) ifFalse: [^ self fail]! !!DADependencyReport methodsFor: 'converting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36352006!newReportScopedOn: aPackageName withoutDependencies: aListOfPackageNameToIgnore	"Generates a new dependency report discarding 	- all packages that are not present in aPackageName transitive dependencies	- all packages in aListOfPackageNameToIgnore"	| report dependenciesToInclude |	report := self class new.	report		imageVersion: imageVersion; 		analysisRunString: analysisRunString , ' scoped on ' , aPackageName.	dependenciesToInclude := self transitiveDependenciesOf: aPackageName withoutDependenciesOf: aListOfPackageNameToIgnore.	warnings 		select: [:warning | dependenciesToInclude includes: warning package ]		thenDo: [:warning | report addWarning: warning ].	dependencies associationsDo: [ :assoc |		((dependenciesToInclude includes: assoc key) 		and: [ (aListOfPackageNameToIgnore includes: assoc key) not ])			ifTrue: [ report 							add: assoc key 							dependencies: assoc value ] ].	^ report! !!DADependencyReport methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36353065!knownDependantsOf: aPackageName	^ dependencies associations 		select: [ :association | association value includes: aPackageName ]		thenCollect: #key! !!FBDDecompiler methodsFor: 'data flow instructions' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36353339!storeIntoLiteralVariable: association	simulatedStack addLast: (builder codeAssignment: simulatedStack removeLast to: (builder codeVariable: association key))! !!LinkedListTest methodsFor: 'tests - fixture' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36353614!test0FixtureSetAritmeticTest	self collection.	self deny: self collection isEmpty.	self nonEmpty.	self deny: self nonEmpty isEmpty.	self anotherElementOrAssociationNotIn.	self collection isDictionary		ifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]		ifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].	self collectionClass! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36354172!absentInitializers	^ initializers reject: [ :each | Smalltalk hasClassNamed: each key ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36354389!writePresentInitializers	| orderedClasses presentInitializers |	presentInitializers := self presentInitializers.	orderedClasses := (Class		superclassOrder: (presentInitializers collect: [ :each | Smalltalk classOrTraitNamed: each key ]))		collect: [ :each | each name ].	orderedClasses		do: [ :className | stream nextPutAll: (presentInitializers detect: [ :each | each key = className ]) value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'writing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36354939!writeAbsentInitializers	(self absentInitializers asSortedCollection: [ :a :b | a key <= b key ])		do: [ :association | stream nextPutAll: association value contents ]! !!MCFileTreePackageStructureStWriter methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36355248!presentInitializers	^ initializers select: [ :each | Smalltalk hasClassNamed: each key ]! !!OCLiteralVariable methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36355449!isFromSharedPool	| sharedPools |	sharedPools := scope getClass baseClass sharedPools.	^ sharedPools 		detect: [ :pool | pool classVarNames includes: assoc key ]		ifFound: [ true ]		ifNone: [ false ]! !!OCLiteralVariable methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36355765!isGlobalClassNameBinding	^ (self value isClass or: [ self value isTrait ])		and: [ self variable key == self value name ]! !!RFReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36356011!for: aSelector	^ self subclasses detect: [ :class | class key = aSelector ]! !!RFReification class methodsFor: 'plugin interface' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36356210!allKeys	^self subclasses collect: [:plugin | plugin key]! !!InterpolatedGradientFillStyle methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36356403!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver."		| bits ramp lastColor lastIndex lastWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := self pixelWord32Of: lastColor .	lastIndex := 0.	ramp do:[:assoc| | distance nextColor theta nextWord nextIndex step |		nextIndex := (assoc key * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWord32.		distance := nextIndex - lastIndex.		distance = 0 ifTrue: [distance := 1].		step := 1.0 / distance.		theta := 0.0.		lastIndex+1 to: nextIndex do: [:i|			theta := theta + step.			bits at: i put: (self interpolatedAlphaMix: theta of: lastWord and: nextWord)].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord].	lastIndex+1 to: length do: [:i| bits at: i put: lastWord].	^bits! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36357435!fixObsoleteBindings	CompiledMethod allInstances do: [ :method |		| obsoleteBindings |		obsoleteBindings := method literals select: [ :literal |				literal isVariableBinding and: [					literal value isBehavior and: [ 						literal value isObsolete ] ] ].		obsoleteBindings do: [ :binding |			| obsName realName realClass |			obsName := binding value name.			self 				trace: 'Binding: ';				traceCr: obsName.			realName := obsName copyReplaceAll: 'AnObsolete' with: ''.			realClass := Smalltalk globals at: realName asSymbol ifAbsent: [ UndefinedObject ].			binding key: binding key value: realClass ].		"do not forget to flush the JIT cache"		obsoleteBindings ifNotEmpty: [ method flushCache ] ]! !!SmalltalkImage methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36358276!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 0>	composite table		title: 'Details';		display: [ 			{ 				'Image directory' -> self imageDirectory asFileReference.				'Image format version' -> self imageFormatVersion.				'License' -> self licenseString.				'VM directory' -> self vmDirectory asFileReference.				'VM version' -> self version			} ];		column: 'Property' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36358858!keysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding			ifTrue: [aBlock value: propertyOrPragma key value: propertyOrPragma value]			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !!AdditionalMethodState methodsFor: 'properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36359349!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma key == aKey]) ifTrue:			[^propertyOrPragma value]].	^aBlock value! !!AdditionalMethodState methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36359863!includesKey: aKey	"Test if the property aKey or pragma with selector aKey is present."	1 to: self basicSize do:		[:i |		(self basicAt: i) key == aKey ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36360164!at: aKey put: aValue       "Replace the property value or pragma associated with aKey."       | keyAlreadyExists |       keyAlreadyExists := false.       1 to: self basicSize do:               [:i |               | propertyOrPragma "<Association|Pragma>" |               (propertyOrPragma := self basicAt: i) key == aKey ifTrue: [                       keyAlreadyExists := true.                       propertyOrPragma isVariableBinding                               ifTrue: [propertyOrPragma value: aValue]                               ifFalse: [self basicAt: i put: aValue]]].       keyAlreadyExists ifFalse: [               method propertyAt: aKey put: aValue ].       ^ aValue! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36360980!at: aKey ifAbsentPut: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^method propertyAt: aKey put: aBlock value! !!AdditionalMethodState methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36361548!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [(aBlock value: propertyOrPragma key)					or: [(aBlock value: propertyOrPragma value)					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36362339!hasLiteralThorough: literal	"Answer true if any literal in these properties is literal,	 even if embedded in array structure."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [propertyOrPragma key == literal					or: [propertyOrPragma value == literal					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteral: literal]]]]			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36363010!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[aBlock value: propertyOrPragma key value: propertyOrPragma value]]! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36363431!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma key]				ifFalse: [propertyOrPragma keyword])			== aKey ifTrue:			[^method removeProperty: aKey]].	^aBlock value! !!AdditionalMethodState methodsFor: 'properties' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36364001!includesProperty: aKey	"Test if the property aKey is present."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma key == aKey]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36364407!properties	| propertyStream |	propertyStream := WriteStream on: (Array new: self basicSize * 2).	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[propertyStream nextPut: propertyOrPragma key; nextPut: propertyOrPragma value]].	^IdentityDictionary newFromPairs: propertyStream contents! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36364912!at: aKey ifAbsent: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^aBlock value! !!LiteralNode methodsFor: 'printing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36365439!printOn: aStream indent: level	key isVariableBinding		ifTrue:			[key key 				ifNil:					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]				ifNotNil:					[aStream nextPutAll: '##'; nextPutAll: key key]]		ifFalse:			[key storeOn: aStream]! !!PharoBootstrapRule methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36365831!collectionsPackages	^ (CollectionsAssembly parts collect: #key)		reject: [ :each | each = #'Collections-Atomic' ]! !!AssociationTest methodsFor: 'tests' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36366054!testEquality		self 		assert: (a key = b key);		deny: (a value = b value);		deny: (a = b)! !!MethodOveridesAction methodsFor: 'order' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36366272!privateActionIcon	"Return the icon for this action"	isOverride		ifTrue: [ 			isOverridden				ifTrue: [					result := self buildUpAndDownArrowIcon: method.					^ result key ]				ifFalse: [ 					^ IconicButton new						target: self browser;						actionSelector: #arrowUp:;						arguments: {method};						labelGraphic: (self iconNamed: #arrowUpIcon);						color: Color transparent;						helpText: 'Browse overriden message';						extent: self iconExtent;						borderWidth: 0 ] ]		ifFalse: [ 			isOverridden				ifTrue: [ 					^ IconicButton new						target: self browser;						actionSelector: #arrowDown:;						arguments: {method};						labelGraphic: (self iconNamed: #arrowDownIcon);						color: Color transparent;						helpText: 'Browse overriding messages';						extent: self iconExtent;						borderWidth: 0 ] ]! !!UnlimitedInstanceVariableSlot methodsFor: 'class building' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36367243!calculateOffset: aClass	| ivarSlots  calculatedOffset |	"first we get all boolean slots and sort them by index"	ivarSlots := aClass allSlots select: [ :each | each isKindOf: self class ].	ivarSlots := ivarSlots select: [ :each | each offset isNotNil ].	ivarSlots sort: [ :a :b | a offset < b offset ]. 	ivarSlots ifEmpty: [ ^1 ]. "we are the first one!!"	"now we find the first spot where the next offset is not yet taken"	calculatedOffset := (ivarSlots withIndexCollect: [ :each :myIndex | myIndex ->each offset ]) 		findFirst: [ :each | each key ~= each value ].	calculatedOffset = 0  "no hole found: use the next index after the last slot"		ifTrue: [ ^ ivarSlots last offset + 1].	^calculatedOffset	! !!GTInspectorHelp class methodsFor: 'documentation' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36368081!extensionsString	| methods title |	^ String streamContents: [ :s |		((GTInspector inspectorExtendingMethods groupedBy: #methodClass)		associations sorted: [ :a :b | a key name < b key name ]) 		do: [ :classMethodsAssociation |			s nextPutAll: classMethodsAssociation key name; cr.			methods := classMethodsAssociation value.			methods do: [ :each | 				title := each ast allChildren 					detect: [ :node | node isMessage and: [ node selector = #title: ] ]					ifFound: [ :node | node arguments first value. ]					ifNone: [ each selector ].				title isString ifFalse: [ title := each selector ].				s 					nextPutAll: '- '; 					nextPutAll: title; 					nextPutAll: ' ('; 					nextPutAll: each selector; 					nextPut: $);					cr ].			s cr ] ]! !!Morph methodsFor: '*SUnit-UITesting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36368971!simulateClickWith: buttons	"Did you know there's #simulateClick (left), #simulateMiddleClick, and #simulateRightClick?	buttons - look at MouseEvent's class-side for button types"	| noButtons |	noButtons := 0.	{ #mouseDown->buttons. #mouseUp->noButtons } do: [ :type |		self activeHand handleEvent: (MouseButtonEvent new 			setType: type key			position: (self pointInWorld: self center) "Some Morphs report local coords"			which: (noButtons bitXor: buttons)			buttons: type value			hand: self activeHand			stamp: Time millisecondClockValue) ].! !!Morph methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36369647!gtInspectorMorphExtensionIn: composite	<gtInspectorPresentationOrder: 15>		^ composite table		title: 'Extension';		showOnly: 50; 		display: [ self extension gtInspectorVariableValuePairs asSortedCollection ];		when: [ extension notNil ];		column: 'Variable' 			evaluated: [:assoc | GTObjectPrinter asNonTruncatedTextFrom: assoc key ];		column: 'Value' 			evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ];		send: #value;		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse';		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect';		selectionAct: [:list | 			((list selection pointersToExcept: { list selection })									reject: [ :each | each pointsOnlyWeaklyTo: list selection ]) inspect ] 			on: $t			entitled: 'Open pointers to'! !!Morph methodsFor: '*SUnit-UITesting' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36370708!simulateClickWith: buttons position: position	"Did you know there's #simulateClick (left), #simulateMiddleClick, and #simulateRightClick?	buttons - look at MouseEvent's class-side for button types"	| noButtons hand |	noButtons := 0.	hand := HandMorph new mouseFocus: self; yourself.	hand privateOwner: self.	{ #mouseDown->buttons. #mouseUp->noButtons } do: [ :type |		hand handleEvent: (MouseButtonEvent new 			setType: type key			position: position "Some Morphs report local coords"			which: (noButtons bitXor: buttons)			buttons: type value			hand: hand			stamp: Time millisecondClockValue) ].! !!ScriptLoader methodsFor: 'ci' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36371420!newGenerateNewUpdateMethodSilentlyConfigurations: configurations preLoad: preload postLoad: postLoad	"ScriptLoader new newGenerateNewUpdateMethod"		| stream methodName preamble postscript |	stream := ReadWriteStream on: (String new: 1000).	methodName := 'update', self currentUpdateVersionNumber asString.	stream 		<< methodName << String cr		<< Character tab << '"self new ' << methodName << '"' << String cr		<< Character tab .			preamble := self decodeFromPrint: (preload reset contents asString).	preamble isEmptyOrNil 		ifFalse: [ stream nextPutAll: preamble; ensureEndsWith: $.; crtab ].	stream 		<< 'self withUpdateLog: ''' << self commentForCurrentUpdate << '''.' << String cr		<< Character tab << 'self loadTogether: self script' << self currentScriptVersionNumber asString << ' merge: false.' << String cr		<< Character tab.			configurations 		do: [ :each | stream << 'self loadConfiguration: ''' << each key << ''' version: ' << each value printString << '.' ]		separatedBy: [ stream cr ].			postscript := self decodeFromPrint: (postLoad reset contents asString). 	postscript isEmptyOrNil 		ifFalse: [ stream nextPutAll: postscript; ensureEndsWith: $.; crtab ].		stream << 'self flushCaches.' << String cr.		^ stream contents! !!KMDispatcher methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36372815!gtInspectorMappingsIn: composite	<gtInspectorPresentationOrder: 40>	composite table 		title: 'Keys';		display: [ 			self gtAllKeyCategoryPairs ];		filterOn: [ :text :each | each gtDisplayString includesSubstring: text caseSensitive: false ];		column: 'Shortcut' evaluated: [ :assoc | assoc key shortcut gtDisplayString ] width: 120;		column: 'Action' evaluated: [ :assoc | assoc key action gtDisplayString ];		column: 'Description' evaluated: [ :assoc | assoc key description ];		column: 'Category' evaluated: [ :assoc | '' ] tags: [ :assoc | assoc value name ifNil: [ #() ] ifNotNil: [ { assoc value name }]];		send: #key! !!KMDispatcher methodsFor: '*GT-SpotterExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36373604!spotterForKeysFor: aStep	<spotterOrder: 15>			aStep listProcessor			title: 'Keys';			allCandidates: [ (self gtAllKeyCategoryPairs collect: #key) asOrderedCollection ];			itemName: [ :aKeymap | 				aKeymap shortcut gtDisplayString, 				(aKeymap name ifNil: [ '' ] ifNotNil: [ ' [', aKeymap name,']' ]) ];			candidatesLimit: 5;			filter: GTFilterSubstrings! !!FuzzyMatcher class methodsFor: 'utilities api' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36374087!allSortedByScoreMatching: aPattern in: aCollection by: aBlockReturningString	| matcher matches |		aPattern isEmpty ifTrue: [ ^ aCollection asArray ].		matcher := self pattern: aPattern.	matches := OrderedCollection new: aCollection size // 2.		aCollection do: [ :each | 		matcher 			match: (aBlockReturningString value: each) 			ifScored: [ :score | matches add: score -> each ] 	].		matches sort: [ :a :b | a key >= b key ].		^ matches collect: [ :each | each value ] as: Array	! !!Duration methodsFor: '*GT-InspectorExtensions-Core' stamp: 'EncinasJavier 11/17/2017 19:45' prior: 36374718!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'days' -> self days.					'hours' -> self hours.					'minutes' -> self minutes.					'seconds' -> self seconds .					'nanoseconds' -> self nanoSeconds } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !GTSpotterHelp class removeSelector: #Differencekey!GTInspectorSelfNode removeSelector: #Differencekey!GTPlaygroundHelp class removeSelector: #Differencekey!RFThisContextReification class removeSelector: #Differencekey!RubShoutStylerDecorator class removeSelector: #Differencekey!KMModifiedKeyCombination removeSelector: #Differencekey!GLMHighlighterTextStylerDecorator class removeSelector: #Differencekey!RubExtraSelectionDecorator class removeSelector: #Differencekey!CustomHelp class removeSelector: #Differencekey!RubLineNumberDisplayer class removeSelector: #Differencekey!WeakKeyAssociation removeSelector: #Differencekey!GTInspectorDynamicNode removeSelector: #Differencekey!NautilusAnnotationDisplayer class removeSelector: #Differencekey!GTInspectorContextNamedTempNode removeSelector: #Differencekey!RFSelectorReification class removeSelector: #Differencekey!RubParagraphDecorator removeSelector: #Differencekey!LeafNode removeSelector: #Differencekey!RFEReceiverReification class removeSelector: #Differencekey!RubParagraph class removeSelector: #Differencekey!HelpTopic removeSelector: #Differencekey!RFArgumentsReification class removeSelector: #Differencekey!LookupKey removeSelector: #Differencekey!ShiftCipher removeSelector: #Differencekey!RubCommentAnnotationDisplayer class removeSelector: #Differencekey!KMSingleKeyCombination removeSelector: #Differencekey!NautilusKeyPressed removeSelector: #Differencekey!GTInspectorIndexedNode removeSelector: #Differencekey!GTInspectorSlotNode removeSelector: #Differencekey!GTInspectorProtoObjectNode removeSelector: #Differencekey!RFEntityReification class removeSelector: #Differencekey!HelpOnHelp class removeSelector: #Differencekey!RubColumnDisplayer class removeSelector: #Differencekey!RubCurrentLineBarDecorator class removeSelector: #Differencekey!KeyNotFound removeSelector: #Differencekey!RubGhostTextDisplayer class removeSelector: #Differencekey!RubScrolledTextExtra class removeSelector: #Differencekey!RubParagraph removeSelector: #Differencekey!RFVariableReification class removeSelector: #Differencekey!KMKeymap removeSelector: #Differencekey!RubAdornmentDisplayer class removeSelector: #Differencekey!RubCodeSizeFeedback class removeSelector: #Differencekey!RFObjectReification class removeSelector: #Differencekey!RFClassReification class removeSelector: #Differencekey!GTDebuggerHelp class removeSelector: #Differencekey!RubWorkspaceBar class removeSelector: #Differencekey!RFReification class removeSelector: #Differencekey!RFNameReification class removeSelector: #Differencekey!RFValueReification class removeSelector: #Differencekey!GTInspectorHelp class removeSelector: #Differencekey!GTInspectorVariableNode removeSelector: #Differencekey!RubTextSegmentIconBox class removeSelector: #Differencekey!RubParagraphDecorator class removeSelector: #Differencekey!RubOpeningClosingDelimiterDecorator class removeSelector: #Differencekey!Pragma removeSelector: #Differencekey!RFNodeReification class removeSelector: #Differencekey!RFNewValueReification class removeSelector: #Differencekey!KeyboardEvent removeSelector: #Differencekey!RFSenderReification class removeSelector: #Differencekey!RubAnnotationDisplayer class removeSelector: #Differencekey!GTInspectorWrapperNode removeSelector: #Differencekey!RFLinkReification class removeSelector: #Differencekey!SpecHelpTopics class removeSelector: #Differencekey!RubScrolledTextExtra removeSelector: #Differencekey!RubTextSegmentIconDisplayer class removeSelector: #Differencekey!Object subclass: #ShiftCipher	instanceVariableNames: 'alphabetKey alphabet'	classVariableNames: ''	package: 'OBJ1'!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:49'!alphabetKey	^ alphabetKey! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:49'!alphabetKey: anObject	alphabetKey := anObject! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:50' prior: 36380876!key	^ alphabet findString: self alphabetKey asString.! !ShiftCipher removeSelector: #key:!!ShiftCipher class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:51' prior: 36003071!key: aKey alphabet: anAlphabet	^self new alphabetKey: aKey; alphabet: anAlphabet;yourself.! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:52' prior: 36006073!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith: 			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:53' prior: 36742184!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineCipherIndexWith: 			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:53' prior: 36742451!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith: 			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:53' prior: 36003380!alphabet: anObject	alphabet := anObject! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 19:53' prior: 36003648!alphabet	^ alphabet! !ShiftCipher subclass: #BasicShiftCipher	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!BasicShiftCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:55'!initialize	self alphabet: 'abcdefghijklmnopqrstu'.	 ! !!BasicShiftCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 19:55'!alphabetKey: aKey	alphabetKey:= aKey! !!BasicShiftCipher class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:04'!withKey: aKey	^self new alphabetKey: aKey; yourself.! !----SNAPSHOT----2017-11-17T20:04:21.948441-03:00 Pharo6.1.image priorSource: 2450290!ShiftCipher subclass: #CesarCipher	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!CesarCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:07'!initialize	alphabetKey:= 'd'.	alphabet:= 'abcdefghijklmnopqrstuvwxyz'.  ! !TestCase subclass: #BasicShiftCipherTest	instanceVariableNames: 'cesarCipher nullCipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:50'!testCipherDecipherCesar	self should: [ (cesarCipher decipherMessage: (cesarCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:51'!nullCipher"Return a new instance of BasicShiftCipher created with parameter $a "	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 11/2/2017 11:38'!testMissingCharacter	self should: [ (nullCipher cipherMessage: 'WIK1PEDIA') = 'WIK1PEDIA' ].	self should: [ (nullCipher decipherMessage: (nullCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/13/2017 16:15'!testCipherCharactersCesar	self should: [ (cesarCipher cipherMessage: 'X') = 'A' ].	self should: [ (cesarCipher cipherMessage: 'A') = 'D' ].	self should: [ (cesarCipher cipherMessage: 'W') = 'Z' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:26'!cesarCipher"Return a new instance of Basic Shift Cipher with parameter $D"	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:24'!setUp		cesarCipher := self cesarCipher.	nullCipher := self nullCipher	! !TestCase subclass: #CesarCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/17/2017 14:50'!testCipherDecipher	self should: [ (cipher decipherMessage: (cipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15'!testCipher	self should: [ (cipher cipherMessage: 'WIKIPEDIA') = 'ZLNLSHGLD' ].! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15'!testCipherCharacters	self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57'!setUp		cipher := self cesarCipher	! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57'!cesarCipher"Return a new instance of Cesar Cipher"	! !PackageManifest subclass: #ManifestCipherTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ManifestCipherTesting commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestCipherTesting class	instanceVariableNames: ''!!ManifestCipherTesting class methodsFor: 'code-critics' stamp: 'federicobalaguer 5/21/2017 23:10'!ruleShouldTransformedIntoAssertV1FalsePositive	^ #(#(#(#RGClassDefinition #(#ShiftCipherTest)) #'2017-05-16T09:53:27.250403-03:00') #(#(#RGClassDefinition #(#VigenereTest)) #'2017-05-21T23:10:56.960136-03:00') )! !TestCase subclass: #ShiftCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:18'!testCesarEdge			self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:19'!testDecipherCesar		self should: [ (cipher decipherMessage: 'A') = 'X' ].	self should: [ (cipher decipherMessage: 'D') = 'A' ].	self should: [ (cipher decipherMessage: 'Z') = 'W' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/7/2017 07:21'!cesarCipherWithShortAlphabet"Return a new instance of Basic Shift Cipher with parameter $D and alphabet:  ' O P Q R S T U V W X Y Z A B C D E F G H I J K L M N'  "		! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/2/2017 16:35'!setUp		cipher := self cesarCipherWithShortAlphabet.		! !----End fileIn----!TestCase subclass: #BasicShiftCipherTest	instanceVariableNames: 'cesarCipher nullCipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:50' prior: 36744332!testCipherDecipherCesar	self should: [ (cesarCipher decipherMessage: (cesarCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:51' prior: 36744563!nullCipher"Return a new instance of BasicShiftCipher created with parameter $a "	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 11/2/2017 11:38' prior: 36744748!testMissingCharacter	self should: [ (nullCipher cipherMessage: 'WIK1PEDIA') = 'WIK1PEDIA' ].	self should: [ (nullCipher decipherMessage: (nullCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36745047!testCipherCharactersCesar	self should: [ (cesarCipher cipherMessage: 'X') = 'A' ].	self should: [ (cesarCipher cipherMessage: 'A') = 'D' ].	self should: [ (cesarCipher cipherMessage: 'W') = 'Z' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:26' prior: 36745348!cesarCipher"Return a new instance of Basic Shift Cipher with parameter $D"	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:24' prior: 36745527!setUp		cesarCipher := self cesarCipher.	nullCipher := self nullCipher	! !TestCase subclass: #CesarCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/17/2017 14:50' prior: 36745845!testCipherDecipher	self should: [ (cipher decipherMessage: (cipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36746044!testCipher	self should: [ (cipher cipherMessage: 'WIKIPEDIA') = 'ZLNLSHGLD' ].! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36746211!testCipherCharacters	self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57' prior: 36746475!setUp		cipher := self cesarCipher	! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57' prior: 36746598!cesarCipher"Return a new instance of Cesar Cipher"	! !PackageManifest subclass: #ManifestCipherTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestCipherTesting class	instanceVariableNames: ''!!ManifestCipherTesting class methodsFor: 'code-critics' stamp: 'federicobalaguer 5/21/2017 23:10' prior: 36747232!ruleShouldTransformedIntoAssertV1FalsePositive	^ #(#(#(#RGClassDefinition #(#ShiftCipherTest)) #'2017-05-16T09:53:27.250403-03:00') #(#(#RGClassDefinition #(#VigenereTest)) #'2017-05-21T23:10:56.960136-03:00') )! !TestCase subclass: #ShiftCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:18' prior: 36747686!testCesarEdge			self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:19' prior: 36747947!testDecipherCesar		self should: [ (cipher decipherMessage: 'A') = 'X' ].	self should: [ (cipher decipherMessage: 'D') = 'A' ].	self should: [ (cipher decipherMessage: 'Z') = 'W' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/7/2017 07:21' prior: 36748215!cesarCipherWithShortAlphabet"Return a new instance of Basic Shift Cipher with parameter $D and alphabet:  ' O P Q R S T U V W X Y Z A B C D E F G H I J K L M N'  "		! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/2/2017 16:35' prior: 36748467!setUp		cipher := self cesarCipherWithShortAlphabet.		! !----End fileIn----!TestCase subclass: #BasicShiftCipherTest	instanceVariableNames: 'cesarCipher nullCipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:50' prior: 36748843!testCipherDecipherCesar	self should: [ (cesarCipher decipherMessage: (cesarCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:51' prior: 36749090!nullCipher"Return a new instance of BasicShiftCipher created with parameter $a "	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 11/2/2017 11:38' prior: 36749291!testMissingCharacter	self should: [ (nullCipher cipherMessage: 'WIK1PEDIA') = 'WIK1PEDIA' ].	self should: [ (nullCipher decipherMessage: (nullCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36749606!testCipherCharactersCesar	self should: [ (cesarCipher cipherMessage: 'X') = 'A' ].	self should: [ (cesarCipher cipherMessage: 'A') = 'D' ].	self should: [ (cesarCipher cipherMessage: 'W') = 'Z' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:26' prior: 36749923!cesarCipher"Return a new instance of Basic Shift Cipher with parameter $D"	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:24' prior: 36750118!setUp		cesarCipher := self cesarCipher.	nullCipher := self nullCipher	! !TestCase subclass: #CesarCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/17/2017 14:50' prior: 36750452!testCipherDecipher	self should: [ (cipher decipherMessage: (cipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36750667!testCipher	self should: [ (cipher cipherMessage: 'WIKIPEDIA') = 'ZLNLSHGLD' ].! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36750850!testCipherCharacters	self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57' prior: 36751130!setUp		cipher := self cesarCipher	! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57' prior: 36751269!cesarCipher"Return a new instance of Cesar Cipher"	! !PackageManifest subclass: #ManifestCipherTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestCipherTesting class	instanceVariableNames: ''!!ManifestCipherTesting class methodsFor: 'code-critics' stamp: 'federicobalaguer 5/21/2017 23:10' prior: 36751720!ruleShouldTransformedIntoAssertV1FalsePositive	^ #(#(#(#RGClassDefinition #(#ShiftCipherTest)) #'2017-05-16T09:53:27.250403-03:00') #(#(#RGClassDefinition #(#VigenereTest)) #'2017-05-21T23:10:56.960136-03:00') )! !TestCase subclass: #ShiftCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:18' prior: 36752190!testCesarEdge			self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:19' prior: 36752467!testDecipherCesar		self should: [ (cipher decipherMessage: 'A') = 'X' ].	self should: [ (cipher decipherMessage: 'D') = 'A' ].	self should: [ (cipher decipherMessage: 'Z') = 'W' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/7/2017 07:21' prior: 36752751!cesarCipherWithShortAlphabet"Return a new instance of Basic Shift Cipher with parameter $D and alphabet:  ' O P Q R S T U V W X Y Z A B C D E F G H I J K L M N'  "		! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/2/2017 16:35' prior: 36753019!setUp		cipher := self cesarCipherWithShortAlphabet.		! !----End fileIn----!!CesarCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:12' prior: 36743976!initialize	alphabetKey:= 'd'.	alphabet:= 'abcdefghijklmnopqrstuvwxyz' asUppercase.  ! !!BasicShiftCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:12' prior: 36743348!initialize	self alphabet: 'abcdefghijklmnopqrstu' asUppercase.	 ! !TestCase subclass: #BasicShiftCipherTest	instanceVariableNames: 'cesarCipher nullCipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:50'!testCipherDecipherCesar	self should: [ (cesarCipher decipherMessage: (cesarCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:51'!nullCipher"Return a new instance of BasicShiftCipher created with parameter $a "	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 11/2/2017 11:38'!testMissingCharacter	self should: [ (nullCipher cipherMessage: 'WIK1PEDIA') = 'WIK1PEDIA' ].	self should: [ (nullCipher decipherMessage: (nullCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/13/2017 16:15'!testCipherCharactersCesar	self should: [ (cesarCipher cipherMessage: 'X') = 'A' ].	self should: [ (cesarCipher cipherMessage: 'A') = 'D' ].	self should: [ (cesarCipher cipherMessage: 'W') = 'Z' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:26'!cesarCipher"Return a new instance of Basic Shift Cipher with parameter $D"	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:24'!setUp		cesarCipher := self cesarCipher.	nullCipher := self nullCipher	! !TestCase subclass: #CesarCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/17/2017 14:50'!testCipherDecipher	self should: [ (cipher decipherMessage: (cipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15'!testCipher	self should: [ (cipher cipherMessage: 'WIKIPEDIA') = 'ZLNLSHGLD' ].! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15'!testCipherCharacters	self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57'!setUp		cipher := self cesarCipher	! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57'!cesarCipher"Return a new instance of Cesar Cipher"	! !PackageManifest subclass: #ManifestCipherTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ManifestCipherTesting commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestCipherTesting class	instanceVariableNames: ''!!ManifestCipherTesting class methodsFor: 'code-critics' stamp: 'federicobalaguer 5/21/2017 23:10'!ruleShouldTransformedIntoAssertV1FalsePositive	^ #(#(#(#RGClassDefinition #(#ShiftCipherTest)) #'2017-05-16T09:53:27.250403-03:00') #(#(#RGClassDefinition #(#VigenereTest)) #'2017-05-21T23:10:56.960136-03:00') )! !TestCase subclass: #ShiftCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:18'!testCesarEdge			self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:19'!testDecipherCesar		self should: [ (cipher decipherMessage: 'A') = 'X' ].	self should: [ (cipher decipherMessage: 'D') = 'A' ].	self should: [ (cipher decipherMessage: 'Z') = 'W' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/7/2017 07:21'!cesarCipherWithShortAlphabet"Return a new instance of Basic Shift Cipher with parameter $D and alphabet:  ' O P Q R S T U V W X Y Z A B C D E F G H I J K L M N'  "		! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/2/2017 16:35'!setUp		cipher := self cesarCipherWithShortAlphabet.		! !----End fileIn----!TestCase subclass: #BasicShiftCipherTest	instanceVariableNames: 'cesarCipher nullCipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:50' prior: 36758294!testCipherDecipherCesar	self should: [ (cesarCipher decipherMessage: (cesarCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/17/2017 14:51' prior: 36758525!nullCipher"Return a new instance of BasicShiftCipher created with parameter $a "	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 11/2/2017 11:38' prior: 36758710!testMissingCharacter	self should: [ (nullCipher cipherMessage: 'WIK1PEDIA') = 'WIK1PEDIA' ].	self should: [ (nullCipher decipherMessage: (nullCipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36759009!testCipherCharactersCesar	self should: [ (cesarCipher cipherMessage: 'X') = 'A' ].	self should: [ (cesarCipher cipherMessage: 'A') = 'D' ].	self should: [ (cesarCipher cipherMessage: 'W') = 'Z' ]! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:26' prior: 36759310!cesarCipher"Return a new instance of Basic Shift Cipher with parameter $D"	! !!BasicShiftCipherTest methodsFor: 'as yet unclassified' stamp: 'federicobalaguer 10/2/2017 16:24' prior: 36759489!setUp		cesarCipher := self cesarCipher.	nullCipher := self nullCipher	! !TestCase subclass: #CesarCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/17/2017 14:50' prior: 36759807!testCipherDecipher	self should: [ (cipher decipherMessage: (cipher cipherMessage: 'WIKIPEDIA')) = 'WIKIPEDIA' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36760006!testCipher	self should: [ (cipher cipherMessage: 'WIKIPEDIA') = 'ZLNLSHGLD' ].! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 10/13/2017 16:15' prior: 36760173!testCipherCharacters	self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ]! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57' prior: 36760437!setUp		cipher := self cesarCipher	! !!CesarCipherTest methodsFor: 'testing' stamp: 'federicobalaguer 9/25/2017 10:57' prior: 36760560!cesarCipher"Return a new instance of Cesar Cipher"	! !PackageManifest subclass: #ManifestCipherTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestCipherTesting class	instanceVariableNames: ''!!ManifestCipherTesting class methodsFor: 'code-critics' stamp: 'federicobalaguer 5/21/2017 23:10' prior: 36761194!ruleShouldTransformedIntoAssertV1FalsePositive	^ #(#(#(#RGClassDefinition #(#ShiftCipherTest)) #'2017-05-16T09:53:27.250403-03:00') #(#(#RGClassDefinition #(#VigenereTest)) #'2017-05-21T23:10:56.960136-03:00') )! !TestCase subclass: #ShiftCipherTest	instanceVariableNames: 'cipher'	classVariableNames: ''	poolDictionaries: ''	category: 'Cipher-SubstitutionTesting'!!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:18' prior: 36761648!testCesarEdge			self should: [ (cipher cipherMessage: 'X') = 'A' ].	self should: [ (cipher cipherMessage: 'A') = 'D' ].	self should: [ (cipher cipherMessage: 'W') = 'Z' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/13/2017 16:19' prior: 36761909!testDecipherCesar		self should: [ (cipher decipherMessage: 'A') = 'X' ].	self should: [ (cipher decipherMessage: 'D') = 'A' ].	self should: [ (cipher decipherMessage: 'Z') = 'W' ].! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/7/2017 07:21' prior: 36762177!cesarCipherWithShortAlphabet"Return a new instance of Basic Shift Cipher with parameter $D and alphabet:  ' O P Q R S T U V W X Y Z A B C D E F G H I J K L M N'  "		! !!ShiftCipherTest methodsFor: 'tests' stamp: 'federicobalaguer 10/2/2017 16:35' prior: 36762429!setUp		cipher := self cesarCipherWithShortAlphabet.		! !----End fileIn----!----SNAPSHOT----2017-11-17T20:15:45.097073-03:00 Pharo6.1.image priorSource: 3189263!----SNAPSHOT----2017-11-17T20:16:26.40331-03:00 Pharo6.1.image priorSource: 3212630!BasicShiftCipher subclass: #CesarCipher	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!CesarCipher class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:20'!initialize	alphabetKey:= 'd'! !!CesarCipher class methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:21' prior: 36767440!initialize	alphabetKey= 'd'! !!CesarCipher class methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:21' prior: 36767578!initialize	alphabetKey:= 'd'! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:23' prior: 36742716!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineCipherIndexWith: 			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:24' prior: 36767842!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith: 			(self alphabet findString: letter asString) )							].! !----SNAPSHOT----2017-11-17T20:24:28.61877-03:00 Pharo6.1.image priorSource: 3212717!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:25' prior: 36434098!determineCipherIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^(anInteger + self key - self alphabet size) ]			ifFalse:		[ ^(anInteger  + self key) ]! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:26' prior: 36768460!determineCipherIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^anInteger + self key - self alphabet size ]			ifFalse:		[ ^anInteger  + self key ]! !!BasicShiftCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:36' prior: 36743348!initialize	self alphabet: 'abcdefghijklmnopqrstu' asUppercase.	 ! !----SNAPSHOT----2017-11-17T20:36:18.388525-03:00 Pharo6.1.image priorSource: 3213847!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:40' prior: 36768107!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineCipherIndexWith: 			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:40' prior: 36769293!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith:			(self alphabet findString: letter asString) )							].! !----SNAPSHOT----2017-11-17T20:40:30.396745-03:00 Pharo6.1.image priorSource: 3214679!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:40' prior: 36769558!cipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineCipherIndexWith:			(self alphabet findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 20:41' prior: 36433862!decipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith:			(self alphabet findString: letter asString) )							].! !----SNAPSHOT----2017-11-17T20:41:15.383449-03:00 Pharo6.1.image priorSource: 3215297!CesarCipher class removeSelector: #initialize!!CesarCipher class methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:47'!initialize	alphabetKey:= 'd' ! !!CesarCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:49'!initiliaze	alphabetKey:= 'd' ! !!CesarCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:50' prior: 36770695!initiliaze	alphabetKey:= 'D' ! !!CesarCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:52'!initialize	alphabetKey:= 'D' 	 ! !!CesarCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:52' prior: 36770955!initialize	alphabetKey:= 'D' 	 ! !----SNAPSHOT----2017-11-17T20:53:02.678549-03:00 Pharo6.1.image priorSource: 3215916!Smalltalk globals removeClassNamed: #AnObsoleteCesarCipher!ShiftCipher subclass: #CesarCipher	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!BasicShiftCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 20:54' prior: 36769042!initialize	super alphabet: 'abcdefghijklmnopqrstu' asUppercase.	 ! !BasicShiftCipher removeSelector: #alphabetKey:!!CesarCipher methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/17/2017 20:55'!initialize	super alphabet: 'abcdefghijklmnopqrstu' asUppercase.	super alphabetKey: 'D'.! !----SNAPSHOT----2017-11-17T20:56:06.485532-03:00 Pharo6.1.image priorSource: 3216695!!CesarCipherTest methodsFor: 'testing' stamp: 'EncinasJavier 11/17/2017 20:58' prior: 36765092!setUp		cipher := CesarCipher new	! !!CesarCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 21:11' prior: 36771693!initialize	super alphabet: 'abcdefghijklmnopqrstu' asUppercase.	super alphabetKey: 'E'.! !!CesarCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 21:12' prior: 36772108!initialize	super alphabet: 'abcdefghijklmnopqrstu' asUppercase.	super alphabetKey: 'D'.! !----SNAPSHOT----2017-11-17T21:21:11.342788-03:00 Pharo6.1.image priorSource: 3217353!!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 21:40' prior: 36768748!determineCipherIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^(anInteger + self key - self alphabet size) ]			ifFalse:		[ ^(anInteger  + self key) ]! !!CesarCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 21:44' prior: 36772300!initialize	super alphabet: 'abcdefghijklmnopqrstu' asUppercase.	super alphabetKey: 'C'.! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 21:55' prior: 36772574!determineCipherIndexWith: anInteger	(( anInteger + self key ) > self alphabet size)			ifTrue: 		[ ^(anInteger + self key) - self alphabet size ]			ifFalse:		[ ^(anInteger  + self key) ]! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 21:58' prior: 36770175!decipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith:			('ABCDEFGHIJKLMNOPQRSTUVWXYZ' findString: letter asString) )							].! !!ShiftCipher methodsFor: 'accessing' stamp: 'EncinasJavier 11/17/2017 21:58' prior: 36773342!decipherMessage: aMessage	^aMessage collect:[ :letter | 		self alphabet at: (self determineDecipherIndexWith:			(self alphabet findString: letter asString) )							].! !!CesarCipher methodsFor: 'initialization' stamp: 'EncinasJavier 11/17/2017 22:00' prior: 36772867!initialize	super alphabet: 'abcdefghijklmnopqrstuvwxyz' asUppercase.	super alphabetKey: 'C'.! !----SNAPSHOT----2017-11-17T22:03:32.818392-03:00 Pharo6.1.image priorSource: 3217960!----QUIT----2017-11-17T23:24:28.777225-03:00 Pharo6.1.image priorSource: 3219563!----QUIT/NOSAVE----2017-11-20T00:02:14.979001-03:00 Pharo6.1.image priorSource: 3219650!Object subclass: #Comunicacion	instanceVariableNames: 'horaComienzo distancia duracion'	classVariableNames: ''	package: 'OBJ1'!(Smalltalk globals at: #Comunicacion) rename: #Comunication!Comunication subclass: #Local	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!Local methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 10:10'!cost	^self fixedValuePerMinute * self duration! !!Local methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 10:11'!fixedValuePerMinute	^fixedValuePerMinute! !!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 10:13'!distance	^ distance! !!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 10:13'!distance: anObject	distance := anObject! !!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 10:13'!duration	^ duration! !!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 10:13'!duration: anObject	duration := anObject! !!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 10:13'!initialTime	^ initialTime! !!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 10:13'!initialTime: anObject	initialTime := anObject! !Comunication subclass: #Urban	instanceVariableNames: 'rank'	classVariableNames: ''	package: 'OBJ1'!!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 11:23'!rankAValue|rankAValue|	^rankAValue! !!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 11:23'!rankBValue|rankBValue|	^rankBValue! !!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 11:24'!rankCValue|rankCValue|	^rankCValue! !!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:05'!cost	^self distance * self rank! !Comunication subclass: #International	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!International methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:15'!cost	|value1 value2|	self dayTime ifTrue: [ ^value1 ]					ifFalse: [ ^value2 ]! !!International methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:17'!dayTime	"chequea si el rango de horario esta dentro del margen 8 a 20"	^self initialTime between: 8 and: 20! !Object subclass: #Subscriber	instanceVariableNames: 'comunicationList'	classVariableNames: ''	package: 'OBJ1'!!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:20'!amountToPay	self comm! !Object subclass: #Subscriber	instanceVariableNames: 'communicationList'	classVariableNames: ''	package: 'OBJ1'!!Subscriber methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 12:20'!communicationList	^ communicationList! !!Subscriber methodsFor: 'accessing' stamp: 'EncinasJavier 11/20/2017 12:20'!communicationList: anObject	communicationList := anObject! !!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:24' prior: 36776776!amountToPay	self communicationList inject: 0 into: [ :commValue :comm | commValue + comm value ]! !!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:24' prior: 36777279!amountToPay	^self communicationList inject: 0 into: [ :commValue :comm | commValue + comm value ]! !!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:32'!longestCall30Days"time current asMonth es incorrecto, despues ver como detectar si se realizo en los ultimos 30 dias"   |maxComm|	maxComm:= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self communicationList do: [ :comm | (comm duration > maxComm duration) & (comm isCurrent30Days)  ]! !!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/20/2017 12:33' prior: 36777672!longestCall30Days"time current asMonth es incorrecto, despues ver como detectar si se realizo en los ultimos 30 dias"   |maxComm|	maxComm:= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self communicationList do: [ :comm | (comm duration > maxComm duration) & (comm isCurrent30Days)										ifTrue: [maxComm:= comm]  ].	^maxComm! !----QUIT----2017-11-20T12:41:45.131091-03:00 Pharo6.1.image priorSource: 3219650!!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 16:43'!isCurrent30Days	|daysFromHere30|	daysFromHere30:= Date current addDays: 30.	^self initialTime between: Date current and: daysFromHere30. ! !Object subclass: #EmpresaTelefonica	instanceVariableNames: 'subscriberList'	classVariableNames: ''	package: 'OBJ1'!!EmpresaTelefonica methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 16:49'!longestCall30Days   |maxComm|	maxComm:= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self subscriberList do: [ :comm | (comm duration > maxComm duration) & (comm isCurrent30Days)										ifTrue: [maxComm:= comm]  ].	^maxComm! !!EmpresaTelefonica methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 16:49'!subscriberList	^ subscriberList! !!EmpresaTelefonica methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 16:49'!subscriberList: anObject	subscriberList := anObject! !!EmpresaTelefonica methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 16:51' prior: 36778979!longestCall30Days   |maxSub|	maxSub= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self subscriberList do: [ :sub | (sub longestCall30Days duration > maxSub duration)										ifTrue: [maxSub= sub]  ].	^maxSub! !!EmpresaTelefonica methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 16:52' prior: 36779611!longestCall30Days   |maxSub|	maxSub:= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self subscriberList do: [ :sub | (sub longestCall30Days duration > maxSub duration)										ifTrue: [maxSub:= sub]  ].	^maxSub! !----SNAPSHOT----2017-11-22T16:52:22.370968-03:00 Pharo6.1.image priorSource: 3224026!!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 16:56'!totalCommDuration		^self communicationList inject: 0 into:[ :sum :comm | sum + comm duration ] ! !(Smalltalk globals at: #EmpresaTelefonica) rename: #PhoneService!!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 17:06'!longestTotalDurationSub		| maxSub |	maxSub:= (Subscriber new) communicationList add: ((Comunication new)duration: 0.1; initialTime: Date   current). 	self subscriberList do:[ :sub | (sub totalCommDuration > maxSub totalCommDuration)												ifTrue: [ maxSub:= sub ]].	^maxSub! !----SNAPSHOT----2017-11-22T17:06:55.760081-03:00 Pharo6.1.image priorSource: 3225780!----SNAPSHOT----2017-11-22T17:33:42.445566-03:00 Pharo6.1.image priorSource: 3226499!!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 17:33' prior: 36780644!longestTotalDurationSub		| maxSub |	maxSub:= (Subscriber new) communicationList add: ((Comunication new)duration: 0.1; initialTime: Date   current). 	self subscriberList do:[ :sub | (sub totalCommDuration > maxSub totalCommDuration)												ifTrue: [ maxSub:= sub ]].		^maxSub! !!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 17:41' prior: 36777483!amountToPay	^self communicationList inject: 0 into: [ :commValue :comm | commValue + comm cost ]! !----SNAPSHOT----2017-11-22T17:45:45.362274-03:00 Pharo6.1.image priorSource: 3226586!----SNAPSHOT----2017-11-22T17:46:57.798447-03:00 Pharo6.1.image priorSource: 3227271!!Comunication methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 17:48'!cost	self subclassResponsibility ! !Object subclass: #Lantern	instanceVariableNames: 'switch neighbors'	classVariableNames: ''	package: 'OBJ1'!!Lantern methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 17:53'!initialize	self switch: false.	self neighbors: OrderedCollection new.	! !!Lantern methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 17:53'!switch	^ switch! !!Lantern methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 17:53'!switch: anObject	switch := anObject! !!Lantern methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 17:53'!neighbors	^ neighbors! !!Lantern methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 17:53'!neighbors: anObject	neighbors := anObject! !!Lantern methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 17:55'!turnOn	self isOn ifFalse: [ self switch:true ].	! !!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 17:55'!turnOff	self isOn ifTrue: [ self switch:false ].	! !!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 17:59'!pairWithNeighbor: aLantern	self neighbors addLast: aLantern.	! !----SNAPSHOT----2017-11-22T18:02:23.406602-03:00 Pharo6.1.image priorSource: 3227358!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:03' prior: 36782780!turnOn	self isOn ifFalse: [ self switch:true. 								self neighbors do:[ :lantern | lantern turnOn ].								]		! !!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:04' prior: 36783281!turnOn	self isOn		ifTrue: [ ^ self ].	self switch: true.	self neighbors do: [ :lantern | lantern turnOn ]! !!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:04' prior: 36783493!turnOn	self isOn ifFalse: [ self switch:true. 								self neighbors do:[ :lantern | lantern turnOn ].								]	! !----SNAPSHOT----2017-11-22T18:05:09.808858-03:00 Pharo6.1.image priorSource: 3228671!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:07' prior: 36783037!pairWithNeighbor: aLantern	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self.	! !----SNAPSHOT----2017-11-22T18:07:18.037199-03:00 Pharo6.1.image priorSource: 3229383!----SNAPSHOT----2017-11-22T18:07:54.2121-03:00 Pharo6.1.image priorSource: 3229661!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:11' prior: 36783993!pairWithNeighbor: aLantern	(self neighbors anySatisfy: aLantern) ifFalse:[	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self.]	! !----SNAPSHOT----2017-11-22T18:11:52.822186-03:00 Pharo6.1.image priorSource: 3229748!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:14' prior: 36784356!pairWithNeighbor: aLantern	self neighbors detect: aLantern ifNone:[ 	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self.]	! !----SNAPSHOT----2017-11-22T18:14:46.862767-03:00 Pharo6.1.image priorSource: 3230074!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:15' prior: 36784684!pairWithNeighbor: aLantern	self neighbors detect: aLantern ifNone:[ 	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self].	! !----SNAPSHOT----2017-11-22T18:15:13.990329-03:00 Pharo6.1.image priorSource: 3230396!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:18' prior: 36785006!pairWithNeighbor: aLantern	"self neighbors detect: aLantern ifNone:[ 	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self].	"	self neighbors addIfNotPresent: aLantern.	aLantern pairWithNeighbor: self.! !----SNAPSHOT----2017-11-22T18:18:10.94635-03:00 Pharo6.1.image priorSource: 3230718!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:19' prior: 36785328!pairWithNeighbor: aLantern	(self neighbors contains: aLantern) ifFalse:[ 	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self].	! !----SNAPSHOT----2017-11-22T18:19:54.608416-03:00 Pharo6.1.image priorSource: 3231119!!Lantern methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:20' prior: 36785728!pairWithNeighbor: aLantern	(self neighbors includes: aLantern) ifFalse:[ 	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self].	! !----SNAPSHOT----2017-11-22T18:20:43.969081-03:00 Pharo6.1.image priorSource: 3231445!----SNAPSHOT----2017-11-22T18:21:06.585662-03:00 Pharo6.1.image priorSource: 3231772!!Lantern methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 18:21'!isOn	^self switch.! !----SNAPSHOT----2017-11-22T18:21:43.201226-03:00 Pharo6.1.image priorSource: 3231859!----SNAPSHOT----2017-11-22T18:22:17.290451-03:00 Pharo6.1.image priorSource: 3232043!----SNAPSHOT----2017-11-22T18:22:32.843422-03:00 Pharo6.1.image priorSource: 3232130!'From Pharo3.0 of 18 March 2013 [Latest update: #30858] on 17 October 2014 at 12:55:33.386004 am'!TestCase subclass: #TestLightGrid	instanceVariableNames: 'turnedOn turnedOff mixed'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-LightPost'!!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:42'!testTurnOnPrincipal	"Test: turning on the principal, turns on the entire neighborhood"	(turnedOff at: 1) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43'!testTurnOnNeighbor	"Test: turning on a neighbor, turns on the entire neighborhood"	(turnedOff at: 2) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43'!testTurnOffNeighbor	"Test: turning off a neighbor, turns off the entire neighborhood"	(turnedOn at: 2) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43'!testTurnOffPrincipal	"Test: turning off the principal, turns off the entire neighborhood"	(turnedOn at: 1) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43'!testMixed	(mixed at: 3) turnOff.	self deny: (mixed inject: true 		          into: [:result :next | result and: [next isOn]])! !!TestLightGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:45'!setUp	turnedOn := OrderedCollection with: ((self createLightPost)						turnOn;						yourself)				with: ((self createLightPost)						turnOn;						yourself).	turnedOn addFirst: ((self createLightPost)				turnOn;				pairWithNeighbor: turnedOn first;				pairWithNeighbor: turnedOn last;				yourself).	turnedOff := OrderedCollection with: self createLightPost				with: self createLightPost.	turnedOff addFirst: ((self createLightPost)				pairWithNeighbor: turnedOff first;				pairWithNeighbor: turnedOff last;				yourself).	mixed := OrderedCollection with: self createLightPost				with: ((self createLightPost)						turnOn;						yourself).	mixed addFirst: ((self createLightPost)				pairWithNeighbor: mixed first;				pairWithNeighbor: mixed last;				yourself)! !!TestLightGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:45'!tearDown	turnedOn := turnedOff := mixed := nil! !!TestLightGrid methodsFor: 'accesing' stamp: 'Ger 10/17/2014 00:54'!createLightPost	"El codigo de este metodo deberia ser algo asi:       ^ ClaseFarola new.    Por ejemplo: ^LightPost new  "! !----End fileIn----!'From Pharo3.0 of 18 March 2013 [Latest update: #30858] on 17 October 2014 at 12:55:33.386004 am'!TestCase subclass: #TestLightGrid	instanceVariableNames: 'turnedOn turnedOff mixed'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-LightPost'!!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:42' prior: 36787070!testTurnOnPrincipal	"Test: turning on the principal, turns on the entire neighborhood"	(turnedOff at: 1) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43' prior: 36787348!testTurnOnNeighbor	"Test: turning on a neighbor, turns on the entire neighborhood"	(turnedOff at: 2) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43' prior: 36787622!testTurnOffNeighbor	"Test: turning off a neighbor, turns off the entire neighborhood"	(turnedOn at: 2) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43' prior: 36787902!testTurnOffPrincipal	"Test: turning off the principal, turns off the entire neighborhood"	(turnedOn at: 1) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:43' prior: 36788186!testMixed	(mixed at: 3) turnOff.	self deny: (mixed inject: true 		          into: [:result :next | result and: [next isOn]])! !!TestLightGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:45' prior: 36788402!setUp	turnedOn := OrderedCollection with: ((self createLightPost)						turnOn;						yourself)				with: ((self createLightPost)						turnOn;						yourself).	turnedOn addFirst: ((self createLightPost)				turnOn;				pairWithNeighbor: turnedOn first;				pairWithNeighbor: turnedOn last;				yourself).	turnedOff := OrderedCollection with: self createLightPost				with: self createLightPost.	turnedOff addFirst: ((self createLightPost)				pairWithNeighbor: turnedOff first;				pairWithNeighbor: turnedOff last;				yourself).	mixed := OrderedCollection with: self createLightPost				with: ((self createLightPost)						turnOn;						yourself).	mixed addFirst: ((self createLightPost)				pairWithNeighbor: mixed first;				pairWithNeighbor: mixed last;				yourself)! !!TestLightGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:45' prior: 36789270!tearDown	turnedOn := turnedOff := mixed := nil! !!TestLightGrid methodsFor: 'accesing' stamp: 'Ger 10/17/2014 00:54' prior: 36789390!createLightPost	"El codigo de este metodo deberia ser algo asi:       ^ ClaseFarola new.    Por ejemplo: ^LightPost new  "! !----End fileIn----!'From Pharo3.0 of 18 March 2013 [Latest update: #30858] on 17 October 2014 at 12:55:30.848006 am'!TestCase subclass: #TestLightAcuteGrid	instanceVariableNames: 'turnedOn turnedOff mixed'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-LightPost'!!TestLightAcuteGrid methodsFor: 'accesing' stamp: 'Ger 10/17/2014 00:55'!createLightPost	"El codigo de este metodo deberia ser algo asi:    ^ClaseFarolaExtendida new.    Por ejemplo: ^AcuteLightPost new"! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:54'!testTurnOnPrincipal	"Test: turning on the principal, turns on the entire neighborhood"	(turnedOff at: 1) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:54'!testTurnOnNeighbor	"Test: turning on a neighbor, turns on the entire neighborhood"	(turnedOff at: 2) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:54'!testTurnOffNeighbor	"Test: turning off a neighbor, turns off the entire neighborhood"	(turnedOn at: 2) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:53'!testTurnOffPrincipal	"Test: turning off the principal, turns off the entire neighborhood"	(turnedOn at: 1) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:53'!testMixed	(mixed at: 3) turnOff.	self assert: (mixed inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightAcuteGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:55'!setUp	turnedOn := OrderedCollection with: ((self createLightPost)						turnOn;						yourself)				with: ((self createLightPost)						turnOn;						yourself).	turnedOn addFirst: ((self createLightPost)				turnOn;				pairWithNeighbor: turnedOn first;				pairWithNeighbor: turnedOn last;				yourself).	turnedOff := OrderedCollection with: self createLightPost				with: self createLightPost.	turnedOff addFirst: ((self createLightPost)				pairWithNeighbor: turnedOff first;				pairWithNeighbor: turnedOff last;				yourself).	mixed := OrderedCollection with: self createLightPost				with: ((self createLightPost)						turnOn;						yourself).	mixed addFirst: ((self createLightPost)				pairWithNeighbor: mixed first;				pairWithNeighbor: mixed last;				yourself)! !!TestLightAcuteGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:55'!tearDown	turnedOn := turnedOff := mixed := nil! !----End fileIn----!'From Pharo3.0 of 18 March 2013 [Latest update: #30858] on 17 October 2014 at 12:55:30.848006 am'!TestCase subclass: #TestLightAcuteGrid	instanceVariableNames: 'turnedOn turnedOff mixed'	classVariableNames: ''	poolDictionaries: ''	category: 'Objetos1-LightPost'!!TestLightAcuteGrid methodsFor: 'accesing' stamp: 'Ger 10/17/2014 00:55' prior: 36792817!createLightPost	"El codigo de este metodo deberia ser algo asi:    ^ClaseFarolaExtendida new.    Por ejemplo: ^AcuteLightPost new"! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:54' prior: 36793028!testTurnOnPrincipal	"Test: turning on the principal, turns on the entire neighborhood"	(turnedOff at: 1) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:54' prior: 36793311!testTurnOnNeighbor	"Test: turning on a neighbor, turns on the entire neighborhood"	(turnedOff at: 2) turnOn.	self assert: (turnedOff inject: true				into: [:result :next | result and: [next isOn]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:54' prior: 36793590!testTurnOffNeighbor	"Test: turning off a neighbor, turns off the entire neighborhood"	(turnedOn at: 2) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:53' prior: 36793875!testTurnOffPrincipal	"Test: turning off the principal, turns off the entire neighborhood"	(turnedOn at: 1) turnOff.	self assert: (turnedOn inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightAcuteGrid methodsFor: 'testing' stamp: 'Ger 10/16/2014 01:53' prior: 36794164!testMixed	(mixed at: 3) turnOff.	self assert: (mixed inject: true				into: [:result :next | result and: [next isOn not]])! !!TestLightAcuteGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:55' prior: 36794382!setUp	turnedOn := OrderedCollection with: ((self createLightPost)						turnOn;						yourself)				with: ((self createLightPost)						turnOn;						yourself).	turnedOn addFirst: ((self createLightPost)				turnOn;				pairWithNeighbor: turnedOn first;				pairWithNeighbor: turnedOn last;				yourself).	turnedOff := OrderedCollection with: self createLightPost				with: self createLightPost.	turnedOff addFirst: ((self createLightPost)				pairWithNeighbor: turnedOff first;				pairWithNeighbor: turnedOff last;				yourself).	mixed := OrderedCollection with: self createLightPost				with: ((self createLightPost)						turnOn;						yourself).	mixed addFirst: ((self createLightPost)				pairWithNeighbor: mixed first;				pairWithNeighbor: mixed last;				yourself)! !!TestLightAcuteGrid methodsFor: 'testing - initialization' stamp: 'Ger 10/16/2014 01:55' prior: 36795255!tearDown	turnedOn := turnedOff := mixed := nil! !----End fileIn----!----SNAPSHOT----2017-11-22T18:25:45.521577-03:00 Pharo6.1.image priorSource: 3232217!(Smalltalk globals at: #Lantern) rename: #LightPost!!TestLightGrid methodsFor: 'accesing' stamp: 'EncinasJavier 11/22/2017 18:27' prior: 36792322!createLightPost	"El codigo de este metodo deberia ser algo asi:       ^ ClaseFarola new.    Por ejemplo: ^LightPost new  " ^LightPost new ! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:27' prior: 36782908!turnOff	self isOn ifTrue: [ self switch:false. 								self neighbors do:[ :lantern | lantern turnOff ].								]		! !----SNAPSHOT----2017-11-22T18:27:55.841811-03:00 Pharo6.1.image priorSource: 3243876!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:32'!emergencyTurnOn	self switch:true.	self neighbors do:[ :lantern | lantern emergencyTurnOn ].	! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:34' prior: 36799070!emergencyTurnOn	"como hago para evitar el loop"	self switch:true.	self neighbors do:[ :lantern | lantern emergencyTurnOn ].	! !----SNAPSHOT----2017-11-22T18:35:17.356986-03:00 Pharo6.1.image priorSource: 3244474!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 18:38' prior: 36799261!emergencyTurnOn	"como hago para evitar el loop?"	self switch:true.	self neighbors do:[ :lantern | lantern emergencyTurnOn ].	! !Object subclass: #LightAcute	instanceVariableNames: 'switch neighbors'	classVariableNames: ''	package: 'OBJ1'!!LightAcute methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 18:40'!switch	^ switch! !!LightAcute methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 18:40'!switch: anObject	switch := anObject! !!LightAcute methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 18:40'!neighbors	^ neighbors! !!LightAcute methodsFor: 'accessing' stamp: 'EncinasJavier 11/22/2017 18:40'!neighbors: anObject	neighbors := anObject! !Smalltalk globals removeClassNamed: #AnObsoleteLightAcute!LightPost subclass: #LightAcute	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!LightAcute methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 18:43'!pairWithNeighbor: aLantern	(self neighbors includes: aLantern) ifFalse:[ 	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self.	self isOn ifTrue: [aLantern turnOn]				ifFalse: [aLantern turnOff].]! !----SNAPSHOT----2017-11-22T18:43:45.788288-03:00 Pharo6.1.image priorSource: 3244960!(Smalltalk globals at: #LightAcute) rename: #AcuteLightPost!!TestLightAcuteGrid methodsFor: 'accesing' stamp: 'EncinasJavier 11/22/2017 18:44' prior: 36795687!createLightPost	"El codigo de este metodo deberia ser algo asi:    ^ClaseFarolaExtendida new.    Por ejemplo: ^AcuteLightPost new"	^AcuteLightPost new! !----SNAPSHOT----2017-11-22T18:47:50.688344-03:00 Pharo6.1.image priorSource: 3246294!----SNAPSHOT----2017-11-22T19:00:08.951912-03:00 Pharo6.1.image priorSource: 3246702!!Subscriber methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 19:14' prior: 36778094!longestCall30Days"time current asMonth es incorrecto, despues ver como detectar si se realizo en los ultimos 30 dias"	^(self communicationList select: [ :comm | comm isCurrent30Days ]) detectMax:[ :comm | comm duration ].! !!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 19:16' prior: 36779966!longestCall30Days   |maxSub|	maxSub:= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self subscriberList do: [ :sub | (sub longestCall30Days duration > maxSub duration)										ifTrue: [maxSub:= sub]  ].	^maxSub	! !----SNAPSHOT----2017-11-22T19:17:31.840287-03:00 Pharo6.1.image priorSource: 3246789!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:20' prior: 36786055!pairWithNeighbor: aLantern	(self neighbors includes: aLantern)		ifTrue: [ ^ self ].	self neighbors addLast: aLantern.	aLantern pairWithNeighbor: self! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:21' prior: 36783696!turnOn	self isOn		ifTrue: [ ^ self ].	self switch: true.	self neighbors do: [ :lantern | lantern turnOn ]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:30' prior: 36799572!emergencyTurnOn	"como hago para evitar el loop?"	self switch:true.	self neighbors do:[ :lantern | lantern emergencyTurnOn ].		self neighbors collect:[ :lantern |  ] 	! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:32'!spreadEmergency: aCollection		! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:34' prior: 36802628!emergencyTurnOn	"como hago para evitar el loop?"	|notOn|	self spreadEmergency: notOn.		self switch:true.	self neighbors do:[ :lantern | lantern emergencyTurnOn ].		self neighbors collect:[ :lantern |  ] 		! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:34' prior: 36803008!emergencyTurnOn	"como hago para evitar el loop?"	|notOn|	notOn:= Set new.	self spreadEmergency: notOn.		self switch:true.	self neighbors do:[ :lantern | lantern emergencyTurnOn ].		self neighbors collect:[ :lantern |  ] 		! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:38' prior: 36802880!spreadEmergency: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	self switch: true. 			! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:39' prior: 36803648!spreadEmergency: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	self add: self.	self switch: true. 	self neighbors do: [ :lantern | lantern spreadEmergency: aCollection ]			! !----SNAPSHOT----2017-11-22T19:40:15.152459-03:00 Pharo6.1.image priorSource: 3247562!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:41' prior: 36803849!spreadEmergency: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	aCollection add: self.	self switch: true. 	self neighbors do: [ :lantern | lantern spreadEmergency: aCollection ]			! !----SNAPSHOT----2017-11-22T19:41:22.840365-03:00 Pharo6.1.image priorSource: 3249614!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 11/22/2017 19:42' prior: 36803319!emergencyTurnOn	"como hago para evitar el loop?"	|notOn|	notOn:= Set new.	self spreadEmergency: notOn.			! !----SNAPSHOT----2017-11-22T19:42:11.842036-03:00 Pharo6.1.image priorSource: 3249998!!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 19:48' prior: 36801745!longestCall30Days	   |maxSub|	maxSub:= (Comunication new) initialTime: (Time current asMonth); duration: 0.01.	self subscriberList do: [ :sub | (sub longestCall30Days duration > maxSub duration)										ifTrue: [maxSub:= sub]  ].	self detectMax: [ :sub | sub longestCall30Days duration  ]	! !!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 19:49' prior: 36804918!longestCall30Days	^self detectMax: [ :sub | sub longestCall30Days duration  ]	! !!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 19:51' prior: 36781211!longestTotalDurationSub		^self subscriberList detectMax: [ :sub | sub totalCommDuration  ]! !!PhoneService methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/22/2017 19:52' prior: 36805326!longestCall30Days	^(self subscriberList collect: [ :sub | sub longestCall30Days ]) detectMax: [ :call | call duration] 	! !----SNAPSHOT----2017-11-22T19:54:41.345423-03:00 Pharo6.1.image priorSource: 3250293!----QUIT----2017-11-22T19:54:47.054731-03:00 Pharo6.1.image priorSource: 3251413!----QUIT/NOSAVE----2017-11-26T08:55:38.004725-03:00 Pharo6.1.image priorSource: 3251500!!Local methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 15:24'!fixedValuePerMinute: aValue	fixedValuePerMinute:= aValue! !!Local class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 15:25'!withFixedValue: aValue	^(self new)fixedValuePerMinute: aValue;yourself.! !Object subclass: #DistanceRanker		instanceVariableNames: '' 		classVariableNames: ''		category: 'OBJ1'!Object subclass: #CityRanker		instanceVariableNames: '' 		classVariableNames: ''		category: 'OBJ1'!!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 15:40' prior: 36776052!cost	 DistanceRanker value: self distance + CityRanker value: self rank! !Object subclass: #DistanceRanker	instanceVariableNames: 'distance'	classVariableNames: ''	package: 'OBJ1'!!DistanceRanker methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 15:55'!distance	^distance.! !!DistanceRanker methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 15:59'!rankA	! !Comunication subclass: #Urban	instanceVariableNames: 'city'	classVariableNames: ''	package: 'OBJ1'!!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:15'!city	^ city! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:15'!city: anObject	city := anObject! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:22' prior: 36806713!cost	 ^(DistanceRanker value: self distance) + (CityRanker value: self city) 		! !!DistanceRanker class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 16:29'!value: aDistance	(aDistance < self rankADistance) ifTrue: [ ^50 ].	(aDistance < self rankBDistance) ifTrue: [ ^100 ]											  ifFalse: [^200].! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:39' prior: 36807495!cost	 ^(DistanceRanker value: self distance) + (self city fixedValue) 		! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:41' prior: 36807918!cost	 self isRankA ifTrue: [ ^self rankAValue + self city fixedValue ].	 self isRankB ifTrue: [ ^self rankBValue + self city fixedValue ].	 self isRankC ifTrue: [ ^self rankCValue + self city fixedValue ].		! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:42'!isRankA	^self distance between: 10 and: 50! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:42'!isRankB	^self distance between: 51 and: 100! !!Urban methodsFor: 'accessing' stamp: 'EncinasJavier 11/26/2017 16:42'!isRankC	^self distance between: 101 and: 200! !!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 16:43' prior: 36775808!rankBValue	^20! !!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 16:43' prior: 36775930!rankCValue	^30! !!Urban methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 11/26/2017 16:43' prior: 36775686!rankAValue		^10! !Smalltalk globals removeClassNamed: #AnObsoleteCityRanker!Smalltalk globals removeClassNamed: #AnObsoleteDistanceRanker!----QUIT----2017-11-26T17:46:14.231964-03:00 Pharo6.1.image priorSource: 3251500!----QUIT----2017-11-29T09:29:20.033659-03:00 Pharo6.1.image priorSource: 3254707!LightPost subclass: #GeneratorLightPost	instanceVariableNames: 'power'	classVariableNames: ''	package: 'OBJ1'!!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/6/2017 18:48'!power	^ power! !!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/6/2017 18:48'!power: anObject	power := anObject! !Object subclass: #LightPost	instanceVariableNames: 'switch neighbors bulb'	classVariableNames: ''	package: 'OBJ1'!Object subclass: #Bulb	instanceVariableNames: 'watt expiration'	classVariableNames: ''	package: 'OBJ1'!!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/6/2017 19:26'!watt	^ watt! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/6/2017 19:26'!watt: anObject	watt := anObject! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/6/2017 19:26'!expiration	^ expiration! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/6/2017 19:26'!expiration: anObject	expiration := anObject! !!Bulb class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/6/2017 19:41'!watt: anAmount expiration: aDate	^(self new)watt: anAmount; expiration: aDate;yourself.! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/6/2017 19:50'!setBulb: aBulb	bulb:= aBulb! !Object subclass: #LightPost	instanceVariableNames: 'switch neighbors bulb'	classVariableNames: ''	package: 'OBJ1'!!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:29'!bulb	^ bulb! !!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:29'!bulb: anObject	bulb := anObject! !LightPost subclass: #GeneratorLightPost	instanceVariableNames: 'power'	classVariableNames: ''	package: 'OBJ1'!!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:30'!power	^ power! !!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:30'!power: anObject	power := anObject! !!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:31'!setBulb: anObject	bulb := anObject! !LightPost removeSelector: #bulb:!Object subclass: #Bulb	instanceVariableNames: 'watt expiration'	classVariableNames: ''	package: 'OBJ1'!!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:38'!watt	^ watt! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:38'!watt: anObject	watt := anObject! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:38'!expiration	^ expiration! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 08:38'!expiration: anObject	expiration := anObject! !!Bulb class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/7/2017 08:39'!watt: anAmount expires: aDate	^(self new)watt: anAmount; expiration: aDate;yourself.! !!Bulb class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/7/2017 09:06' prior: 36811976!watt: anAmount expires: aDate	^(self new)watt: anAmount; expiration: aDate;yourself.	! !----SNAPSHOT----2017-12-07T09:06:17.250224-03:00 Pharo6.1.image priorSource: 3254790!Object subclass: #Bulb	instanceVariableNames: 'watt expiration condition'	classVariableNames: ''	package: 'OBJ1'!!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 09:26'!condition	^ condition! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 09:26'!condition: anObject	condition := anObject! !!Bulb class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/7/2017 09:27' prior: 36812167!watt: anAmount expires: aDate	^(self new)watt: anAmount; expiration: aDate;condition: true;yourself.	! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 09:32'!isFunctional	self condition ifFalse:[^self condition].	^(self expiration > Date current).	! !!Bulb methodsFor: 'accessing' stamp: 'EncinasJavier 12/7/2017 09:42'!daysToExpiration	"devuelve la cantidad de dias restantes para que expire"! !----QUIT----2017-12-08T00:16:13.778897-03:00 Pharo6.1.image priorSource: 3257824!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:08'!burnBulb	"quema la lampara sin tener en cuenta la fecha de expiracion"			self bulb condition: false.! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:18'!hasEnoughPower	self neighbors collect:[ :light | light neighbors collect: [ :l2 | l2 ]]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:18' prior: 36813537!hasEnoughPower	^self neighbors collect:[ :light | light neighbors collect: [ :l2 | l2 ]]! !----SNAPSHOT----2017-12-08T10:18:21.044768-03:00 Pharo6.1.image priorSource: 3258764!----SNAPSHOT----2017-12-08T10:20:40.643012-03:00 Pharo6.1.image priorSource: 3259380!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:23' prior: 36813720!hasEnoughPower	^self neighbors collect:[ :light | light neighbors select: [ :l2 | l2 ]]! !!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/8/2017 10:24'!isALightPost	^self class == LightPost! !!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/8/2017 10:24' prior: 36814245!isALightPost	^self class == LightPost! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:25' prior: 36814078!hasEnoughPower	^self neighbors collect:[ :light | light neighbors select: [ :l2 | l2 isALightPost ]]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:27' prior: 36814513!hasEnoughPower	^self neighbors collect:[ :light | light neighbors ]! !----SNAPSHOT----2017-12-08T10:28:14.11047-03:00 Pharo6.1.image priorSource: 3259467!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:30' prior: 36814709!hasEnoughPower	^self neighbors collect:[ :light | light neighbors select: [ :light2 | light2 isALightPost ]]! !----SNAPSHOT----2017-12-08T10:33:11.512495-03:00 Pharo6.1.image priorSource: 3260348!----SNAPSHOT----2017-12-08T10:44:57.923712-03:00 Pharo6.1.image priorSource: 3260638!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:46' prior: 36802174!pairWithNeighbor: aLantern	(self neighbors includes: aLantern)		ifTrue: [ ^ self ].	self neighbors add: aLantern.	aLantern pairWithNeighbor: self! !----SNAPSHOT----2017-12-08T10:52:26.047815-03:00 Pharo6.1.image priorSource: 3260725!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:54'!lightPostGrid	^self neighbors collect:[ :light | light neighbors select: [ :light2 | light2 isALightPost ]]! !LightPost removeSelector: #hasEnoughPower!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:55'!lightPostGrid: aCollection		^self neighbors collect:[ :light | light neighbors select: [ :light2 | light2 isALightPost ]]! !LightPost removeSelector: #lightPostGrid!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 10:56' prior: 36815882!lightPostGrid: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	aCollection add: self.	self neighbors do: [ :lantern | lantern isALightPost ifTrue: [lantern lightPostGrid: aCollection ]]! !----SNAPSHOT----2017-12-08T10:56:57.86791-03:00 Pharo6.1.image priorSource: 3261056!----SNAPSHOT----2017-12-08T10:57:46.056409-03:00 Pharo6.1.image priorSource: 3261916!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:12'!collectLightPost: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	aCollection add: self.	self neighbors do: [ :lantern | lantern isALightPost ifTrue: [lantern lightPostGrid: aCollection ]]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:12' prior: 36816597!collectLightPost: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	aCollection add: self.	self neighbors do: [ :lantern | lantern isALightPost ifTrue: [lantern collectLightPost: aCollection ]]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:12' prior: 36816143!lightPostGrid: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	aCollection add: self.	self neighbors do: [ :lantern | lantern isALightPost ifTrue: [lantern collectLightPost: aCollection ]]! !LightPost removeSelector: #lightPostGrid:!----SNAPSHOT----2017-12-08T17:12:10.348097-03:00 Pharo6.1.image priorSource: 3262002!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:21' prior: 36816897!collectLightPost: aCollection	(aCollection includes: self) ifTrue: [ ^self ]. 	aCollection add: self.	self neighbors do: [ :lantern | lantern collectLightPost: aCollection ]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:27'!lightpostGrid		^(self collectLightPost:(OrderedCollection new)) select: [ :light | light isALightPost ].! !!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/8/2017 17:27'!isAGenerator	^self class == GeneratorLightPost.! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:28'!generatorGrid		^(self collectLightPost:(OrderedCollection new)) select: [ :light | light isAGenerator ].! !----SNAPSHOT----2017-12-08T17:29:06.548528-03:00 Pharo6.1.image priorSource: 3263020!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:32' prior: 36817887!lightpostGrid		^(self collectLightPost:(OrderedCollection new)) select:[ :light | light isALightPost ].! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:35' prior: 36818496!lightpostGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost:grid.	^grid select:[ :light | light isALightPost ].! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 17:35' prior: 36818208!generatorGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost: grid.	grid select: [ :light | light isAGenerator ].! !----SNAPSHOT----2017-12-08T17:35:55.104093-03:00 Pharo6.1.image priorSource: 3263885!----SNAPSHOT----2017-12-08T17:36:13.822034-03:00 Pharo6.1.image priorSource: 3264619!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 18:05'!hasEnoughPower		^(self lightpostGrid inject: 0 into: [ :sum :light | sum + light bulb watt ])	>	(self generatorGrid inject: 0 into: [ :sum :light | sum + light power ])! !----SNAPSHOT----2017-12-08T18:05:13.360237-03:00 Pharo6.1.image priorSource: 3264706!----SNAPSHOT----2017-12-08T18:07:30.854596-03:00 Pharo6.1.image priorSource: 3265044!GeneratorLightPost removeSelector: #isAGenerator!!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/8/2017 18:08'!isAGenerator	^self class == GeneratorLightPost.! !----SNAPSHOT----2017-12-08T18:08:27.024176-03:00 Pharo6.1.image priorSource: 3265131!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 18:09' prior: 36819301!hasEnoughPower	^(self lightpostGrid inject: 0 into: [ :sum :light | sum + light bulb watt ])	>	(self generatorGrid inject: 0 into: [ :sum :light | sum + light power ])! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 18:09' prior: 36818919!generatorGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost: grid.	^grid select: [ :light | light isAGenerator ].! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/8/2017 18:10' prior: 36820007!hasEnoughPower	^(self lightpostGrid inject: 0 into: [ :sum :light | sum + light bulb watt ])	<	(self generatorGrid inject: 0 into: [ :sum :light | sum + light power ])! !----SNAPSHOT----2017-12-08T18:10:30.969313-03:00 Pharo6.1.image priorSource: 3265396!----SNAPSHOT----2017-12-08T18:10:47.494073-03:00 Pharo6.1.image priorSource: 3266238!----QUIT----2017-12-09T08:02:29.149276-03:00 Pharo6.1.image priorSource: 3266325!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:19' prior: 36817631!collectLightPost: aCollection	(aCollection includes: self) ifTrue: [ aCollection add: self.	self neighbors do: [ :lantern | lantern collectLightPost: aCollection ] ]. 	! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:19' prior: 36821020!collectLightPost: aCollection	(aCollection includes: self)		ifFalse: [ ^ self ].	aCollection add: self.	self neighbors		do: [ :lantern | lantern collectLightPost: aCollection ]! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:20' prior: 36821287!collectLightPost: aCollection	(aCollection includes: self)		ifTrue: [ ^ self ].	aCollection add: self.	self neighbors		do: [ :lantern | lantern collectLightPost: aCollection ]! !!AcuteLightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:25'!isALightPost! !LightPost removeSelector: #isOn!!AcuteLightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:26' prior: 36821829!isALightPost	^self class == LightPost! !!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/14/2017 18:26'!isAGenerator	^self class == GeneratorLightPost.! !LightPost removeSelector: #isALightPost!LightPost removeSelector: #isAGenerator!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:28' prior: 36818696!lightpostGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost:grid.	^grid select:[ :light | light not isAGenerator ].! !----SNAPSHOT----2017-12-14T18:28:20.71402-03:00 Pharo6.1.image priorSource: 3266412!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:28' prior: 36822332!lightpostGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost:grid.	^grid select:[ :light | light isAGenerator not ].! !!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/14/2017 18:32'!isAGenerator	^self subclassResponsibility.! !----SNAPSHOT----2017-12-14T18:32:44.969281-03:00 Pharo6.1.image priorSource: 3268035!!LightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/14/2017 18:33'!isALightPost	^self subclassResponsibility.! !----QUIT----2017-12-14T18:33:57.777183-03:00 Pharo6.1.image priorSource: 3268473!LightPost removeSelector: #isALightPost!LightPost removeSelector: #isAGenerator!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:37'!isALightPost	^self class == LightPost! !AcuteLightPost removeSelector: #isALightPost!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:37'!isAGenerator	^self subclassResponsibility.! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:38' prior: 36822646!lightpostGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost:grid.	^grid select:[ :light | light isALightPost ].! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:39' prior: 36823359!isALightPost	^true! !!GeneratorLightPost methodsFor: 'accessing' stamp: 'EncinasJavier 12/14/2017 18:39' prior: 36822104!isAGenerator	^true.! !----SNAPSHOT----2017-12-14T18:40:01.240798-03:00 Pharo6.1.image priorSource: 3268683!LightPost removeSelector: #isAGenerator!!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:58'!isAGenerator	^false! !!LightPost methodsFor: 'switching' stamp: 'EncinasJavier 12/14/2017 18:59' prior: 36823664!lightpostGrid	|grid|	grid:= OrderedCollection new.	self collectLightPost:grid.	^grid reject:[ :light | light isAGenerator ].! !----SNAPSHOT----2017-12-14T18:59:26.88156-03:00 Pharo6.1.image priorSource: 3269604!----QUIT----2017-12-15T14:36:34.922974-03:00 Pharo6.1.image priorSource: 3270057!270057!Object subclass: #Escudo	instanceVariableNames: 'obras'	classVariableNames: ''	package: 'OBJ1'!Object subclass: #Obras	instanceVariableNames: 'nombre funciones'	classVariableNames: ''	package: 'OBJ1'!Object subclass: #Funcion	instanceVariableNames: 'fecha precio'	classVariableNames: ''	package: 'OBJ1'!Funcion subclass: #Borderau	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!Funcion subclass: #Cache	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ1'!!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:42'!obras	^ obras! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:42'!obras: anObject	obras := anObject! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!fecha	^ fecha! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!fecha: anObject	fecha := anObject! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!precio	^ precio! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!precio: anObject	precio := anObject! !!Obras methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!nombre	^ nombre! !!Obras methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!nombre: anObject	nombre := anObject! !!Obras methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!funciones	^ funciones! !!Obras methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:43'!funciones: anObject	funciones := anObject! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:45'!funcionBorderauPara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:45'!funcionCachePara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:46'!personasQueFueronAVer: unaObra! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:46'!obraConMayorRecaudacion: unaObra! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:47'!obrasQueSuperanElPisoDeRecaudacion! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:51'!initialize	self obras: OrderedCollection new.! !Object subclass: #Funcion	instanceVariableNames: 'fecha precio capacidad'	classVariableNames: ''	package: 'OBJ1'!!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:58'!capacidad	^ capacidad! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 15:58'!capacidad: anObject	capacidad := anObject! !!Obras methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:06'!agregarFuncion: unaFuncion	self funciones add: unaFuncion! !!Funcion class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/15/2017 16:08'!capacidad: unaCapacidad fecha: unaFecha precio:unPrecio		^(self new) capacidad: unaCapacidad; fecha: unaFecha; precio: unPrecio.! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:18' prior: 36826284!funcionBorderauPara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio	"Precondicion: la obra existe"	(self obras detect:[ :obra | obra nombre = unaObra nombre ]) agregarFuncion: 		(Funcion capacidad: unNumero fecha: unaFecha precio: unPrecio).  ! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:21' prior: 36827755!funcionBorderauPara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio	"Precondicion: la obra existe"	(self obras detect:[ :obra | obra nombre = unaObra nombre ]) agregarFuncion: 		(Borderau capacidad: unNumero fecha: unaFecha precio: unPrecio).  ! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:23' prior: 36826440!funcionCachePara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio	"Precondicion: la obra existe"	(self obras detect:[ :obra | obra nombre = unaObra nombre ]) agregarFuncion: 		(Cache capacidad: unNumero fecha: unaFecha precio: unPrecio).  ! !Object subclass: #Entrada	instanceVariableNames: 'nombre'	classVariableNames: ''	package: 'OBJ1'!!Entrada methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:27'!nombre	^ nombre! !!Entrada methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:27'!nombre: anObject	nombre := anObject! !Object subclass: #Funcion	instanceVariableNames: 'fecha precio capacidad entradasVendidas'	classVariableNames: ''	package: 'OBJ1'!!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:28'!entradasVendidas	^ entradasVendidas! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:28'!entradasVendidas: anObject	entradasVendidas := anObject! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:29'!añadirVenta: unNombre	self entradasVendidas add:(Entrada nombre: unNombre).! !!Entrada class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/15/2017 16:30'!nombre: unNombre	^(self new)nombre: unNombre.! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:31'!personas	^self entradasVendidas collect: [ :each | each nombre ].! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:46' prior: 36826593!personasQueFueronAVer: unaObra		! !Obras removeSelector: #agregarFuncion:!Obras removeSelector: #funciones!Obras removeSelector: #funciones:!Object subclass: #Escudo	instanceVariableNames: 'funciones'	classVariableNames: ''	package: 'OBJ1'!Escudo removeSelector: #obras:!Escudo removeSelector: #obras!!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:50'!funciones	^ funciones! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:50'!funciones: anObject	funciones := anObject! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:51' prior: 36828106!funcionBorderauPara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio	"Precondicion: la obra existe"	self funciones agregarFuncion: 		(Borderau capacidad: unNumero fecha: unaFecha precio: unPrecio obra: unaObra).  ! !Object subclass: #Funcion	instanceVariableNames: 'fecha precio capacidad entradas obra'	classVariableNames: ''	package: 'OBJ1'!!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:52'!entradas	^ entradas! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:52'!entradas: anObject	entradas := anObject! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:52'!obra	^ obra! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:52'!obra: anObject	obra := anObject! !Funcion removeSelector: #entradasVendidas!Funcion removeSelector: #entradasVendidas:!Object subclass: #Obras	instanceVariableNames: 'nombre funcion'	classVariableNames: ''	package: 'OBJ1'!!Funcion class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/15/2017 16:57'!capacidad: unaCapacidad fecha: unaFecha precio:unPrecio obra: unaObra		^(self new) capacidad: unaCapacidad; fecha: unaFecha; precio: unPrecio; obra: unaObra.! !Funcion class removeSelector: #capacidad:fecha:precio:!!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 16:59' prior: 36828458!funcionCachePara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio	"Precondicion: la obra existe"	(self obras detect:[ :obra | obra nombre = unaObra nombre ]) agregarFuncion: 		(Cache capacidad: unNumero fecha: unaFecha precio: unPrecio obra: unaObra).  ! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 17:02'!recaudacion	^(self entradas size) * (self precio). ! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 17:08'!bruto	^(self entradas size) * (self precio). ! !Funcion removeSelector: #recaudacion!!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 17:11' prior: 36829937!personasQueFueronAVer: unaObra		(self funciones select: [ :each | each obra = unaObra ])! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 17:13'!recolectarPersonas: unaColecion! !!Escudo methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/15/2017 18:49'!agregarFuncion: unaFuncion	self funciones add: unaFuncion.! !!Escudo methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/15/2017 18:51' prior: 36831938!funcionCachePara: unaObra capacidad: unNumero dia: unaFecha precio: unPrecio	"Precondicion: la obra existe"	self funciones agregarFuncion: 		(Cache capacidad: unNumero fecha: unaFecha precio: unPrecio obra: unaObra).  ! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 18:57' prior: 36832591!personasQueFueronAVer: unaObra		^(self funciones select: [ :each | each obra = unaObra ]) collect: [ :each | each personas ].! !----SNAPSHOT----2017-12-15T19:00:10.282524-03:00 Pharo6.1.image priorSource: 3270143!!Borderau methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 12/15/2017 19:03'!neto	^(self bruto) / 0.3 ! !Funcion subclass: #Cache	instanceVariableNames: 'montoFijo'	classVariableNames: ''	package: 'OBJ1'!!Cache methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:03'!montoFijo	^ montoFijo! !!Cache methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:03'!montoFijo: anObject	montoFijo := anObject! !!Cache methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:04'!initialize	self montoFijo: 0.! !!Cache methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:05'!neto	^self bruto - self montoFijo.! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:07'!superanPiso	^self neto > 500.! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:07'!neto	^self subclassResponsibility.! !!Funcion methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:08' prior: 36832413!bruto	^self subclassResponsibility.! !----SNAPSHOT----2017-12-15T19:08:14.264556-03:00 Pharo6.1.image priorSource: 3279052!Funcion removeSelector: #recolectarPersonas:!!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:12' prior: 36826809!obrasQueSuperanElPisoDeRecaudacion	self funciones inject: 0 into: [ :sum :each | each  ] ! !!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:13' prior: 36834798!obrasQueSuperanElPisoDeRecaudacion	self funciones inject: 0 into: [ :sum :each | (each superanPiso) ifTrue: [ sum + 1 ]]. ! !----SNAPSHOT----2017-12-15T19:13:52.895688-03:00 Pharo6.1.image priorSource: 3280142!!Escudo methodsFor: 'accessing' stamp: 'EncinasJavier 12/15/2017 19:14' prior: 36834981!obrasQueSuperanElPisoDeRecaudacion	^self funciones inject: 0 into: [ :sum :each | (each superanPiso) ifTrue: [ sum + 1 ]]. ! !----SNAPSHOT----2017-12-15T19:14:17.93645-03:00 Pharo6.1.image priorSource: 3280675!----SNAPSHOT----2017-12-15T19:14:24.035828-03:00 Pharo6.1.image priorSource: 3280979!----SNAPSHOT----2017-12-15T19:26:31.55337-03:00 Pharo6.1.image priorSource: 3281065!----QUIT----2017-12-15T19:39:53.962454-03:00 Pharo6.1.image priorSource: 3281152!Object subclass: #Juego	instanceVariableNames: 'jugadores'	classVariableNames: ''	package: 'OBJ2'!Object subclass: #Jugadores	instanceVariableNames: 'energia'	classVariableNames: ''	package: 'OBJ2'!(Smalltalk globals at: #Jugadores) rename: #Jugador!!Jugador methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/27/2018 11:48'!jugadaParaTurno: unTurno	^(Random new) nextInt: 2.! !!Jugador methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/27/2018 11:51' prior: 36836099!jugadaParaTurno: unTurno	self juego jugador: self turno: unTurno movimiento: (Random new) nextInt: 2.! !!Jugador methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/27/2018 11:54' prior: 36836254!jugadaParaTurno: unTurno	self juego jugador: self turno: unTurno movimiento: ((Random new) nextInt: 2).! !Object subclass: #Juego	instanceVariableNames: 'jugadores turnos'	classVariableNames: ''	package: 'OBJ2'!!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:55'!jugadores	^ jugadores! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:55'!jugadores: anObject	jugadores := anObject! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:55'!turnos	^ turnos! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:55'!turnos: anObject	turnos := anObject! !!Juego methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/27/2018 11:55'!initialize	jugadores! !!Jugador methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:55'!energia	^ energia! !!Jugador methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:55'!energia: anObject	energia := anObject! !!Juego methodsFor: 'initialization' stamp: 'EncinasJavier 3/27/2018 11:56' prior: 36837176!initialize	self jugadores: OrderedCollection new.! !!Juego methodsFor: 'initialization' stamp: 'EncinasJavier 3/27/2018 11:57' prior: 36837503!initialize	self jugadores: OrderedCollection new.	self turnos: OrderedCollection new.! !Object subclass: #Turno	instanceVariableNames: 'jugada1 jugada2'	classVariableNames: ''	package: 'OBJ2'!!Turno methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:58'!jugada1	^ jugada1! !!Turno methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:58'!jugada1: anObject	jugada1 := anObject! !!Turno methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:58'!jugada2	^ jugada2! !!Turno methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:58'!jugada2: anObject	jugada2 := anObject! !!Turno methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 11:59'!getJugadas	! !!Jugador methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/27/2018 11:59' prior: 36836460!jugadaParaTurno: unTurno	^((Random new) nextInt: 2).! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 12:11'!jugarTurno: unTurno	self determinarGanadorEntreJugador: (self jugadores at: 1) y: (self jugadores at: 2).! !Smalltalk globals removeClassNamed: #AnObsoleteTurno!Object subclass: #Juego	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Juego removeSelector: #jugadores!Juego removeSelector: #initialize!Juego removeSelector: #turnos!Juego removeSelector: #jugadores:!Juego removeSelector: #jugarTurno:!Juego removeSelector: #turnos:!Object subclass: #Jugador	instanceVariableNames: 'energia nombre'	classVariableNames: ''	package: 'OBJ2'!!Jugador methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 15:32'!nombre	^ nombre! !!Jugador methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 15:32'!nombre: anObject	nombre := anObject! !!Jugador methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/27/2018 16:06'!veinteDe: unJugador! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 16:08'!determinarGanador: j1 y: j2	| turno finalizo aux|	finalizo:= false.	turno:= 1.	((turno <= 10) & (finalizo = false)) whileTrue:[		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 2)) 			ifTrue: [j1 veinteDe: j2.j2 veinteDe: j1].		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 1))		ifTrue: [ j2 resta10 ].		(((j1 jugadaParaTurno: turno) = 1) & ((j2 jugadaParaTurno: turno) = 2)) 		ifTrue: [ j1 resta10. ].		(j1 estaVivo & j2 estaVivo) ifFalse: [ finalizo:= true ].	]! !!Jugador methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 16:09'!resta10! !!Jugador methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 16:10'!estaVivo! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 16:10' prior: 36839538!determinarGanador: j1 y: j2	| turno finalizo |	finalizo:= false.	turno:= 1.	((turno <= 10) & (finalizo = false)) whileTrue:[		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 2)) 			ifTrue: [j1 veinteDe: j2.j2 veinteDe: j1].		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 1))		ifTrue: [ j2 resta10 ].		(((j1 jugadaParaTurno: turno) = 1) & ((j2 jugadaParaTurno: turno) = 2)) 		ifTrue: [ j1 resta10. ].		(j1 estaVivo & j2 estaVivo) ifFalse: [ finalizo:= true ].	]! !!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/27/2018 16:14' prior: 36840315!determinarGanador: j1 y: j2	| turno finalizo |	finalizo:= false.	turno:= 1.	((turno <= 10) & (finalizo = false)) whileTrue:[		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 2)) 			ifTrue: [j1 veinteDe: j2.j2 veinteDe: j1].		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 1))		ifTrue: [ j2 resta10 ].		(((j1 jugadaParaTurno: turno) = 1) & ((j2 jugadaParaTurno: turno) = 2)) 		ifTrue: [ j1 resta10. ].		(j1 estaVivo & j2 estaVivo) ifFalse: [ finalizo:= true ].	].	(j1 energia = j2 energia) ifTrue: [ Transcript show: 'Empate' ].	(j1 energia > j2 energia) ifTrue: [ Transcript show: 'Jugador 1 Gano' ].	(j2 energia > j1 energia) ifTrue: [ Transcript show: 'Jugador 2 Gano' ].! !----QUIT----2018-03-27T16:17:51.484731-03:00 Pharo6.1.image priorSource: 3281238!!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/29/2018 10:45' prior: 36840920!determinarGanador: j1 y: j2	| turno finalizo |	finalizo:= false.	turno:= 1.	((turno <= 10) & (finalizo = false)) whileTrue:[		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 2)) 			ifTrue: [j1 veinteDe: j2.j2 veinteDe: j1].		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 1))		ifTrue: [ j2 resta10 ].		(((j1 jugadaParaTurno: turno) = 1) & ((j2 jugadaParaTurno: turno) = 2)) 		ifTrue: [ j1 resta10. ].		(j1 estaVivo & j2 estaVivo) ifFalse: [ finalizo:= true ].		Transcript show: 'Jugador 1 energia: ',j1 energia. Transcript show: 'Jugador 2 energia: ',j2 energia.	].	(j1 energia = j2 energia) ifTrue: [ Transcript show: 'Empate' ].	(j1 energia > j2 energia) ifTrue: [ Transcript show: 'Jugador 1 Gano' ].	(j2 energia > j1 energia) ifTrue: [ Transcript show: 'Jugador 2 Gano' ].! !----SNAPSHOT----2018-03-29T10:53:50.763215-03:00 Pharo6.1.image priorSource: 3287220!!Juego methodsFor: 'accessing' stamp: 'EncinasJavier 3/29/2018 11:07' prior: 36841823!determinarGanador: j1 y: j2	| turno finalizo |	finalizo:= false.	turno:= 1.	((turno <= 10) & (finalizo = false)) whileTrue:[		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 2)) 			ifTrue: [j1 veinteDe: j2.j2 veinteDe: j1].		(((j1 jugadaParaTurno: turno) = 2) & ((j2 jugadaParaTurno: turno) = 1))		ifTrue: [ j2 resta10 ].		(((j1 jugadaParaTurno: turno) = 1) & ((j2 jugadaParaTurno: turno) = 2)) 		ifTrue: [ j1 resta10. ].		(j1 estaVivo & j2 estaVivo) ifFalse: [ finalizo:= true ].		Transcript show: 'Jugador 1 energia: ',j1 energia. Transcript show: 'Jugador 2 energia: ',j2 energia.	].	(j1 energia = j2 energia) ifTrue: [ Transcript show: 'Empate' ].	(j1 energia > j2 energia) ifTrue: [ Transcript show: 'Jugador 1 Gano' ].	(j2 energia > j1 energia) ifTrue: [ Transcript show: 'Jugador 2 Gano' ].! !----QUIT----2018-03-29T11:07:18.673614-03:00 Pharo6.1.image priorSource: 3288227!Object subclass: #Twitter	instanceVariableNames: 'usuarios'	classVariableNames: ''	package: 'OBJ2'!Object subclass: #Usuario	instanceVariableNames: 'tweets'	classVariableNames: ''	package: 'OBJ2'!Object subclass: #Tweet	instanceVariableNames: 'texto'	classVariableNames: ''	package: 'OBJ2'!!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:50'!tweets	^ tweets! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:50'!tweets: anObject	tweets := anObject! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:50'!texto	^ texto! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:50'!texto: anObject	texto := anObject! !!Twitter methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:50'!usuarios	^ usuarios! !!Twitter methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:50'!usuarios: anObject	usuarios := anObject! !!Twitter methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:51'!nuevoUsuario: unUsuario	self usuarios add: unUsuario.! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:53'!twitear: unTexto	self tweets add: (Tweet conTexto: unTexto).! !!Tweet class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 3/31/2018 23:53'!conTexto: unTexto	^(self new)texto: unTexto.! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:58'!initialize	self tweets: OrderedCollection new.! !!Twitter methodsFor: 'accessing' stamp: 'EncinasJavier 3/31/2018 23:58'!initialize	self usuarios: OrderedCollection new.! !Object subclass: #Usuario	instanceVariableNames: 'tweets screenName'	classVariableNames: ''	package: 'OBJ2'!!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/1/2018 00:02'!screenName	^ screenName! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/1/2018 00:02'!screenName: anObject	screenName := anObject! !----QUIT----2018-04-01T00:04:36.718028-03:00 Pharo6.1.image priorSource: 3289238!Object subclass: #FrontPage	instanceVariableNames: 'tweets'	classVariableNames: ''	package: 'OBJ2'!!FrontPage methodsFor: 'accessing' stamp: 'EncinasJavier 4/3/2018 12:10'!tweets	^ tweets! !!FrontPage methodsFor: 'accessing' stamp: 'EncinasJavier 4/3/2018 12:10'!tweets: anObject	tweets := anObject! !----QUIT----2018-04-03T12:21:38.257353-03:00 Pharo6.1.image priorSource: 3291232!----QUIT/NOSAVE----2018-04-05T10:10:04.792523-03:00 Pharo6.1.image priorSource: 3291627!----QUIT/NOSAVE----2018-04-06T14:09:43.925003-03:00 Pharo6.1.image priorSource: 3291627!Smalltalk globals removeClassNamed: #AnObsoleteFrontPage!!AnObsoleteFrontPage methodsFor: 'nil' stamp: 'EncinasJavier 4/6/2018 14:14'!print		self tweets do: [ :tw | Transcript show: tw   ]! !----QUIT/NOSAVE----2018-04-06T14:15:17.227017-03:00 Pharo6.1.image priorSource: 3291627!Smalltalk globals removeClassNamed: #AnObsoleteFrontPage!!Tweet class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/6/2018 14:17'!conTexto: unTexto op: anUser	^(self new)texto: unTexto;op: anUser.! !Tweet class removeSelector: #conTexto:!Object subclass: #Tweet	instanceVariableNames: 'texto op'	classVariableNames: ''	package: 'OBJ2'!Object subclass: #Tweet	instanceVariableNames: 'texto op'	classVariableNames: ''	package: 'OBJ2'!!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 14:18'!op	^ op! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 14:18'!op: anObject	op := anObject! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 14:19' prior: 36844881!twitear: unTexto	self tweets add: (Tweet conTexto: unTexto op:self).! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 14:40'!reTwitear: unTweet! !Object subclass: #Usuario	instanceVariableNames: 'retweets tweets screenName'	classVariableNames: ''	package: 'OBJ2'!!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 14:59'!retweets	^ retweets! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 14:59'!retweets: anObject	retweets := anObject! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 15:00' prior: 36847488!reTwitear: unTweet	self retweets add: unTweet.! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 15:01'!printTweets	! !Object subclass: #Tweet	instanceVariableNames: 'date texto op'	classVariableNames: ''	package: 'OBJ2'!!Tweet class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/6/2018 15:01' prior: 36846755!conTexto: unTexto op: anUser	^(self new)texto: unTexto;op: anUser;date: DateAndTime now.! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/6/2018 15:12'!printTweet: aTweet! !Usuario removeSelector: #printTweets!Usuario removeSelector: #printTweet:!----QUIT----2018-04-06T15:14:11.519797-03:00 Pharo6.1.image priorSource: 3291627!!Random methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:07' prior: 57413693!nextInt: anInteger	"Answer a random integer in the uwuinterval [1, anInteger].	Handle large numbers too (for cryptography)."	anInteger strictlyPositive ifFalse: [ self error: 'Rangebb must be positive' ].	anInteger asFloat isInfinite		ifTrue: [^(self privateNextValue asFraction * anInteger) truncated + 1].	^ (self privateNextcaquitaValue * anInteger) truncated + 1! !----QUIT/NOSAVE----2018-04-07T19:10:53.197537-03:00 Pharo6.1.image priorSource: 3294112!!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:35'!date	^ date! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:35'!date: anObject	date := anObject! !Tweet subclass: #Retweet	instanceVariableNames: 'retweetedBy'	classVariableNames: ''	package: 'OBJ2'!!Retweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:39'!retweetedBy	^ retweetedBy! !!Retweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:39'!retweetedBy: anObject	retweetedBy := anObject! !Object subclass: #Usuario	instanceVariableNames: 'tweets screenName'	classVariableNames: ''	package: 'OBJ2'!Usuario removeSelector: #retweets!Usuario removeSelector: #retweets:!!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:44'!retweet: unTweet	self tweets add:(((Retweet new)= unTweet )retweetedBy: self).! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 19:54' prior: 36849962!retweet: unTweet	"copia los elemenos de unTweet, crea un retweet y me asigno como retweeter"	self tweets add:(((Retweet new)copyFrom: unTweet)retweetedBy: self).! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 20:01'!asString	self date,self op, self texto.! !!Retweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 20:04'!asString	^self retweetedBy,(super asString).! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 20:05' prior: 36850370!asString	self op, self texto,self dat.! !!Tweet methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 20:05' prior: 36850621!asString	^self op, self texto,self date.! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 20:26'!printFeed	self tweets do:[ :t | t print].! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/7/2018 20:28' prior: 36850867!printFeed	self tweets do:[ :t | Transcript show: t asString;cr].! !----QUIT----2018-04-07T20:31:30.56058-03:00 Pharo6.1.image priorSource: 3294112!!Tweet class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/8/2018 11:05' prior: 36848280!conTexto: unTexto op: anUser	( unTexto size < 140 ) ifTrue:	[^(self new)texto: unTexto;op: anUser;date: DateAndTime now]	ifFalse:	[^Error ]! !!Tweet class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/8/2018 11:05' prior: 36851254!conTexto: unTexto op: anUser	( unTexto size < 140 ) ifTrue:	[^(self new)texto: unTexto;op: anUser;date: DateAndTime now]	ifFalse:[^Error].! !!Twitter methodsFor: 'accessing' stamp: 'EncinasJavier 4/8/2018 11:12' prior: 36844750!nuevoUsuario: unUsuario	(self usuarios includes: unUsuario) ifFalse: [	self usuarios add: unUsuario ]	ifTrue:[^Error].! !----QUIT----2018-04-08T11:12:24.548462-03:00 Pharo6.1.image priorSource: 3296637!Object subclass: #Facebook	instanceVariableNames: 'posts'	classVariableNames: ''	package: 'OBJ2'!!Facebook methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:07'!posts	^ posts! !!Facebook methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:07'!posts: anObject	posts := anObject! !Twitter subclass: #TwitterAdapter	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!!Facebook methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:09'!post: aPost.	self posts add: aPost.! !Facebook subclass: #TwitterAdapter	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!!TwitterAdapter methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/10/2018 11:13'!post: aPost	(aPost size < 140) ifTrue:[aPost trimRight: (140 - aPost size)*(-1)].! !!TwitterAdapter methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:16' prior: 36852664!post: aPost	(aPost size < 140) ifTrue:[aPost trimRight: (140 - aPost size)*(-1)].	! !!TwitterAdapter methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:25' prior: 36852846!post: aPost	|trimeado|	trimeado:= aPost.	(trimeado size < 140)ifTrue:[trimeado trimRight: (140 - trimeado size)*(-1)].	self tweeter twitear: trimeado.		! !Facebook subclass: #TwitterAdapter	instanceVariableNames: 'tweeter'	classVariableNames: ''	package: 'OBJ2'!!TwitterAdapter methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:25'!tweeter	^ tweeter! !!TwitterAdapter methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:25'!tweeter: anObject	tweeter := anObject! !!TwitterAdapter methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 11:29' prior: 36853030!post: aPost	|trimeado|	trimeado:= aPost.	(trimeado size < 140)ifTrue:[trimeado trimRight: (140 - trimeado size)*(-1)].	self tweeter twitear: trimeado.		! !----SNAPSHOT----2018-04-10T11:43:59.211696-03:00 Pharo6.1.image priorSource: 3297429!Object subclass: #Biblioteca	instanceVariableNames: 'socios exporter'	classVariableNames: ''	poolDictionaries: ''	category: 'Biblioteca'!!Biblioteca methodsFor: 'as yet unclassified' stamp: 'DiegoTowers 4/10/2016 16:17'!exportarSocios"Retorna la representacion JSON de la coleccion de socios."^ self exporter export:(self socios).! !!Biblioteca methodsFor: 'initialization' stamp: 'EmilianoPrez 4/7/2016 19:44'!initialize	socios:= OrderedCollection new.	exporter:= VoorheesExporter new.! !!Biblioteca methodsFor: 'initialization' stamp: 'EmilianoPrez 4/7/2016 19:56'!initialize: anExporter	socios:= OrderedCollection new.	exporter:= anExporter.! !!Biblioteca methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:44'!exporter	^ exporter! !!Biblioteca methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:44'!socios: anObject	socios := anObject! !!Biblioteca methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:44'!exporter: anObject	exporter := anObject! !!Biblioteca methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:44'!socios	^ socios! !!Biblioteca methodsFor: 'socios' stamp: 'EmilianoPrez 4/7/2016 19:41'!agregarSocio: aSocio 	socios add: aSocio.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Biblioteca class	instanceVariableNames: ''!!Biblioteca class methodsFor: 'as yet unclassified' stamp: 'EmilianoPrez 4/7/2016 19:55'!new: anExporter	^self new initialize: anExporter	! !Object subclass: #Socio	instanceVariableNames: 'nombre email legajo'	classVariableNames: ''	poolDictionaries: ''	category: 'Biblioteca'!!Socio methodsFor: 'initialization' stamp: 'EmilianoPrez 4/7/2016 19:40'!nombre: aString email: aString2 legajo: aString3 	nombre:= aString.	email:= aString2.	legajo:= aString3.! !!Socio methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:45'!nombre: anObject	nombre := anObject! !!Socio methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:45'!email: anObject	email := anObject! !!Socio methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:45'!legajo: anObject	legajo := anObject! !!Socio methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:45'!email	^ email! !!Socio methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:45'!legajo	^ legajo! !!Socio methodsFor: 'accessing' stamp: 'EmilianoPrez 4/7/2016 19:45'!nombre	^ nombre! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Socio class	instanceVariableNames: ''!!Socio class methodsFor: 'creation' stamp: 'EmilianoPrez 4/7/2016 19:39'!nombre: aString email: aString2 legajo: aString3 	^self new nombre: aString email: aString2 legajo: aString3 ! !Object subclass: #VoorheesExporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Biblioteca'!!VoorheesExporter methodsFor: 'exporting' stamp: 'EmilianoPrez 4/7/2016 20:37'!exportSocio: aSocio	^		'	{', Character cr asString,		'		"nombre" : "',aSocio nombre,'",',Character cr asString,		'		"email" : "',aSocio email,'",',Character cr asString,		'		"legajo" : "',aSocio legajo,'"',Character cr asString,		'	}'! !!VoorheesExporter methodsFor: 'exporting' stamp: 'EmilianoPrez 4/7/2016 20:50'!export: socios 		| exportedString |		exportedString := '[', Character cr asString, 	(self exportSocio: socios first). 	socios allButFirst do: [ :socio | 		exportedString := exportedString, ',', Character cr asString, (self exportSocio: socio).			].		^exportedString,Character cr asString,']'.! !----End fileIn----!!ConfigurationOfNeoJSON commentStamp: '<historical>' prior: 0!I am ConfigurationOfNeoJSON, a Metacello configuration for NeoJSON.NeoJSON is a flexible and efficient reader and writer for JSON.!!ConfigurationOfNeoJSON class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:38'!catalogContactInfo	^ 'Written and maintained by Sven Van Caekenberghe (http://stfx.eu) and the community. Discussions on the Pharo mailing lists.'! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:39'!catalogDescription	^ 'JSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.'! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:39'!catalogKeywords	^ #(format input output json serialization encoding text javascript)! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfNeoJSON class methodsFor: 'metacello tool support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!project	^self new project! !!ConfigurationOfNeoJSON class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfNeoJSON methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 6/22/2012 16:53'!baseline1: spec	<version: '1-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://mc.stfx.eu/Neo';			package: 'Neo-JSON-Core';			package: 'Neo-JSON-Tests' with: [ spec requires: 'Neo-JSON-Core' ];			group: 'default' with: #('Neo-JSON-Core' 'Neo-JSON-Tests');			group: 'Core' with: #('Neo-JSON-Core');			group: 'Tests' with: #('Neo-JSON-Tests') ]! !!ConfigurationOfNeoJSON methodsFor: 'baselines' stamp: 'PaulDeBruicker 11/2/2014 20:39'!baseline2: spec	<version: '2-baseline'>	spec		for: #common		do: [ 			spec				blessing: #baseline;				repository: 'http://mc.stfx.eu/Neo';				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: 'Neo-JSON-Core' ];				group: 'default' with: #('Neo-JSON-Core' 'Neo-JSON-Tests');				group: 'Core' with: #('Neo-JSON-Core');				group: 'Tests' with: #('Neo-JSON-Tests') ].	spec		for: #gemstone		do: [ 			spec				baseline: 'NeoJSON' with: [ spec repository: 'github://GsDevKit/NeoJSON:master/repository' ];				import: 'NeoJSON' ]! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 7/11/2016 10:22'!bleedingEdge: spec	<symbolicVersion: #'bleedingEdge'>! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 7/11/2016 10:22'!development: spec	<symbolicVersion: #'development'>! !!ConfigurationOfNeoJSON methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 12/19/2017 15:30'!stable: spec	<symbolicVersion: #'stable'>		spec for: #common version: '17'.		spec for: #gemstone version: '13'.! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 3/29/2015 11:39'!version10: spec	<version: '10' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.29';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.26' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 11/25/2015 09:34'!version11: spec	<version: '11' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.30';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.30' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/22/2016 12:58'!version12: spec	<version: '12' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.31';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.31' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 7/4/2016 14:58'!version13: spec	<version: '13' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.33';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.33' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:46'!version14: spec	<version: '14' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.37';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.35' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:50'!version15: spec	<version: '15' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.37';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.36' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 5/29/2017 14:40'!version16: spec	<version: '16' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.42';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.39' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/19/2017 15:30'!version17: spec	<version: '17' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.46';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.44' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 9/27/2012 20:29'!version1: spec	<version: '1' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.17';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.15' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/18/2012 10:27'!version2: spec	<version: '2' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.19';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.16' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 5/29/2013 15:54'!version3: spec	<version: '3' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.20';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.16' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 8/30/2013 11:12'!version4: spec	<version: '4' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.23';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.18' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 9/3/2013 12:22'!version5: spec	<version: '5' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.19' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/27/2013 19:02'!version6: spec	<version: '6' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.20' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/27/2013 21:44'!version7: spec	<version: '7' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.21' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/21/2014 20:08'!version8: spec	<version: '8' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.22' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 4/24/2014 13:29'!version9: spec	<version: '9' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.27';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.24' ]! !"ConfigurationOfNeoJSON"!!NeoJSONMapper commentStamp: '<historical>' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: 'SvenVanCaekenberghe 3/16/2016 11:23' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '<historical>' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: 'SvenVanCaekenberghe 3/23/2014 19:22' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '<historical>' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '<historical>' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '<historical>' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '<historical>' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONObject commentStamp: 'SvenVanCaekenberghe 4/26/2017 10:53' prior: 0!I am NeoJSONObject.I am a Dictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	Except that in the first case, self is returned.I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	NeoJSONObject new foo: 1; bar: -2.	{ #x -> 100. #y -> 200 } as: NeoJSONObject.	(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.I use JSON as my printed representation. To convert me to JSON, use #printString or #asString.Additionally, I support path access for nested instances of me, using #atPath: and #atPath:put:The first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.	NeoJSONObject new atPath: #(one two three) put: 42; yourself.	NeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).		!!NeoJSONParseError commentStamp: '<historical>' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONMappingNotFound commentStamp: '<historical>' prior: 0!I am NeoJSONMappingNotFound.I am a NotFound exception.I am signalled when no mapping is found for a schema.!!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/22/2014 10:57'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 3/22/2014 10:56'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 3/22/2014 10:57'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:48'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:24'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 14:55'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/9/2012 18:29'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:26'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:30'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/13/2012 16:10'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/6/2013 14:46'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 13:50'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 21:26'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/12/2012 15:54'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:01'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 09:38'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:39'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:37'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:38'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:37'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:38'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:57'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:51'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/7/2012 16:56'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/16/2016 11:21'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/16/2016 10:58'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 16:10'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 10:25'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	char 		ifNil: [ self error: 'invalid escape, end of file' ]		ifNotNil: [ self error: 'invalid escape character \' , char asString ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:48'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:41'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:21'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:16'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:17'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 10:56'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			(self matchChar: $,)				ifFalse: [ self error: ', or ] expected' ] ].	self error: 'incomplete list'! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:16'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 10:56'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		(self matchChar: $,)			ifFalse: [ self error: ', or } expected' ] ].	self error: 'incomplete map'! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:22'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/3/2012 11:08'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 09:45'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	(readStream atEnd or: [ readStream peek isDigit not ])		ifTrue: [ self error: 'number exponent expected' ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	number positive 		ifTrue: [ number > Float emax ifTrue: [ self error: 'number exponent too large' ] ]		ifFalse: [ number < Float emin ifTrue: [ self error: 'number exponent too small' ] ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/2/2012 14:00'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10.0 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:15'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:40'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/10/2017 13:51'!parseString	| result |	(readStream peekFor: $")		ifFalse: [ self error: '" expected' ].	result := self stringStreamContents: [ :stream | 		[ readStream atEnd or: [ readStream peek = $" ] ] 			whileFalse: [ stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:49'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:56'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:39'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 16:54'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"		stringStream 		ifNil: [ 			stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 16:55'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/14/2012 09:54'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:27'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:28'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/13/2017 18:37'!asciiOnly: boolean	"Set whether I should escape all non ASCII characters or not"		asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/13/2017 18:37'!close	"Close the stream that I write to"		writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 9/3/2013 11:58'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 9/3/2013 11:55'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:41'!encodeKey: key value: value	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/23/2014 21:53'!encodeKey: key value: value as: valueSchema	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:17'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:29'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 10:06'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:31'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 5/28/2014 20:43'!initialize	super initialize.	self newLine: String cr.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	level := 0! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:32'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:32'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/13/2017 18:38'!newLine: string	"Set the newline string that I should use when pretty printing"		newLine := string! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/17/2014 11:58'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/17/2014 11:55'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 11/13/2017 18:34'!nextPut: anObject	"Primary interface. Write a JSON representation of anObject to my stream."		anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 11/13/2017 18:30'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	(schema isNil or: [ anObject isNil ]) ifTrue: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/14/2012 09:54'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/13/2017 18:38'!prettyPrint: boolean	"Set whether I should pretty print the JSON that I write"	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/10/2012 16:33'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:18'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:19'!writeFloat: float	float printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:18'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:20'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:04'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 11/13/2017 18:35'!writeNil	"Return whether I will write nil/null properties of objects or skip them."		^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/13/2017 18:39'!writeNil: boolean	"Set whether I will write nil/null properties of objects or skip them."		writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:15'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/7/2012 15:55'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'MaxLeske 4/30/2017 13:40'!writeString: string	writeStream nextPut: $".	1 to: string size do: [ :index |		self encodeChar: (string at: index) ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:14'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:14'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:24'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 9/22/2017 14:46'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 9/22/2017 14:45'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient, no element type known anyway"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 9/22/2017 14:46'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ].	self writer: [ :jsonWriter :list | 		jsonWriter writeListStreamingDo: [ :listWriter |			list do: [ :each | 				listWriter writeElement: each as: elementSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 9/22/2017 14:45'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ].	self writer: [ :jsonWriter :map | 		jsonWriter writeMapStreamingDo: [ :mapWriter |			map keysAndValuesDo: [ :key :value | 				mapWriter writeKey: key value: value as: valueSchema ] ] ]! !!NeoJSONCustomMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:34'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:36'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:09'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 22:10'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 22:12'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:22'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:24'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:23'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:23'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 11/13/2017 18:40'!allowNil	"Set that I will allow nil/null values when I read/expect an object"		allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:25'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 7/11/2016 10:54'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:13'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:12'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:13'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 7/6/2017 09:55'!mapAccessors: accessors	^ accessors collect: [ :each | self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 7/6/2017 09:55'!mapAllInstVars	^ self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/9/2012 18:37'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/9/2012 18:36'!mapInstVar: instVarName to: propertyName	| index |	index := subjectClass 		instVarIndexFor: instVarName 		ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] ! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 7/6/2017 09:55'!mapInstVars	^ self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 7/6/2017 09:55'!mapInstVars: instVarNames	^ instVarNames collect: [ :each | self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 7/11/2016 11:01'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:58'!propertyNamed: propertyName ifAbsent: block	^ properties detect: [ :each | each propertyName = propertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/30/2015 11:48'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:32'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:54'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 7/4/2013 19:07'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:59'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!propertyName: string	propertyName := string! !!NeoJSONPropertyMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/8/2012 17:04'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2012 17:01'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:46'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/6/2012 15:05'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/6/2012 14:48'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/6/2012 14:49'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:00'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:15'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 9/22/2017 14:38'!writeElement: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:01'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 21:53'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:45'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/5/2012 22:29'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!Number methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:17'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:30'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONObject class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 9/8/2014 13:33'!fromString: string	"Parse string as JSON, so that maps become instances of me"	^ (NeoJSONReader on: string readStream)			mapClass: NeoJSONObject;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:43'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."		^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/26/2017 09:06'!atPath: keyCollection	"Use each key in keyCollection recursively, stop when nil is encountered"		| value |	value := self.	keyCollection do: [ :each |		value := value at: each.		value ifNil: [ ^ nil ] ].	^ value ! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/26/2017 11:29'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed"		| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		(target at: each)			ifNil: [ target := target at: each put: target species new ]			ifNotNil: [ :subValue | target := subValue ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONObject methodsFor: 'reflective operations' stamp: 'SvenVanCaekenberghe 2/3/2017 14:29'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned"		| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:46'!name	"Overwritten to make this accessor available as key"		^ self at: #name! !!NeoJSONObject methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:45'!printOn: stream	"I use my JSON representation when printing myself"		(NeoJSONWriter on: stream) nextPut: self! !!NeoJSONObject methodsFor: 'evaluating' stamp: 'SvenVanCaekenberghe 9/8/2014 11:46'!value	"Overwritten to make this accessor available as key"		^ self at: #value! !!UndefinedObject methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:15'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!String methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:26'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!Boolean methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:14'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!Integer methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:17'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!OrderedDictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 8/26/2015 12:03'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!Collection methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:29'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !!SmallDictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:30'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONMappingNotFound methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:47'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !"Neo-JSON-Core"!!NeoJSONBenchmarkTests commentStamp: 'SvenVanCaekenberghe 6/5/2012 10:05' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONExamplesTests commentStamp: 'SvenVanCaekenberghe 7/6/2017 09:50' prior: 0!NeoJSONExamplesTests runs a couple of examples as tests!!NeoJSONMappingTests commentStamp: 'SvenVanCaekenberghe 9/22/2017 15:07' prior: 0!I am NeoJSONMappingTests, testing more exotic kinds of mapping constructs.!!NeoJSONObjectTests commentStamp: 'SvenVanCaekenberghe 9/8/2014 12:39' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: 'SvenVanCaekenberghe 6/2/2012 14:02' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: 'SvenVanCaekenberghe 6/4/2012 15:34' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: 'SvenVanCaekenberghe 11/24/2016 10:07' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: 'SvenVanCaekenberghe 11/24/2016 10:07' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: 'SvenVanCaekenberghe 6/5/2012 09:50' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: 'SvenVanCaekenberghe 6/2/2012 22:20' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: 'SvenVanCaekenberghe 6/5/2012 09:48' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '<historical>' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '<historical>' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: 'SvenVanCaekenberghe 3/22/2014 09:36' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: 'SvenVanCaekenberghe 3/22/2014 09:40' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONValidation commentStamp: 'SvenVanCaekenberghe 5/28/2017 16:40' prior: 0!I am NeoJSONValidation, a set of tests to validate NeoJSON against some external rules.Both positive & negative tests are includes.Some of these are implementation choices.http://seriot.ch/parsing_json.phphttps://github.com/nst/JSONTestSuitehttps://github.com/nst/JSONTestSuite.git  test_parsing  test_transformhttps://github.com/miloyip/nativejson-benchmarkhttps://github.com/miloyip/nativejson-benchmark.git  data/jsonchecker  data/roundtripThis can only be run with the correct setup (checkout/config).  NeoJSONValidation new runNativeJsonBenchmarkRoundTrip.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerPasses.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingPasses.  NeoJSONValidation new runJsonTestSuiteTestParsingFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingInfo.Logging goes to a file, neo-json-validation.log!!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:20'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:29'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:30'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:30'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 7/6/2017 10:24'!testPoints	| points json result |		points := { 1@2. 3@4. 5@6 }.		json := String streamContents: [ :out |		(NeoJSONWriter on: out)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: points ].			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #ListOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ListOfPoints.		self assert: result equals: points.				result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		nextListAs: Point.		self assert: result equals: points.			result := (NeoJSONReader on: json readStream)		mapInstVarsFor: Point;		for: #OrderedCollectionOfPoints customDo: [ :mapping |			mapping listOfType: OrderedCollection andElementSchema: Point ];		nextAs: #OrderedCollectionOfPoints.		self assert: result equals: points asOrderedCollection.! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 7/6/2017 09:56'!testRectanglePoints	| rectangle rectangleJson result |	rectangle := Rectangle origin: 3 @ 4 extent: 5 @ 6.	rectangleJson := String streamContents: [ :stream | 		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			mapInstVarsFor: Rectangle;			nextPut: rectangle ].	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			(mapping mapInstVar: #origin) valueSchema: Point.			(mapping mapInstVar: #corner) valueSchema: Point ];		nextAs: Rectangle.	self assert: result equals: rectangle.	result := (NeoJSONReader on: rectangleJson readStream)		mapInstVarsFor: Point;		for: Rectangle do: [ :mapping | 			mapping mapInstVars do: [ :each | each valueSchema: Point ] ];		nextAs: Rectangle.			self assert: result equals: rectangle ! !!NeoJSONExamplesTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 11/13/2017 18:51'!testRectanglePointsWithNils	self		assert: 			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					nextPut: Rectangle new ])		equals: '{}'.	self		assert:			(String streamContents: [ :stream | 				(NeoJSONWriter on: stream)					for: Point do: [ :mapping | mapping mapAllInstVars ];					for: Rectangle	do: [ :mapping | 						(mapping mapInstVar: #origin) valueSchema: Point.						(mapping mapInstVar: #corner) valueSchema: Point ];					writeNil: true;					nextPut: Rectangle new ])		equals: '{"origin":null,"corner":null}'.! !!NeoJSONMappingTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/26/2017 13:40'!testDynamicTyping	| data customMapping json result |	data := Array with: #foo->1 with: #(foo 2).	"The idea is to map a key value combination as either a classic association or a simple pair, 	using key & value properties as well as a type property to distinguish between the two"	customMapping := [ :mapper |		mapper 			for: #AssocOrPair customDo: [ :mapping |				mapping					encoder: [ :x | 						x isArray 							ifTrue: [ { #type->#pair. #key->x first. #value->x second } asDictionary ] 							ifFalse: [ { #type->#assoc. #key->x key. #value->x value } asDictionary ] ];					decoder: [ :x |						(x at: #type) = #pair							ifTrue: [ Array with: (x at: #key) with: (x at: #value) ]							ifFalse: [ (x at: #key) -> (x at: #value)] ] ];			for: #ArrayOfAssocOrPair customDo: [ :mapping |				mapping listOfType: Array andElementSchema: #AssocOrPair ];			yourself ].	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #ArrayOfAssocOrPair ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #ArrayOfAssocOrPair.	self assert: result equals: data! !!NeoJSONMappingTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/26/2017 14:13'!testVirtualTransferObject	| data customMapping extraJson json result |	data := NeoJSONObject new data: { 1@1. 2@2 }.	extraJson := '{"foo":1,"data":[{"x":1,"y":1},{"x":2,"y":2,"z":-1}]}'.	"The idea here is that we are not interested in the top level object just in its data property, 	which should be of a specific type, hence we create a virtual transfer object"	customMapping := [ :mapper |		mapper			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			for: #TransferObject do: [ :mapping |				mapping subjectClass: NeoJSONObject.				(mapping mapAccessor: #data) valueSchema: #ArrayOfPoints ];			yourself ].	"By using NeoJSONObject accessors (#data & #data:) are translated to generic #at:[put:] messages.	A longer alternative is 	(mapping mapProperty: #data getter: [ :obj | obj at: #data ] setter: [ :obj :x | obj at: #data put: x]) valueSchema: #ArrayOfPoints	where the blocks give you the flexibility to use a plain Dictionary for example"	result := (customMapping value: (NeoJSONReader on: extraJson readStream)) nextAs: #TransferObject.	self assert: result equals: data.	json := String streamContents: [ :out |		(customMapping value: (NeoJSONWriter on: out)) nextPut: data as: #TransferObject ].	result := (customMapping value: (NeoJSONReader on: json readStream)) nextAs: #TransferObject.	self assert: result equals: data! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 4/26/2017 16:14'!testAtPath	| object |	object := { #one -> ({ #two -> ({ #three -> 42 } as: NeoJSONObject) } as: NeoJSONObject) } as: NeoJSONObject.	self assert: (object atPath: #(one two three)) equals: 42.	self assert: (object atPath: #(one two three)) equals: object one two three.		self assert: (object atPath: #(missing)) equals: nil.	self assert: (object atPath: #(one missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: object one two missing.		object := { #foo -> 42 } as: NeoJSONObject.	self assert: (object atPath: #(foo)) equals: 42.	self assert: (object atPath: #(foo)) equals: object foo.	self assert: (object atPath: #(foo)) equals: (object at: #foo).	self assert: (object atPath: #()) equals: object.	! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 4/26/2017 16:17'!testAtPathPut	| object |	object := NeoJSONObject new.	object atPath: #(one test) put: 42.	self assert: (object atPath: #(one test)) equals: 42.	self assert: object one test equals: 42.	object atPath: #(one two three) put: #foo.	self assert: (object atPath: #(one two three)) equals: #foo.	self assert: object one two three equals: #foo.	object atPath: #(one two threeBis) put: #bar.	self assert: (object atPath: #(one two threeBis)) equals: #bar.	self assert: object one two threeBis equals: #bar.		self assert: object foo isNil.	self assert: (object atPath: #() put: 1) equals: object.	self assert: (object atPath: #(foo) put: 1) equals: 1.	self assert: (object atPath: #(foo)) equals: 1.	self assert: object foo equals: 1	 ! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/8/2014 12:39'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 11/25/2015 09:19'!testJSON	| data  json object |	data := { #foo->1. #bar->2. #str->'Str!!'. #bool->true. #flt->1.5 } as: NeoJSONObject.	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/30/2015 12:29'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: { 1 @ 2. nil. 3 @ -1 }.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:32'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: { 1@2. -1@ -2 }. 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: { Point new }! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/16/2016 10:58'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: { 1@2. -1@ -2 }. 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: { Point new }! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 13:18'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 14:44'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:32'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date newDay: 8 month: 6 year: 2012)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 21:49'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:08'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:16'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:16'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 11:58'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/24/2016 14:15'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 14:29'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 10:18'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:33'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: { 1@2. -1@ -2 } asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 5/29/2017 11:00'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.		self should: [ (NeoJSONReader on: '[1,2,3]true' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '{"foo":1}"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '[]"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:58'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/7/2012 15:23'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:43'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 10:00'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 7/4/2013 18:38'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/10/2017 13:49'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '" foo "') equals: ' foo '.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'élève en Français'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 10:03'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/13/2012 16:28'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:05'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: #one put: NeoJSONTestObject2 example1;		at: #two put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:49'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:05'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:59'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/4/2012 15:45'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:03'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: #one put: NeoJSONTestObject2 example1;		at: #two put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:51'!testFloats	| objects |	objects := { Float pi . 1.0 . -1.0 . 0.0 . 1.5e6 . -1.5e6 . 1.5e-6 . -1.5e-6 }.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:46'!testIntegers	| objects |	objects := { 1. -1. 0. 123467890. -1234567890 }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:51'!testLists	| objects |	objects := { #(1 2 3). #(). #( 'foo' 'bar') }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:53'!testMaps	| objects |	objects := { 		Dictionary new.		Dictionary with: 'x' -> 1.		Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' ) }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:48'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 10:12'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:14'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:46'!testSpecials	| objects |	objects := { true. false. nil }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 11/24/2016 10:04'!testStrings	| objects |	objects := { 		'foo'. 'Foo BAR'. ''. '	\\'''. 		'élève en Français'. 		String with: (Character codePoint: 12354) "HIRAGANA LETTER A" }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/4/2012 15:36'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/3/2013 12:06'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'élève français') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 13:19'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:56'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:54'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date newDay: 8 month: 6 year: 2012)) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:24'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:24'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:39'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/4/2015 14:02'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:40'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) equals: '{"x":1,"y":2}'.	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/26/2015 14:05'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 11:57'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/24/2016 14:15'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:23'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:58'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/6/2012 17:29'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:41'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:49'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 7/1/2016 23:50'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 21:15'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:56'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time print24 ] ];				nextPut: object ] ].	self assert: (writer value: (Time hour: 14 minute: 30 second: 8)) equals: '"14:30:08"'! !!NeoJSONBenchmark methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/4/2012 18:49'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/4/2012 17:02'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/4/2012 17:26'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/6/2012 15:07'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/13/2012 16:25'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/3/2012 10:53'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/9/2012 18:06'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: { 1@2. 3@4 };		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:34'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:45'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:04'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:46'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:02'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:02'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:04'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:53'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:54'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:54'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:52'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: { count });		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: { count });		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:53'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: { count });		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: { count });		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:50'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:22'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 6/10/2012 20:47'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:22'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:50'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:45'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 3/22/2014 09:46'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!transparent: anObject	transparent := anObject! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:28'!closeLog	logStream ifNotNil: [ 		logStream close.		logStream := nil ].	^ self logFile exists		ifTrue: [ self logFile contents ] 		ifFalse: [ 'log file is empty' ]! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:27'!ensureLog	logStream ifNil: [ 		logStream := self logFile ensureDelete; writeStream. 		logStream setToEnd ]	! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:25'!gitDirectory	^ gitDirectory ifNil: [ gitDirectory := FileLocator home / #Develop / #git ]! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:23'!gitDirectory: fileReference	gitDirectory := fileReference! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:26'!jsonTestSuiteDirectory	^ self gitDirectory / #JSONTestSuite! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:27'!jsonTestSuiteTestParsingDirectory	^ self jsonTestSuiteDirectory / 'test_parsing'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 13:50'!jsonTestSuiteTestParsingFailFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'n_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 13:50'!jsonTestSuiteTestParsingInfoFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'i_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 13:50'!jsonTestSuiteTestParsingPassFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'y_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:27'!jsonTestSuiteTestTransformDirectory	^ self jsonTestSuiteDirectory / 'test_transform'! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!log: message	self ensureLog.	logStream nextPutAll: message; lf; flush! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:26'!logFile	^ 'neo-json-validation.log' asFileReference! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:28'!nativeJsonBenchmarkDataDirectory	^ self nativeJsonBenchmarkDirectory / #data! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:28'!nativeJsonBenchmarkDirectory	^ self gitDirectory / 'nativejson-benchmark'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:29'!nativeJsonBenchmarkJsonCheckerDirectory	^ self nativeJsonBenchmarkDataDirectory / #jsonchecker! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 12:05'!nativeJsonBenchmarkJsonCheckerFailFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'fail*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 12:05'!nativeJsonBenchmarkJsonCheckerPassFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'pass*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:29'!nativeJsonBenchmarkRoundTripDirectory	^ self nativeJsonBenchmarkDataDirectory / #roundtrip! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:34'!nativeJsonBenchmarkRoundTripFiles	^ self nativeJsonBenchmarkRoundTripDirectory children! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:57'!runJsonTestSuiteTestParsingFailures	^ self		validateFiles: self jsonTestSuiteTestParsingFailFiles 		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runJsonTestSuiteTestParsingInfo	^ self		validateFiles: self jsonTestSuiteTestParsingInfoFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runJsonTestSuiteTestParsingPasses	^ self		validateFiles: self jsonTestSuiteTestParsingPassFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:40'!runNativeJsonBenchmarkJsonCheckerFailures	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerFailFiles		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runNativeJsonBenchmarkJsonCheckerPasses	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerPassFiles		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runNativeJsonBenchmarkRoundTrip	^ self 		validateFiles: self nativeJsonBenchmarkRoundTripFiles		usingTest: [ :file |			| data json |			data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ].			json := NeoJSONWriter toString: data.			json = file contents ]! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!validateFiles: files usingTest: block	| total succeeded failed |	total := succeeded := failed := 0.	files do: [ :file | 		| success |		self log: 'Running ' , file pathString.		self log: ([ file contents contractTo: 64 ] on: Error do: [ :exception | exception printString ]).		success := [ block value: file ]			on: Error			do: [ :exception | self log: '  Errored. ' , exception printString. false ].		total := total + 1.		success			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed := failed + 1 ].		self log: (success ifTrue: [ '  Succeeded' ] ifFalse: [ '  Failed' ]); log: '' ].	self log: ('{1} total = {2} succeeded + {3} failed' format: { total. succeeded. failed }).	^ self closeLog! !"Neo-JSON-Tests"!Object subclass: #BibliotecaNeo	instanceVariableNames: ''	classVariableNames: ''	package: 'Biblioteca'!!BibliotecaNeo methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/10/2018 12:04'!exporter	! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:06'!initialize	super initialize. 	self exporter: NeoJSONWriter new.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:07' prior: 36982728!exporter	^self exporter.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:08'!exporter: anObject.	! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:09' prior: 36983093!exporter: anObject. 	! !BibliotecaNeo removeSelector: #exporter:!BibliotecaNeo removeSelector: #exporter!!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:12'!exportarSocios	^self exporter writeString:(self socios).! !Biblioteca subclass: #BibliotecaNeo	instanceVariableNames: ''	classVariableNames: ''	package: 'Biblioteca'!----QUIT----2018-04-10T12:17:03.129957-03:00 Pharo6.1.image priorSource: 3299353!!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:18' prior: 36982821!initialize	super initialize. 	self exporter: NeoJSONWriter new.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:20' prior: 36983754!initialize	self socios: OrderedCollection new.	self exporter: NeoJSONWriter new.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:26' prior: 36983403!exportarSocios	^self exporter toStringPretty:(self socios).! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:37' prior: 36983918!initialize	self socios: Dictionary new.	self exporter: NeoJSONWriter new.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:39'!agregarSocio: unSocio	self ! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:40' prior: 36984416!agregarSocio: unSocio	socios add: unSocio cio at: 2.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:40' prior: 36984543!agregarSocio: unSocio	socios add: unSocio at: 2.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:40' prior: 36984695!agregarSocio: unSocio	self socios add: unSocio at: 2.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:40' prior: 36984843!agregarSocio: unSocio	socios add: unSocio at: 2.! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:41' prior: 36984996!agregarSocio: unSocio	socios add: (Association key: (socios size) value: unSocio).! !----SNAPSHOT----2018-04-10T12:42:00.802378-03:00 Pharo6.1.image priorSource: 3429143!!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:46' prior: 36985144!agregarSocio: unSocio	self socios add: (Association key: (socios size) value: unSocio).! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:53' prior: 36985413!agregarSocio: unSocio	self socios add:(Dictionary new at: #email put: (unSocio email);at:#legajo put:(unSocio legajo); 	at:#nombre put:(unSocio nombre)).! !!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:53' prior: 36984258!initialize	self socios: OrderedCollection new.	self exporter: NeoJSONWriter new.! !----SNAPSHOT----2018-04-10T12:53:31.644264-03:00 Pharo6.1.image priorSource: 3430798!!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 12:54' prior: 36984099!exportarSocios	^self exporter toStringPretty:(self socios).! !BibliotecaNeo removeSelector: #initialize!!BibliotecaNeo methodsFor: 'accessing' stamp: 'EncinasJavier 4/10/2018 13:07' prior: 36986121!exportarSocios	^NeoJSONWriter toStringPretty:(self socios).! !----SNAPSHOT----2018-04-10T13:07:29.080879-03:00 Pharo6.1.image priorSource: 3431506!----QUIT----2018-04-10T13:08:23.617846-03:00 Pharo6.1.image priorSource: 3431955!----QUIT/NOSAVE----2018-04-10T14:12:57.751715-03:00 Pharo6.1.image priorSource: 3432042!Object subclass: #Topografia	instanceVariableNames: 'tierra agua'	classVariableNames: ''	package: 'OBJ2'!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:27'!tierra	^ tierra! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:27'!tierra: anObject	tierra := anObject! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:27'!agua	^ agua! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:27'!agua: anObject	agua := anObject! !Topografia subclass: #Agua	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Topografia subclass: #Tierra	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Topografia subclass: #Mixta	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:29'!proporcionAgua	^self subclassResponsibility.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:29'!proporcionTierra	^self subclassResponsibility.! !!Agua methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/21/2018 20:30'!proporcionAgua	^1.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:30'!proporcionTierra	^0.! !!Tierra methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/21/2018 20:30'!proporcionAgua	^0.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:30'!proporcionTierra	^1.! !Topografia subclass: #Mixta	instanceVariableNames: 'componentes'	classVariableNames: ''	package: 'OBJ2'!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:43'!componentes	^ componentes! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:43'!componentes: anObject	componentes := anObject! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:47'!proporcionAgua	^self componentes inject: 0 into: [ :prop :comp | prop + comp proporcionAgua ].! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 20:48'!proporcionTierra	^self componentes inject: 0 into: [ :prop :comp | prop + comp proporcionTierra ].! !!Mixta class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/21/2018 20:52'!with: componente1 with: componente2 with: componente3 with: componente4		^(self new)componentes: Array braceWith: componente1 with: componente2 with: componente3 with: componente4! !!Mixta class methodsFor: 'instance creation' stamp: 'EncinasJavier 4/21/2018 20:52' prior: 36988884!with: componente1 with: componente2 with: componente3 with: componente4		^(self new)componentes: (Array braceWith: componente1 with: componente2 with: componente3 with: componente4).! !----SNAPSHOT----2018-04-21T21:02:34.914454-03:00 Pharo6.1.image priorSource: 3432042!----SNAPSHOT----2018-04-21T21:03:24.704022-03:00 Pharo6.1.image priorSource: 3434925!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:07' prior: 36988522!proporcionAgua	^self componentes inject: 0 into: [ :prop :comp | prop= ( comp proporcionAgua )/ 4 ].! !----SNAPSHOT----2018-04-21T21:07:45.272397-03:00 Pharo6.1.image priorSource: 3435012!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:09' prior: 36989619!proporcionAgua	^(self componentes inject: 0 into: [ :prop :comp | prop + comp proporcionAgua ])/4.! !----SNAPSHOT----2018-04-21T21:09:34.337861-03:00 Pharo6.1.image priorSource: 3435292!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:11' prior: 36988693!proporcionTierra	^(self componentes inject: 0 into: [ :prop :comp | prop + comp proporcionTierra ])/4.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:20'!equalTo: otraTopografia	! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:22' prior: 36990361!equalTo: otraTopografia	^self componentes literalEqual: otraTopografia componentes.! !----SNAPSHOT----2018-04-21T21:24:39.008324-03:00 Pharo6.1.image priorSource: 3435570!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:28' prior: 36990482!equalTo: otraTopografia	^self componentes = otraTopografia componentes.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:28' prior: 36990749!equalTo: otraTopografia	^self componentes literalEqual: otraTopografia componentes.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:40' prior: 36990917!equalTo: otraTopografia	^self componentes  with: otraTopografia componentes do:		[ :c1 :c2 | (c1 proporcionAgua = c2 proporcionAgua) & (c1 proporcionTierra = c2 proporcionTierra )].	! !----SNAPSHOT----2018-04-21T21:40:46.036477-03:00 Pharo6.1.image priorSource: 3436137!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 21:41' prior: 36991097!equalTo: otraTopografia	^self componentes with: otraTopografia componentes collect:		[ :c1 :c2 | (c1 proporcionAgua = c2 proporcionAgua) & (c1 proporcionTierra = c2 proporcionTierra )].	! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 22:45'!esMixta	^true! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 22:45'!esMixta	^false.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 22:45'!esMixta	^false.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:21' prior: 36991465!equalTo: otraTopografia	self esMixta & otraTopografia esMixta ifTrue: 		[	| sonIguales | 			sonIguales:= false. 			self componentes with: otraTopografia componentes do:			[:c1 :c2 | sonIguales:=(c1 equalTo: otraTopografia) ].			^sonIguales.		]		ifFalse:[ self  ]	! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:24'!isEqualTo: otraTopografia	otraTopografia esMixta ifTrue: [ ^false ].! !Agua removeSelector: #isEqualTo:!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:31' prior: 36992021!equalTo: otraTopografia	! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:33'!equalTo: otraTopografia	|sonIguales|	sonIguales:= false.	self esMixta & otraTopografia esMixta ifTrue: 		[			self componentes with: otraTopografia componentes do:			[:c1 :c2 | sonIguales:=(c1 equalTo: otraTopografia) ].		].	^sonIguales.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:34' prior: 36992567!equalTo: otraTopografia	^(	self proporcionAgua = otraTopografia proporcionAgua )	&	(self proporcionTierra  = otraTopografia proporcionTierra ).	! !----SNAPSHOT----2018-04-21T23:35:19.494671-03:00 Pharo6.1.image priorSource: 3436853!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:36' prior: 36992668!equalTo: otraTopografia	|sonIguales|	sonIguales:= false.	self esMixta & otraTopografia esMixta ifTrue: 		[			self componentes with: otraTopografia componentes do:			[:c1 :c2 | sonIguales:=(c1 equalTo: c2) ].		].	^sonIguales.! !----SNAPSHOT----2018-04-21T23:36:42.097395-03:00 Pharo6.1.image priorSource: 3438728!!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:41'!compararseConMixta: unaTopoMixta	^false! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:42'!compararseConMixta: unaTopoMixta	^false! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:44'!compararseConMixta: unaTopoMixta		self componentes with: unaTopoMixta componentes collect:	[:c1 :c2 | c1 equalTo: c2].		! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:45' prior: 36993960!compararseConMixta: unaTopoMixta		(self componentes with: unaTopoMixta componentes collect:	[:c1 :c2 | c1 equalTo: c2]) allSatisfy: [ true ].		! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:45' prior: 36994177!compararseConMixta: unaTopoMixta		^(self componentes with: unaTopoMixta componentes collect:	[:c1 :c2 | c1 equalTo: c2]) allSatisfy: [ true ].		! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:50' prior: 36993335!equalTo: otraTopografia		otraTopografia compararseConMixta: self.! !----SNAPSHOT----2018-04-21T23:51:16.606552-03:00 Pharo6.1.image priorSource: 3439139!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:56' prior: 36994417!compararseConMixta: unaTopoMixta		self componentes with: unaTopoMixta componentes do:	[:c1 :c2 | (c1 equalTo: c2 )ifFalse:[ ^false]].	^true.		! !----SNAPSHOT----2018-04-21T23:56:35.526145-03:00 Pharo6.1.image priorSource: 3440297!!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/21/2018 23:56' prior: 36994658!equalTo: otraTopografia		^otraTopografia compararseConMixta: self.! !----SNAPSHOT----2018-04-21T23:56:57.359619-03:00 Pharo6.1.image priorSource: 3440624!----QUIT----2018-04-21T23:58:50.749868-03:00 Pharo6.1.image priorSource: 3440871!Object subclass: #Directorio	instanceVariableNames: 'nombre creacion'	classVariableNames: ''	package: 'OBJ2'!!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:25'!nombre	^ nombre! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:25'!nombre: anObject	nombre := anObject! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:25'!creacion	^ creacion! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:25'!creacion: anObject	creacion := anObject! !Directorio subclass: #Subdirectorio	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Directorio subclass: #Archivo	instanceVariableNames: 'tamaño'	classVariableNames: ''	package: 'OBJ2'!!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:27'!tamaño	^ tamaño! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:27'!tamaño: anObject	tamaño := anObject! !!Subdirectorio methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 10:28'!tamaño	^32! !!Archivo class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 10:29'!llamado: unString creadoEl: unaFecha	"Método de clase. Crea un nuevo Directorio con nombre unString y en la fecha	unaFecha"	^(self new)nombre: unString ;creacion: unaFecha;yourself.! !!Subdirectorio class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 10:30'!llamado: unString creadoEl: unaFecha tamaño: unTamaño	"Método de clase. Crea un nuevo Directorio con nombre unString y en la fecha	unaFecha"	^(self new)nombre: unString ;creacion: unaFecha; tamaño: unTamaño ;yourself.! !----SNAPSHOT----2018-04-22T10:30:24.079672-03:00 Pharo6.1.image priorSource: 3440958!Object subclass: #Directorio	instanceVariableNames: 'nombre creacion contenido'	classVariableNames: ''	package: 'OBJ2'!!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:31'!contenido	^ contenido! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:31'!contenido: anObject	contenido := anObject! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:32'!addContenido: unDato		contenido add: unDato.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:32'!initialize		contenido:= OrderedCollection new.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:37'!tamañoTotalOcupado		^self contenido inject: 0 into: [ :sum : cont | sum + cont tamaño ].! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:38' prior: 36997915!tamañoTotalOcupado		^self contenido inject: 0 into: [ :sum : cont | sum + cont tamañoTotalOcupado ].! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:54'!tamañoTotalOcupado	^(super tamañoTotalOcupado) + self tamaño.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:54'!tamañoTotalOcupado	^(super tamañoTotalOcupado) + self tamaño.! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 10:54' prior: 36998284!tamañoTotalOcupado	^self tamaño.! !----SNAPSHOT----2018-04-22T10:58:48.244872-03:00 Pharo6.1.image priorSource: 3442717!!Archivo class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 10:59'!llamado: unString creadoEl: unaFecha tamaño: unTamaño	"Método de clase. Crea un nuevo Directorio con nombre unString y en la fecha	unaFecha"	^(self new)nombre: unString ;creacion: unaFecha; tamaño: unTamaño ;yourself.! !!Subdirectorio class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 10:59'!llamado: unString creadoEl: unaFecha	"Método de clase. Crea un nuevo Directorio con nombre unString y en la fecha	unaFecha"	^(self new)nombre: unString ;creacion: unaFecha;yourself.! !Subdirectorio class removeSelector: #llamado:creadoEl:tamaño:!Archivo class removeSelector: #llamado:creadoEl:tamaño:!----SNAPSHOT----2018-04-22T11:00:14.232875-03:00 Pharo6.1.image priorSource: 3444199!!Archivo class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 11:00'!llamado: unString creadoEl: unaFecha tamaño: unTamaño	"Método de clase. Crea un nuevo Directorio con nombre unString y en la fecha	unaFecha"	^(self new)nombre: unString ;creacion: unaFecha;tamaño: unTamaño ;yourself.! !----SNAPSHOT----2018-04-22T11:00:55.788918-03:00 Pharo6.1.image priorSource: 3445012!!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:01' prior: 36997661!addContenido: unDato		self contenido add: unDato.! !----SNAPSHOT----2018-04-22T11:01:51.637645-03:00 Pharo6.1.image priorSource: 3445416!----SNAPSHOT----2018-04-22T11:04:43.342731-03:00 Pharo6.1.image priorSource: 3445650!----SNAPSHOT----2018-04-22T11:05:16.220185-03:00 Pharo6.1.image priorSource: 3445737!!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:21'!listadoDeContenido		self nombre. self contenido do: [ :cont | cont listadoDeContenido ]! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:27' prior: 37000420!listadoDeContenido		^self nombre + String cr + self contenido do: [ :cont | cont listadoDeContenido ]! !----SNAPSHOT----2018-04-22T11:27:13.055177-03:00 Pharo6.1.image priorSource: 3445824!----SNAPSHOT----2018-04-22T11:30:19.137118-03:00 Pharo6.1.image priorSource: 3446279!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:31'!listadoDeContenido		^self nombre + String cr + self contenido do: [ :cont | cont listadoDeContenido ]! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:31' prior: 37000605!listadoDeContenido		^self subclassResponsibility.! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:33'!listadoDeContenido		^self nombre ! !----SNAPSHOT----2018-04-22T11:33:51.848842-03:00 Pharo6.1.image priorSource: 3446366!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:36' prior: 37000965!listadoDeContenido		^self nombre + String cr + self contenido collect: [ :cont | cont listadoDeContenido ]! !----SNAPSHOT----2018-04-22T11:36:42.515785-03:00 Pharo6.1.image priorSource: 3446898!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:37' prior: 37001513!listadoDeContenido		^self nombre , String cr , self contenido collect: [ :cont | cont listadoDeContenido ].! !----SNAPSHOT----2018-04-22T11:37:13.395396-03:00 Pharo6.1.image priorSource: 3447192!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:37' prior: 37001807!listadoDeContenido		^self nombre ,' ', String cr ,' ',  self contenido collect: [ :cont | cont listadoDeContenido ].! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:39' prior: 37001292!listadoDeContenido		^self nombre.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:54' prior: 37002102!listadoDeContenido		^self nombre ,' ', String cr ,' ',  self contenido collect: [ :cont | cont listadoDeContenido asString].! !----SNAPSHOT----2018-04-22T11:54:53.575966-03:00 Pharo6.1.image priorSource: 3447487!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:55' prior: 37002447!listadoDeContenido		^self nombre ,' ', String cr ,' ',  self contenido collect: [ :cont | cont listadoDeContenido] asString.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 11:55' prior: 37002759!listadoDeContenido		^self nombre ,' ', String cr ,' ',  (self contenido collect: [ :cont | cont listadoDeContenido])asString.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:00' prior: 37002984!listadoDeContenido		^self nombre ,' ', String cr ,' ',  (self contenido do: [ :cont | cont listadoDeContenido])asString.! !----SNAPSHOT----2018-04-22T12:00:13.805465-03:00 Pharo6.1.image priorSource: 3448144!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:03' prior: 37003210!listadoDeContenido		^self nombre ,' ', String cr ,' ',  (self contenido collect: [ :cont | cont listadoDeContenido])asString.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:03' prior: 37003518!listadoDeContenido		^self nombre ,' ', String cr ,' ',  self contenido collect: [ :cont | cont listadoDeContenido] as: String.! !----SNAPSHOT----2018-04-22T12:04:03.139863-03:00 Pharo6.1.image priorSource: 3448903!----SNAPSHOT----2018-04-22T12:13:13.845201-03:00 Pharo6.1.image priorSource: 3449443!----SNAPSHOT----2018-04-22T12:15:57.706899-03:00 Pharo6.1.image priorSource: 3449530!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:17' prior: 37003744!listadoDeContenido	| st | 	st:= ''.	^self nombre ,' ', String cr ,' ',  self contenido do: [ :cont | st , cont nombre] .! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:18' prior: 37004232!listadoDeContenido	| st | 	st:= ''.	self contenido do: [ :cont | st , cont nombre] .	^self nombre ,' ', String cr ,' ',  st.! !----SNAPSHOT----2018-04-22T12:18:03.893072-03:00 Pharo6.1.image priorSource: 3449617!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:20' prior: 37004454!listadoDeContenido	| st | 	st:= ''.	self contenido do: [ :cont | st , cont listadoDeContenido] .	^self nombre ,' ', String cr ,' ',  st.! !----SNAPSHOT----2018-04-22T12:20:29.121916-03:00 Pharo6.1.image priorSource: 3450153!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:30' prior: 37004768!listadoDeContenido	self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:30'!sumarse	^1! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:31'!sumarse	^0! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:32' prior: 37005094!listadoDeContenido	self nombre , 'cantidad de archivos: ',self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ].	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:33' prior: 37005462!listadoDeContenido	self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:33' prior: 37005690!listadoDeContenido	^self nombre , 'cantidad de archivos: ',self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ].	! !----SNAPSHOT----2018-04-22T12:33:34.819983-03:00 Pharo6.1.image priorSource: 3450479!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:34' prior: 37005929!listadoDeContenido	^self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:35'!imprimirse	^self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:36' prior: 37006469!imprimirse	self contenido do:[ :cont | cont listadoDeContenido. ]	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:36' prior: 37006245!listadoDeContenido	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:36' prior: 37006701!imprimirse	^self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:37' prior: 37006869!listadoDeContenido	self contenido do:[ :cont | cont listadoDeContenido. ]	! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:37'!imprimirse		! !----SNAPSHOT----2018-04-22T12:37:35.414352-03:00 Pharo6.1.image priorSource: 3451630!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:37' prior: 37007219!listadoDeContenido	self contenido do:[ :cont | cont imprimirse. ]	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:38' prior: 37007573!listadoDeContenido	self imprimirse.	self contenido do:[ :cont | cont listadoDeContenido. ]	! !----SNAPSHOT----2018-04-22T12:38:14.14158-03:00 Pharo6.1.image priorSource: 3452958!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:39' prior: 37007741!listadoDeContenido	| st |	st:= self imprimirse.	self contenido do:[ :cont | cont listadoDeContenido. ].	^st.	! !----SNAPSHOT----2018-04-22T12:39:32.984643-03:00 Pharo6.1.image priorSource: 3453407!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:54' prior: 37008021!listadoDeContenido		^self contenido do:[ :cont | self imprimirse,cont listadoDeContenido. ].		! !----SNAPSHOT----2018-04-22T12:54:16.210303-03:00 Pharo6.1.image priorSource: 3453707!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:54' prior: 37008322!listadoDeContenido		^self contenido collect:[ :cont | self imprimirse,cont listadoDeContenido. ].		! !----SNAPSHOT----2018-04-22T12:55:01.960639-03:00 Pharo6.1.image priorSource: 3453992!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 12:59' prior: 37008607!listadoDeContenido		^Stream with:(self contenido collect:[ :cont | self imprimirse,cont listadoDeContenido.]).		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 13:00' prior: 37008897!listadoDeContenido		^Stream on:(self contenido collect:[ :cont | self imprimirse,cont listadoDeContenido.]).		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 13:00' prior: 37009113!listadoDeContenido		^DecoratorStream on:(self contenido collect:[ :cont | self imprimirse,cont listadoDeContenido.]).		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 13:01' prior: 37009327!listadoDeContenido	|st|	self contenido do:[ :cont | st:= self imprimirse,cont listadoDeContenido.].	^st.	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 13:02' prior: 37009550!listadoDeContenido	|st|	self imprimirse.	self contenido do:[ :cont | st:= cont listadoDeContenido.].	^st.	! !----SNAPSHOT----2018-04-22T13:02:11.583291-03:00 Pharo6.1.image priorSource: 3454282!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 13:04' prior: 37009759!listadoDeContenido	|st|	self imprimirse.	self contenido do:[ :cont | cont listadoDeContenido. st:= cont imprimirse.].	^st.	! !----SNAPSHOT----2018-04-22T13:04:16.401555-03:00 Pharo6.1.image priorSource: 3455442!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 13:05' prior: 37010057!listadoDeContenido		self imprimirse.	self contenido do:[ :cont | cont imprimirse].		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:01' prior: 37010372!listadoDeContenido		self imprimirse.	self contenido do:[ :cont | cont listadoDeContenido].		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:05' prior: 37010561!listadoDeContenido		self imprimirse.	^(Symbol new) withAll: (self contenido collect:[ :cont | cont listadoDeContenido]).		! !----SNAPSHOT----2018-04-22T14:05:36.889027-03:00 Pharo6.1.image priorSource: 3455757!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:06' prior: 37010758!listadoDeContenido		self imprimirse.	^Symbol withAll: (self contenido collect:[ :cont | cont listadoDeContenido]).		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:08' prior: 37011072!listadoDeContenido		^self imprimirse,	Symbol withAll: (self contenido collect:[ :cont | cont listadoDeContenido]).		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:10' prior: 37011293!listadoDeContenido		^self imprimirse,	(self contenido collect:[ :cont | cont listadoDeContenido])asString.		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:18' prior: 37011514!listadoDeContenido		^'-',self imprimirse, 	(self contenido collect:[ :cont | cont listadoDeContenido])asString.		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:18' prior: 37011727!listadoDeContenido		^self imprimirse, 	(self contenido collect:[ :cont | cont listadoDeContenido])asString.		! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:19' prior: 37006990!imprimirse	^'-',self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.! !----SNAPSHOT----2018-04-22T14:19:36.799004-03:00 Pharo6.1.image priorSource: 3456457!!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:25'!printOn: aStream.	self printOn: aStream indentation: 0.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:25' prior: 37012454!printOn: aStream.	self printOn: aStream.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:27'!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Agua'.	aStream nextPutAll: Character cr.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:27'!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Tierra'.	aStream nextPutAll: Character cr.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:28'!printOn: aStream	self printOn: aStream indentation: 0.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:30'!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Mixta ('.	aStream nextPutAll: Character cr.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ')'.	aStream nextPutAll: Character cr.! !Agua removeSelector: #printOn:!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:44' prior: 37013191!printOn: aStream 	self printOn: aStream indentation: 0.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:52' prior: 37013321!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Mixta ('.	aStream nextPut: Character cr.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ')'.	aStream nextPutAll: Character cr.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:53' prior: 37013962!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Mixta ('.	aStream nextPut: Character cr.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	aStream nextPut: Character cr! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:53' prior: 37014416!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Mixta ('.	aStream nextPut: Character cr.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ')'.	aStream nextPut: Character cr.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:53' prior: 37012715!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Agua'.	aStream nextPut: Character cr.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 14:53' prior: 37012950!printOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Tierra'.	aStream nextPut: Character cr.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:01'!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '\"Tierra\"'.	aStream nextPut: Character cr.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:01' prior: 37015833!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '\"Tierra\",'.	aStream nextPut: Character cr.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:02'!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '"Agua",'.	aStream nextPut: Character cr.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:02' prior: 37016091!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '"Tierra",'.	aStream nextPut: Character cr.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:02' prior: 37016588!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '"Tierra"'.	aStream nextPut: Character cr.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:02' prior: 37016332!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '"Agua"'.	aStream nextPut: Character cr.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:04'!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Mixta ('.	aStream nextPut: Character cr.	aStream nextPutAll: ','.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ')'.	aStream nextPut: Character cr.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:04' prior: 37017337!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: 'Mixta ('.	aStream nextPut: Character cr.	aStream nextPutAll: ','.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ']'.	aStream nextPut: Character cr.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:05' prior: 37017818!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '"Mixta":['.	aStream nextPut: Character cr.	aStream nextPutAll: ','.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space ].	aStream nextPutAll: ']'.	aStream nextPut: Character cr.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:06' prior: 37018299!printJSONOn: aStream indentation: spaces	spaces timesRepeat: [ aStream nextPut: Character space ].	aStream nextPutAll: '"Mixta":['.	aStream nextPut: Character cr.	self componentes do: [ :each | each printOn: aStream indentation: spaces + 4 ].	1 to: spaces do: [ :i | aStream nextPut: Character space.	aStream nextPutAll: ','. ].	aStream nextPutAll: ']'.	aStream nextPut: Character cr.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:07'!printJSONOn: aStream 	self printOn: aStream indentation: 0.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 15:07' prior: 37019254!printJSONOn: aStream 	self printJSONOn: aStream indentation: 0.! !Object subclass: #Empleado	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Empleado subclass: #Temporario	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Empleado subclass: #Pasantes	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Smalltalk globals removeClassNamed: #AnObsoletePasantes!Empleado subclass: #Pasante	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Empleado subclass: #Planta	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Empleado subclass: #Planta	instanceVariableNames: 'tieneHijos'	classVariableNames: ''	package: 'OBJ2'!Empleado subclass: #Planta	instanceVariableNames: ''	classVariableNames: ''	package: 'OBJ2'!Object subclass: #Empleado	instanceVariableNames: 'tieneHijos'	classVariableNames: ''	package: 'OBJ2'!!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 16:44'!tieneHijos	^ tieneHijos! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 16:44'!tieneHijos: anObject	tieneHijos := anObject! !!Empleado methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 16:44'!initialize 	self tieneHijos: false.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 16:46'!tieneHijosSwitch	self tieneHijos ifTrue:[ self tieneHijos: false]						ifFalse:[self tieneHijos: true].! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 16:47' prior: 37020766!tieneHijosSwitch	self tieneHijos ifTrue:[ self tieneHijos: false]						ifFalse:[self tieneHijos: true].	! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 16:48'!pesosPorHora	^self subclassResponsibility.! !!Pasante methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 16:57'!pagoPorHora! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 16:58'!pagoPorHora	^self subclassResponsibility.! !Empleado removeSelector: #pesosPorHora!!Pasante methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 16:58' prior: 37021284!pagoPorHora	^50! !!Planta methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 16:59'!pagoPorHora	^0! !!Temporario methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 16:59'!pagoPorHora	^40! !!Pasante methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 16:59' prior: 37021559!pagoPorHora	^5! !!Pasante methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:00'!pagoBasico	^0! !!Temporario methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:01'!pagoBasico	^1000.! !!Planta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:01'!pagoBasico	^3000.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:04'!aportesDescuento! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:04'!sueldo! !Empleado removeSelector: #aportesDescuento!!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:07' prior: 37022355!sueldo	^( self pagoBasico + self pagoPorHora * self horasTrabajadas + self pagoPorHijos ) / 13 * 100! !Object subclass: #Empleado	instanceVariableNames: 'tieneHijos horasTrabajadas'	classVariableNames: ''	package: 'OBJ2'!!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:07'!horasTrabajadas	^ horasTrabajadas! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:07'!horasTrabajadas: anObject	horasTrabajadas := anObject! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:08'!pagoPorHijos	^self subclassResponsibility ! !!Planta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:09'!pagoPorHijos	self tieneHijos ifTrue: [ ^150].! !!Temporario methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:09'!pagoPorHijos	self tieneHijos ifTrue: [ ^100].! !!Pasante methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:09'!pagoPorHijos	^0! !!Planta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:10' prior: 37023170!pagoPorHijos	self tieneHijos ifTrue: [ ^150].	^0.! !!Temporario methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:10' prior: 37023296!pagoPorHijos	self tieneHijos ifTrue: [ ^100].	^0.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:11' prior: 37020647!initialize 	self tieneHijos: false.	self horasTrabajadas: 0.! !!Empleado class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/22/2018 17:11'!new	^self error: 'empleado es abstracta'! !!Empleado class methodsFor: 'instance creation' stamp: 'EncinasJavier 4/22/2018 17:13'!withHoras: cantHoras hijos: unBoolean	^(self new)horasTrabajadas: cantHoras;tieneHijos: unBoolean ;yourself.! !----SNAPSHOT----2018-04-22T17:18:51.948634-03:00 Pharo6.1.image priorSource: 3457864!Empleado class removeSelector: #new!!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:19' prior: 37022505!sueldo	^(( self pagoBasico + self pagoPorHora * self horasTrabajadas + self pagoPorHijos ) / 13 * 100)asFloat.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:19' prior: 37024446!sueldo	^(( self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos ) / 13 * 100)asFloat.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:22' prior: 37024656!sueldo	| bruto |	bruto:= self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos.	^bruto-((bruto * 13)/100).! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:23' prior: 37024868!sueldo	| bruto |	bruto:= self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos.	^bruto-((bruto * 13)/100) asFloat.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:24' prior: 37025102!sueldo	| bruto |	bruto:= self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos.	^(bruto-((bruto * 13)/100)) asFloat.! !!Temporario methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:26' prior: 37021766!pagoPorHora	^5! !!Pasante methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:26' prior: 37021875!pagoPorHora	^40! !----SNAPSHOT----2018-04-22T17:30:38.239699-03:00 Pharo6.1.image priorSource: 3469793!!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:32'!descuento: unMonto	^self! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:32' prior: 37025344!sueldo	| bruto |	bruto:= self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:33' prior: 37025879!descuento: unMonto		^unMonto-((unMonto * 13)/100).! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:33' prior: 37026003!sueldo	self descuento:self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos.! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:33' prior: 37026209!descuento: unMonto		^(unMonto-((unMonto * 13)/100))asFloat .! !!Empleado methodsFor: 'initialization' stamp: 'EncinasJavier 4/22/2018 17:34' prior: 37026360!sueldo	^self descuento:self pagoBasico + (self pagoPorHora * self horasTrabajadas) + self pagoPorHijos.! !!Empleado class methodsFor: 'instance creation' stamp: 'EncinasJavier 4/22/2018 17:36' prior: 37024113!withHoras: cantHoras hijos: cantHijos	^(self new)horasTrabajadas: cantHoras;tieneHijos: cantHijos ;yourself.! !!Planta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:37' prior: 37023527!pagoPorHijos	self cantHijos! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:37' prior: 37020413!tieneHijos	^ cantidadHijos! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:37' prior: 37020515!tieneHijos: anObject	cantidadHijos := anObject! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:37' prior: 37027258!tieneHijos	^ cantidadHijos! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:37' prior: 37027379!tieneHijos: anObject	cantidadHijos := anObject! !!Planta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:38' prior: 37027136!pagoPorHijos	^self cantHijos*150.! !!Planta methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:38' prior: 37027780!pagoPorHijos	^self cantidadHijos*150.! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:38'!cantidadHijos	^ cantidadHijos! !!Empleado methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:38'!cantidadHijos: anObject	cantidadHijos := anObject! !Empleado removeSelector: #tieneHijosSwitch!Empleado removeSelector: #tieneHijos!!Temporario methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:39' prior: 37023674!pagoPorHijos	self cantidadHijos * 100.! !!Temporario methodsFor: 'accessing' stamp: 'EncinasJavier 4/22/2018 17:39' prior: 37028360!pagoPorHijos	^self cantidadHijos * 100.! !----SNAPSHOT----2018-04-22T17:41:19.768858-03:00 Pharo6.1.image priorSource: 3471280!----QUIT----2018-04-22T18:04:53.782341-03:00 Pharo6.1.image priorSource: 3474106!----QUIT/NOSAVE----2018-04-23T15:49:45.045909-03:00 Pharo6.1.image priorSource: 3474193!!Usuario class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/23/2018 17:09'!withName: aName	^(self new)initialize;name: aName.! !!Usuario methodsFor: 'accessing' stamp: 'EncinasJavier 4/23/2018 17:09' prior: 36845155!initialize	self tweets: OrderedCollection new! !!Usuario class methodsFor: 'instance creation' stamp: 'EncinasJavier 4/23/2018 17:10' prior: 37028888!withName: aName	^(self new)initialize;screenName: aName.! !----SNAPSHOT----2018-04-23T17:11:55.022221-03:00 Pharo6.1.image priorSource: 3474193!----SNAPSHOT----2018-04-23T17:36:01.43355-03:00 Pharo6.1.image priorSource: 3474813!!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/23/2018 17:38' prior: 37019410!printJSONOn: aStream 	self printJSONOn: aStream indentation: 0.	^aStream contents.! !----SNAPSHOT----2018-04-23T17:39:14.961544-03:00 Pharo6.1.image priorSource: 3474900!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/23/2018 17:53' prior: 37011945!listadoDeContenido	| aStream |	aStream := ReadWriteStream on: (String new).	self imprimirseEn: aStream nivel: 1.	^aStream contents.	"	^self imprimirse, 	(self contenido collect:[ :cont | cont listadoDeContenido])asString."		! !----QUIT----2018-04-23T17:54:01.785504-03:00 Pharo6.1.image priorSource: 3475166!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:22'!imprimirse: aStream	^'-',self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:23'!imprimirse: aStream nivel: unNivel"	aStream 	'-',self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString."	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:23'!imprimirseEn: aStream nivel: unNivel"	aStream 	'-',self nombre , 'cantidad de archivos: ',(self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString."	! !Subdirectorio removeSelector: #imprimirse:nivel:!Subdirectorio removeSelector: #imprimirse!Subdirectorio removeSelector: #imprimirse:!!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:24'!imprimirseEn: aStream nivel: unNivel			! !Archivo removeSelector: #imprimirse!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:28' prior: 37030661!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPut: self nombre.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPut: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]).	aStream nextPutAll: ')'.	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:29' prior: 37031230!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPut: self nombre.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPut: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]).	aStream nextPutAll: ')'.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:33' prior: 37031611!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]).	aStream nextPutAll: ')'.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:33' prior: 37031990!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]).	aStream nextPutAll: ')'.	self ! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:33' prior: 37029781!listadoDeContenido	| aStream |	aStream := ReadWriteStream on: (String new).	self imprimirseEn: aStream nivel: 1.	^aStream contents.			! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:34' prior: 37032375!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]).	aStream nextPutAll: ')'.	self contenido collect:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:35' prior: 37033008!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]).	aStream nextPutAll: ')'.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !----SNAPSHOT----2018-04-24T11:35:26.895339-03:00 Pharo6.1.image priorSource: 3475586!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:36' prior: 37033475!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.	aStream nextPutAll: ')'.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:37' prior: 37034024!imprimirseEn: aStream nivel: unNivel	aStream nextPut: Character cr.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.	aStream nextPutAll: ')'.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:38' prior: 37034504!imprimirseEn: aStream nivel: unNivel	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: (self contenido inject: 0 into: [ :sum :cont | sum + cont sumarse ]) asString.	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:45'!compararTopografia: unaTopografia	^self subclassResponsability! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:45' prior: 37035509!compararTopografia: unaTopografia	^self subclassResponsibility.! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:47'!compararseConTierra: unaTierra	unaTierra compararseConAgua: self! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:48' prior: 37035806!compararseConTierra: unaTierra	^unaTierra compararseConAgua: self! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:48'!compararseConAgua: unaTierra	^unaTierra compararseConAgua: self! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:48' prior: 37035961!compararseConTierra: unaTierra	^unaTierra compararseConTierra: self! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:49' prior: 37036255!compararseConTierra: unaTierra	^unaTierra compararseConAgua: self! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:49' prior: 36993729!compararseConMixta: unaTopoMixta	^unaTopoMixta compararseConAgua: self! !!Agua methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:49' prior: 37036569!compararseConMixta: unaTopoMixta	^unaTopoMixta compararseConAgua: self.! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:50' prior: 37035668!compararTopografia: unaTopografia	unaTopografia compararTopografia: self! !!Topografia methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:50' prior: 37036898!compararTopografia: unaTopografia	^unaTopografia compararTopografia: self! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:50'!compararseConTierra: unaTierra	^unaTierra compararseConTierra: self.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:51'!compararseConAgua: unAgua	^unAgua compararseConTierra: self.! !!Tierra methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:51' prior: 36993845!compararseConMixta: unaTopoMixta	^unaTopoMixta compararseConTierra: self.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:52'!compararseConAgua: unAgua	^unAgua compararseConMixta: self.! !!Mixta methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 11:52'!compararseConTierra: unaTierra	^unaTierra compararseConMixta: self.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:10' prior: 37035016!imprimirseEn: aStream nivel: unNivel	|archivos|	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self agregateAColeccion: archivos.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:10' prior: 37037966!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self agregateAColeccion: archivos.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:10'!agregateAColeccion: unaColeccion	! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:12'!agregarseEnColeccion: unaCol! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:12' prior: 37039108!agregarseEnColeccion: unaColeccion	unaColeccion add: self! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:12' prior: 37039229!agregarseEnColeccion: unaColeccion	unaColeccion add: self.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:13'!agregarseAColeccion: unaColeccion	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:13' prior: 37038472!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self agregarseAColeccion: archivos.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !Subdirectorio removeSelector: #agregateAColeccion:!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:13'!agregarseEnColeccion: unaColeccion	! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:13' prior: 37039656!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self agregarseEnColeccion: archivos.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !Subdirectorio removeSelector: #agregarseAColeccion:!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:14' prior: 37040370!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self agregarseEnColeccion: archivos.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:14'!imprimirStringCantArchivos: aStream! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:15' prior: 37041493!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'.! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:17' prior: 37040967!imprimirseEn: aStream nivel: unNivel		unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.		aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:19' prior: 37041965!imprimirseEn: aStream nivel: unNivel		unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self imprimirStringCantArchivos: aStream.	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:19' prior: 37041627!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	(archivos size > 0) ifTrue:[	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:20' prior: 37042690!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	(archivos size > 0) ifTrue:[	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:20' prior: 37043059!imprimirStringCantArchivos: aStream	| archivos |	archivos := OrderedCollection new.	self agregarseEnColeccion: archivos.	archivos size > 0		ifFalse: [ ^ self ].	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:20' prior: 37043428!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	(archivos size > 0) ifTrue:[	aStream nextPutAll: '(cantidad de archivos: '.	aStream nextPutAll: archivos size asString.	aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:20' prior: 37043810!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	(archivos size > 0) ifTrue:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:22' prior: 37044179!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	(archivos size > 0) ifTrue:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 12:35' prior: 37044551!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	self halt.	(archivos size > 0) ifTrue:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 13:35' prior: 37044923!imprimirStringCantArchivos: aStream	|archivos|	archivos:= OrderedCollection new.	self agregarseEnColeccion: archivos.	(archivos size > 0) ifTrue:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 13:39' prior: 37042307!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	(archivos size > 0) ifTrue:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 13:39' prior: 37045679!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifEmpty:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !----SNAPSHOT----2018-04-24T13:40:00.951665-03:00 Pharo6.1.image priorSource: 3479409!!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 13:49' prior: 37046285!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	self halt.	archivos ifEmpty:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Subdirectorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 13:49' prior: 37046968!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifNotEmpty:[		aStream nextPutAll: '(cantidad de archivos: '.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ')'].	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 10 April 2016 at 4:23:11.848617 pm'!TestCase subclass: #DirectorioTest	instanceVariableNames: 'vacio conUnArchivo conVariosArchivos conSubdirectorios config grande backup2015'	classVariableNames: ''	poolDictionaries: ''	category: 'O2-FileSystem'!!DirectorioTest methodsFor: 'running' stamp: 'JulianGrigera 4/6/2016 12:09'!testListadoDeContenido	| listado listadoStream |	self assert: vacio listadoDeContenido = '- home'.	self assert: conUnArchivo listadoDeContenido = '- var (1 archivos)'.	self assert: conVariosArchivos listadoDeContenido = '- tmp (4 archivos)'.	listadoStream := WriteStream on: String new.	listadoStream << '- log (1 archivos)'; cr.	listadoStream << '-- mysql (4 archivos)'; cr.	listadoStream << '--- older (1 archivos)'; cr.	listadoStream << '-- postgres (3 archivos)'.	listado := listadoStream contents.	self assert: conSubdirectorios listadoDeContenido = listado! !!DirectorioTest methodsFor: 'running' stamp: 'JulianGrigera 4/6/2016 15:46'!setUp	| date |	date := '2015-01-01'.	"Directorio vacío"	vacio := Directorio llamado: 'home' creadoEl: date .	"Directorio con un solo archivo"	conUnArchivo := Directorio llamado: 'var' creadoEl: date.	config := Archivo llamado: 'config.bak' creadoEl: '2016-04-02' asDate kBytes: 128.	conUnArchivo agregar: config.	"Directorio con varios archivos, pero sin subdirectorios"	conVariosArchivos := Directorio llamado: 'tmp' creadoEl: date.	grande := Archivo llamado: 'grande.tmp' creadoEl: '2016-04-02' asDate kBytes: 2000000.	conVariosArchivos		agregar: (Archivo llamado: 'nada.tmp' creadoEl: '2015-05-01' asDate kBytes: 0);		agregar: (Archivo llamado: 'chico.tmp' creadoEl: '2013-06-03' asDate kBytes: 10);		agregar: grande;		agregar: (Archivo llamado: 'mediano.tmp' creadoEl: '1995-11-23' asDate kBytes: 10000).	"Directorio con subdirectorios, archivos, y archivos dentro de los subdirectorios"	conSubdirectorios := Directorio llamado: 'log' creadoEl: date.	backup2015 := Archivo llamado: '2015.zip' creadoEl: '2016-04-06' asDate kBytes: 240000000.	conSubdirectorios		agregar: (Archivo llamado: 'sys.log' creadoEl: '2016-03-03' asDate kBytes: 90000);		agregar:				((Directorio llamado: 'mysql' creadoEl: date)						agregar: (Archivo llamado: 'mysql01.log' creadoEl: '2015-12-03' asDate kBytes: 1200000);						agregar: (Archivo llamado: 'mysql02.log' creadoEl: '2014-03-03' asDate kBytes: 2000000);						agregar: (Archivo llamado: 'mysql03.log' creadoEl: '2013-03-21' asDate kBytes: 2000000);						agregar: (Archivo llamado: 'mysql04.log' creadoEl: '2014-07-15' asDate kBytes: 2000000);						agregar:								((Directorio llamado: 'older' creadoEl: date)										agregar: backup2015;										yourself);						yourself);		agregar:				((Directorio llamado: 'postgres' creadoEl: date)						agregar: (Archivo llamado: 'pg01.log' creadoEl: '2015-04-12' asDate kBytes: 1400000);						agregar: (Archivo llamado: 'pg02.log' creadoEl: '2016-03-08' asDate kBytes: 4000000);						agregar: (Archivo llamado: 'pg03.log' creadoEl: '2016-02-13' asDate kBytes: 4000000);						yourself)! !----End fileIn----!(Smalltalk globals at: #Directorio) rename: #FileSystemAbstract!!DirectorioTest methodsFor: 'running' stamp: 'EncinasJavier 4/24/2018 14:30' prior: 37049124!setUp	| date |	date := '2015-01-01'.	"Directorio vacío"	vacio := FileSystemAbstract llamado: 'home' creadoEl: date .	"Directorio con un solo archivo"	conUnArchivo := FileSystemAbstract llamado: 'var' creadoEl: date.	config := Archivo llamado: 'config.bak' creadoEl: '2016-04-02' asDate kBytes: 128.	conUnArchivo agregar: config.	"Directorio con varios archivos, pero sin subdirectorios"	conVariosArchivos := FileSystemAbstract llamado: 'tmp' creadoEl: date.	grande := Archivo llamado: 'grande.tmp' creadoEl: '2016-04-02' asDate kBytes: 2000000.	conVariosArchivos		agregar: (Archivo llamado: 'nada.tmp' creadoEl: '2015-05-01' asDate kBytes: 0);		agregar: (Archivo llamado: 'chico.tmp' creadoEl: '2013-06-03' asDate kBytes: 10);		agregar: grande;		agregar: (Archivo llamado: 'mediano.tmp' creadoEl: '1995-11-23' asDate kBytes: 10000).	"Directorio con subdirectorios, archivos, y archivos dentro de los subdirectorios"	conSubdirectorios := FileSystemAbstract llamado: 'log' creadoEl: date.	backup2015 := Archivo llamado: '2015.zip' creadoEl: '2016-04-06' asDate kBytes: 240000000.	conSubdirectorios		agregar: (Archivo llamado: 'sys.log' creadoEl: '2016-03-03' asDate kBytes: 90000);		agregar:				((FileSystemAbstract llamado: 'mysql' creadoEl: date)						agregar: (Archivo llamado: 'mysql01.log' creadoEl: '2015-12-03' asDate kBytes: 1200000);						agregar: (Archivo llamado: 'mysql02.log' creadoEl: '2014-03-03' asDate kBytes: 2000000);						agregar: (Archivo llamado: 'mysql03.log' creadoEl: '2013-03-21' asDate kBytes: 2000000);						agregar: (Archivo llamado: 'mysql04.log' creadoEl: '2014-07-15' asDate kBytes: 2000000);						agregar:								((FileSystemAbstract llamado: 'older' creadoEl: date)										agregar: backup2015;										yourself);						yourself);		agregar:				((FileSystemAbstract llamado: 'postgres' creadoEl: date)						agregar: (Archivo llamado: 'pg01.log' creadoEl: '2015-04-12' asDate kBytes: 1400000);						agregar: (Archivo llamado: 'pg02.log' creadoEl: '2016-03-08' asDate kBytes: 4000000);						agregar: (Archivo llamado: 'pg03.log' creadoEl: '2016-02-13' asDate kBytes: 4000000);						yourself)! !(Smalltalk globals at: #Subdirectorio) rename: #Directorio!Archivo class removeSelector: #llamado:creadoEl:!!Archivo class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/24/2018 14:33'!llamado: unString creadoEl: unaFecha kBytes: unTamaño	"Método de clase. Crea un nuevo Directorio con nombre unString y en la fecha	unaFecha"	^(self new)nombre: unString ;creacion: unaFecha;tamaño: unTamaño ;yourself.! !Archivo class removeSelector: #llamado:creadoEl:tamaño:!!FileSystemAbstract class methodsFor: 'as yet unclassified' stamp: 'EncinasJavier 4/24/2018 14:35'!llamado: unString creadoEl: unaFecha kBytes: unTamaño	^self subclassResponsibility.! !!FileSystemAbstract methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 14:36'!agregar: unDato		self contenido add: unDato.! !FileSystemAbstract removeSelector: #addContenido:!FileSystemAbstract class removeSelector: #llamado:creadoEl:kBytes:!!DirectorioTest methodsFor: 'running' stamp: 'EncinasJavier 4/24/2018 14:38' prior: 37051410!setUp	| date |	date := '2015-01-01'.	"Directorio vacío"	vacio := Directorio llamado: 'home' creadoEl: date .	"Directorio con un solo archivo"	conUnArchivo := Directorio llamado: 'var' creadoEl: date.	config := Archivo llamado: 'config.bak' creadoEl: '2016-04-02' asDate kBytes: 128.	conUnArchivo agregar: config.	"Directorio con varios archivos, pero sin subdirectorios"	conVariosArchivos := Directorio llamado: 'tmp' creadoEl: date.	grande := Archivo llamado: 'grande.tmp' creadoEl: '2016-04-02' asDate kBytes: 2000000.	conVariosArchivos		agregar: (Archivo llamado: 'nada.tmp' creadoEl: '2015-05-01' asDate kBytes: 0);		agregar: (Archivo llamado: 'chico.tmp' creadoEl: '2013-06-03' asDate kBytes: 10);		agregar: grande;		agregar: (Archivo llamado: 'mediano.tmp' creadoEl: '1995-11-23' asDate kBytes: 10000).	"Directorio con subdirectorios, archivos, y archivos dentro de los subdirectorios"	conSubdirectorios := Directorio llamado: 'log' creadoEl: date.	backup2015 := Archivo llamado: '2015.zip' creadoEl: '2016-04-06' asDate kBytes: 240000000.	conSubdirectorios		agregar: (Archivo llamado: 'sys.log' creadoEl: '2016-03-03' asDate kBytes: 90000);		agregar:				((Directorio llamado: 'mysql' creadoEl: date)						agregar: (Archivo llamado: 'mysql01.log' creadoEl: '2015-12-03' asDate kBytes: 1200000);						agregar: (Archivo llamado: 'mysql02.log' creadoEl: '2014-03-03' asDate kBytes: 2000000);						agregar: (Archivo llamado: 'mysql03.log' creadoEl: '2013-03-21' asDate kBytes: 2000000);						agregar: (Archivo llamado: 'mysql04.log' creadoEl: '2014-07-15' asDate kBytes: 2000000);						agregar:								((Directorio llamado: 'older' creadoEl: date)										agregar: backup2015;										yourself);						yourself);		agregar:				((Directorio llamado: 'postgres' creadoEl: date)						agregar: (Archivo llamado: 'pg01.log' creadoEl: '2015-04-12' asDate kBytes: 1400000);						agregar: (Archivo llamado: 'pg02.log' creadoEl: '2016-03-08' asDate kBytes: 4000000);						agregar: (Archivo llamado: 'pg03.log' creadoEl: '2016-02-13' asDate kBytes: 4000000);						yourself)! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 14:44' prior: 37047576!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifNotEmpty:[		aStream nextPutAll: ' ('.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ' archivos)'.].	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 14:46' prior: 37056794!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPut: Character space.	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifNotEmpty:[		aStream nextPutAll: ' ('.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ' archivos)'.].	aStream nextPut: Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 14:55' prior: 37057379!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPut: Character space.	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifNotEmpty:[		aStream nextPutAll: ' ('.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ' archivos)'.].	self carriageReturn: aStream.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 14:56'!carriageReturn: aStream	aStream nextPut: Character cr.! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 14:56'!carriageReturn: aStream	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:03' prior: 37057999!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPut: Character space.	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifNotEmpty:[		aStream nextPutAll: ' ('.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ' archivos)'.].	self carriageReturn: aStream.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:04' prior: 37058602!carriageReturn: aStream	self contenido detect: [ :cont | cont class = Directorio ] ifFound: [  	aStream nextPut: Character cr.]! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:37' prior: 37058855!imprimirseEn: aStream nivel: unNivel	|archivos|	archivos:= OrderedCollection new.	unNivel timesRepeat: [ aStream nextPutAll: '-' ].	aStream nextPut: Character space.	aStream nextPutAll: self nombre asString.	self contenido do:[ :cont | cont agregarseEnColeccion: archivos ].	archivos ifNotEmpty:[		aStream nextPutAll: ' ('.		aStream nextPutAll: archivos size asString.		aStream nextPutAll: ' archivos)'.].		aStream << Character cr.	self contenido do:[ :cont | cont imprimirseEn: aStream nivel: unNivel + 1].! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:40' prior: 37032767!listadoDeContenido	| aStream |	aStream := ReadWriteStream on: (String new).	self imprimirseEn: aStream nivel: 1.	^aStream contents truncate: (aStream contents size) - 1.			! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:41' prior: 37060314!listadoDeContenido	| aStream |	aStream := ReadWriteStream on: (String new).	self imprimirseEn: aStream nivel: 1.	^(aStream contents) asString truncate: (aStream contents size) - 1.			! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:42' prior: 37060590!listadoDeContenido	| aStream |	aStream := ReadWriteStream on: (String new).	self imprimirseEn: aStream nivel: 1.	^aStream contents truncate: (aStream contents size) - 1.			! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 15:43' prior: 37060877!listadoDeContenido	| aStream |	aStream := ReadWriteStream on: (String new).	self imprimirseEn: aStream nivel: 1.	^aStream contents truncateTo: (aStream contents size) - 1.			! !Directorio removeSelector: #carriageReturn:!Directorio removeSelector: #sumarse!!FileSystemAbstract methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:02' prior: 36998103!tamañoTotalOcupado		^self subclassResponsibility.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:03' prior: 36998433!tamañoTotalOcupado	^self contenido inject: 0 into: [ :sum : cont | sum + cont tamañoTotalOcupado ] + self tamañoTotalOcupado .! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:04' prior: 37061671!tamañoTotalOcupado	^self contenido inject: 0 into: [ :sum : cont | sum + cont tamañoTotalOcupado ] + self tamaño.! !Archivo removeSelector: #carriageReturn:!!FileSystemAbstract methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:08'!recorrerArchivos: archivos	self contenido do:[ :cont | cont agregarseEnColeccion: archivos. 		cont recorrerArchivos: archivos].! !!FileSystemAbstract methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:09' prior: 37062147!recorrerArchivos: archivos	self contenido do:[ :cont | cont agregarseEnColeccion: archivos. 										cont recorrerArchivos: archivos].	^archivos! !!FileSystemAbstract methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:09' prior: 37062381!recorrerArchivos: archivos	self subclassResponsibility.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:09'!recorrerArchivos:archivos		contenido do:[ :cont | cont agregarseEnColeccion: archivos. 										cont recorrerArchivos: archivos].	^archivos! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:12'!archivoMasGrande	|archivos|	archivos:= ''.	self recorrerArchivos: archivos.	^archivos	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:13' prior: 37062995!archivoMasGrande	|archivos|	archivos:= ''.	self recorrerArchivos: archivos.	^archivos detectMax: [ :arch | arch tamaño ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:14' prior: 37063182!archivoMasGrande	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	^archivos detectMax: [ :arch | arch tamaño ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:14' prior: 37062771!recorrerArchivos:archivos		self contenido do:[ :cont | cont agregarseEnColeccion: archivos. 										cont recorrerArchivos: archivos].	^archivos! !!Archivo methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:15'!recorrerArchivos: archivos! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:20'!archivoMasNuevo	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	^archivos detectMax: [ :arch | arch creacion ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:21' prior: 37063982!archivoMasNuevo	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	self halt.	^archivos detectMax: [ :arch | arch creacion ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:24' prior: 37064225!archivoMasNuevo	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	^archivos detectMax: [ :arch | arch creacion ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:24' prior: 37064480!archivoMasNuevo	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	self halt.	^archivos detectMax: [ :arch | arch creacion ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:25' prior: 37064723!archivoMasNuevo	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	^archivos detectMax: [ :arch | arch creacion ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:33' prior: 37061898!tamañoTotalOcupado	""	^self contenido inject: 0 into: [ :sum : cont | sum + cont tamañoTotalOcupado ] + self tamaño.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:37' prior: 37065221!tamañoTotalOcupado	"se itera recursivamente sobre el contenido de cada directorio y se suma su propio tamaño"	^self contenido inject: 0 into: [ :sum : cont | sum + cont tamañoTotalOcupado ] + self tamaño.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:40' prior: 37065438!tamañoTotalOcupado	"se itera recursivamente sobre el contenido de cada directorio y se suma su propio tamaño"	^self contenido inject: 0 into: [ :sum : cont | sum + cont tamañoTotalOcupado ] + self tamaño.! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:40' prior: 37063406!archivoMasGrande	"ver recorrerArchivos"	|archivos|	archivos:= OrderedCollection new.	self recorrerArchivos: archivos.	^archivos detectMax: [ :arch | arch tamaño ].	! !!Directorio methodsFor: 'accessing' stamp: 'EncinasJavier 4/24/2018 16:41' prior: 37063649!recorrerArchivos:archivos	"metodo auxiliar que itera recursivamente sobre todo el filesystem. devuelve solo los archivos"	self contenido do:[ :cont | cont agregarseEnColeccion: archivos. 										cont recorrerArchivos: archivos].	^archivos! !----SNAPSHOT----2018-04-24T16:42:00.881209-03:00 Pharo6.1.image priorSource: 3492353!